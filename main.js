/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@nodetoy/three-nodetoy/dist/three-nodetoy.es.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@nodetoy/three-nodetoy/dist/three-nodetoy.es.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CubeUVReflectionMapping": () => (/* binding */ CubeUVReflectionMapping),
/* harmony export */   "NodeToyCullMode": () => (/* binding */ NodeToyCullMode),
/* harmony export */   "NodeToyMaterial": () => (/* binding */ NodeToyMaterial),
/* harmony export */   "NodeToyMaterialType": () => (/* binding */ NodeToyMaterialType),
/* harmony export */   "NodeToyRenderType": () => (/* binding */ NodeToyRenderType)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

var C = Object.defineProperty;
var K = (n, t, e) => t in n ? C(n, t, { enumerable: true, configurable: true, writable: true, value: e }) : n[t] = e;
var x = (n, t, e) => (K(n, typeof t != "symbol" ? t + "" : t, e), e);
const k = (n, t = {}) => {
  U("event", n, t);
}, W = (n, t = {}) => {
  const e = "ga-gtag";
  if (document.getElementById(e)) {
    console.error("Already has a gtag script.");
    return;
  }
  const { head: r } = document, i = document.createElement("script");
  i.id = e, i.type = "text/javascript", i.async = true, i.src = `https://www.googletagmanager.com/gtag/js?id=${n}`, r.insertBefore(i, r.firstChild), window.dataLayer = window.dataLayer || [], U("js", new Date()), U("config", n, t);
}, U = function(...n) {
  window.dataLayer.push(arguments);
}, R = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(), F = {}, _ = {
  state: 0,
  stateFrame: 0,
  button: 0,
  viewportState: 0,
  viewportStateFrame: 0,
  x: 0,
  y: 0
};
class X extends three__WEBPACK_IMPORTED_MODULE_0__.DataTexture {
  constructor() {
    const c = new Uint8Array(1024);
    for (let w = 0; w < 4 * 256; w++)
      c[w] = 0;
    super(c, 256, 1, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);
    x(this, "data");
    x(this, "_size");
    this.data = c, this.flipY = true, this._size = 256;
  }
  setKeyDown(e) {
    const r = e * 4;
    this.data[r + 0] !== 255 && (this.data[r + 0] = 255, this.data[r + 1] = 255, this.data[r + 2] = 255 - this.data[r + 2], this.needsUpdate = true);
  }
  setKeyUp(e) {
    const r = e * 4;
    this.data[r + 0] = 0, this.data[r + 1] = 0, this.needsUpdate = true;
  }
  clear() {
    for (let e = 0; e < 4 * this._size; e++)
      this.data[e] = 0;
    this.needsUpdate = true;
  }
  clearFrame() {
    for (let e = 0; e < this._size; e++) {
      const r = e * 4;
      this.data[r + 1] = 0;
    }
    this.needsUpdate = true;
  }
}
class Q {
  constructor(t) {
    x(this, "renderer");
    x(this, "_keyboardTexture", new X());
    x(this, "_onPointerMoveBind");
    x(this, "_onPointerDownBind");
    x(this, "_onPointerUpBind");
    x(this, "_onPointerEnterBind");
    x(this, "_onPointerLeaveBind");
    x(this, "_onKeyDownBind");
    x(this, "_onKeyUpBind");
    this.renderer = t, this.renderer._pointerPosition = { x: 0, y: 0 }, this.renderer._pointerData = _, this.renderer._keyboardTexture = this._keyboardTexture;
    const e = t.domElement;
    if (!e) {
      console.warn("[NodeToy] Unable to bind dom events, domElement is null. Some nodes will not work.");
      return;
    }
    this._onPointerMoveBind = this.onPointerMove.bind(this), this._onPointerDownBind = this.onPointerDown.bind(this), this._onPointerUpBind = this.onPointerUp.bind(this), this._onPointerEnterBind = this.onPointerEnter.bind(this), this._onPointerLeaveBind = this.onPointerLeave.bind(this), this._onKeyDownBind = this.onKeyDown.bind(this), this._onKeyUpBind = this.onKeyUp.bind(this), e.addEventListener("pointermove", this._onPointerMoveBind), e.addEventListener("pointerdown", this._onPointerDownBind), e.addEventListener("pointerup", this._onPointerUpBind), e.addEventListener("pointerenter", this._onPointerEnterBind), e.addEventListener("pointerleave", this._onPointerLeaveBind), window.addEventListener("keydown", this._onKeyDownBind), window.addEventListener("keyup", this._onKeyUpBind);
  }
  dispose() {
    if (!this.renderer)
      return;
    const t = this.renderer.domElement;
    !t || (t.removeEventListener("pointermove", this._onPointerMoveBind), t.removeEventListener("pointerdown", this._onPointerDownBind), t.removeEventListener("pointerup", this._onPointerUpBind), t.removeEventListener("pointerenter", this._onPointerEnterBind), t.removeEventListener("pointerleave", this._onPointerLeaveBind), window.removeEventListener("keydown", this._onKeyDownBind), window.removeEventListener("keyup", this._onKeyUpBind));
  }
  onPointerMove(t) {
    !this.renderer || (this.renderer._pointerPosition = {
      x: Math.floor(t.offsetX),
      y: Math.floor(t.offsetY)
    });
  }
  onPointerDown(t) {
    !this.renderer || (this.renderer._pointerData = {
      state: 1,
      stateFrame: 1,
      button: t.button,
      x: Math.floor(t.offsetX),
      y: Math.floor(t.offsetY)
    });
  }
  onPointerUp(t) {
    !this.renderer || (this.renderer._pointerData = {
      state: 2,
      stateFrame: 2,
      button: t.button,
      x: Math.floor(t.offsetX),
      y: Math.floor(t.offsetY)
    });
  }
  onPointerEnter(t) {
    !this.renderer || (this.renderer._pointerData = __spreadProps(__spreadValues({}, this.renderer._pointerData), {
      viewportState: 1,
      viewportStateFrame: 1,
      x: Math.floor(t.offsetX),
      y: Math.floor(t.offsetY)
    }));
  }
  onPointerLeave(t) {
    !this.renderer || (this.renderer._pointerData = __spreadProps(__spreadValues({}, this.renderer._pointerData), {
      viewportState: 2,
      viewportStateFrame: 2,
      x: Math.floor(t.offsetX),
      y: Math.floor(t.offsetY)
    }));
  }
  onKeyDown(t) {
    !this.renderer || this._keyboardTexture.setKeyDown(t.keyCode);
  }
  onKeyUp(t) {
    !this.renderer || this._keyboardTexture.setKeyUp(t.keyCode);
  }
}
const Z = (n) => n.includes(".json") ? n : `${n}${n[n.length - 1] != "/" ? "/" : ""}material.glsl.json`, Y = (n, t) => {
  if (!n || !t.includes("asset:"))
    return t;
  const e = n[n.length - 1];
  return `${n}${e !== "/" ? "/" : ""}assets/${t.replace("asset:", "")}`;
}, m = (n, t, e, r = {}) => {
  const i = t;
  for (let c = 0; c < e.length; c++) {
    const w = e[c], v = w.name in r ? r[w.name] : w.value;
    i[w.name] = {
      value: $(n, w.type, v),
      type: w.type
    };
  }
  return i;
}, $ = (n, t, e) => {
  switch (t) {
    case "int":
    case "float":
      return e;
    case "vec2":
      return e != null ? new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(e.x, e.y) : new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);
    case "vec3":
      return e != null ? new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(e.x, e.y, e.z) : new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);
    case "vec4":
      return e != null ? new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(e.x, e.y, e.z, e.w) : new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0, 0, 0);
    case "mat3":
      return e || new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();
    case "mat4":
      return e || new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
    case "texture": {
      if (e in F)
        return F[e];
      const r = R.load(Y(n, e));
      return r.wrapS = r.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, F[e] = r, r;
    }
  }
  return "undefined";
}, ee = () => {
  W("G-D7559MFFX3");
}, ne = (n, t) => {
  for (let e = 0; e < n.scene.children.length; e++)
    if (n.scene.children[e].isDirectionalLight) {
      n.light = n.scene.children[e];
      break;
    }
  if ("_sinTime" in t) {
    const e = Math.sin(n.time);
    t._sinTime.value.set(e / 8, e / 4, e / 2, e);
  }
  if ("_cosTime" in t) {
    const e = Math.cos(n.time);
    t._cosTime.value.set(e / 8, e / 4, e / 2, e);
  }
  if ("_objectScale" in t) {
    const e = n.object;
    t._objectScale.value = e.scale;
  }
  if ("_time" in t && (t._time.value = n.time), "_deltaTime" in t && t._deltaTime.value.set(n.deltaTime, 1 / n.deltaTime, 0, 0), "_objectSpaceViewDir" in t) {
    const e = n.object, r = n.camera, i = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(r.position.x, r.position.y, r.position.z), c = e.matrixWorld.clone().invert().elements, w = c[0] * i.x + c[4] * i.y + c[8] * i.z + c[12] * i.w, v = c[1] * i.x + c[5] * i.y + c[9] * i.z + c[13] * i.w, l = c[2] * i.x + c[6] * i.y + c[10] * i.z + c[14] * i.w, a = c[3] * i.x + c[7] * i.y + c[11] * i.z + c[15] * i.w, s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(w, v, l, a);
    t._objectSpaceViewDir.value = s;
  }
  if ("_cameraPosition" in t) {
    const e = n.camera;
    t._cameraPosition.value = e.position.clone();
  }
  if ("_worldSpaceCameraPosition" in t && (n.camera.getWorldDirection(T), t._worldSpaceCameraPosition.value = T), "_worldSpaceLightPosition" in t && (n.light.getWorldDirection(V), t._worldSpaceLightPosition.value = V), "_worldToObject" in t) {
    const e = n.object;
    t._worldToObject.value = e.matrixWorld.clone().invert();
  }
  if ("_worldToObjMatrix" in t && (t._worldToObjMatrix.value = n.object.matrixWorld.clone().invert()), "_worldToCameraMatrix" in t) {
    const e = n.camera;
    t._worldToCameraMatrix.value = e.matrixWorldInverse.clone();
  }
  if ("_viewProjectionMatrix" in t) {
    const e = n.camera, r = e.matrixWorld.clone();
    t._viewProjectionMatrix.value = e.projectionMatrix.clone().multiply(r);
  }
  if ("_viewMatrix" in t) {
    const e = n.camera;
    t._viewMatrix.value = e.matrixWorldInverse;
  }
  if ("_transposeModelViewMatrix" in t) {
    const e = n.object;
    t._transposeModelViewMatrix.value = e.modelViewMatrix.clone().transpose();
  }
  if ("_inverseTransposeModelViewMatrix" in t) {
    const r = n.object.modelViewMatrix.clone();
    t._inverseTransposeModelViewMatrix.value = r.invert().transpose();
  }
  if ("_projectionMatrix" in t) {
    const e = n.camera;
    t._projectionMatrix.value = e.projectionMatrix;
  }
  if ("_projectionParams" in t) {
    const e = n.camera;
    t._projectionParams.value = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(1, e.near, e.far, 1 / e.far);
  }
  if ("_inverseProjectionMatrix" in t) {
    const e = n.camera;
    t._inverseProjectionMatrix.value = e.projectionMatrixInverse;
  }
  if ("_objectToWorldMatrix" in t) {
    const e = n.object;
    t._objectToWorldMatrix.value = e.matrixWorld;
  }
  if ("_modelViewProjectionMatrix" in t) {
    const e = n.object, r = n.camera;
    r.updateMatrixWorld(true), e.updateMatrixWorld(true);
    const i = e.modelViewMatrix.clone();
    t._modelViewProjectionMatrix.value = r.projectionMatrix.clone().multiply(i);
  }
  if ("_modelViewMatrix" in t) {
    const e = n.object;
    n.camera.updateMatrixWorld(true), e.updateMatrixWorld(true), t._modelViewMatrix.value = e.modelViewMatrix.clone();
  }
  if ("_inverseModelViewMatrix" in t) {
    const e = n.object;
    n.camera.updateMatrixWorld(true), e.updateMatrixWorld(true), t._inverseModelViewMatrix.value = e.modelViewMatrix.clone().invert();
  }
  if ("_modelMatrix" in t) {
    const e = n.object;
    t._modelMatrix.value = e.matrixWorld;
  }
  if ("_normalMatrix" in t) {
    const e = n.object;
    t._normalMatrix.value = e.normalMatrix;
  }
  if ("_inverseViewMatrix" in t) {
    const e = n.camera;
    t._inverseViewMatrix.value = e.matrixWorldInverse.clone().invert();
  }
  if ("_cameraToWorldMatrix" in t) {
    const e = n.camera;
    t._cameraToWorldMatrix.value = e.matrixWorldInverse.clone().invert();
  }
  if ("_worldSpaceLightDir" in t && n.light && (t._worldSpaceLightDir.value = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(n.light.rotation._x, n.light.rotation._y, n.light.rotation._z).normalize()), "_lightColor" in t && n.light) {
    const e = n.light.intensity, r = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(n.light.color.r * e, n.light.color.g * e, n.light.color.b * e);
    t._lightColor.value = r;
  }
  if ("_screenSize" in t && (n.renderer.getSize(P), t._screenSize.value.set(Math.floor(P.x), Math.floor(P.y), 1 + 1 / Math.floor(P.x), 1 + 1 / Math.floor(P.y))), "_viewDir" in t && (n.camera.getWorldDirection(f), f.negate(), t._viewDir.value = f), "_pointerPosition" in t) {
    const e = "_pointerPosition" in n.renderer ? n.renderer._pointerPosition : { x: 0, y: 0 };
    t._pointerPosition.value.set(Math.floor(e.x), Math.floor(e.y));
  }
  if ("_pointerPositionNormalized" in t) {
    n.renderer.getSize(P);
    const e = "_pointerPosition" in n.renderer ? n.renderer._pointerPosition : { x: 0, y: 0 };
    t._pointerPositionNormalized.value.set(e.x / P.x, e.y / P.y);
  }
  if ("_pointerDown" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    t._pointerDown.value.set(e.state === 1 ? 1 : 0, e.button);
  }
  if ("_pointerDownPrimary" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 0 && t._pointerDownPrimary.value.set(e.state === 1 ? 1 : 0, e.button);
  }
  if ("_pointerDownAuxiliary" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 1 && t._pointerDownAuxiliary.value.set(e.state === 1 ? 1 : 0, e.button);
  }
  if ("_pointerDownSecondary" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 2 && t._pointerDownSecondary.value.set(e.state === 1 ? 1 : 0, e.button);
  }
  if ("_pointerDownFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    t._pointerDownFrame.value.set(e.stateFrame === 1 ? 1 : 0, e.button);
  }
  if ("_pointerDownPrimaryFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 0 && t._pointerDownPrimaryFrame.value.set(e.stateFrame === 1 ? 1 : 0, e.button);
  }
  if ("_pointerDownAuxiliaryFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 1 && t._pointerDownAuxiliaryFrame.value.set(e.stateFrame === 1 ? 1 : 0, e.button);
  }
  if ("_pointerDownSecondaryFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 2 && t._pointerDownSecondaryFrame.value.set(e.stateFrame === 1 ? 1 : 0, e.button);
  }
  if ("_pointerUp" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    t._pointerUp.value.set(e.state === 0 || e.state === 2 ? 1 : 0, e.button);
  }
  if ("_pointerUpPrimary" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 0 ? t._pointerUpPrimary.value.set(e.state === 0 || e.state === 2 ? 1 : 0, e.button) : t._pointerUpPrimary.value.set(1, e.button);
  }
  if ("_pointerUpAuxiliary" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 1 ? t._pointerUpAuxiliary.value.set(e.state === 0 || e.state === 2 ? 1 : 0, e.button) : t._pointerUpAuxiliary.value.set(1, e.button);
  }
  if ("_pointerUpSecondary" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 2 ? t._pointerUpSecondary.value.set(e.state === 0 || e.state === 2 ? 1 : 0, e.button) : t._pointerUpSecondary.value.set(1, e.button);
  }
  if ("_pointerUpFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    t._pointerUpFrame.value.set(e.stateFrame === 2 ? 1 : 0, e.button);
  }
  if ("_pointerUpPrimaryFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 0 ? t._pointerUpPrimaryFrame.value.set(e.stateFrame === 2 ? 1 : 0, e.button) : t._pointerUpPrimaryFrame.value.set(0, e.button);
  }
  if ("_pointerUpAuxiliaryFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 1 ? t._pointerUpAuxiliaryFrame.value.set(e.stateFrame === 2 ? 1 : 0, e.button) : t._pointerUpAuxiliaryFrame.value.set(0, e.button);
  }
  if ("_pointerUpSecondaryFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    e.button === 2 ? t._pointerUpSecondaryFrame.value.set(e.stateFrame === 2 ? 1 : 0, e.button) : t._pointerUpSecondaryFrame.value.set(0, e.button);
  }
  if ("_pointerEnter" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    t._pointerEnter.value = e.viewportState === 1 ? 1 : 0;
  }
  if ("_pointerLeave" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    t._pointerLeave.value = e.viewportState === 0 || e.viewportState === 2 ? 1 : 0;
  }
  if ("_pointerEnterFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    t._pointerEnterFrame.value = e.viewportStateFrame === 1 ? 1 : 0;
  }
  if ("_pointerLeaveFrame" in t) {
    const e = "_pointerData" in n.renderer ? n.renderer._pointerData : _;
    t._pointerLeaveFrame.value = e.viewportStateFrame === 2 ? 1 : 0;
  }
  if ("_keyboardTexture" in t) {
    const e = "_keyboardTexture" in n.renderer ? n.renderer._keyboardTexture : null;
    t._keyboardTexture.value = e;
  }
}, f = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), T = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), V = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);
let P = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);
var z = { exports: {} };
(function(n) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = false));
  function i(l, a, s) {
    this.fn = l, this.context = a, this.once = s || false;
  }
  function c(l, a, s, d, b) {
    if (typeof s != "function")
      throw new TypeError("The listener must be a function");
    var y = new i(s, d || l, b), p = e ? e + a : a;
    return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], y] : l._events[p].push(y) : (l._events[p] = y, l._eventsCount++), l;
  }
  function w(l, a) {
    --l._eventsCount === 0 ? l._events = new r() : delete l._events[a];
  }
  function v() {
    this._events = new r(), this._eventsCount = 0;
  }
  v.prototype.eventNames = function() {
    var a = [], s, d;
    if (this._eventsCount === 0)
      return a;
    for (d in s = this._events)
      t.call(s, d) && a.push(e ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? a.concat(Object.getOwnPropertySymbols(s)) : a;
  }, v.prototype.listeners = function(a) {
    var s = e ? e + a : a, d = this._events[s];
    if (!d)
      return [];
    if (d.fn)
      return [d.fn];
    for (var b = 0, y = d.length, p = new Array(y); b < y; b++)
      p[b] = d[b].fn;
    return p;
  }, v.prototype.listenerCount = function(a) {
    var s = e ? e + a : a, d = this._events[s];
    return d ? d.fn ? 1 : d.length : 0;
  }, v.prototype.emit = function(a, s, d, b, y, p) {
    var D = e ? e + a : a;
    if (!this._events[D])
      return false;
    var o = this._events[D], M = arguments.length, g, u;
    if (o.fn) {
      switch (o.once && this.removeListener(a, o.fn, void 0, true), M) {
        case 1:
          return o.fn.call(o.context), true;
        case 2:
          return o.fn.call(o.context, s), true;
        case 3:
          return o.fn.call(o.context, s, d), true;
        case 4:
          return o.fn.call(o.context, s, d, b), true;
        case 5:
          return o.fn.call(o.context, s, d, b, y), true;
        case 6:
          return o.fn.call(o.context, s, d, b, y, p), true;
      }
      for (u = 1, g = new Array(M - 1); u < M; u++)
        g[u - 1] = arguments[u];
      o.fn.apply(o.context, g);
    } else {
      var A = o.length, j;
      for (u = 0; u < A; u++)
        switch (o[u].once && this.removeListener(a, o[u].fn, void 0, true), M) {
          case 1:
            o[u].fn.call(o[u].context);
            break;
          case 2:
            o[u].fn.call(o[u].context, s);
            break;
          case 3:
            o[u].fn.call(o[u].context, s, d);
            break;
          case 4:
            o[u].fn.call(o[u].context, s, d, b);
            break;
          default:
            if (!g)
              for (j = 1, g = new Array(M - 1); j < M; j++)
                g[j - 1] = arguments[j];
            o[u].fn.apply(o[u].context, g);
        }
    }
    return true;
  }, v.prototype.on = function(a, s, d) {
    return c(this, a, s, d, false);
  }, v.prototype.once = function(a, s, d) {
    return c(this, a, s, d, true);
  }, v.prototype.removeListener = function(a, s, d, b) {
    var y = e ? e + a : a;
    if (!this._events[y])
      return this;
    if (!s)
      return w(this, y), this;
    var p = this._events[y];
    if (p.fn)
      p.fn === s && (!b || p.once) && (!d || p.context === d) && w(this, y);
    else {
      for (var D = 0, o = [], M = p.length; D < M; D++)
        (p[D].fn !== s || b && !p[D].once || d && p[D].context !== d) && o.push(p[D]);
      o.length ? this._events[y] = o.length === 1 ? o[0] : o : w(this, y);
    }
    return this;
  }, v.prototype.removeAllListeners = function(a) {
    var s;
    return a ? (s = e ? e + a : a, this._events[s] && w(this, s)) : (this._events = new r(), this._eventsCount = 0), this;
  }, v.prototype.off = v.prototype.removeListener, v.prototype.addListener = v.prototype.on, v.prefixed = e, v.EventEmitter = v, n.exports = v;
})(z);
const G = z.exports;
class re {
  constructor() {
    x(this, "events");
    x(this, "requests", []);
    x(this, "cache", {});
    this.events = new G();
  }
  load(t) {
    this.requests.includes(t) || (this.requests.push(t), fetch(t).then((e) => e.json()).then((e) => {
      k("graph.load", { url: t, href: window.location.href }), this.cache[t] = e, this.events.emit("load", { url: t, data: e });
    }));
  }
}
const L = (n) => n instanceof Date, N = (n) => Object.keys(n).length === 0, S = (n) => n != null && typeof n == "object", O = (n, ...t) => Object.prototype.hasOwnProperty.call(n, ...t), E = (n) => S(n) && N(n), I = () => /* @__PURE__ */ Object.create(null), q = (n, t) => {
  if (n === t)
    return {};
  if (!S(n) || !S(t))
    return t;
  const e = Object.keys(n).reduce((r, i) => (O(t, i) || (r[i] = void 0), r), I());
  return L(n) || L(t) ? n.valueOf() == t.valueOf() ? {} : t : Object.keys(t).reduce((r, i) => {
    if (!O(n, i))
      return r[i] = t[i], r;
    const c = q(n[i], t[i]);
    return E(c) && !L(c) && (E(n[i]) || !E(t[i])) || (r[i] = c), r;
  }, e);
}, H = (n) => {
  if (typeof n != "object" || n === null)
    return false;
  const t = Object.getPrototypeOf(n);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}, B = (n) => H(n) ? Object.keys(n).reduce((t, e) => {
  if (e === "__esModule")
    return t;
  const r = Object.getOwnPropertyDescriptor(n, e), i = r && "get" in r, c = n[e];
  return i ? Object.defineProperty(t, e, r) : t[e] = B(c), t;
}, {}) : Array.isArray(n) ? n.map((t) => B(t)) : n;
ee();
const graphLoader = new re();
const CubeUVReflectionMapping = 306;
var NodeToyCullMode;
(function(NodeToyCullMode2) {
  NodeToyCullMode2["Front"] = "front";
  NodeToyCullMode2["Back"] = "back";
  NodeToyCullMode2["None"] = "none";
})(NodeToyCullMode || (NodeToyCullMode = {}));
var NodeToyMaterialType;
(function(NodeToyMaterialType2) {
  NodeToyMaterialType2["Standard"] = "standard";
  NodeToyMaterialType2["Physical"] = "physical";
  NodeToyMaterialType2["Unlit"] = "unlit";
  NodeToyMaterialType2["Image"] = "image";
})(NodeToyMaterialType || (NodeToyMaterialType = {}));
var NodeToyRenderType;
(function(NodeToyRenderType2) {
  NodeToyRenderType2["Opaque"] = "opaque";
  NodeToyRenderType2["Transparent"] = "transparent";
})(NodeToyRenderType || (NodeToyRenderType = {}));
const _NodeToyMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {
  constructor(options) {
    super();
    __publicField(this, "verbose", false);
    __publicField(this, "resetUniformByName", (name) => {
      this.resetUniformsByName([name]);
    });
    __publicField(this, "resetUniformsByName", (names) => {
      for (let i = 0; i < names.length; i++) {
        const key = names[i];
        for (let j = 0; j < this._data.uniforms.length; j++) {
          const uniform = this._data.uniforms[j];
          if (uniform.name === key) {
            this.uniforms[uniform.name] = {
              value: $(this._url, uniform.type, uniform.value),
              type: uniform.type
            };
            break;
          }
        }
      }
    });
    __publicField(this, "_fullURL", null);
    __publicField(this, "_url", null);
    __publicField(this, "_data", null);
    __publicField(this, "_parameters", {});
    __publicField(this, "_cullMode", NodeToyCullMode.Back);
    __publicField(this, "_type", NodeToyMaterialType.Unlit);
    __publicField(this, "_options", {});
    __publicField(this, "_envUUID", null);
    this.toneMapped = false;
    this.flatShading = false;
    this.transparent = true;
    this.onBeforeRender = this.onBeforeRender;
    this.normalMap = new three__WEBPACK_IMPORTED_MODULE_0__.Texture();
    this.tangentSpaceNormalMap = new three__WEBPACK_IMPORTED_MODULE_0__.Texture();
    this.aoMap = new three__WEBPACK_IMPORTED_MODULE_0__.Texture();
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.depthTest = true;
    this.depthWrite = true;
    this.envMapIntensity = 1;
    this.side = three__WEBPACK_IMPORTED_MODULE_0__.FrontSide;
    this.vertexShader = three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib.standard.vertexShader;
    this.fragmentShader = three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib.standard.fragmentShader;
    this.defines = {
      STANDARD: "",
      USE_NORMALMAP: "",
      USE_TANGENT: "",
      TANGENTSPACE_NORMALMAP: ""
    };
    this.uniforms = B(three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib.physical.uniforms);
    this.uniforms.spotShadowMatrix = { value: [new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()] };
    this.lights = true;
    this.isShaderMaterial = true;
    this.isMeshStandardMaterial = false;
    this.type = "ShaderMaterial";
    this.combine = three__WEBPACK_IMPORTED_MODULE_0__.MultiplyOperation;
    if (options) {
      "verbose" in options && (this.verbose = options.verbose);
      "url" in options && (this.url = options.url);
      "toneMapped" in options && (this.toneMapped = options.toneMapped);
      "flatShading" in options && (this.flatShading = options.flatShading);
      "transparent" in options && (this.transparent = options.transparent);
      "cullMode" in options && (this.cullMode = options.cullMode);
      this._parameters = options.parameters ? options.parameters : null;
      "polygonOffset" in options && (this.polygonOffset = options.polygonOffset);
      "polygonOffsetFactor" in options && (this.polygonOffsetFactor = options.polygonOffsetFactor);
      "depthTest" in options && (this.depthTest = options.depthTest);
      "depthWrite" in options && (this.depthWrite = options.depthWrite);
      "envMapIntensity" in options && (this.envMapIntensity = options.envMapIntensity);
      "data" in options && (this.data = options.data);
      this._options = options;
    }
    graphLoader.events.on("load", (obj) => {
      if (obj.url === this._fullURL) {
        this.loadShader(obj.data);
      }
    });
  }
  static tick() {
    _NodeToyMaterial._time.deltaTime = _NodeToyMaterial._clock.getDelta();
    _NodeToyMaterial._time.time += _NodeToyMaterial._time.deltaTime;
  }
  get cullMode() {
    return this._cullMode;
  }
  set cullMode(value) {
    this._cullMode = value;
    this.side = this.getTHREECullMode(value);
  }
  recompile() {
    this.version++;
    this.dispose();
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    super.copy(source);
    this._url = source._url;
    this._data = source._data;
    this.verbose = source.verbose;
    this._parameters && (this._parameters = __spreadValues({}, source._parameters));
    this.vertexShader = source.vertexShader;
    this.fragmentShader = source.fragmentShader;
    this.uniforms = B(source.uniforms);
    this.recompile();
    return this;
  }
  get url() {
    return this._url;
  }
  set url(value) {
    this._url = value;
    if (value) {
      const url = this._fullURL = Z(value);
      if (this.verbose) {
        console.log(`[NodeToy] loading graph... | url: ${url}`);
      }
      if (url in graphLoader.cache) {
        this.loadShader(graphLoader.cache[url]);
      } else {
        graphLoader.load(url);
      }
    } else {
      console.warn(`[NodeToy] Missing material graph URL. Cannot load shader.`);
    }
  }
  get data() {
    return this._data;
  }
  set data(value) {
    if (!value) {
      console.warn(`[NodeToy] Missing material graph data. Cannot load shader.`);
      return;
    }
    if (this.verbose) {
      console.log(`[NodeToy] seting graph data... | data:`, value);
    }
    this.loadShader(value);
  }
  get parameters() {
    return this._parameters;
  }
  set parameters(value) {
    this._parameters = value;
    if (this._data) {
      const uniforms = this._data.uniforms;
      const current = B(this.uniforms);
      const updated = m(this.url, this.uniforms, uniforms, value);
      const updatedKeys = Object.keys(q(current, updated));
      for (let i = 0; i < updatedKeys.length; i++) {
        const key = updatedKeys[i];
        this.uniforms[key] = updated[key];
      }
    }
  }
  updateUniforms(dataUniforms) {
    let uniforms = [];
    Object.assign(uniforms, dataUniforms);
    if (this._parameters !== null) {
      for (const key in this._parameters) {
        for (let i = 0; i < uniforms.length; i++) {
          if (key === uniforms[i].name)
            uniforms[i].value = this._parameters[key];
        }
      }
    }
    return uniforms;
  }
  loadShader(data) {
    if (this.verbose) {
      console.log(`[NodeToy] graph loaded.`, data, m(this.url, this.uniforms, data.uniforms));
    }
    this._data = data;
    this.vertexShader = data.vertex;
    this.fragmentShader = data.fragment;
    const updatedUniforms = this.updateUniforms(data.uniforms);
    this.uniforms = m(this.url, this.uniforms, updatedUniforms);
    this.recompile();
    if ("cullMode" in data && !("cullMode" in this._options)) {
      this.cullMode = data.cullMode;
    }
    if ("lightModel" in data) {
      this._type = data.lightModel;
    }
    if ("renderType" in data) {
      this.transparent = data.renderType === NodeToyRenderType.Transparent;
    }
  }
  onBeforeRender(renderer, scene, camera, _geometry, object) {
    const frame = {
      camera,
      object,
      renderer,
      scene,
      light: null,
      time: _NodeToyMaterial._time.time,
      deltaTime: _NodeToyMaterial._time.deltaTime
    };
    if (!renderer._rendererDOM) {
      renderer._rendererDOM = new Q(renderer);
    }
    if (this.uniforms) {
      ne(frame, this.uniforms);
    }
    if (scene.environment && this._type !== NodeToyMaterialType.Unlit) {
      if (this._envUUID != scene.environment.uuid) {
        this._envUUID = scene.environment.uuid;
        const env = scene.environment.clone();
        env.mapping = three__WEBPACK_IMPORTED_MODULE_0__.CubeUVReflectionMapping;
        this.envMap = env;
        this.envMap.mapping = three__WEBPACK_IMPORTED_MODULE_0__.CubeUVReflectionMapping;
        this.envMapMode = CubeUVReflectionMapping;
        this.uniforms.envMap.value = env;
        this.uniforms.envMapIntensity.value = this.envMapIntensity;
      }
      this.defines = {
        STANDARD: "",
        USE_NORMALMAP: "",
        USE_ENVMAP: "",
        ENVMAP_TYPE_CUBE_UV: "",
        USE_TANGENT: "",
        TANGENTSPACE_NORMALMAP: ""
      };
    } else {
      this.envMap = null;
      if ("envMap" in this.uniforms) {
        this.uniforms.envMap.value = null;
      }
      this.defines = {
        STANDARD: "",
        USE_NORMALMAP: "",
        USE_TANGENT: "",
        TANGENTSPACE_NORMALMAP: ""
      };
    }
    if (scene.fog) {
      this.defines.USE_FOG = "";
    }
  }
  getTHREECullMode(cullMode) {
    if (cullMode === NodeToyCullMode.None) {
      return three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;
    }
    if (cullMode === NodeToyCullMode.Front) {
      return three__WEBPACK_IMPORTED_MODULE_0__.BackSide;
    }
    return three__WEBPACK_IMPORTED_MODULE_0__.FrontSide;
  }
};
let NodeToyMaterial = _NodeToyMaterial;
__publicField(NodeToyMaterial, "_bindDOMEvents", () => {
});
__publicField(NodeToyMaterial, "_time", { time: 0, deltaTime: 0 });
__publicField(NodeToyMaterial, "_clock", new three__WEBPACK_IMPORTED_MODULE_0__.Clock());



/***/ }),

/***/ "./node_modules/animejs/lib/anime.es.js":
/*!**********************************************!*\
  !*** ./node_modules/animejs/lib/anime.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * anime.js v3.2.1
 * (c) 2020 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */

// Defaults

var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};

var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};

var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective', 'matrix', 'matrix3d'];

// Caching

var cache = {
  CSS: {},
  springs: {}
};

// Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) { return Array.isArray(a); },
  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
  svg: function (a) { return a instanceof SVGElement; },
  inp: function (a) { return a instanceof HTMLInputElement; },
  dom: function (a) { return a.nodeType || is.svg(a); },
  str: function (a) { return typeof a === 'string'; },
  fnc: function (a) { return typeof a === 'function'; },
  und: function (a) { return typeof a === 'undefined'; },
  nil: function (a) { return is.und(a) || a === null; },
  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
  rgb: function (a) { return /^rgb/.test(a); },
  hsl: function (a) { return /^hsl/.test(a); },
  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; },
};

// Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
}

// Spring solver inspired by Webkit Copyright © 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

function spring(string, duration) {

  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? (duration * t) / 1000 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) { return t; }
    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];
    if (cached) { return cached; }
    var frame = 1/6;
    var elapsed = 0;
    var rest = 0;
    while(true) {
      elapsed += frame;
      if (solver(elapsed) === 1) {
        rest++;
        if (rest >= 16) { break; }
      } else {
        rest = 0;
      }
    }
    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;

}

// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

function steps(steps) {
  if ( steps === void 0 ) steps = 10;

  return function (t) { return Math.ceil((minMax(t, 0.000001, 1)) * steps) * (1 / steps); };
}

// BezierEasing https://github.com/gre/bezier-easing

var bezier = (function () {

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
  function C(aA1)      { return 3.0 * aA1 }

  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) { return aGuessT; }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {

    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {

      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }

    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) { return x; }
      if (x === 0 || x === 1) { return x; }
      return calcBezier(getTForX(x), mY1, mY2);
    }

  }

  return bezier;

})();

var penner = (function () {

  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)

  var eases = { linear: function () { return function (t) { return t; }; } };

  var functionEasings = {
    Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },
    Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },
    Back: function () { return function (t) { return t * t * (3 * t - 2); }; },
    Bounce: function () { return function (t) {
      var pow2, b = 4;
      while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
      return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2)
    }; },
    Elastic: function (amplitude, period) {
      if ( amplitude === void 0 ) amplitude = 1;
      if ( period === void 0 ) period = .5;

      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return (t === 0 || t === 1) ? t : 
          -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
      }
    }
  };

  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];

  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };
  });

  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;
    eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };
    eases['easeInOut' + name] = function (a, b) { return function (t) { return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 
      1 - easeIn(a, b)(t * -2 + 2) / 2; }; };
    eases['easeOutIn' + name] = function (a, b) { return function (t) { return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : 
      (easeIn(a, b)(t * 2 - 1) + 1) / 2; }; };
  });

  return eases;

})();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) { return easing; }
  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);
  switch (name) {
    case 'spring' : return spring(easing, duration);
    case 'cubicBezier' : return applyArguments(bezier, args);
    case 'steps' : return applyArguments(steps, args);
    default : return applyArguments(ease, args);
  }
}

// Strings

function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch(e) {
    return;
  }
}

// Arrays

function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];
  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];
      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }
  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
}

function toArray(o) {
  if (is.arr(o)) { return o; }
  if (is.str(o)) { o = selectString(o) || o; }
  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) { return a === val; });
}

// Objects

function cloneObject(o) {
  var clone = {};
  for (var p in o) { clone[p] = o[p]; }
  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
  return o;
}

// Colors

function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return ("rgba(" + r + "," + g + "," + b + ",1)");
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;
  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1/6) { return p + (q - p) * 6 * t; }
    if (t < 1/2) { return q; }
    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
    return p;
  }
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
}

function colorToRgb(val) {
  if (is.rgb(val)) { return rgbToRgba(val); }
  if (is.hex(val)) { return hexToRgba(val); }
  if (is.hsl(val)) { return hslToRgba(val); }
}

// Units

function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
  if (split) { return split[1]; }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
}

// Values

function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) { return val; }
  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);
  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
  var cached = cache.CSS[value + unit];
  if (!is.und(cached)) { return cached; }
  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || (is.svg(el) && el[prop]))) { return 'attribute'; }
  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
  if (el[prop] != null) { return 'object'; }
}

function getElementTransforms(el) {
  if (!is.dom(el)) { return; }
  var str = el.style.transform || '';
  var reg  = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;
  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }
  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform': return getTransformValue(target, propName, animatable, unit);
    case 'css': return getCSSValue(target, propName, unit);
    case 'attribute': return getAttribute(target, propName);
    default: return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);
  if (!operator) { return to; }
  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));
  switch (operator[0][0]) {
    case '+': return x + y + u;
    case '-': return x - y + u;
    case '*': return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) { return colorToRgb(val); }
  if (/\s/g.test(val)) { return val; }
  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
  if (unit) { return unitLess + unit; }
  return unitLess;
}

// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
}

function getLineLength(el) {
  return getDistance(
    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
  );
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;
  for (var i = 0 ; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
    previousPos = currentPos;
  }
  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}

// Path animation

function getTotalLength(el) {
  if (el.getTotalLength) { return el.getTotalLength(); }
  switch(el.tagName.toLowerCase()) {
    case 'circle': return getCircleLength(el);
    case 'rect': return getRectLength(el);
    case 'line': return getLineLength(el);
    case 'polyline': return getPolylineLength(el);
    case 'polygon': return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
}

// Motion path

function getParentSvgEl(el) {
  var parentEl = el.parentNode;
  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) { break; }
    parentEl = parentEl.parentNode;
  }
  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width,
    h: height,
    vW: viewBox[2],
    vH: viewBox[3]
  }
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function(property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    }
  }
}

function getPathProgress(path, progress, isPathTargetInsideSVG) {
  function point(offset) {
    if ( offset === void 0 ) offset = 0;

    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }
  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;
  var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;
  switch (path.property) {
    case 'x': return (p.x - svg.x) * scaleX;
    case 'y': return (p.y - svg.y) * scaleY;
    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
}

// Decompose value

function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: (is.str(val) || unit) ? value.split(rgx) : []
  }
}

// Animatables

function parseTargets(targets) {
  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
  });
}

// Properties

function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings);
  // Override duration if easing is a spring
  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = (l === 2 && !is.obj(prop[0]));
    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {value: prop};
    }
  }
  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
    // Default delay value should only be applied to the first tween
    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
    // Default endDelay value should only be applied to the last tween
    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
    return obj;
  }).map(function (k) { return mergeObjects(k, settings); });
}


function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
  var properties = {};
  var loop = function ( i ) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};
      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) { newKey.value = key[p]; }
        } else {
          newKey[p] = key[p];
        }
      }
      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop( i );
  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;
  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }
  return properties;
}

// Tweens

function normalizeTweenValues(tween, animatable) {
  var t = {};
  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);
    if (is.arr(value)) {
      value = value.map(function (v) { return getFunctionValue(v, animatable); });
      if (value.length === 1) { value = value[0]; }
    }
    t[p] = value;
  }
  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;
    if (is.und(to)) { to = previousValue; }
    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);
    tween.isColor = is.col(tween.from.original);
    if (tween.isColor) { tween.round = 1; }
    previousTween = tween;
    return tween;
  });
}

// Tween progress

var setProgressValue = {
  css: function (t, p, v) { return t.style[p] = v; },
  attribute: function (t, p, v) { return t.setAttribute(p, v); },
  object: function (t, p, v) { return t[p] = v; },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);
    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
      t.style.transform = str;
    }
  }
};

// Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
}

// Animations

function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);
  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    }
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) { return !is.und(a); });
}

// Create Instance

function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;
  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
}

// Core

var activeInstances = [];

var engine = (function () {
  var raf;

  function play() {
    if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {
      raf = requestAnimationFrame(step);
    }
  }
  function step(t) {
    // memo on algorithm issue:
    // dangerous iteration over mutable `activeInstances`
    // (that collection may be updated from within callbacks of `tick`-ed animation instances)
    var activeInstancesLength = activeInstances.length;
    var i = 0;
    while (i < activeInstancesLength) {
      var activeInstance = activeInstances[i];
      if (!activeInstance.paused) {
        activeInstance.tick(t);
        i++;
      } else {
        activeInstances.splice(i, 1);
        activeInstancesLength--;
      }
    }
    raf = i > 0 ? requestAnimationFrame(step) : undefined;
  }

  function handleVisibilityChange() {
    if (!anime.suspendWhenDocumentHidden) { return; }

    if (isDocumentHidden()) {
      // suspend ticks
      raf = cancelAnimationFrame(raf);
    } else { // is back to active tab
      // first adjust animations to consider the time that ticks were suspended
      activeInstances.forEach(
        function (instance) { return instance ._onDocumentVisibility(); }
      );
      engine();
    }
  }
  if (typeof document !== 'undefined') {
    document.addEventListener('visibilitychange', handleVisibilityChange);
  }

  return play;
})();

function isDocumentHidden() {
  return !!document && document.hidden;
}

// Public Instance

function anime(params) {
  if ( params === void 0 ) params = {};


  var startTime = 0, lastTime = 0, now = 0;
  var children, childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;
    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }
    instance.reversed = !instance.reversed;
    children.forEach(function (child) { return child.reversed = instance.reversed; });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) { child.seek(time - child.timelineOffset); }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }
    } else {
      for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;
    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength];
      // Only check for keyframes if there is more than one tween
      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = (void 0);
      for (var n = 0; n < toNumbersLength; n++) {
        var value = (void 0);
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;
        if (!tween.isPath) {
          value = fromNumber + (eased * (toNumber - fromNumber));
        } else {
          value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);
        }
        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }
        numbers.push(value);
      }
      // Manual Array.reduce for better performances
      var stringsLength = strings.length;
      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];
        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];
          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }
      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;
    if (children) { syncInstanceChildren(insTime); }
    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }
    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }
    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }
    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
      setAnimationsProgress(insDuration);
    }
    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }
      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }
    instance.currentTime = minMax(insTime, 0, insDuration);
    if (instance.began) { setCallback('update'); }
    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();
      if (!instance.remaining) {
        instance.paused = true;
        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');
          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;
        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function() {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;
    for (var i = childrenLength; i--;) { instance.children[i].reset(); }
    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  };

  // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)
  instance._onDocumentVisibility = resetTime;

  // Set Value helper

  instance.set = function(targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function(t) {
    now = t;
    if (!startTime) { startTime = now; }
    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function(time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function() {
    instance.paused = true;
    resetTime();
  };

  instance.play = function() {
    if (!instance.paused) { return; }
    if (instance.completed) { instance.reset(); }
    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    engine();
  };

  instance.reverse = function() {
    toggleInstanceDirection();
    instance.completed = instance.reversed ? false : true;
    resetTime();
  };

  instance.restart = function() {
    instance.reset();
    instance.play();
  };

  instance.remove = function(targets) {
    var targetsArray = parseTargets(targets);
    removeTargetsFromInstance(targetsArray, instance);
  };

  instance.reset();

  if (instance.autoplay) { instance.play(); }

  return instance;

}

// Remove targets from animation

function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargetsFromInstance(targetsArray, instance) {
  var animations = instance.animations;
  var children = instance.children;
  removeTargetsFromAnimations(targetsArray, animations);
  for (var c = children.length; c--;) {
    var child = children[c];
    var childAnimations = child.animations;
    removeTargetsFromAnimations(targetsArray, childAnimations);
    if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
  }
  if (!animations.length && !children.length) { instance.pause(); }
}

function removeTargetsFromActiveInstances(targets) {
  var targetsArray = parseTargets(targets);
  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    removeTargetsFromInstance(targetsArray, instance);
  }
}

// Stagger helpers

function stagger(val, params) {
  if ( params === void 0 ) params = {};

  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) { fromIndex = 0; }
    if (fromCenter) { fromIndex = (t - 1) / 2; }
    if (fromLast) { fromIndex = t - 1; }
    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
          var toX = index%grid[0];
          var toY = Math.floor(index/grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') { value = -distanceX; }
          if (axis === 'y') { value = -distanceY; }
          values.push(value);
        }
        maxValue = Math.max.apply(Math, values);
      }
      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
    }
    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
  }
}

// Timeline

function timeline(params) {
  if ( params === void 0 ) params = {};

  var tl = anime(params);
  tl.duration = 0;
  tl.add = function(instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;
    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
    function passThrough(ins) { ins.passThrough = true; }
    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();
    if (tl.autoplay) { tl.play(); }
    return tl;
  };
  return tl;
}

anime.version = '3.2.1';
anime.speed = 1;
// TODO:#review: naming, documentation
anime.suspendWhenDocumentHidden = true;
anime.running = activeInstances;
anime.remove = removeTargetsFromActiveInstances;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;
anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (anime);


/***/ }),

/***/ "./build-config/config.ts":
/*!********************************!*\
  !*** ./build-config/config.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "config": () => (/* binding */ config)
/* harmony export */ });
const config = {
  storeUrl: {
    ios: "https://apps.apple.com/us/app/moon-pioneer/id1586844471",
    android: "https://play.google.com/store/apps/details?id=com.norwichsidegames.tothemoon&hl=en_US&gl=US"
  }
};

/***/ }),

/***/ "./build-config/networks/preview.js":
/*!******************************************!*\
  !*** ./build-config/networks/preview.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "network": () => (/* binding */ network)
/* harmony export */ });
/* harmony import */ var _src_playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/playable-helper/ice-cream/ice-cream */ "./src/playable-helper/ice-cream/ice-cream.ts");

function network(app, config) {
  return {
    start: function () {
      window.addEventListener("load", function () {
        new app();
      });
    },
    openStore: function () {
      window.top.open(this.getUrl());
    },
    getUrl: function () {
      var ua = navigator.userAgent.toLowerCase();
      var isAndroid = ua.indexOf("android") > -1;
      if (_src_playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_0__.ICECREAM) {
        if (isAndroid) {
          return config.storeUrl.android;
        }
        return config.storeUrl.ios;
      } else {
        if (isAndroid) {
          return config.storeUrl.android;
        }
        return config.storeUrl.ios;
      }
    }
  };
}

/***/ }),

/***/ "./build-config/shared-dependencies.js":
/*!*********************************************!*\
  !*** ./build-config/shared-dependencies.js ***!
  \*********************************************/
/***/ (() => {



/***/ }),

/***/ "./src/game/asset-list/raw-assets-list.ts":
/*!************************************************!*\
  !*** ./src/game/asset-list/raw-assets-list.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DevFontName": () => (/* binding */ DevFontName),
/* harmony export */   "DevModelName": () => (/* binding */ DevModelName),
/* harmony export */   "DevTextureName": () => (/* binding */ DevTextureName)
/* harmony export */ });
/* harmony import */ var _assets_textures_base_error_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../assets/textures/base/error.png */ "./src/assets/textures/base/error.png");
/* harmony import */ var _assets_textures_white_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../assets/textures/white.png */ "./src/assets/textures/white.png");
/* harmony import */ var _assets_models_base_cube_gltf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/models/base/cube.gltf */ "./src/assets/models/base/cube.gltf");
/* harmony import */ var _assets_models_diamond_rush_Career_gltf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../assets/models/diamond_rush/Career.gltf */ "./src/assets/models/diamond_rush/Career.gltf");
/* harmony import */ var _assets_models_diamond_rush_TronMalen_gltf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../assets/models/diamond_rush/TronMalen.gltf */ "./src/assets/models/diamond_rush/TronMalen.gltf");
/* harmony import */ var _assets_models_diamond_rush_blocks_gltf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../assets/models/diamond_rush/blocks.gltf */ "./src/assets/models/diamond_rush/blocks.gltf");
/* harmony import */ var _assets_models_diamond_rush_Kirka_gltf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../assets/models/diamond_rush/Kirka.gltf */ "./src/assets/models/diamond_rush/Kirka.gltf");
/* harmony import */ var _assets_models_animations_diamond_rush_idle_gltf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../assets/models/animations/diamond_rush/idle.gltf */ "./src/assets/models/animations/diamond_rush/idle.gltf");
/* harmony import */ var _assets_models_animations_diamond_rush_Walking_gltf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../assets/models/animations/diamond_rush/Walking.gltf */ "./src/assets/models/animations/diamond_rush/Walking.gltf");
/* harmony import */ var _assets_models_animations_diamond_rush_Running4_gltf__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../assets/models/animations/diamond_rush/Running4.gltf */ "./src/assets/models/animations/diamond_rush/Running4.gltf");
/* harmony import */ var _assets_models_animations_diamond_rush_attack_gltf__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../assets/models/animations/diamond_rush/attack.gltf */ "./src/assets/models/animations/diamond_rush/attack.gltf");
/* harmony import */ var _assets_models_animations_diamond_rush_Jump_gltf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../assets/models/animations/diamond_rush/Jump.gltf */ "./src/assets/models/animations/diamond_rush/Jump.gltf");
/* harmony import */ var _assets_textures_diamond_rush_character_texture_roughnes_map_png__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/character_texture/roughnes_map.png */ "./src/assets/textures/diamond_rush/character_texture/roughnes_map.png");
/* harmony import */ var _assets_textures_diamond_rush_character_texture_normal_map_png__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/character_texture/normal_map.png */ "./src/assets/textures/diamond_rush/character_texture/normal_map.png");
/* harmony import */ var _assets_textures_diamond_rush_character_texture_emmisive_png__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/character_texture/emmisive.png */ "./src/assets/textures/diamond_rush/character_texture/emmisive.png");
/* harmony import */ var _assets_textures_diamond_rush_terrain_grass_terrain_png__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/terrain/grass_terrain.png */ "./src/assets/textures/diamond_rush/terrain/grass_terrain.png");
/* harmony import */ var _assets_textures_diamond_rush_terrain_ground_01_png__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/terrain/ground_01.png */ "./src/assets/textures/diamond_rush/terrain/ground_01.png");
/* harmony import */ var _assets_textures_diamond_rush_grass_blade_diffuse_jpg__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/grass/blade_diffuse.jpg */ "./src/assets/textures/diamond_rush/grass/blade_diffuse.jpg");
/* harmony import */ var _assets_textures_diamond_rush_grass_blade_alpha_jpg__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/grass//blade_alpha.jpg */ "./src/assets/textures/diamond_rush/grass/blade_alpha.jpg");
/* harmony import */ var _assets_textures_diamond_rush_grass_perlinFbm_jpg__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/grass//perlinFbm.jpg */ "./src/assets/textures/diamond_rush/grass/perlinFbm.jpg");
/* harmony import */ var _assets_background_blue_skybox_png__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../assets/background/blue_skybox.png */ "./src/assets/background/blue_skybox.png");
/* harmony import */ var _assets_textures_diamond_rush_popup_white_png__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/popup/white.png */ "./src/assets/textures/diamond_rush/popup/white.png");
/* harmony import */ var _assets_textures_diamond_rush_popup_purple_png__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/popup/purple.png */ "./src/assets/textures/diamond_rush/popup/purple.png");
/* harmony import */ var _assets_textures_diamond_rush_popup_bitcoin_png__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/popup/bitcoin.png */ "./src/assets/textures/diamond_rush/popup/bitcoin.png");
/* harmony import */ var _assets_textures_diamond_rush_popup_gold_png__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/popup/gold.png */ "./src/assets/textures/diamond_rush/popup/gold.png");
/* harmony import */ var _assets_textures_diamond_rush_popup_sand_png__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/popup/sand.png */ "./src/assets/textures/diamond_rush/popup/sand.png");
/* harmony import */ var _assets_textures_diamond_rush_popup_ore_png__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/popup/ore.png */ "./src/assets/textures/diamond_rush/popup/ore.png");
/* harmony import */ var _assets_textures_diamond_rush_popup_crystal_png__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../assets/textures/diamond_rush/popup/crystal.png */ "./src/assets/textures/diamond_rush/popup/crystal.png");
/* harmony import */ var _assets_textures_pointer_png__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../assets/textures/pointer.png */ "./src/assets/textures/pointer.png");
/* harmony import */ var _assets_textures_cloud_png__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../../assets/textures/cloud.png */ "./src/assets/textures/cloud.png");
/* harmony import */ var _assets_fonts_Anton_Regular_json__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../../assets/fonts/Anton-Regular.json */ "./src/assets/fonts/Anton-Regular.json");
//world




//dr





//dr animations






//dr texture






//shader grass




//dr blue skybox

//dr popup








//texture


//dr
//---
//--

//particles
//fonts

const DevModelName = {
  //glb, gltf
  GLTF_ERROR: _assets_models_base_cube_gltf__WEBPACK_IMPORTED_MODULE_2__,
  //diamond_rush
  GLTF_CAREER: _assets_models_diamond_rush_Career_gltf__WEBPACK_IMPORTED_MODULE_3__,
  GLTF_CHARACTER_TRON: _assets_models_diamond_rush_TronMalen_gltf__WEBPACK_IMPORTED_MODULE_4__,
  GLTF_FLOATING_ISLAND: _assets_models_diamond_rush_blocks_gltf__WEBPACK_IMPORTED_MODULE_5__,
  GLTF_WEAPON_PICKAXE: _assets_models_diamond_rush_Kirka_gltf__WEBPACK_IMPORTED_MODULE_6__,
  //animations
  ANIMATION_DR_IDLE: _assets_models_animations_diamond_rush_idle_gltf__WEBPACK_IMPORTED_MODULE_7__,
  ANIMATION_DR_WALK: _assets_models_animations_diamond_rush_Walking_gltf__WEBPACK_IMPORTED_MODULE_8__,
  ANIMATION_DR_RUN: _assets_models_animations_diamond_rush_Running4_gltf__WEBPACK_IMPORTED_MODULE_9__,
  ANIMATION_DR_ATTACK: _assets_models_animations_diamond_rush_attack_gltf__WEBPACK_IMPORTED_MODULE_10__,
  ANIMATION_DR_JUMP: _assets_models_animations_diamond_rush_Jump_gltf__WEBPACK_IMPORTED_MODULE_11__
};
const DevTextureName = {
  MISSING_TEXTURE: _assets_textures_base_error_png__WEBPACK_IMPORTED_MODULE_0__,
  WHITE: _assets_textures_white_png__WEBPACK_IMPORTED_MODULE_1__,
  POINTER: _assets_textures_pointer_png__WEBPACK_IMPORTED_MODULE_28__,
  //character
  DR_CHARACTER_EMMISIVE: _assets_textures_diamond_rush_character_texture_emmisive_png__WEBPACK_IMPORTED_MODULE_14__,
  DR_CHARACTER_NORMAL: _assets_textures_diamond_rush_character_texture_normal_map_png__WEBPACK_IMPORTED_MODULE_13__,
  DR_CHARACTER_ROUGHNES: _assets_textures_diamond_rush_character_texture_roughnes_map_png__WEBPACK_IMPORTED_MODULE_12__,
  //blue skybox
  DR_BLUE_SKYBOX: _assets_background_blue_skybox_png__WEBPACK_IMPORTED_MODULE_20__,
  //terrain
  DR_TERRAIN_GRASS: _assets_textures_diamond_rush_terrain_grass_terrain_png__WEBPACK_IMPORTED_MODULE_15__,
  DR_GROUND_BLOCK: _assets_textures_diamond_rush_terrain_ground_01_png__WEBPACK_IMPORTED_MODULE_16__,
  //grass
  DR_SHADER_GRASS_MAP: _assets_textures_diamond_rush_grass_blade_diffuse_jpg__WEBPACK_IMPORTED_MODULE_17__,
  DR_SHADER_GRASS_ALPHA: _assets_textures_diamond_rush_grass_blade_alpha_jpg__WEBPACK_IMPORTED_MODULE_18__,
  DR_SHADER_GRASS_NOISE: _assets_textures_diamond_rush_grass_perlinFbm_jpg__WEBPACK_IMPORTED_MODULE_19__,
  //popup
  DR_POPUP_WHITE: _assets_textures_diamond_rush_popup_white_png__WEBPACK_IMPORTED_MODULE_21__,
  DR_POPUP_PURPLE: _assets_textures_diamond_rush_popup_purple_png__WEBPACK_IMPORTED_MODULE_22__,
  DR_POPUP_GOLD: _assets_textures_diamond_rush_popup_gold_png__WEBPACK_IMPORTED_MODULE_24__,
  DR_POPUP_BITCOIN: _assets_textures_diamond_rush_popup_bitcoin_png__WEBPACK_IMPORTED_MODULE_23__,
  DR_POPUP_SAND: _assets_textures_diamond_rush_popup_sand_png__WEBPACK_IMPORTED_MODULE_25__,
  DR_POPUP_CRYSTAL: _assets_textures_diamond_rush_popup_crystal_png__WEBPACK_IMPORTED_MODULE_27__,
  DR_POPUP_ORE: _assets_textures_diamond_rush_popup_ore_png__WEBPACK_IMPORTED_MODULE_26__,
  //shader
  CLOUD: _assets_textures_cloud_png__WEBPACK_IMPORTED_MODULE_29__
};
const DevFontName = {
  ANTONTTF: _assets_fonts_Anton_Regular_json__WEBPACK_IMPORTED_MODULE_30__
};

/***/ }),

/***/ "./src/game/asset-list/raw-assets/font-raw-assets.ts":
/*!***********************************************************!*\
  !*** ./src/game/asset-list/raw-assets/font-raw-assets.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawFonts": () => (/* binding */ RawFonts),
/* harmony export */   "fontList": () => (/* binding */ fontList)
/* harmony export */ });
/* harmony import */ var _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw-assets-list */ "./src/game/asset-list/raw-assets-list.ts");

let RawFonts;
(function (RawFonts) {
  RawFonts[RawFonts["FONT_ANTON"] = 0] = "FONT_ANTON";
})(RawFonts || (RawFonts = {}));
const fontList = {
  // @ts-ignore
  [RawFonts.FONT_ANTON]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevFontName.ANTONTTF
};

/***/ }),

/***/ "./src/game/asset-list/raw-assets/object3d-raw-asstes.ts":
/*!***************************************************************!*\
  !*** ./src/game/asset-list/raw-assets/object3d-raw-asstes.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawObject3D": () => (/* binding */ RawObject3D),
/* harmony export */   "object3DList": () => (/* binding */ object3DList)
/* harmony export */ });
/* harmony import */ var _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw-assets-list */ "./src/game/asset-list/raw-assets-list.ts");
/* harmony import */ var _playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../playable-helper/ice-cream/ice-cream */ "./src/playable-helper/ice-cream/ice-cream.ts");


if (!_playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_1__.ICECREAM) {
  console.log("%c 💣 PLAYPHORIA 3D MODELS", "background: #222; color: #ffffff");
  window._gameplay = {
    creative: {}
  };
} else {
  console.log("%c 🍦ICECREAM 3D MODELS IS INIT by 💣 PLAYPHORIA", "background: #222; color: #8B00FF");
}
let RawObject3D;
(function (RawObject3D) {
  RawObject3D[RawObject3D["ERRORMODEL"] = 0] = "ERRORMODEL";
  RawObject3D[RawObject3D["DR_CHARACTER"] = 1] = "DR_CHARACTER";
  RawObject3D[RawObject3D["DR_FLOATINGISLAND"] = 2] = "DR_FLOATINGISLAND";
  RawObject3D[RawObject3D["DR_GRASS_PLANE"] = 3] = "DR_GRASS_PLANE";
  RawObject3D[RawObject3D["DR_CAREER"] = 4] = "DR_CAREER";
  RawObject3D[RawObject3D["DR_TERRAIN"] = 5] = "DR_TERRAIN";
  RawObject3D[RawObject3D["DR_WEAPON_PICKAXE"] = 6] = "DR_WEAPON_PICKAXE";
  RawObject3D[RawObject3D["ANIMATION_DR_IDLE"] = 7] = "ANIMATION_DR_IDLE";
  RawObject3D[RawObject3D["ANIMATION_DR_WALK"] = 8] = "ANIMATION_DR_WALK";
  RawObject3D[RawObject3D["ANIMATION_DR_RUN"] = 9] = "ANIMATION_DR_RUN";
  RawObject3D[RawObject3D["ANIMATION_DR_JUMP"] = 10] = "ANIMATION_DR_JUMP";
  RawObject3D[RawObject3D["ANIMATION_DR_ATTACK"] = 11] = "ANIMATION_DR_ATTACK";
})(RawObject3D || (RawObject3D = {}));
const object3DList = {
  [RawObject3D.ERRORMODEL]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.GLTF_ERROR,
  //diamond_rush
  [RawObject3D.DR_CHARACTER]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.GLTF_CHARACTER_TRON,
  [RawObject3D.DR_FLOATINGISLAND]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.GLTF_FLOATING_ISLAND,
  [RawObject3D.DR_GRASS_PLANE]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.GLTF_GRASS_PLANE,
  [RawObject3D.DR_CAREER]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.GLTF_CAREER,
  [RawObject3D.DR_TERRAIN]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.GLTF_TERRAIN,
  [RawObject3D.DR_WEAPON_PICKAXE]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.GLTF_WEAPON_PICKAXE,
  //animations
  [RawObject3D.ANIMATION_DR_IDLE]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.ANIMATION_DR_IDLE,
  [RawObject3D.ANIMATION_DR_WALK]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.ANIMATION_DR_WALK,
  [RawObject3D.ANIMATION_DR_RUN]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.ANIMATION_DR_RUN,
  [RawObject3D.ANIMATION_DR_JUMP]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.ANIMATION_DR_JUMP,
  [RawObject3D.ANIMATION_DR_ATTACK]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.ANIMATION_DR_ATTACK
};

/***/ }),

/***/ "./src/game/asset-list/raw-assets/texture-raw-assets.ts":
/*!**************************************************************!*\
  !*** ./src/game/asset-list/raw-assets/texture-raw-assets.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawTexture": () => (/* binding */ RawTexture),
/* harmony export */   "textureList": () => (/* binding */ textureList)
/* harmony export */ });
/* harmony import */ var _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw-assets-list */ "./src/game/asset-list/raw-assets-list.ts");
/* harmony import */ var _playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../playable-helper/ice-cream/ice-cream */ "./src/playable-helper/ice-cream/ice-cream.ts");


if (!_playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_1__.ICECREAM) {
  console.log("%c 💣 PLAYPHORIA TEXTURES", "background: #222; color: #ffffff");
  window._gameplay = {
    creative: {}
  };
} else {
  console.log("%c 🍦ICECREAM TEXTURES IS INIT by 💣 PLAYPHORIA", "background: #222; color: #8B00FF");
}
let RawTexture;

//
// DR_CHARACTER_EMMISIVE: character_emmisive,
//     DR_CHARACTER_NORMAL: character_normal,
//     DR_CHARACTER_ROUGHNES: character_roughnes,
(function (RawTexture) {
  RawTexture[RawTexture["ERROR"] = 0] = "ERROR";
  RawTexture[RawTexture["DR_CHARACTER_NORMAL"] = 1] = "DR_CHARACTER_NORMAL";
  RawTexture[RawTexture["DR_CHARACTER_ROUGHNES"] = 2] = "DR_CHARACTER_ROUGHNES";
  RawTexture[RawTexture["DR_CHARACTER_EMMISIVE"] = 3] = "DR_CHARACTER_EMMISIVE";
  RawTexture[RawTexture["DR_BLUE_SKYBOX"] = 4] = "DR_BLUE_SKYBOX";
  RawTexture[RawTexture["DR_TERRAIN_GRASS"] = 5] = "DR_TERRAIN_GRASS";
  RawTexture[RawTexture["DR_SHADER_GRASS_MAP"] = 6] = "DR_SHADER_GRASS_MAP";
  RawTexture[RawTexture["DR_SHADER_GRASS_ALPHA"] = 7] = "DR_SHADER_GRASS_ALPHA";
  RawTexture[RawTexture["DR_SHADER_GRASS_NOISE"] = 8] = "DR_SHADER_GRASS_NOISE";
  RawTexture[RawTexture["DR_BLOCK_TEXTURE"] = 9] = "DR_BLOCK_TEXTURE";
  RawTexture[RawTexture["DR_POPUP_WHITE"] = 10] = "DR_POPUP_WHITE";
  RawTexture[RawTexture["DR_POPUP_PURPLE"] = 11] = "DR_POPUP_PURPLE";
  RawTexture[RawTexture["DR_POPUP_GOLD"] = 12] = "DR_POPUP_GOLD";
  RawTexture[RawTexture["DR_POPUP_BITCOIN"] = 13] = "DR_POPUP_BITCOIN";
  RawTexture[RawTexture["DR_POPUP_SAND"] = 14] = "DR_POPUP_SAND";
  RawTexture[RawTexture["DR_POPUP_ORE"] = 15] = "DR_POPUP_ORE";
  RawTexture[RawTexture["DR_POPUP_CRYSTAL"] = 16] = "DR_POPUP_CRYSTAL";
})(RawTexture || (RawTexture = {}));
const textureList = {
  [RawTexture.ERROR]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.MISSING_TEXTURE,
  [RawTexture.DR_BLUE_SKYBOX]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_BLUE_SKYBOX,
  //character
  [RawTexture.DR_CHARACTER_ROUGHNES]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_CHARACTER_ROUGHNES,
  [RawTexture.DR_CHARACTER_NORMAL]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_CHARACTER_NORMAL,
  [RawTexture.DR_CHARACTER_EMMISIVE]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_CHARACTER_EMMISIVE,
  //skybox

  //terrain
  [RawTexture.DR_TERRAIN_GRASS]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_TERRAIN_GRASS,
  [RawTexture.DR_BLOCK_TEXTURE]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_GROUND_BLOCK,
  //shader
  [RawTexture.DR_SHADER_GRASS_ALPHA]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_SHADER_GRASS_ALPHA,
  [RawTexture.DR_SHADER_GRASS_NOISE]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_SHADER_GRASS_NOISE,
  [RawTexture.DR_SHADER_GRASS_MAP]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_SHADER_GRASS_MAP,
  //popup
  [RawTexture.DR_POPUP_WHITE]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_POPUP_WHITE,
  [RawTexture.DR_POPUP_PURPLE]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_POPUP_PURPLE,
  [RawTexture.DR_POPUP_GOLD]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_POPUP_GOLD,
  [RawTexture.DR_POPUP_SAND]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_POPUP_SAND,
  [RawTexture.DR_POPUP_BITCOIN]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_POPUP_BITCOIN,
  [RawTexture.DR_POPUP_ORE]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_POPUP_ORE,
  [RawTexture.DR_POPUP_CRYSTAL]: _raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.DR_POPUP_CRYSTAL
};

/***/ }),

/***/ "./src/game/components/animation-state-component.ts":
/*!**********************************************************!*\
  !*** ./src/game/components/animation-state-component.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationStateComponent": () => (/* binding */ AnimationStateComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _descriptor3;

let AnimationStateComponent = (_dec = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, _dec2 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, _dec3 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class AnimationStateComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "stateManager", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "states", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "currentState", _descriptor3, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "stateManager", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "states", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "currentState", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/bhv-components/ground-collision.ts":
/*!****************************************************************!*\
  !*** ./src/game/components/bhv-components/ground-collision.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GroundCollisionComponent": () => (/* binding */ GroundCollisionComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _class, _class2, _descriptor;

let GroundCollisionComponent = (_dec = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class GroundCollisionComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", _descriptor, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "id", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/bhv-components/sphere-collider-component.ts":
/*!*************************************************************************!*\
  !*** ./src/game/components/bhv-components/sphere-collider-component.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DestroyBlock": () => (/* binding */ DestroyBlock),
/* harmony export */   "HitComponentTag": () => (/* binding */ HitComponentTag),
/* harmony export */   "HpBlock": () => (/* binding */ HpBlock),
/* harmony export */   "IsHitBlock": () => (/* binding */ IsHitBlock),
/* harmony export */   "SphereColliderComponent": () => (/* binding */ SphereColliderComponent),
/* harmony export */   "damageBlock": () => (/* binding */ damageBlock),
/* harmony export */   "registerSphereColliderTag": () => (/* binding */ registerSphereColliderTag)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _class4, _class5, _class6, _dec5, _class7, _class8, _descriptor5, _dec6, _class10, _class11, _descriptor6, _class13;

let SphereColliderComponent = (_dec = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.object
}), _dec3 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec4 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class SphereColliderComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "parent", _descriptor, this);
    // @field({ type: Type.object, default: new Mesh() }) declare sphereMesh: Mesh;
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "sphereMesh", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "radius", _descriptor3, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "position", _descriptor4, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "parent", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "sphereMesh", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "radius", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "position", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
let registerSphereColliderTag = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class4 = class registerSphereColliderTag {}) || _class4;
let HitComponentTag = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class5 = class HitComponentTag {}) || _class5;
let IsHitBlock = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class6 = class IsHitBlock {}) || _class6;
let damageBlock = (_dec5 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.int32,
  default: 1
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class7 = (_class8 = class damageBlock {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "value", _descriptor5, this);
  }
}, (_descriptor5 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class8.prototype, "value", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class8)) || _class7);
let HpBlock = (_dec6 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.int32,
  default: 3
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class10 = (_class11 = class HpBlock {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "value", _descriptor6, this);
  }
}, (_descriptor6 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class11.prototype, "value", [_dec6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class11)) || _class10);
let DestroyBlock = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class13 = class DestroyBlock {}) || _class13;

/***/ }),

/***/ "./src/game/components/bhv-components/vision-collider-component.ts":
/*!*************************************************************************!*\
  !*** ./src/game/components/bhv-components/vision-collider-component.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VisionColliderComponent": () => (/* binding */ VisionColliderComponent),
/* harmony export */   "VisionColliderHit": () => (/* binding */ VisionColliderHit),
/* harmony export */   "registerVisionColliderTag": () => (/* binding */ registerVisionColliderTag)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _class4, _class5;

let VisionColliderComponent = (_dec = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.object
}), _dec3 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec4 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class VisionColliderComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "parent", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "boxMesh", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "radius", _descriptor3, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "position", _descriptor4, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "parent", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "boxMesh", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "radius", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "position", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
let registerVisionColliderTag = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class4 = class registerVisionColliderTag {}) || _class4;
let VisionColliderHit = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class5 = class VisionColliderHit {}) || _class5;

/***/ }),

/***/ "./src/game/components/camera-component.ts":
/*!*************************************************!*\
  !*** ./src/game/components/camera-component.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CameraComponent": () => (/* binding */ CameraComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "./src/game/components/types.ts");



var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _descriptor3;


let CameraComponent = (_dec = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)(_types__WEBPACK_IMPORTED_MODULE_4__.Vec3WithDefaultZeroType), _dec3 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.boolean, (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class CameraComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "camera", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "offSet", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isFollow", _descriptor3, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "camera", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "offSet", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "isFollow", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/camera-shake-component.ts":
/*!*******************************************************!*\
  !*** ./src/game/components/camera-shake-component.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CameraShakeComponent": () => (/* binding */ CameraShakeComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _dec2, _class, _class2, _descriptor, _descriptor2;

let CameraShakeComponent = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float64,
  default: 0.32
}), _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float64,
  default: 0.2
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class CameraShakeComponent {
  constructor() {
    //duration
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "duration", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "intensity", _descriptor2, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "duration", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "intensity", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/character-stats/attack.ts":
/*!*******************************************************!*\
  !*** ./src/game/components/character-stats/attack.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Attack": () => (/* binding */ Attack)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _dec2, _class, _class2, _descriptor, _descriptor2;

let Attack = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float32,
  default: 5
}), _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float32,
  default: 2
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class Attack {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attack", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "distance", _descriptor2, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "attack", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "distance", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/character-stats/defence.ts":
/*!********************************************************!*\
  !*** ./src/game/components/character-stats/defence.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Defence": () => (/* binding */ Defence)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _class, _class2, _descriptor;

let Defence = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float32,
  default: 10
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class Defence {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "defence", _descriptor, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "defence", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/character-stats/health.ts":
/*!*******************************************************!*\
  !*** ./src/game/components/character-stats/health.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Health": () => (/* binding */ Health)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _descriptor3;

let Health = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float32,
  default: 100
}), _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float32,
  default: 100
}), _dec3 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.object
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class Health {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "currentHealth", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "maxHealth", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "healthBar", _descriptor3, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "currentHealth", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "maxHealth", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "healthBar", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/character-stats/states/world-states-components.ts":
/*!*******************************************************************************!*\
  !*** ./src/game/components/character-stats/states/world-states-components.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttackStateComponent": () => (/* binding */ AttackStateComponent),
/* harmony export */   "IdleStateComponent": () => (/* binding */ IdleStateComponent),
/* harmony export */   "RunStateComponent": () => (/* binding */ RunStateComponent),
/* harmony export */   "WalkStateComponent": () => (/* binding */ WalkStateComponent)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
var _class, _class2, _class3, _class4;

let IdleStateComponent = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.component)(_class = class IdleStateComponent {}) || _class;
let WalkStateComponent = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.component)(_class2 = class WalkStateComponent {}) || _class2;
let RunStateComponent = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.component)(_class3 = class RunStateComponent {}) || _class3;
let AttackStateComponent = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.component)(_class4 = class AttackStateComponent {}) || _class4;

/***/ }),

/***/ "./src/game/components/face-direction-component.ts":
/*!*********************************************************!*\
  !*** ./src/game/components/face-direction-component.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FaceDirectionComponent": () => (/* binding */ FaceDirectionComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "./src/game/components/types.ts");



var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;


let FaceDirectionComponent = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)(_types__WEBPACK_IMPORTED_MODULE_4__.Vec3WithDefaultZeroType), _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)(_types__WEBPACK_IMPORTED_MODULE_4__.Vec3WithDefaultZeroType), _dec3 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float64,
  default: 15
}), _dec4 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float64,
  default: 15
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class FaceDirectionComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "direction", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "futurePosition", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "rotationSpeed", _descriptor3, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "currentRotationSpeed", _descriptor4, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "direction", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "futurePosition", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "rotationSpeed", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "currentRotationSpeed", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/input-controller-component.ts":
/*!***********************************************************!*\
  !*** ./src/game/components/input-controller-component.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InputControllerComponent": () => (/* binding */ InputControllerComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "./src/game/components/types.ts");



var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;


let InputControllerComponent = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)(_types__WEBPACK_IMPORTED_MODULE_4__.Vec3WithDefaultZeroType), _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.object
}), _dec3 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.boolean, _dec4 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float32, (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class InputControllerComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "direction", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "controller", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isBlocked", _descriptor3, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "force", _descriptor4, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "direction", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "controller", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "isBlocked", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "force", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/mesh-renderable.ts":
/*!************************************************!*\
  !*** ./src/game/components/mesh-renderable.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshRenderable": () => (/* binding */ MeshRenderable),
/* harmony export */   "OnSceneComponent": () => (/* binding */ OnSceneComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _class4;

let MeshRenderable = (_dec = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.boolean,
  default: true
}), _dec3 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, _dec4 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.ref, _dec5 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class MeshRenderable {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "mesh", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isAttachToScene", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "parent", _descriptor3, this);
    // @ts-ignore
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "parentEntity", _descriptor4, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", _descriptor5, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "mesh", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "isAttachToScene", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "parent", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "parentEntity", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "id", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
let OnSceneComponent = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class4 = class OnSceneComponent {}) || _class4;

/***/ }),

/***/ "./src/game/components/pathfinding-component.ts":
/*!******************************************************!*\
  !*** ./src/game/components/pathfinding-component.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathCollisionComponent": () => (/* binding */ PathCollisionComponent),
/* harmony export */   "PathfindingComponent": () => (/* binding */ PathfindingComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "./src/game/components/types.ts");



var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _class4;


let PathfindingComponent = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)(_types__WEBPACK_IMPORTED_MODULE_4__.Vec3WithDefaultZeroType), _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)(_types__WEBPACK_IMPORTED_MODULE_4__.Vec3WithDefaultZeroType), _dec3 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)(_types__WEBPACK_IMPORTED_MODULE_4__.Vec3WithDefaultZeroType), _dec4 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, _dec5 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.boolean, _dec6 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.boolean,
  default: true
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class PathfindingComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "startPosition", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "endPosition", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "previousPosition", _descriptor3, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "previousPath", _descriptor4, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isMoving", _descriptor5, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "hasDynamicPath", _descriptor6, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "startPosition", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "endPosition", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "previousPosition", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "previousPath", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "isMoving", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "hasDynamicPath", [_dec6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
let PathCollisionComponent = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class4 = class PathCollisionComponent {}) || _class4;

/***/ }),

/***/ "./src/game/components/physic-body.ts":
/*!********************************************!*\
  !*** ./src/game/components/physic-body.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicPhysicComponent": () => (/* binding */ BasicPhysicComponent),
/* harmony export */   "PhysicInitComponent": () => (/* binding */ PhysicInitComponent),
/* harmony export */   "UnityPhysicComponent": () => (/* binding */ UnityPhysicComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");



var _dec, _class, _class2, _descriptor, _dec2, _class4, _class5, _descriptor2, _class7;


let UnityPhysicComponent = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.object,
  default: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Body({})
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class UnityPhysicComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "physicBody", _descriptor, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "physicBody", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
let BasicPhysicComponent = (_dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.object,
  default: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Body({})
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class4 = (_class5 = class BasicPhysicComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "physicBody", _descriptor2, this);
  }
}, (_descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class5.prototype, "physicBody", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class5)) || _class4);
let PhysicInitComponent = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class7 = class PhysicInitComponent {}) || _class7;

/***/ }),

/***/ "./src/game/components/singletons/scene-component.ts":
/*!***********************************************************!*\
  !*** ./src/game/components/singletons/scene-component.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SceneComponent": () => (/* binding */ SceneComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _class, _class2, _descriptor;

let SceneComponent = (_dec = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.object, (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class SceneComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "scene", _descriptor, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "scene", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/tag-components.ts":
/*!***********************************************!*\
  !*** ./src/game/components/tag-components.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttackComponent": () => (/* binding */ AttackComponent),
/* harmony export */   "ControllerInitTag": () => (/* binding */ ControllerInitTag),
/* harmony export */   "EnemyTag": () => (/* binding */ EnemyTag),
/* harmony export */   "PlayerTag": () => (/* binding */ PlayerTag),
/* harmony export */   "WallTag": () => (/* binding */ WallTag)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _class, _class2, _class3, _class4, _dec, _dec2, _class5, _class6, _descriptor, _descriptor2;

let PlayerTag = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = class PlayerTag {}) || _class;
let EnemyTag = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class2 = class EnemyTag {}) || _class2;
let ControllerInitTag = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class3 = class ControllerInitTag {}) || _class3;
let WallTag = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class4 = class WallTag {}) || _class4;
let AttackComponent = (_dec = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float64,
  default: 1
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class5 = (_class6 = class AttackComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attackCount", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "damage", _descriptor2, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class6.prototype, "attackCount", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class6.prototype, "damage", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class6)) || _class5);

/***/ }),

/***/ "./src/game/components/transform.ts":
/*!******************************************!*\
  !*** ./src/game/components/transform.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Transform": () => (/* binding */ Transform)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "./src/game/components/types.ts");



var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _descriptor3;


let Transform = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)(_types__WEBPACK_IMPORTED_MODULE_4__.Vec3WithDefaultZeroType), _dec2 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)(_types__WEBPACK_IMPORTED_MODULE_4__.Vec3WithDefaultOneType), _dec3 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64.vector(["x", "y", "z"]), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class Transform {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "position", _descriptor, this);
    // @field(EulerWithDefaulZeroType)
    // declare rotation: Euler;
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "scale", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "rotation", _descriptor3, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "position", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "scale", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "rotation", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

/***/ }),

/***/ "./src/game/components/types.ts":
/*!**************************************!*\
  !*** ./src/game/components/types.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EulerWithDefaulZeroType": () => (/* binding */ EulerWithDefaulZeroType),
/* harmony export */   "Vec3WithDefaultOneType": () => (/* binding */ Vec3WithDefaultOneType),
/* harmony export */   "Vec3WithDefaultZeroType": () => (/* binding */ Vec3WithDefaultZeroType)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
//export const Vector3Type = Type.vector(Type.float64, ["x", "y", "z"], Vector3);


const Vec3WithDefaultZeroType = {
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.Type.object,
  default: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0)
};
const EulerWithDefaulZeroType = {
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.Type.object,
  default: new three__WEBPACK_IMPORTED_MODULE_1__.Euler(0, 0, 0)
};
const Vec3WithDefaultOneType = {
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.Type.object,
  default: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1)
};

/***/ }),

/***/ "./src/game/components/velocity-component.ts":
/*!***************************************************!*\
  !*** ./src/game/components/velocity-component.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TargetVelocityComponent": () => (/* binding */ TargetVelocityComponent),
/* harmony export */   "VelocityComponent": () => (/* binding */ VelocityComponent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");



var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _dec8, _dec9, _dec10, _class4, _class5, _descriptor8, _descriptor9, _descriptor10;

let VelocityComponent = (_dec = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec2 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec3 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec4 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec5 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec6 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec7 = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field)({
  type: _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.Type.float64,
  default: 3
}), (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class = (_class2 = class VelocityComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "vx", _descriptor, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "vy", _descriptor2, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "vz", _descriptor3, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "rx", _descriptor4, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "ry", _descriptor5, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "rz", _descriptor6, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "speedMod", _descriptor7, this);
  }
}, (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "vx", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "vy", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "vz", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "rx", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "ry", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "rz", [_dec6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class2.prototype, "speedMod", [_dec7], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
let TargetVelocityComponent = (_dec8 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec9 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, _dec10 = _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.field.float64, (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_3__.component)(_class4 = (_class5 = class TargetVelocityComponent {
  constructor() {
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "vx", _descriptor8, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "vy", _descriptor9, this);
    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "vz", _descriptor10, this);
  }
}, (_descriptor8 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class5.prototype, "vx", [_dec8], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor9 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class5.prototype, "vy", [_dec9], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor10 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_1__["default"])(_class5.prototype, "vz", [_dec10], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class5)) || _class4);

/***/ }),

/***/ "./src/game/entities/Fabric/entities-fabric.ts":
/*!*****************************************************!*\
  !*** ./src/game/entities/Fabric/entities-fabric.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EntitiesFabric)
/* harmony export */ });
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_physic_body__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/physic-body */ "./src/game/components/physic-body.ts");
/* harmony import */ var _components_pathfinding_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/pathfinding-component */ "./src/game/components/pathfinding-component.ts");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/tag-components */ "./src/game/components/tag-components.ts");
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _utils_uuid_generator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utils/uuid-generator */ "./src/game/utils/uuid-generator.ts");
/* harmony import */ var _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../components/bhv-components/sphere-collider-component */ "./src/game/components/bhv-components/sphere-collider-component.ts");
/* harmony import */ var _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../components/bhv-components/ground-collision */ "./src/game/components/bhv-components/ground-collision.ts");












class EntitiesFabric {
  static createGeometryBlocks(scale, position, rotation = new three__WEBPACK_IMPORTED_MODULE_11__.Euler(0, 0, 0), groupName, modelPrefab, hp = 1) {
    const world = _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD;
    const mainGroup = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_7__["default"].getObject3D(modelPrefab).clone();
    mainGroup.visible = true;
    const groupByName = mainGroup.getObjectByName(groupName);
    const blocksCounts = groupByName.children.length;

    //setup empty Entity
    world.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
      mesh: mainGroup
    }, _components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform, {
      position: position,
      scale: scale,
      rotation: {
        x: rotation.x,
        y: rotation.y,
        z: rotation.z
      }
    });
    for (let i = 0; i < blocksCounts; i++) {
      const block = groupByName.children[i];
      const blockPosition = block.position.clone();
      const blockScale = block.scale.clone();
      const rotate = block.rotation.clone();
      const matrix = block.matrix.clone();
      const radius = 0.005;
      const material = new three__WEBPACK_IMPORTED_MODULE_11__.MeshPhongMaterial({
        color: 0xffffff,
        side: three__WEBPACK_IMPORTED_MODULE_11__.DoubleSide,
        transparent: true,
        opacity: 0.3
      });
      material.visible = false;
      const collisionBlock = block.clone();
      _utils_assets_utils__WEBPACK_IMPORTED_MODULE_6__["default"].addMaterial(collisionBlock, material);
      //set addition collision size
      collisionBlock.scale.set(blockScale.x, blockScale.y, blockScale.z).multiplyScalar(0.012);
      collisionBlock.rotation.setFromRotationMatrix(matrix);
      world.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
        parent: {
          position: position,
          scale: scale,
          rotation: {
            x: rotation.x,
            y: rotation.y,
            z: rotation.z
          }
        },
        mesh: block,
        isAttachToScene: false,
        id: _utils_uuid_generator__WEBPACK_IMPORTED_MODULE_8__["default"].generateUniqueNumericId()
      }, _components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform, {
        position: blockPosition,
        scale: blockScale,
        rotation: rotate
      }, _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_9__.SphereColliderComponent, {
        parent: block,
        position: new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(0, 0, 0),
        radius: radius,
        sphereMesh: collisionBlock
      }, _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_9__.HpBlock, {
        value: hp
      }, _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_10__.GroundCollisionComponent);
    }
  }
}
EntitiesFabric.createBasedEntity = (object, position, rotation, scale = new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(1, 1, 1), attachToScene = true) => {
  _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
    mesh: object,
    isAttachToScene: attachToScene
  }, _components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform, {
    position: position,
    rotation: {
      x: rotation.x,
      y: rotation.y,
      z: rotation.z
    },
    scale: {
      x: scale.x,
      y: scale.y,
      z: scale.z
    }
  });
};
EntitiesFabric.createUnityColliderEntity = (object, position, rotation, scale = new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(1, 1, 1), attachToScene = false) => {
  _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
    mesh: object,
    isAttachToScene: attachToScene
  }, _components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform, {
    position: position,
    rotation: {
      x: rotation.x,
      y: rotation.y,
      z: rotation.z
    },
    scale: {
      x: scale.x,
      y: scale.y,
      z: scale.z
    }
  }, _components_physic_body__WEBPACK_IMPORTED_MODULE_3__.UnityPhysicComponent, _components_pathfinding_component__WEBPACK_IMPORTED_MODULE_4__.PathCollisionComponent, _components_tag_components__WEBPACK_IMPORTED_MODULE_5__.WallTag);
};
EntitiesFabric.createUnityGroundEntity = (object, position, rotation, scale = new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(1, 1, 1), attachToScene = false) => {
  _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
    mesh: object,
    isAttachToScene: attachToScene
  }, _components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform, {
    position: position,
    rotation: {
      x: rotation.x,
      y: rotation.y,
      z: rotation.z
    },
    scale: {
      x: scale.x,
      y: scale.y,
      z: scale.z
    }
  }, _components_physic_body__WEBPACK_IMPORTED_MODULE_3__.UnityPhysicComponent);
};

/***/ }),

/***/ "./src/game/entities/creat-sky-box.ts":
/*!********************************************!*\
  !*** ./src/game/entities/creat-sky-box.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "creatSkyBox": () => (/* binding */ creatSkyBox)
/* harmony export */ });
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assets-utils */ "./src/game/utils/assets-utils.ts");
/* harmony import */ var _asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asset-list/raw-assets/texture-raw-assets */ "./src/game/asset-list/raw-assets/texture-raw-assets.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_velocity_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/velocity-component */ "./src/game/components/velocity-component.ts");







const creatSkyBox = () => {
  const world = _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD;
  const blueSkyBoxTexture = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_1__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_2__.RawTexture.DR_BLUE_SKYBOX, 1);
  const material = new three__WEBPACK_IMPORTED_MODULE_6__.MeshBasicMaterial({
    map: blueSkyBoxTexture,
    side: three__WEBPACK_IMPORTED_MODULE_6__.BackSide
  });
  const s = 1000;
  const sphereGeometry = new three__WEBPACK_IMPORTED_MODULE_6__.SphereGeometry(s);
  const sphere = new three__WEBPACK_IMPORTED_MODULE_6__.Mesh(sphereGeometry, material);
  world.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_3__.MeshRenderable, {
    mesh: sphere
  }, _components_transform__WEBPACK_IMPORTED_MODULE_4__.Transform, {
    position: {
      x: 0,
      y: 1,
      z: 0
    },
    rotation: {
      x: 0,
      y: 0,
      z: 0
    }
  }, _components_velocity_component__WEBPACK_IMPORTED_MODULE_5__.VelocityComponent, {
    ry: 0.01
  });
};

/***/ }),

/***/ "./src/game/entities/create-blocks.ts":
/*!********************************************!*\
  !*** ./src/game/entities/create-blocks.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBlocks": () => (/* binding */ createBlocks)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../prefabs/object3d-prefabs */ "./src/game/prefabs/object3d-prefabs.ts");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js");
/* harmony import */ var _Fabric_entities_fabric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fabric/entities-fabric */ "./src/game/entities/Fabric/entities-fabric.ts");




three__WEBPACK_IMPORTED_MODULE_2__.Mesh.prototype.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__.acceleratedRaycast;
three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry.prototype.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__.computeBoundsTree;
three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry.prototype.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__.disposeBoundsTree;
const createBlocks = () => {
  //top
  const scale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 1, 1);
  const positionTop = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);
  _Fabric_entities_fabric__WEBPACK_IMPORTED_MODULE_1__["default"].createGeometryBlocks(scale, positionTop, new three__WEBPACK_IMPORTED_MODULE_2__.Euler(0, 0, 0), "RootNode", _prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_0__.ModelPrefabs.DR_BLOCKS);

  //-----------------------
  //middle
  const scaleMiddle = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.87, 1, 0.87);
  const mainPosition = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, -1.05, 0);
  _Fabric_entities_fabric__WEBPACK_IMPORTED_MODULE_1__["default"].createGeometryBlocks(scaleMiddle, mainPosition, new three__WEBPACK_IMPORTED_MODULE_2__.Euler(0, -0.4, 0), "RootNode", _prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_0__.ModelPrefabs.DR_BLOCKS, 2);

  //-----------------------
  //bottom
  const scaleBottom = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.75, 1, 0.75);
  const positionBottom = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, -2.05, 0);
  _Fabric_entities_fabric__WEBPACK_IMPORTED_MODULE_1__["default"].createGeometryBlocks(scaleBottom, positionBottom, new three__WEBPACK_IMPORTED_MODULE_2__.Euler(0, 1.3, 0), "RootNode", _prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_0__.ModelPrefabs.DR_BLOCKS, 3);

  // const weaponModel = new Mesh(new BoxGeometry(4, 2, 3));
  // PrefabsManager.getObject3D(ModelPrefabs.SM_ENV_WALL_01);
  // GameManager.SCENE.add(weaponModel);
  // const voxeliZeWeapon = new VoxelObject3D(weaponModel);
  // console.log(weaponModel);
  // voxeliZeWeapon.bvhVoxels();
};

/***/ }),

/***/ "./src/game/entities/create-camera.ts":
/*!********************************************!*\
  !*** ./src/game/entities/create-camera.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCamera": () => (/* binding */ createCamera)
/* harmony export */ });
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_camera_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/camera-component */ "./src/game/components/camera-component.ts");
/* harmony import */ var _components_velocity_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/velocity-component */ "./src/game/components/velocity-component.ts");




const createCamera = () => {
  _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD.createEntity(_components_camera_component__WEBPACK_IMPORTED_MODULE_2__.CameraComponent, {
    camera: _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.CAMERA,
    isFollow: true,
    offSet: {
      x: 0,
      y: 3.4 * 2,
      z: -5 * 2
    }
  }, _components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform, {
    //   rotation: { x: 0, y: 0, z: 0 },
  }, _components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.VelocityComponent);

  // const gui = GameManager.GUI.instantiate();
  // gui.addEulerRotationSetting(GameManager.CAMERA.rotation);
  // gui.addVec3Setting(GameManager.CAMERA.position);
};

/***/ }),

/***/ "./src/game/entities/create-character.ts":
/*!***********************************************!*\
  !*** ./src/game/entities/create-character.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCharacter": () => (/* binding */ createCharacter)
/* harmony export */ });
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../prefabs/object3d-prefabs */ "./src/game/prefabs/object3d-prefabs.ts");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _game_state_state_machine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../game-state/state-machine */ "./src/game/game-state/state-machine.ts");
/* harmony import */ var _components_animation_state_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/animation-state-component */ "./src/game/components/animation-state-component.ts");
/* harmony import */ var _components_velocity_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/velocity-component */ "./src/game/components/velocity-component.ts");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/tag-components */ "./src/game/components/tag-components.ts");
/* harmony import */ var _components_face_direction_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/face-direction-component */ "./src/game/components/face-direction-component.ts");
/* harmony import */ var _components_character_stats_health__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../components/character-stats/health */ "./src/game/components/character-stats/health.ts");
/* harmony import */ var _components_character_stats_attack__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../components/character-stats/attack */ "./src/game/components/character-stats/attack.ts");
/* harmony import */ var _components_character_stats_defence__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../components/character-stats/defence */ "./src/game/components/character-stats/defence.ts");
/* harmony import */ var _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../components/bhv-components/sphere-collider-component */ "./src/game/components/bhv-components/sphere-collider-component.ts");
/* harmony import */ var _components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../components/bhv-components/vision-collider-component */ "./src/game/components/bhv-components/vision-collider-component.ts");
/* harmony import */ var three_examples_jsm_geometries_RoundedBoxGeometry__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! three/examples/jsm/geometries/RoundedBoxGeometry */ "./node_modules/three/examples/jsm/geometries/RoundedBoxGeometry.js");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js");
/* harmony import */ var _utils_mesh_capsule__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils/mesh-capsule */ "./src/game/utils/mesh-capsule.ts");
/* harmony import */ var _game_config__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../game-config */ "./src/game/game-config.ts");




















three__WEBPACK_IMPORTED_MODULE_17__.Mesh.prototype.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_18__.acceleratedRaycast;
three__WEBPACK_IMPORTED_MODULE_17__.BufferGeometry.prototype.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_18__.computeBoundsTree;
three__WEBPACK_IMPORTED_MODULE_17__.BufferGeometry.prototype.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_18__.disposeBoundsTree;
const createCharacter = () => {
  const world = _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD;

  //capsule player
  const playerCapsule = new _utils_mesh_capsule__WEBPACK_IMPORTED_MODULE_15__.MeshCapsule(new three_examples_jsm_geometries_RoundedBoxGeometry__WEBPACK_IMPORTED_MODULE_19__.RoundedBoxGeometry(1.0, 2.0, 1.0, 10, 0.5), new three__WEBPACK_IMPORTED_MODULE_17__.MeshStandardMaterial({
    transparent: true,
    opacity: 0
  }), {
    radius: 0.5,
    segment: new three__WEBPACK_IMPORTED_MODULE_17__.Line3(new three__WEBPACK_IMPORTED_MODULE_17__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_17__.Vector3(0, -1, 0.0))
  });
  playerCapsule.geometry.translate(0, -0.5, 0);
  playerCapsule.castShadow = true;
  playerCapsule.receiveShadow = true;

  // character
  const character = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_1__["default"].getObject3D(_prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_2__.ModelPrefabs.DR_TRON);
  character.scale.multiplyScalar(0.1);
  playerCapsule.add(character);
  character.position.y = -1.5;
  const idleState = {
    name: "idle",
    animation: character.animations[1],
    transitions: new Map([]),
    settings: {
      speed: 0.1
    }
  };
  const walkState = {
    name: "walk",
    animation: character.animations[4],
    transitions: new Map([]),
    settings: {
      speed: 0.2
    }
  };
  const attackState = {
    name: "attack",
    animation: character.animations[3],
    transitions: new Map([]),
    settings: {
      speed: 0.1
    }
  };
  const runState = {
    name: "run",
    animation: character.animations[5],
    transitions: new Map([]),
    settings: {
      speed: 0.1,
      fadeSpeed: 0.5
    }
  };
  const jumpState = {
    name: "jump",
    animation: character.animations[2],
    transitions: new Map([]),
    settings: {
      speed: 0.4,
      fadeSpeed: 0.3
    }
  };
  idleState.transitions.set("walk", walkState);
  idleState.transitions.set("run", runState);
  idleState.transitions.set("attack", attackState);
  idleState.transitions.set("jump", jumpState);
  attackState.transitions.set("walk", walkState);
  attackState.transitions.set("idle", idleState);
  attackState.transitions.set("run", runState);
  attackState.transitions.set("jump", jumpState);
  runState.transitions.set("idle", idleState);
  runState.transitions.set("walk", walkState);
  runState.transitions.set("attack", attackState);
  runState.transitions.set("jump", jumpState);
  walkState.transitions.set("idle", idleState);
  walkState.transitions.set("run", runState);
  walkState.transitions.set("attack", attackState);
  walkState.transitions.set("jump", jumpState);
  jumpState.transitions.set("idle", idleState);
  jumpState.transitions.set("run", runState);
  jumpState.transitions.set("attack", attackState);
  jumpState.transitions.set("walk", walkState);
  const states = new _game_state_state_machine__WEBPACK_IMPORTED_MODULE_5__.StateMachine(character);
  states.addState(idleState);
  states.addState(walkState);
  states.addState(runState);
  states.addState(attackState);
  states.addState(jumpState);
  const stateMap = new Map();
  stateMap.set("idle", idleState);
  stateMap.set("walk", walkState);
  stateMap.set("run", runState);
  stateMap.set("attack", attackState);
  stateMap.set("jump", jumpState);
  const radius = _game_config__WEBPACK_IMPORTED_MODULE_16__.GameConfig.radiusWeapon;
  const sphereGeometry = new three__WEBPACK_IMPORTED_MODULE_17__.SphereGeometry(radius);
  const boxGeometry = new three__WEBPACK_IMPORTED_MODULE_17__.BoxGeometry(20, 20, 15);
  const material = new three__WEBPACK_IMPORTED_MODULE_17__.MeshPhongMaterial({
    color: 0xffffff,
    side: three__WEBPACK_IMPORTED_MODULE_17__.DoubleSide
  });
  material.visible = false;
  const sphereMesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(sphereGeometry, material);
  const boxMesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(boxGeometry, material.clone());
  const weapon = character.getObjectByName("weapon");
  world.createEntity(_components_tag_components__WEBPACK_IMPORTED_MODULE_8__.PlayerTag, _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_3__.MeshRenderable, {
    mesh: playerCapsule
  }, _components_velocity_component__WEBPACK_IMPORTED_MODULE_7__.VelocityComponent, _components_transform__WEBPACK_IMPORTED_MODULE_4__.Transform, {
    position: new three__WEBPACK_IMPORTED_MODULE_17__.Vector3(0, 3, 0),
    rotation: {
      x: 0,
      y: Math.PI,
      z: 0
    }
  }, _components_animation_state_component__WEBPACK_IMPORTED_MODULE_6__.AnimationStateComponent, {
    stateManager: states,
    states: stateMap,
    currentState: idleState
  }, _components_face_direction_component__WEBPACK_IMPORTED_MODULE_9__.FaceDirectionComponent,
  //stats
  _components_character_stats_health__WEBPACK_IMPORTED_MODULE_10__.Health, {
    currentHealth: 100,
    maxHealth: 100
  }, _components_character_stats_attack__WEBPACK_IMPORTED_MODULE_11__.Attack, {
    attack: 10
  }, _components_character_stats_defence__WEBPACK_IMPORTED_MODULE_12__.Defence, {
    defence: 5
  }, _components_tag_components__WEBPACK_IMPORTED_MODULE_8__.AttackComponent, _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_13__.SphereColliderComponent, {
    parent: weapon,
    position: new three__WEBPACK_IMPORTED_MODULE_17__.Vector3(-0.3, 3.22, 0.07),
    radius: radius,
    sphereMesh: sphereMesh
  }, _components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_14__.VisionColliderComponent, {
    parent: character,
    position: new three__WEBPACK_IMPORTED_MODULE_17__.Vector3(0, 10, 5),
    radius: radius,
    boxMesh: boxMesh
  });

  //
  //
  // const posConfig = {
  //   x: 0.15,
  //   y: 0.31,
  //   z: 0.029,
  // };
  // const rotConfig = {
  //   rx: 0.15,
  //   ry: 0.31,
  //   rz: 0.029,
  // };
  // // const weapon = character.getObjectByName("weapon") as Mesh;
  // //
  // const gui = new GuiManager();
  // gui.addAllNumberSetting(posConfig, { min: -5, max: 5 }, 0.01, () => {
  //   sphereMesh.position.x = posConfig.x;
  //   sphereMesh.position.y = posConfig.y;
  //   sphereMesh.position.z = posConfig.z;
  //   console.log(sphereMesh.position.x);
  // });
  //
  // gui.addAllNumberSetting(
  //   rotConfig,
  //   { min: -Math.PI, max: Math.PI },
  //   0.01,
  //   () => {
  //     weapon!.rotation.x = rotConfig.rx;
  //     weapon!.rotation.y = rotConfig.ry;
  //     weapon!.rotation.z = rotConfig.rz;
  //   }
  // );
};

/***/ }),

/***/ "./src/game/entities/create-controller.ts":
/*!************************************************!*\
  !*** ./src/game/entities/create-controller.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createController": () => (/* binding */ createController)
/* harmony export */ });
const createController = () => {
  // const world = GameManager.ENTITYWORLD;
  // const rightJoystick = nipplejs.create({});
  // world.createEntity(InputControllerComponent, {
  //   controller: rightJoystick,
  // });
};

/***/ }),

/***/ "./src/game/entities/create-light.ts":
/*!*******************************************!*\
  !*** ./src/game/entities/create-light.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLight": () => (/* binding */ createLight)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");




const createLight = () => {
  _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.SCENE.fog = new three__WEBPACK_IMPORTED_MODULE_3__.FogExp2(0xefd1b5, 0.025);
  const light = new three__WEBPACK_IMPORTED_MODULE_3__.AmbientLight(0x404040, 1);
  _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable, {
    mesh: light
  }, _components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform);
  const light2 = new three__WEBPACK_IMPORTED_MODULE_3__.DirectionalLight(new three__WEBPACK_IMPORTED_MODULE_3__.Color().setHex(0xffffff).convertLinearToSRGB(), 2);
  _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable, {
    mesh: light2
  }, _components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform, {
    position: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 200, 0)
  });
};

/***/ }),

/***/ "./src/game/entities/create-scene.ts":
/*!*******************************************!*\
  !*** ./src/game/entities/create-scene.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createScene": () => (/* binding */ createScene)
/* harmony export */ });
const createScene = () => {
  //TODO SCENE MANAGER
  // const world = GameManager.ENTITYWORLD;
  // world.createEntity(SceneComponent, { scene: GameManager.SCENE });
};

/***/ }),

/***/ "./src/game/entities/create-shader-grass.ts":
/*!**************************************************!*\
  !*** ./src/game/entities/create-shader-grass.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createShaderGrass": () => (/* binding */ createShaderGrass)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _prefabs_material_prefabs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../prefabs/material-prefabs */ "./src/game/prefabs/material-prefabs.ts");
/* harmony import */ var _fx_shaders_grass_shader_grass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/shaders/grass/shader-grass */ "./src/game/fx/shaders/grass/shader-grass.ts");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../managers/game-manager */ "./src/game/managers/game-manager.ts");







const createShaderGrass = () => {
  const world = _managers_game_manager__WEBPACK_IMPORTED_MODULE_5__.GameManager.ENTITYWORLD;
  const terrainWidthExtents = 100;
  const terrainDepthExtents = 100;
  const terrainWidth = 320;
  const terrainDepth = 320;
  const terrainMaxHeight = 5;
  const terrainMinHeight = -2;
  const heightData = generateHeight(terrainWidth, terrainDepth, terrainMinHeight, terrainMaxHeight);
  const geometry = new three__WEBPACK_IMPORTED_MODULE_6__.PlaneGeometry(terrainWidthExtents, terrainDepthExtents, terrainWidth - 1, terrainDepth - 1);
  geometry.rotateX(-Math.PI / 2);
  const vertices = geometry.attributes.position.array;
  for (let i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
    // j + 1 because it is the y component that we modify
    // @ts-ignore
    vertices[j + 1] = heightData[i];
  }
  geometry.computeVertexNormals();
  const groundMaterial = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getMaterial(_prefabs_material_prefabs__WEBPACK_IMPORTED_MODULE_1__.MaterialPrefabs.DR_TERRAIN_GRASS);
  const terrainMesh = new three__WEBPACK_IMPORTED_MODULE_6__.Mesh(geometry, groundMaterial);
  terrainMesh.receiveShadow = true;
  terrainMesh.castShadow = true;
  new _fx_shaders_grass_shader_grass__WEBPACK_IMPORTED_MODULE_2__.ShaderGrass(terrainMesh);
  world.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_3__.MeshRenderable, {
    mesh: terrainMesh
  }, _components_transform__WEBPACK_IMPORTED_MODULE_4__.Transform, {
    position: {
      x: 0,
      y: 0,
      z: 0
    },
    rotation: {
      x: 0,
      y: 0,
      z: 0
    }
  });
};
function generateHeight(width, depth, minHeight, maxHeight) {
  // Generates the height data (a sinus wave)

  const size = width * depth;
  const data = new Float32Array(size);
  const hRange = maxHeight - minHeight;
  const w2 = width / 2;
  const d2 = depth / 2;
  const phaseMult = 2.4;
  let p = 0;
  for (let j = 0; j < depth; j++) {
    for (let i = 0; i < width; i++) {
      const radius = Math.sqrt(Math.pow((i - w2) / w2, 2.0) + Math.pow((j - d2) / d2, 2.0));
      const height = Math.sin(radius * phaseMult - 0.2) * 2.5 * hRange + minHeight;
      data[p] = height - 7.5;
      p++;
    }
  }
  return data;
}

/***/ }),

/***/ "./src/game/entities/create-walls.ts":
/*!*******************************************!*\
  !*** ./src/game/entities/create-walls.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createWalls": () => (/* binding */ createWalls)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _utils_uuid_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uuid-generator */ "./src/game/utils/uuid-generator.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/bhv-components/ground-collision */ "./src/game/components/bhv-components/ground-collision.ts");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../prefabs/object3d-prefabs */ "./src/game/prefabs/object3d-prefabs.ts");
/* harmony import */ var _prefabs_material_prefabs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../prefabs/material-prefabs */ "./src/game/prefabs/material-prefabs.ts");










three__WEBPACK_IMPORTED_MODULE_8__.Mesh.prototype.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_9__.acceleratedRaycast;
three__WEBPACK_IMPORTED_MODULE_8__.BufferGeometry.prototype.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_9__.computeBoundsTree;
three__WEBPACK_IMPORTED_MODULE_8__.BufferGeometry.prototype.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_9__.disposeBoundsTree;
//setup invisible wall
const createWalls = () => {
  const world = _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.ENTITYWORLD;
  const position = new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(0, 1, 0);
  const scale = new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(1, 1, 1).multiplyScalar(1);
  const rotation = new three__WEBPACK_IMPORTED_MODULE_8__.Euler(0, 0, 0);
  const curve = new three__WEBPACK_IMPORTED_MODULE_8__.QuadraticBezierCurve3(new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(0, -8, 0), new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(0, 3, 0), new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(0, 5, 0));
  const r = 16.5;
  const wallGeometry = new three__WEBPACK_IMPORTED_MODULE_8__.TubeGeometry(curve, 10, r, 15, true);
  wallGeometry.computeVertexNormals();
  const wallMaterial = new three__WEBPACK_IMPORTED_MODULE_8__.MeshStandardMaterial({});
  const wall = new three__WEBPACK_IMPORTED_MODULE_8__.Mesh(wallGeometry, wallMaterial);
  wall.visible = false;
  world.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
    mesh: wall,
    id: _utils_uuid_generator__WEBPACK_IMPORTED_MODULE_2__["default"].generateUniqueNumericId()
  }, _components_transform__WEBPACK_IMPORTED_MODULE_3__.Transform, {
    position: position,
    scale: scale,
    rotation: rotation
  }, _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_4__.GroundCollisionComponent);
  const planeGeometry = new three__WEBPACK_IMPORTED_MODULE_8__.PlaneGeometry(26, 26);
  planeGeometry.rotateX(Math.PI / 2);
  const planeMaterial = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_5__["default"].getMaterial(_prefabs_material_prefabs__WEBPACK_IMPORTED_MODULE_7__.MaterialPrefabs.DR_BLOCK_MATERIAL);
  const planeMesh = new three__WEBPACK_IMPORTED_MODULE_8__.Mesh(planeGeometry, planeMaterial);
  world.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
    mesh: planeMesh,
    id: _utils_uuid_generator__WEBPACK_IMPORTED_MODULE_2__["default"].generateUniqueNumericId()
  }, _components_transform__WEBPACK_IMPORTED_MODULE_3__.Transform, {
    position: new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(0, -2.4, 0),
    scale: scale,
    rotation: rotation
  }, _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_4__.GroundCollisionComponent);
  const career = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_5__["default"].getObject3D(_prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_6__.ModelPrefabs.DR_CAREER);
  const careerTop = career.clone();
  const mainScale = 0.8;
  const scaleY = 0.55;

  //top
  world.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
    mesh: careerTop,
    id: _utils_uuid_generator__WEBPACK_IMPORTED_MODULE_2__["default"].generateUniqueNumericId()
  }, _components_transform__WEBPACK_IMPORTED_MODULE_3__.Transform, {
    position: new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(0, 0.66, 0),
    scale: new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(mainScale, scaleY, mainScale),
    rotation: new three__WEBPACK_IMPORTED_MODULE_8__.Euler(rotation.x, rotation.y - Math.PI / 2, rotation.z)
  }, _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_4__.GroundCollisionComponent);
  const careerMiddle = career.clone();
  const mainScaleMiddle = mainScale - 0.2;
  //middle
  world.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
    mesh: careerMiddle,
    id: _utils_uuid_generator__WEBPACK_IMPORTED_MODULE_2__["default"].generateUniqueNumericId()
  }, _components_transform__WEBPACK_IMPORTED_MODULE_3__.Transform, {
    position: new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(0, 0.66 - 2, 0),
    scale: new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(mainScaleMiddle, scaleY, mainScaleMiddle),
    rotation: rotation
  }, _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_4__.GroundCollisionComponent);
  const careerBottom = career.clone();
  const mainScaleBottom = mainScale - 0.1;
  //middle
  world.createEntity(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable, {
    mesh: careerBottom,
    id: _utils_uuid_generator__WEBPACK_IMPORTED_MODULE_2__["default"].generateUniqueNumericId()
  }, _components_transform__WEBPACK_IMPORTED_MODULE_3__.Transform, {
    position: new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(0, 0.66 - 1, 0),
    scale: new three__WEBPACK_IMPORTED_MODULE_8__.Vector3(mainScaleBottom, scaleY, mainScaleBottom),
    rotation: rotation
  }, _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_4__.GroundCollisionComponent);
};

/***/ }),

/***/ "./src/game/fx/explosion-voxel/explosion.ts":
/*!**************************************************!*\
  !*** ./src/game/fx/explosion-voxel/explosion.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Explosion": () => (/* binding */ Explosion)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! animejs */ "./node_modules/animejs/lib/anime.es.js");
/* harmony import */ var _voxeling_simple_mesh_grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../voxeling/simple-mesh-grid */ "./src/game/voxeling/simple-mesh-grid.ts");




class ExplosionBox {
  constructor(mesh) {
    this.mesh = void 0;
    this.velocity = void 0;
    this.acceleration = void 0;
    this.damping = void 0;
    this.mesh = mesh;
    this.velocity = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
    this.acceleration = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, -0.0005, 0); // gravity-like acceleration
    this.damping = 0.98; // damping to simulate air resistance
  }

  destroy() {
    (0,animejs__WEBPACK_IMPORTED_MODULE_1__["default"])({
      targets: [this.mesh.scale],
      x: 0,
      y: 0,
      z: 0,
      easing: "linear",
      duration: 250,
      complete: () => {
        if (this.mesh.parent) {
          this.mesh.parent.remove(this.mesh);
        }
      }
    });
  }
}
class Explosion extends three__WEBPACK_IMPORTED_MODULE_3__.Group {
  constructor(mesh, boxSize, scale, maxCubes, color, target) {
    super();
    this.timer = 0;
    this.maxCubes = void 0;
    this.boxSize = void 0;
    this._scale = void 0;
    this.boxArray = [];
    this.color = void 0;
    this.mesh = mesh;
    this.target = target;
    this.maxCubes = maxCubes;
    this.boxSize = boxSize;
    this._scale = scale;
    this.color = color;
    this.init();
  }
  start() {
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.GAMEUPDATESERVICE.register(this);
    let timer = 500;
    if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {
      timer = 1000;
    }
    setTimeout(() => {
      for (const box of this.boxArray) {
        box.destroy();
      }
    }, timer);
  }
  destroy() {
    if (this.parent) {
      this.parent.remove(this);
    }
  }
  update(delta, time) {
    for (const box of this.boxArray) {
      box.velocity.add(box.acceleration);
      box.mesh.position.add(box.velocity);
      box.velocity.multiplyScalar(box.damping);
      box.mesh.rotation.x += 0.05;
      box.mesh.rotation.y += 0.05;
      box.mesh.rotation.z += 0.05;
      if (this.target) {
        this.timer += 0.001;
        if (this.timer > 2) {
          const direction = this.target.clone().sub(box.mesh.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3())).normalize();

          //    console.log(direction);
          const speed = 0.01; // Adjust the speed as needed
          const acceleration = 0.008; // Adjust the acceleration as needed
          box.velocity.add(direction.multiplyScalar(speed));
          box.acceleration.set(0, acceleration, 0); // Update the acceleration
        }
      }
    }
  }

  init() {
    // const meshGrid = new MeshGrid(
    //   this.mesh,
    //   this.boxSize,
    //   this._scale,
    //   this.maxCubes,
    //   this.color
    // );

    const meshGrid = new _voxeling_simple_mesh_grid__WEBPACK_IMPORTED_MODULE_2__.SimpleMeshGrid(this.mesh, this.boxSize, this._scale, this.maxCubes, this.color);
    const count = meshGrid.getBoxes().length;
    for (let i = 0; i < count; i++) {
      const explosionBox = new ExplosionBox(meshGrid.getBoxes()[i]);
      explosionBox.velocity = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.3, Math.random() - 0.5);
      explosionBox.acceleration = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, -0.008, 0); // gravity-like acceleration
      explosionBox.damping = 0.92; // damping to simulate air resistance
      this.add(meshGrid.getBoxes()[i]);
      this.boxArray.push(explosionBox);
    }
  }
}

/***/ }),

/***/ "./src/game/fx/shaders/grass/shader-grass.ts":
/*!***************************************************!*\
  !*** ./src/game/fx/shaders/grass/shader-grass.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderGrass": () => (/* binding */ ShaderGrass)
/* harmony export */ });
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _shaderPrefix_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaderPrefix.glsl */ "./src/game/fx/shaders/grass/shaderPrefix.glsl");
/* harmony import */ var _fragment_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragment.glsl */ "./src/game/fx/shaders/grass/fragment.glsl");
/* harmony import */ var _vertex_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vertex.glsl */ "./src/game/fx/shaders/grass/vertex.glsl");
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");
/* harmony import */ var _asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../asset-list/raw-assets/texture-raw-assets */ "./src/game/asset-list/raw-assets/texture-raw-assets.ts");
/* harmony import */ var three_src_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/src/constants */ "./node_modules/three/src/constants.js");








class ShaderGrass {
  constructor(terrain) {
    this.alpha = void 0;
    this.noise = void 0;
    this.grassMap = void 0;
    this.grassConfig = void 0;
    this.sun = void 0;
    this.pos = new three__WEBPACK_IMPORTED_MODULE_6__.Vector2(0.01, 0.01);
    this.radius = void 0;
    this.width = void 0;
    this.grassMaterial = void 0;
    this.ambientStrength = void 0;
    this.translucencyStrength = void 0;
    this.specularStrength = void 0;
    this.diffuseStrength = void 0;
    this.shininess = void 0;
    this.sunColour = void 0;
    this.specularColour = void 0;
    this.grassBaseGeometry = void 0;
    this.instancedGeometry = void 0;
    this.instances = void 0;
    this.vertex = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();
    this.quaternion0 = new three__WEBPACK_IMPORTED_MODULE_6__.Quaternion();
    this.quaternion1 = new three__WEBPACK_IMPORTED_MODULE_6__.Quaternion();
    this.quaternion2 = void 0;
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    this.angle = void 0;
    this.sinAngle = void 0;
    this.rotationAxis = void 0;
    this.terrain = void 0;
    this.terrain = terrain;
    this.initMath();
    this.loadTextures();
    this.init();
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.GAMEUPDATESERVICE.register(this);
  }
  update(delta, time) {
    if (this.grassMaterial) {
      this.grassMaterial.uniforms.time.value = time;
      this.grassMaterial.uniforms.delta.value = delta;
      this.grassMaterial.uniforms.cameraPosition.value = _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.CAMERA.position;

      // this.sunDirection = new Vector3(Math.sin(GameManager.CAMERA.position.), Math.sin(elevation), -Math.cos(azimuth));
    }
  }

  initMath() {
    this.grassConfig = {
      joints: 4,
      bladeWidth: 0.12,
      bladeHeight: 0.4
    };
    this.sun = {
      elevation: 0.2,
      //Rotation around Y axis in range [0, 2*PI]
      azimuth: 0.4,
      fogFade: 0.13
    };
    this.instances = 100000;
    this.ambientStrength = 0.7;
    this.translucencyStrength = 1.5;
    this.specularStrength = 0.5;
    this.diffuseStrength = 1.5;
    this.shininess = 256;
    this.sunColour = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(1.0, 1.0, 1.0);
    this.specularColour = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(1.0, 1.0, 1.0);
    this.radius = 0;
    this.width = 128;
  }
  loadTextures() {
    const alpha = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_5__.RawTexture.DR_SHADER_GRASS_ALPHA);
    this.alpha = alpha;
    alpha.encoding = three_src_constants__WEBPACK_IMPORTED_MODULE_7__.LinearEncoding;
    const grass = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_5__.RawTexture.DR_SHADER_GRASS_MAP);
    this.grassMap = grass;
    grass.encoding = three_src_constants__WEBPACK_IMPORTED_MODULE_7__.LinearEncoding;
    const noise = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_5__.RawTexture.DR_SHADER_GRASS_NOISE);
    this.noise = noise;
    noise.encoding = three_src_constants__WEBPACK_IMPORTED_MODULE_7__.LinearEncoding;
  }
  calculateQuaternions() {
    //Rotate around Y
    this.angle = 0.05;
    this.sinAngle = Math.sin(this.angle / 2.0);
    this.rotationAxis = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 1, 0);
    this.x = this.rotationAxis.x * this.sinAngle;
    this.y = this.rotationAxis.y * this.sinAngle;
    this.z = this.rotationAxis.z * this.sinAngle;
    this.w = Math.cos(this.angle / 2.0);
    this.quaternion0.set(this.x, this.y, this.z, this.w);

    //Rotate around X
    this.angle = 0.3;
    this.sinAngle = Math.sin(this.angle / 2.0);
    this.rotationAxis.set(1, 0, 0);
    this.x = this.rotationAxis.x * this.sinAngle;
    this.y = this.rotationAxis.y * this.sinAngle;
    this.z = this.rotationAxis.z * this.sinAngle;
    this.w = Math.cos(this.angle / 2.0);
    this.quaternion1.set(this.x, this.y, this.z, this.w);

    //Combine rotations to a single quaternion
    this.quaternion0.multiply(this.quaternion1);

    //Rotate around Z
    this.angle = 0.1;
    this.sinAngle = Math.sin(this.angle / 2.0);
    this.rotationAxis.set(0, 0, 1);
    this.x = this.rotationAxis.x * this.sinAngle;
    this.y = this.rotationAxis.y * this.sinAngle;
    this.z = this.rotationAxis.z * this.sinAngle;
    this.w = Math.cos(this.angle / 2.0);
    this.quaternion1.set(this.x, this.y, this.z, this.w);

    //Combine rotations to a single quaternion
    this.quaternion0.multiply(this.quaternion1);
    this.quaternion2 = new three__WEBPACK_IMPORTED_MODULE_6__.Quaternion();
  }
  instancingGrass() {
    const vertex = _shaderPrefix_glsl__WEBPACK_IMPORTED_MODULE_1__ + _vertex_glsl__WEBPACK_IMPORTED_MODULE_3__;
    const fragment = _fragment_glsl__WEBPACK_IMPORTED_MODULE_2__;
    const {
      azimuth,
      elevation,
      fogFade
    } = this.sun;
    const instancedGeometry = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferGeometry();
    instancedGeometry.index = this.grassBaseGeometry.index;
    instancedGeometry.attributes.position = this.grassBaseGeometry.attributes.position;
    instancedGeometry.attributes.uv = this.grassBaseGeometry.attributes.uv;
    instancedGeometry.attributes.normal = this.grassBaseGeometry.attributes.normal;

    // Each instance has its own data for position, orientation and scale
    const indices = [];
    const offsets = [];
    const scales = [];
    const halfRootAngles = [];

    //For each instance of the grass blade
    // for (let i = 0; i < this.instances; i++) {
    //   indices.push(i / this.instances);
    //
    //   //Offset of the roots
    //   this.x = Math.random() * this.width - this.width / 2;
    //   this.z = Math.random() * this.width - this.width / 2;
    //   this.y = 3;
    //   offsets.push(this.x, this.y, this.z);
    //
    //   //Random orientation
    //   const angle = Math.PI - Math.random() * (2 * Math.PI);
    //   halfRootAngles.push(Math.sin(0.5 * angle), Math.cos(0.5 * angle));
    //
    //   //Define variety in height
    //   if (i % 3 != 0) {
    //     scales.push(2.0 + Math.random() * 1.25);
    //   } else {
    //     scales.push(2.0 + Math.random());
    //   }
    // }

    const innerRadius = 27.5; //внутренний радиус составляет 50% от внешнего радиуса
    const outerRadius = this.width / 2;
    for (let i = 0; i < this.instances; i++) {
      indices.push(i / this.instances);

      // Случайное расстояние от центра между внутренним и внешним радиусами
      const distance = innerRadius + Math.random() * (outerRadius - innerRadius);

      // Случайный угол в радианах
      const angle = Math.random() * 2 * Math.PI;

      // Расчет координат x и z на основе расстояния и угла
      this.x = distance * Math.cos(angle);
      this.z = distance * Math.sin(angle);
      this.y = 3;
      offsets.push(this.x, this.y, this.z);

      // Random orientation
      const randomAngle = Math.PI - Math.random() * (2 * Math.PI);
      halfRootAngles.push(Math.sin(0.5 * randomAngle), Math.cos(0.5 * randomAngle));

      // Define variety in height
      if (i % 3 != 0) {
        scales.push(2.0 + Math.random() * 1.25);
      } else {
        scales.push(2.0 + Math.random());
      }
    }
    const offsetAttribute = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferAttribute(new Float32Array(offsets), 3);
    const scaleAttribute = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferAttribute(new Float32Array(scales), 1);
    const halfRootAngleAttribute = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferAttribute(new Float32Array(halfRootAngles), 2);
    const indexAttribute = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferAttribute(new Float32Array(indices), 1);
    instancedGeometry.setAttribute("offset", offsetAttribute);
    instancedGeometry.setAttribute("scale", scaleAttribute);
    instancedGeometry.setAttribute("halfRootAngle", halfRootAngleAttribute);
    instancedGeometry.setAttribute("index", indexAttribute);

    //Define the material, specifying attributes, uniforms, shaders etc.
    const grassMaterial = new three__WEBPACK_IMPORTED_MODULE_6__.RawShaderMaterial({
      uniforms: {
        time: {
          value: 0
        },
        delta: {
          value: 0
        },
        bladeHeight: {
          value: this.grassConfig.bladeHeight
        },
        posX: {
          value: this.pos.x
        },
        posZ: {
          value: this.pos.y
        },
        radius: {
          value: this.radius
        },
        width: {
          value: this.width
        },
        map: {
          value: this.grassMap
        },
        alphaMap: {
          value: this.alpha
        },
        noiseTexture: {
          value: this.noise
        },
        sunDirection: {
          value: new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(Math.sin(azimuth), Math.sin(elevation), -Math.cos(azimuth))
        },
        cameraPosition: {
          value: _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.CAMERA.position
        },
        ambientStrength: {
          value: this.ambientStrength
        },
        translucencyStrength: {
          value: this.translucencyStrength
        },
        diffuseStrength: {
          value: this.diffuseStrength
        },
        specularStrength: {
          value: this.specularStrength
        },
        shininess: {
          value: this.shininess
        },
        lightColour: {
          value: this.sunColour
        },
        specularColour: {
          value: this.specularColour
        }
      },
      vertexShader: vertex,
      fragmentShader: fragment,
      side: three__WEBPACK_IMPORTED_MODULE_6__.DoubleSide
    });
    this.grassMaterial = grassMaterial;
    this.instancedGeometry = instancedGeometry;
    const grass = new three__WEBPACK_IMPORTED_MODULE_6__.Mesh(instancedGeometry, this.grassMaterial);
    grass.frustumCulled = false;
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.SCENE.add(grass);
    //  grass.position.set(15, 0, 0);
  }

  customInstancingGrass(terrainMesh) {
    const {
      azimuth,
      elevation
    } = this.sun;
    const vertex = _shaderPrefix_glsl__WEBPACK_IMPORTED_MODULE_1__ + _vertex_glsl__WEBPACK_IMPORTED_MODULE_3__;
    const fragment = _fragment_glsl__WEBPACK_IMPORTED_MODULE_2__;
    // Get the vertices of the terrain mesh geometry
    const terrainVertices = terrainMesh.geometry.attributes.position.array;
    const instancedGeometry = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferGeometry();
    instancedGeometry.index = this.grassBaseGeometry.index;
    instancedGeometry.attributes.position = this.grassBaseGeometry.attributes.position;
    instancedGeometry.attributes.uv = this.grassBaseGeometry.attributes.uv;
    instancedGeometry.attributes.normal = this.grassBaseGeometry.attributes.normal;
    const indices = [];
    const offsets = [];
    const scales = [];
    const halfRootAngles = [];
    const offsetRange = 0.21;
    const innerRadius = 17; //внутренний радиус составляет 50% от внешнего радиуса

    console.log(terrainVertices.length);
    for (let i = 0; i < terrainVertices.length; i += 3) {
      // Get the position of the current vertex
      const x = terrainVertices[i];
      const y = terrainVertices[i + 1];
      const z = terrainVertices[i + 2];

      // Calculate the distance from the center of the terrain
      const distanceFromCenter = Math.sqrt(x * x + z * z);

      // Exclude vertices within the inner radius
      if (distanceFromCenter < innerRadius) {
        continue; // Skip this vertex
      }

      indices.push(i / 3);

      // Random position around the vertex
      const randomOffset = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
      const offsetX = x + randomOffset.x * offsetRange;
      const offsetY = y - randomOffset.y * offsetRange;
      const offsetZ = z + randomOffset.z * offsetRange;
      offsets.push(offsetX, offsetY, offsetZ);

      // Random orientation
      const angle = Math.PI - Math.random() * (2 * Math.PI);
      halfRootAngles.push(Math.sin(0.5 * angle), Math.cos(0.5 * angle));

      // Adjust the scale to create a more clustered appearance
      const scale = 2.5 + Math.random() * 0.5; // Decreased maximum scale value
      scales.push(scale);
    }

    // Create instanced attributes using the calculated data
    const offsetAttribute = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferAttribute(new Float32Array(offsets), 3);
    const scaleAttribute = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferAttribute(new Float32Array(scales), 1);
    const halfRootAngleAttribute = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferAttribute(new Float32Array(halfRootAngles), 2);
    const indexAttribute = new three__WEBPACK_IMPORTED_MODULE_6__.InstancedBufferAttribute(new Float32Array(indices), 1);

    // Set the instanced attributes on the instanced geometry
    instancedGeometry.setAttribute("offset", offsetAttribute);
    instancedGeometry.setAttribute("scale", scaleAttribute);
    instancedGeometry.setAttribute("halfRootAngle", halfRootAngleAttribute);
    instancedGeometry.setAttribute("index", indexAttribute);

    // Create the grass material
    const grassMaterial = new three__WEBPACK_IMPORTED_MODULE_6__.RawShaderMaterial({
      uniforms: {
        time: {
          value: 0
        },
        delta: {
          value: 0
        },
        bladeHeight: {
          value: this.grassConfig.bladeHeight
        },
        posX: {
          value: this.pos.x
        },
        posZ: {
          value: this.pos.y
        },
        radius: {
          value: this.radius
        },
        width: {
          value: this.width
        },
        map: {
          value: this.grassMap
        },
        alphaMap: {
          value: this.alpha
        },
        noiseTexture: {
          value: this.noise
        },
        sunDirection: {
          value: new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(Math.sin(azimuth), Math.sin(elevation), -Math.cos(azimuth))
        },
        cameraPosition: {
          value: _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.CAMERA.position
        },
        ambientStrength: {
          value: this.ambientStrength
        },
        translucencyStrength: {
          value: this.translucencyStrength
        },
        diffuseStrength: {
          value: this.diffuseStrength
        },
        specularStrength: {
          value: this.specularStrength
        },
        shininess: {
          value: this.shininess
        },
        lightColour: {
          value: this.sunColour
        },
        specularColour: {
          value: this.specularColour
        }
      },
      vertexShader: vertex,
      fragmentShader: fragment,
      side: three__WEBPACK_IMPORTED_MODULE_6__.DoubleSide
    });
    this.grassMaterial = grassMaterial;
    this.instancedGeometry = instancedGeometry;
    const grass = new three__WEBPACK_IMPORTED_MODULE_6__.Mesh(instancedGeometry, this.grassMaterial);
    grass.frustumCulled = false;
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.SCENE.add(grass);
  }
  init() {
    const {
      bladeHeight,
      bladeWidth,
      joints
    } = this.grassConfig;
    this.grassBaseGeometry = new three__WEBPACK_IMPORTED_MODULE_6__.PlaneGeometry(bladeWidth, bladeHeight, 1, joints);
    this.grassBaseGeometry.translate(0, bladeHeight / 2, 0);
    this.calculateQuaternions();
    const newArray = [];
    for (let v = 0; v < this.grassBaseGeometry.attributes.position.array.length; v += 3) {
      this.quaternion2.setFromAxisAngle(new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 1, 0), Math.PI / 2);
      const positionAttribute = this.grassBaseGeometry.attributes.position;
      this.vertex.x = positionAttribute.array[v];
      this.vertex.y = positionAttribute.array[v + 1];
      this.vertex.z = positionAttribute.array[v + 2];
      const frac = this.vertex.y / bladeHeight;
      this.quaternion2.slerp(this.quaternion0, frac);
      this.vertex.applyQuaternion(this.quaternion2);
      newArray[v] = this.vertex.x;
      newArray[v + 1] = this.vertex.y;
      newArray[v + 2] = this.vertex.z;
    }
    this.grassBaseGeometry.attributes.position.array = new Float32Array(newArray);
    this.grassBaseGeometry.computeVertexNormals();
    const baseMaterial = new three__WEBPACK_IMPORTED_MODULE_6__.MeshNormalMaterial({
      side: three__WEBPACK_IMPORTED_MODULE_6__.DoubleSide
    });
    const baseBlade = new three__WEBPACK_IMPORTED_MODULE_6__.Mesh(this.grassBaseGeometry, baseMaterial);

    //GameManager.SCENE.add(baseBlade);

    if (this.terrain) {
      let mesh;
      this.terrain.traverse(e => {
        if (e.isMesh) {
          mesh = e;
        }
      });
      this.customInstancingGrass(mesh);
    } else {
      this.instancingGrass();
    }
    //this.instancedMesh();
  }
}

/***/ }),

/***/ "./src/game/fx/shaders/meteor/meteor-material.ts":
/*!*******************************************************!*\
  !*** ./src/game/fx/shaders/meteor/meteor-material.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "meteorMaterial": () => (/* binding */ meteorMaterial)
/* harmony export */ });
/* harmony import */ var _nodetoy_three_nodetoy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @nodetoy/three-nodetoy */ "./node_modules/@nodetoy/three-nodetoy/dist/three-nodetoy.es.js");
/* harmony import */ var _shaderData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaderData */ "./src/game/fx/shaders/meteor/shaderData.ts");


const meteorMaterial = () => {
  const material = new _nodetoy_three_nodetoy__WEBPACK_IMPORTED_MODULE_0__.NodeToyMaterial({
    // @ts-ignore
    data: _shaderData__WEBPACK_IMPORTED_MODULE_1__.data
  });
  return material;
};

/***/ }),

/***/ "./src/game/fx/shaders/meteor/shaderData.ts":
/*!**************************************************!*\
  !*** ./src/game/fx/shaders/meteor/shaderData.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "data": () => (/* binding */ data)
/* harmony export */ });
const data = {
  version: 1,
  uniforms: [{
    name: "_normalMatrix",
    type: "mat3",
    value: {
      elements: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
  }, {
    name: "_viewMatrix",
    type: "mat4",
    value: {
      elements: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
  }, {
    name: "nodeUniform0",
    type: "texture",
    value: "https://static.nodetoy.co/static/texture_library/noise/512/Noise_001.jpg"
  }, {
    name: "_worldToObjMatrix",
    type: "mat4",
    value: {
      elements: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
  }, {
    name: "_viewDir",
    type: "vec3",
    value: {
      x: 0,
      y: 0,
      z: 0
    }
  }, {
    name: "_time",
    type: "float",
    value: 0
  }],
  vertex: "// Created with NodeToy | Three.js r149\n\n// <node_builder>\n\n// uniforms\nuniform mat3 _normalMatrix; uniform mat4 _viewMatrix; \n// attributes\n\n// varys\nvarying vec3 nodeVary0; varying vec3 nodeVary1; varying vec2 nodeVary2; \n// vars\nvec3 nodeVar0; vec4 nodeVar1; vec4 nodeVar2; vec3 nodeVar3; vec3 nodeVar4; \n// codes\n\n// variables\n// </node_builder>\n\n#define PHYSICAL\n\n\n\n\n\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifdef USE_TRANSMISSION\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ) * c );\n\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\nfloat luminance( const in vec3 rgb ) {\n\n\t// assumes rgb is in linear color space with sRGB primaries and D65 white point\n\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\n\treturn dot( weights, rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n\treturn m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n\t// dir is assumed to be unit length\n\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\treturn vec2( u, v );\n\n}\n\n\n#ifdef USE_UV\n\n\t#ifdef UVS_VERTEX_ONLY\n\n\t\tvec2 vUv;\n\n\t#else\n\n\t\tvarying vec2 vUv;\n\n\t#endif\n\n\tuniform mat3 uvTransform;\n\n#endif\n\n\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n\tuniform mat3 uv2Transform;\n\n#endif\n\n\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n\n\n#ifdef USE_FOG\n\n\tvarying float vFogDepth;\n\n#endif\n\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_MORPHTARGETS\n\n\tuniform float morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\n\t\t}\n\n\t#else\n\n\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\n\t\t#else\n\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\n\tmat4 getBoneMatrix( const in float i ) {\n\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\ty = dy * ( y + 0.5 );\n\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\treturn bone;\n\n\t}\n\n#endif\n\n\n\n#if NUM_SPOT_LIGHT_COORDS > 0\n\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n\n\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n#endif\n\n\nvoid main() {\nnodeVary1 = normal;\n\tnodeVar0 = ( _normalMatrix * nodeVary1 );\n\tnodeVar1 = ( vec4( nodeVar0, 0.0 ) );\n\tnodeVar2 = ( nodeVar1 * _viewMatrix );\n\tnodeVar3 = normalize( nodeVar2.xyz );\n\tnodeVar4 = nodeVar3;\n\tnodeVary0 = nodeVar4;\n\tnodeVary2 = uv;\n\t\n\n\n\n#ifdef USE_UV\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n\n\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tvColor = vec4( 1.0 );\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvColor = vec3( 1.0 );\n\n#endif\n\n#ifdef USE_COLOR\n\n\tvColor *= color;\n\n#endif\n\n#ifdef USE_INSTANCING_COLOR\n\n\tvColor.xyz *= instanceColor.xyz;\n\n#endif\n\n\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tvColor *= morphTargetBaseInfluence;\n\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t#if defined( USE_COLOR_ALPHA )\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\n\t\t#elif defined( USE_COLOR )\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\n\t\t#endif\n\n\t}\n\n#endif\n\n\n\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n\n\n#ifdef USE_MORPHNORMALS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tobjectNormal *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\n\t\t}\n\n\t#else\n\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n\n\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n\t// this is in lieu of a per-instance normal-matrix\n\t// shear transforms in the instance matrix are not supported\n\n\tmat3 m = mat3( instanceMatrix );\n\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n\ttransformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n\n\n#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\n\nvec3 transformed = vec3( position );\n\n\n#ifdef USE_MORPHTARGETS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\ttransformed *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\n\t\t}\n\n\t#else\n\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n\n\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n\n\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n\tmvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition;\n\n\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n\t#else\n\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\t\tgl_Position.z *= gl_Position.w;\n\n\t\t}\n\n\t#endif\n\n#endif\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvClipPosition = - mvPosition.xyz;\n\n#endif\n\n\n\tvViewPosition = - mvPosition.xyz;\n\n\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\n#endif\n\n\n\n#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\n\t// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n\n#endif\n\n#if defined( USE_SHADOWMAP )\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n\n// spot lights can be evaluated without active shadow mapping (when SpotLight.map is used)\n\n#if NUM_SPOT_LIGHT_COORDS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n\n\n\n#ifdef USE_FOG\n\n\tvFogDepth = - mvPosition.z;\n\n#endif\n\n\n#ifdef USE_TRANSMISSION\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif\n}\n\n\n",
  fragment: "// Created with NodeToy | Three.js r149\n\n// <node_builder>\n\n// uniforms\nuniform sampler2D nodeUniform0; uniform mat4 _worldToObjMatrix; uniform vec3 _viewDir; uniform float _time; \n// attributes\n\n// varys\nvarying vec3 nodeVary0; varying vec3 nodeVary1; varying vec2 nodeVary2; \n// vars\nvec3 nodeVar0; vec3 nodeVar1; vec3 nodeVar2; float nodeVar3; vec2 nodeVar4; float nodeVar5; float nodeVar6; vec2 nodeVar7; vec3 nodeVar8; float nodeVar9; vec4 nodeVar10; vec4 nodeVar11; vec4 nodeVar12; \n// codes\nfloat customFn_0ScgysEzIUp2 (  ) {\n                \n    \n    float NdotV = dot(nodeVar1, normalize(nodeVar2));\n    float fresnelNode = ( 0.0 + 1.0 * pow( 1.0 - NdotV, 0.5) );\n    return fresnelNode;\n    \n            }\nvec3 mod3D289_s40kZzklVH4k ( vec3 x ) { return x - floor( x / 289.0 ) * 289.0; }\n\n    vec4 mod3D289_s40kZzklVH4k( vec4 x ) { return x - floor( x / 289.0 ) * 289.0; }\n\n    vec4 permute_s40kZzklVH4k( vec4 x ) { return mod3D289_s40kZzklVH4k( ( x * 34.0 + 1.0 ) * x ); }\n\n    vec4 taylorInvSqrt_s40kZzklVH4k( vec4 r ) { return 1.79284291400159 - r * 0.85373472095314; }\n\n    float snoise_s40kZzklVH4k( vec3 v ){\n        const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n        vec3 i = floor( v + dot( v, C.yyy ) );\n        vec3 x0 = v - i + dot( i, C.xxx );\n        vec3 g = step( x0.yzx, x0.xyz );\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy;\n        vec3 x3 = x0 - 0.5;\n        i = mod3D289_s40kZzklVH4k( i);\n        vec4 p = permute_s40kZzklVH4k( permute_s40kZzklVH4k( permute_s40kZzklVH4k( i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) ) + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) ) + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n        vec4 j = p - 49.0 * floor( p / 49.0 );  \n        vec4 x_ = floor( j / 7.0 );\n        vec4 y_ = floor( j - 7.0 * x_ );  // mod(j,N)\n        vec4 x = ( x_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n        vec4 y = ( y_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n        vec4 h = 1.0 - abs( x ) - abs( y );\n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n        vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n        vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n        vec4 sh = -step( h, vec4(0.0,0.0,0.0,0.0) );\n        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n        vec3 g0 = vec3( a0.xy, h.x );\n        vec3 g1 = vec3( a0.zw, h.y );\n        vec3 g2 = vec3( a1.xy, h.z );\n        vec3 g3 = vec3( a1.zw, h.w );\n        vec4 norm = taylorInvSqrt_s40kZzklVH4k( vec4( dot( g0, g0 ), dot( g1, g1 ), dot( g2, g2 ), dot( g3, g3 ) ) );\n        g0 *= norm.x;\n        g1 *= norm.y;\n        g2 *= norm.z;\n        g3 *= norm.w;\n        vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n        m = m* m;\n        m = m* m;\n        vec4 px = vec4( dot( x0, g0 ), dot( x1, g1 ), dot( x2, g2 ), dot( x3, g3 ) );\n        return 42.0 * dot( m, px);\n    }\nfloat customFn_GPs7NAm5JvTp ( vec2 uv, float scale ) {\n                \n    float noise = snoise_s40kZzklVH4k( vec3(uv.x,uv.y,0.0) * scale );\n    \n    noise = noise*0.5 + 0.5;\n    return noise;\n    \n            \n            }\nvec2 customFn_N5cFnMo1THVU ( vec2 uv, vec2 center, float radialScale, float lengthScale ) {\n                \n    \n    // (^.^)   <3 <3\n    vec2 delta = uv - center;\n    float radius = length(delta) * 2.0 * radialScale;\n    float angle = atan(delta.y, delta.x) * 1.0/6.28 * lengthScale;\n    return vec2(radius, angle);\n    \n            }\n\n// variables\n// </node_builder>\n\n#define PHYSICAL\n\n\n\n\n\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\n\n#ifdef IOR\n\tfloat ior;\n#endif\n\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n\n#ifdef USE_CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n\n#ifdef USE_IRIDESCENCE\n\tfloat iridescence;\n\tfloat iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tfloat iridescenceThicknessMaximum;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ) * c );\n\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\nfloat luminance( const in vec3 rgb ) {\n\n\t// assumes rgb is in linear color space with sRGB primaries and D65 white point\n\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\n\treturn dot( weights, rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n\treturn m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n\t// dir is assumed to be unit length\n\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\treturn vec2( u, v );\n\n}\n\n\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\n\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\n\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n\n\n#ifdef DITHERING\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift according to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n\n\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n\tvarying vec2 vUv;\n\n#endif\n\n\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n\n\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n\n\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n\n\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n\n\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n\n\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n\n\n\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n\n} // validated\n\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n\n} // validated\n\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( V * D );\n\n}\n\n#ifdef USE_IRIDESCENCE\n\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\n\t\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\t\tfloat D = D_GGX( alpha, dotNH );\n\n\t\treturn F * ( V * D );\n\n\t}\n\n#endif\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nfloat D_Charlie( float roughness, float dotNH ) {\n\n\tfloat alpha = pow2( roughness );\n\n\t// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\n\t// Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n\n}\n\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\n\treturn sheenColor * ( D * V );\n\n}\n\n#endif\n\n\n\n#ifdef USE_IRIDESCENCE\n\n\t// XYZ to linear-sRGB color space\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\n\t// Assume air interface for top\n\t// Note: We don't handle the case fresnel0 == 1\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n\t}\n\n\t// Conversion FO/IOR\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n\t}\n\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\n\t}\n\n\t// Fresnel equations for dielectric/dielectric interfaces.\n\t// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n\t// Evaluation XYZ sensitivity curves in Fourier space\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\n\t}\n\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\t\tvec3 I;\n\n\t\t// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\n\t\t// Handle TIR:\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\t\t return vec3( 1.0 );\n\n\t\t}\n\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t\t// First interface\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\n\t\t// Second interface\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\n\t\t// Phase shift\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t\t// Compound terms\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t\t// Reflectance term for m = 0 (DC term amplitude)\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\n\t\t// Reflectance term for m > 0 (pairs of diracs)\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\n\t\t}\n\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\t\treturn max( I, vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection = abs( direction );\n\n\t\tfloat face = - 1.0;\n\n\t\tif ( absDirection.x > absDirection.z ) {\n\n\t\t\tif ( absDirection.x > absDirection.y )\n\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z > absDirection.y )\n\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face == 0.0 ) {\n\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face == 1.0 ) {\n\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face == 2.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face == 3.0 ) {\n\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face == 4.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face = getFace( direction );\n\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize = exp2( mipInt );\n\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071\n\n\t\tif ( face > 2.0 ) {\n\n\t\t\tuv.y += faceSize;\n\n\t\t\tface -= 3.0;\n\n\t\t}\n\n\t\tuv.x += face * faceSize;\n\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\n\t\t#ifdef texture2DGradEXT\n\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering\n\n\t\t#else\n\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\n\t\t#endif\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip = 0.0;\n\n\t\tif ( roughness >= cubeUV_r1 ) {\n\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\n\t\t} else {\n\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\n\t\tfloat mipF = fract( mip );\n\n\t\tfloat mipInt = floor( mip );\n\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF == 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#ifdef USE_ENVMAP\n\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n\n\n#if defined( USE_ENVMAP )\n\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\n\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n#endif\n\n\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n\n\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\treturn irradiance;\n\n}\n\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t#else\n\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t\t}\n\n\t\treturn 1.0;\n\n\t#endif\n\n}\n\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\tif ( spotAttenuation > 0.0 ) {\n\n\t\t\tfloat lightDistance = length( lVector );\n\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t\t} else {\n\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n\nstruct PhysicalMaterial {\n\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\n};\n\n// temporary\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\n\n// This is a curve-fit approxmation to the \"Charlie sheen\" BRDF integrated over the hemisphere from \n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tfloat r2 = roughness * roughness;\n\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\n\treturn saturate( DG * RECIPROCAL_PI );\n\n}\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\n\treturn fab;\n\n}\n\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\treturn specularColor * fab.x + specularF90 * fab.y;\n\n}\n\n// Fdez-Agüera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\t#ifdef USE_IRIDESCENCE\n\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\n\t#else\n\n\t\tvec3 Fr = specularColor;\n\n\t#endif\n\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\n\t#endif\n\n\t#ifdef USE_IRIDESCENCE\n\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\n\t#else\n\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\n\t#endif\n\n\t// Both indirect specular and indirect diffuse light accumulate here\n\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\t#ifdef USE_IRIDESCENCE\n\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\n\t#else\n\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\n\t#endif\n\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n\n\n#ifdef USE_TRANSMISSION\n\n\t// Transmission code is based on glTF-Sampler-Viewer\n\t// https://github.com/KhronosGroup/glTF-Sample-Viewer\n\n\tfloat transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tuniform sampler2D transmissionMap;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tuniform sampler2D thicknessMap;\n\n\t#endif\n\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\n\tvarying vec3 vWorldPosition;\n\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\n\t\t// Direction of refracted light.\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\n\t\t// Compute rotation-independant scaling of the model matrix.\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t// The thickness is specified in local space.\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\n\t}\n\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\n\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\n\t}\n\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\n\t\t#ifdef texture2DLodEXT\n\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#else\n\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#endif\n\n\t}\n\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\n\t\tif ( isinf( attenuationDistance ) ) {\n\n\t\t\t// Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\n\t\t\treturn radiance;\n\n\t\t} else {\n\n\t\t\t// Compute light attenuation using Beer's law.\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n\t\t\treturn transmittance * radiance;\n\n\t\t}\n\n\t}\n\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\n\t\t// Get the specular component.\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\n\t}\n#endif\n\n\n#if NUM_SPOT_LIGHT_COORDS > 0\n\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n\n#endif\n\n#if NUM_SPOT_LIGHT_MAPS > 0\n\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n\n\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm; // normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n\n\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tuniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n\t// Normal Mapping Without Precomputed Tangents\n\t// http://www.thetenthplanet.de/archives/1180\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 N = surf_norm; // normalized\n\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n\t}\n\n#endif\n\n\n\n#ifdef USE_CLEARCOATMAP\n\n\tuniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n\n#endif\n\n\n\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform sampler2D iridescenceMap;\n\n#endif\n\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform sampler2D iridescenceThicknessMap;\n\n#endif\n\n\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n\n\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n\n\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n\n#endif\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n\n\nvoid main() {\n\n\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n\n\n\tvec4 diffuseColor = vec4( 0.0 );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = vec3( 0.0 );\n\n\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\t// Doing a strict comparison with == 1.0 can cause noise artifacts\n\t// on some platforms. See issue #17623.\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n\n\n#ifdef USE_MAP\n\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\n\t#ifdef DECODE_VIDEO_TEXTURE\n\n\t\t// inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\n\t#endif\n\n\tdiffuseColor *= sampledDiffuseColor;\n\n#endif\n\n\n\tior = 1.5;\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tdiffuseColor *= vColor;\n\n#elif defined( USE_COLOR )\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n\nnodeVar0 = ( vec4( 0.9254901960784314, 0.6705882352941176, 0.27058823529411763, 1 ).xyz * vec3( 1, 1, 1 ) );\n\t\n\tdiffuseColor = vec4( nodeVar0, 1.0 );\n\n\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n\n\n#ifdef USE_ALPHATEST\n\n\tif ( diffuseColor.a < alphaTest ) discard;\n\n#endif\n\n\nfloat roughnessFactor = 0.0;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n\n\n\troughnessFactor = 0.0;\n\n\nfloat metalnessFactor = 0.0;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n\n\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n\n#ifdef FLAT_SHADED\n\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * faceDirection;\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\n\t\t#endif\n\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n\n\t\n\n#ifdef USE_CLEARCOAT\n\n\tvec3 clearcoatNormal = geometryNormal;\n\n#endif\n\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n\t#else\n\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n\nnodeVar1 = (normalize(nodeVary0));\n\tnodeVar2 = _viewDir;\n\tnodeVar3 = customFn_0ScgysEzIUp2(  );\n\tnodeVar4 = customFn_N5cFnMo1THVU( nodeVary2, vec2( 0.5, 0.5 ), 4.0, 0.5 );\n\tnodeVar5 = ( _time * 0.04 );\n\tnodeVar6 = nodeVar5;\n\tnodeVar7 = ( nodeVar4 + vec2( nodeVar6 ) );\n\tnodeVar8 = ( vec3( nodeVar7, 0.0 ) * vec3( 1, 1, 1 ) );\n\tnodeVar9 = customFn_GPs7NAm5JvTp( nodeVar8.xy, 2.5 );\n\tnodeVar10 = vec4(nodeVar3,nodeVar9,0.0,0.0);\n\tnodeVar11 = ( texture2D( nodeUniform0, nodeVar10.xy ) );\n\tnodeVar12 = ( nodeVar11 * vec4( vec3( nodeVar3 ), 1.0 ) );\n\t\n\ttotalEmissiveRadiance = nodeVar12.xyz * vec3(1);\n\n\n\t// accumulation\n\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n\n#ifdef IOR\n\n\tmaterial.ior = ior;\n\n\t#ifdef SPECULAR\n\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\n\t\t#endif\n\n\t\t#ifdef USE_SPECULARCOLORMAP\n\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\n\t\t#endif\n\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\n\t#else\n\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\n\t#endif\n\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n\n#else\n\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\n\t#ifdef USE_CLEARCOATMAP\n\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n\t#endif\n\n\tmaterial.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\n\t#ifdef USE_IRIDESCENCEMAP\n\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\n\t#endif\n\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\n\t#else\n\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\n\t#endif\n\n#endif\n\n#ifdef USE_SHEEN\n\n\tmaterial.sheenColor = sheenColor;\n\n\t#ifdef USE_SHEENCOLORMAP\n\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\n\t#endif\n\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\n\t#ifdef USE_SHEENROUGHNESSMAP\n\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\n\t#endif\n\n#endif\n\n\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\n\tif ( material.iridescenceThickness == 0.0 ) {\n\n\t\tmaterial.iridescence = 0.0;\n\n\t} else {\n\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\n\t}\n\n\tif ( material.iridescence > 0.0 ) {\n\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\n\t\t// Iridescence F0 approximation\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\n\t}\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n\n\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\n\t#endif\n\n#endif\n\n\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n\n\n\t// modulation\n\t\n\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n\n#ifdef USE_TRANSMISSION\n\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\n\t#endif\n\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n\n#endif\n\n\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n\t#ifdef USE_SHEEN\n\n\t\t// Sheen energy compensation approximation calculation can be found at the end of\n\t\t// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\n\t#endif\n\n\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n\n// https://github.com/mrdoob/three.js/pull/22425\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\n\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n\n\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n\n\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n\n\n#ifdef DITHERING\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n\n\n}\n\n\n",
  cullMode: "back",
  lightModel: "physical",
  renderType: "opaque"
};

/***/ }),

/***/ "./src/game/fx/shaders/pinkGlow/data.ts":
/*!**********************************************!*\
  !*** ./src/game/fx/shaders/pinkGlow/data.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "data": () => (/* binding */ data)
/* harmony export */ });
const data = {
  version: 1,
  uniforms: [{
    name: "Lavacolor",
    type: "vec3",
    value: {
      x: 1,
      y: 0.1,
      z: 0
    }
  }, {
    name: "_time",
    type: "float",
    value: 0
  }, {
    name: "noiseintensityreduction",
    type: "float",
    value: 0.5
  }, {
    name: "lavacontrast",
    type: "float",
    value: 4
  }, {
    name: "darkpatchredness",
    type: "float",
    value: 0.1
  }, {
    name: "emicolintensity",
    type: "float",
    value: 2
  }],
  vertex: "// Created with NodeToy | Three.js r149\n\n// <node_builder>\n\n// uniforms\n\n// attributes\n\n// varys\nvarying vec2 nodeVary0; \n// vars\n\n// codes\n\n// variables\n// </node_builder>\n\n\n\n\n\n\n\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifdef USE_TRANSMISSION\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ) * c );\n\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\nfloat luminance( const in vec3 rgb ) {\n\n\t// assumes rgb is in linear color space with sRGB primaries and D65 white point\n\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\n\treturn dot( weights, rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n\treturn m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n\t// dir is assumed to be unit length\n\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\treturn vec2( u, v );\n\n}\n\n\n#ifdef USE_UV\n\n\t#ifdef UVS_VERTEX_ONLY\n\n\t\tvec2 vUv;\n\n\t#else\n\n\t\tvarying vec2 vUv;\n\n\t#endif\n\n\tuniform mat3 uvTransform;\n\n#endif\n\n\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n\tuniform mat3 uv2Transform;\n\n#endif\n\n\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n\n\n#ifdef USE_FOG\n\n\tvarying float vFogDepth;\n\n#endif\n\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_MORPHTARGETS\n\n\tuniform float morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\n\t\t}\n\n\t#else\n\n\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\n\t\t#else\n\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\n\tmat4 getBoneMatrix( const in float i ) {\n\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\ty = dy * ( y + 0.5 );\n\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\treturn bone;\n\n\t}\n\n#endif\n\n\n\n#if NUM_SPOT_LIGHT_COORDS > 0\n\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n\n\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n#endif\n\n\nvoid main() {\nnodeVary0 = uv;\n\t\n\n\n\n#ifdef USE_UV\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n\n\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tvColor = vec4( 1.0 );\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvColor = vec3( 1.0 );\n\n#endif\n\n#ifdef USE_COLOR\n\n\tvColor *= color;\n\n#endif\n\n#ifdef USE_INSTANCING_COLOR\n\n\tvColor.xyz *= instanceColor.xyz;\n\n#endif\n\n\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tvColor *= morphTargetBaseInfluence;\n\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t#if defined( USE_COLOR_ALPHA )\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\n\t\t#elif defined( USE_COLOR )\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\n\t\t#endif\n\n\t}\n\n#endif\n\n\n\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n\n\n#ifdef USE_MORPHNORMALS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tobjectNormal *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\n\t\t}\n\n\t#else\n\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n\n\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n\t// this is in lieu of a per-instance normal-matrix\n\t// shear transforms in the instance matrix are not supported\n\n\tmat3 m = mat3( instanceMatrix );\n\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n\ttransformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n\n\n#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\n\nvec3 transformed = vec3( position );\n\n\n#ifdef USE_MORPHTARGETS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\ttransformed *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\n\t\t}\n\n\t#else\n\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n\n\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n\n\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n\tmvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition;\n\n\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n\t#else\n\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\t\tgl_Position.z *= gl_Position.w;\n\n\t\t}\n\n\t#endif\n\n#endif\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvClipPosition = - mvPosition.xyz;\n\n#endif\n\n\n\tvViewPosition = - mvPosition.xyz;\n\n\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\n#endif\n\n\n\n#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\n\t// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n\n#endif\n\n#if defined( USE_SHADOWMAP )\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n\n// spot lights can be evaluated without active shadow mapping (when SpotLight.map is used)\n\n#if NUM_SPOT_LIGHT_COORDS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n\n\n\n#ifdef USE_FOG\n\n\tvFogDepth = - mvPosition.z;\n\n#endif\n\n\n#ifdef USE_TRANSMISSION\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif\n}\n\n\n",
  fragment: "// Created with NodeToy | Three.js r149\n\n// <node_builder>\n\n// uniforms\nuniform vec3 Lavacolor; uniform float _time; uniform float noiseintensityreduction; uniform float lavacontrast; uniform float darkpatchredness; uniform float emicolintensity; \n// attributes\n\n// varys\nvarying vec2 nodeVary0; \n// vars\nfloat nodeVar0; float nodeVar1; vec2 nodeVar2; float nodeVar3; float nodeVar4; vec2 nodeVar5; float nodeVar6; float nodeVar7; float nodeVar8; vec3 nodeVar9; vec3 nodeVar10; vec3 nodeVar11; \n// codes\nvec4 CalculateContrast_rY7rcDCumd3A ( float contrastValue, vec4 colorTarget )\n\t\t{\n\t\t\tfloat t = 0.5 * ( 1.0 - contrastValue );\n\t\t\treturn  mat4( contrastValue,0,0,t, 0,contrastValue,0,t, 0,0,contrastValue,t, 0,0,0,1 ) * colorTarget ;\n\t\t}\nvec3 customFn_0F0JN3hc5LPA ( vec4 RGBA, float Value ) {\n                \n        vec4 color = RGBA;\n        vec4 SimpleContrast = CalculateContrast_rY7rcDCumd3A(Value,color);\n        return vec3(SimpleContrast.x, SimpleContrast.y, SimpleContrast.z);\n        \n            }\nvec3 mod2D289_ZYvSjmJ1eRYO ( vec3 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n\n\tvec2 mod2D289_ZYvSjmJ1eRYO( vec2 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n\n\tvec3 permute_ZYvSjmJ1eRYO( vec3 x ) { return mod2D289_ZYvSjmJ1eRYO( ( ( x * 34.0 ) + 1.0 ) * x ); }\n\n    float snoise_ZYvSjmJ1eRYO( vec2 v ){\n        const vec4 C = vec4( 0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439 );\n        vec2 i = floor( v + dot( v, C.yy ) );\n        vec2 x0 = v - i + dot( i, C.xx );\n        vec2 i1;\n        i1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n        i = mod2D289_ZYvSjmJ1eRYO( i );\n        vec3 p = permute_ZYvSjmJ1eRYO( permute_ZYvSjmJ1eRYO( i.y + vec3( 0.0, i1.y, 1.0 ) ) + i.x + vec3( 0.0, i1.x, 1.0 ) );\n        vec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0 );\n        m = m * m;\n        m = m * m;\n        vec3 x = 2.0 * fract( p * C.www ) - 1.0;\n        vec3 h = abs( x ) - 0.5;\n        vec3 ox = floor( x + 0.5 );\n        vec3 a0 = x - ox;\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\n        vec3 g;\n        g.x = a0.x * x0.x + h.x * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot( m, g );\n    }\nfloat customFn_dZFZkL420ekU ( vec2 uv, float scale ) {\n                \n    float noise = snoise_ZYvSjmJ1eRYO( uv * scale );\n    \n    noise = noise*0.5 + 0.5;\n    return noise;\n    \n            \n            }\nvec3 mod2D289_dtGWMceV6TuX ( vec3 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n\n\tvec2 mod2D289_dtGWMceV6TuX( vec2 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n\n\tvec3 permute_dtGWMceV6TuX( vec3 x ) { return mod2D289_dtGWMceV6TuX( ( ( x * 34.0 ) + 1.0 ) * x ); }\n\n    float snoise_dtGWMceV6TuX( vec2 v ){\n        const vec4 C = vec4( 0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439 );\n        vec2 i = floor( v + dot( v, C.yy ) );\n        vec2 x0 = v - i + dot( i, C.xx );\n        vec2 i1;\n        i1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n        i = mod2D289_dtGWMceV6TuX( i );\n        vec3 p = permute_dtGWMceV6TuX( permute_dtGWMceV6TuX( i.y + vec3( 0.0, i1.y, 1.0 ) ) + i.x + vec3( 0.0, i1.x, 1.0 ) );\n        vec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0 );\n        m = m * m;\n        m = m * m;\n        vec3 x = 2.0 * fract( p * C.www ) - 1.0;\n        vec3 h = abs( x ) - 0.5;\n        vec3 ox = floor( x + 0.5 );\n        vec3 a0 = x - ox;\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\n        vec3 g;\n        g.x = a0.x * x0.x + h.x * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot( m, g );\n    }\nfloat customFn_Z8kJqFIgVk9F ( vec2 uv, float scale ) {\n                \n    float noise = snoise_dtGWMceV6TuX( uv * scale );\n    \n    noise = noise*0.5 + 0.5;\n    return noise;\n    \n            \n            }\n\n// variables\n// </node_builder>\n\n\n\n\n\n\n\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\n\n#ifdef IOR\n\tfloat ior;\n#endif\n\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n\n#ifdef USE_CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n\n#ifdef USE_IRIDESCENCE\n\tfloat iridescence;\n\tfloat iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tfloat iridescenceThicknessMaximum;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ) * c );\n\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\nfloat luminance( const in vec3 rgb ) {\n\n\t// assumes rgb is in linear color space with sRGB primaries and D65 white point\n\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\n\treturn dot( weights, rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n\treturn m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n\t// dir is assumed to be unit length\n\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\treturn vec2( u, v );\n\n}\n\n\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\n\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\n\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n\n\n#ifdef DITHERING\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift according to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n\n\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n\tvarying vec2 vUv;\n\n#endif\n\n\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n\n\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n\n\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n\n\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n\n\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n\n\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n\n\n\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n\n} // validated\n\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n\n} // validated\n\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( V * D );\n\n}\n\n#ifdef USE_IRIDESCENCE\n\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\n\t\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\t\tfloat D = D_GGX( alpha, dotNH );\n\n\t\treturn F * ( V * D );\n\n\t}\n\n#endif\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nfloat D_Charlie( float roughness, float dotNH ) {\n\n\tfloat alpha = pow2( roughness );\n\n\t// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\n\t// Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n\n}\n\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\n\treturn sheenColor * ( D * V );\n\n}\n\n#endif\n\n\n\n#ifdef USE_IRIDESCENCE\n\n\t// XYZ to linear-sRGB color space\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\n\t// Assume air interface for top\n\t// Note: We don't handle the case fresnel0 == 1\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n\t}\n\n\t// Conversion FO/IOR\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n\t}\n\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\n\t}\n\n\t// Fresnel equations for dielectric/dielectric interfaces.\n\t// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n\t// Evaluation XYZ sensitivity curves in Fourier space\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\n\t}\n\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\t\tvec3 I;\n\n\t\t// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\n\t\t// Handle TIR:\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\t\t return vec3( 1.0 );\n\n\t\t}\n\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t\t// First interface\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\n\t\t// Second interface\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\n\t\t// Phase shift\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t\t// Compound terms\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t\t// Reflectance term for m = 0 (DC term amplitude)\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\n\t\t// Reflectance term for m > 0 (pairs of diracs)\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\n\t\t}\n\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\t\treturn max( I, vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection = abs( direction );\n\n\t\tfloat face = - 1.0;\n\n\t\tif ( absDirection.x > absDirection.z ) {\n\n\t\t\tif ( absDirection.x > absDirection.y )\n\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z > absDirection.y )\n\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face == 0.0 ) {\n\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face == 1.0 ) {\n\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face == 2.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face == 3.0 ) {\n\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face == 4.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face = getFace( direction );\n\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize = exp2( mipInt );\n\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071\n\n\t\tif ( face > 2.0 ) {\n\n\t\t\tuv.y += faceSize;\n\n\t\t\tface -= 3.0;\n\n\t\t}\n\n\t\tuv.x += face * faceSize;\n\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\n\t\t#ifdef texture2DGradEXT\n\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering\n\n\t\t#else\n\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\n\t\t#endif\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip = 0.0;\n\n\t\tif ( roughness >= cubeUV_r1 ) {\n\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\n\t\t} else {\n\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\n\t\tfloat mipF = fract( mip );\n\n\t\tfloat mipInt = floor( mip );\n\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF == 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#ifdef USE_ENVMAP\n\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n\n\n#if defined( USE_ENVMAP )\n\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\n\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n#endif\n\n\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n\n\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\treturn irradiance;\n\n}\n\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t#else\n\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t\t}\n\n\t\treturn 1.0;\n\n\t#endif\n\n}\n\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\tif ( spotAttenuation > 0.0 ) {\n\n\t\t\tfloat lightDistance = length( lVector );\n\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t\t} else {\n\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n\nstruct PhysicalMaterial {\n\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\n};\n\n// temporary\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\n\n// This is a curve-fit approxmation to the \"Charlie sheen\" BRDF integrated over the hemisphere from \n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tfloat r2 = roughness * roughness;\n\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\n\treturn saturate( DG * RECIPROCAL_PI );\n\n}\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\n\treturn fab;\n\n}\n\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\treturn specularColor * fab.x + specularF90 * fab.y;\n\n}\n\n// Fdez-Agüera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\t#ifdef USE_IRIDESCENCE\n\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\n\t#else\n\n\t\tvec3 Fr = specularColor;\n\n\t#endif\n\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\n\t#endif\n\n\t#ifdef USE_IRIDESCENCE\n\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\n\t#else\n\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\n\t#endif\n\n\t// Both indirect specular and indirect diffuse light accumulate here\n\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\t#ifdef USE_IRIDESCENCE\n\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\n\t#else\n\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\n\t#endif\n\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n\n\n#ifdef USE_TRANSMISSION\n\n\t// Transmission code is based on glTF-Sampler-Viewer\n\t// https://github.com/KhronosGroup/glTF-Sample-Viewer\n\n\tfloat transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tuniform sampler2D transmissionMap;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tuniform sampler2D thicknessMap;\n\n\t#endif\n\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\n\tvarying vec3 vWorldPosition;\n\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\n\t\t// Direction of refracted light.\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\n\t\t// Compute rotation-independant scaling of the model matrix.\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t// The thickness is specified in local space.\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\n\t}\n\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\n\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\n\t}\n\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\n\t\t#ifdef texture2DLodEXT\n\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#else\n\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#endif\n\n\t}\n\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\n\t\tif ( isinf( attenuationDistance ) ) {\n\n\t\t\t// Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\n\t\t\treturn radiance;\n\n\t\t} else {\n\n\t\t\t// Compute light attenuation using Beer's law.\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n\t\t\treturn transmittance * radiance;\n\n\t\t}\n\n\t}\n\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\n\t\t// Get the specular component.\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\n\t}\n#endif\n\n\n#if NUM_SPOT_LIGHT_COORDS > 0\n\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n\n#endif\n\n#if NUM_SPOT_LIGHT_MAPS > 0\n\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n\n\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm; // normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n\n\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tuniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n\t// Normal Mapping Without Precomputed Tangents\n\t// http://www.thetenthplanet.de/archives/1180\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 N = surf_norm; // normalized\n\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n\t}\n\n#endif\n\n\n\n#ifdef USE_CLEARCOATMAP\n\n\tuniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n\n#endif\n\n\n\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform sampler2D iridescenceMap;\n\n#endif\n\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform sampler2D iridescenceThicknessMap;\n\n#endif\n\n\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n\n\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n\n\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n\n#endif\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n\n\nvoid main() {\n\n\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n\n\n\tvec4 diffuseColor = vec4( 0.0 );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = vec3( 0.0 );\n\n\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\t// Doing a strict comparison with == 1.0 can cause noise artifacts\n\t// on some platforms. See issue #17623.\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n\n\n#ifdef USE_MAP\n\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\n\t#ifdef DECODE_VIDEO_TEXTURE\n\n\t\t// inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\n\t#endif\n\n\tdiffuseColor *= sampledDiffuseColor;\n\n#endif\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tdiffuseColor *= vColor;\n\n#elif defined( USE_COLOR )\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n\n\n\tdiffuseColor = vec4( 0, 0, 0, 1 );\n\n\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n\n\n#ifdef USE_ALPHATEST\n\n\tif ( diffuseColor.a < alphaTest ) discard;\n\n#endif\n\n\nfloat roughnessFactor = 0.0;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n\n\n\troughnessFactor = 0.5;\n\n\nfloat metalnessFactor = 0.0;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n\n\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n\n#ifdef FLAT_SHADED\n\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * faceDirection;\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\n\t\t#endif\n\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n\n\t\n\n#ifdef USE_CLEARCOAT\n\n\tvec3 clearcoatNormal = geometryNormal;\n\n#endif\n\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n\t#else\n\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n\nnodeVar0 = ( _time * 0.5 );\n\tnodeVar1 = nodeVar0;\n\tnodeVar2 = (nodeVary0 * vec2( 7, 7 ) + vec2( nodeVar1 ));\n\tnodeVar3 = customFn_dZFZkL420ekU( nodeVar2, 3.0 );\n\tnodeVar4 = ( nodeVar3 - noiseintensityreduction );\n\tnodeVar5 = (nodeVary0 * vec2( 10, 10 ) + vec2( 0, 0 ));\n\tnodeVar6 = customFn_Z8kJqFIgVk9F( nodeVar5, 1.0 );\n\tnodeVar7 = ( nodeVar4 + nodeVar6 );\n\tnodeVar8 = (pow(nodeVar7,5.0));\n\tnodeVar9 = ( customFn_0F0JN3hc5LPA( vec4( vec3( nodeVar8 ), 1.0 ), lavacontrast ) + vec3( darkpatchredness ) );\n\tnodeVar10 = ( Lavacolor * nodeVar9 );\n\tnodeVar11 = ( nodeVar10 * vec3( emicolintensity ) );\n\t\n\ttotalEmissiveRadiance = nodeVar11 * vec3(1);\n\n\n\t// accumulation\n\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n\n#ifdef IOR\n\n\tmaterial.ior = ior;\n\n\t#ifdef SPECULAR\n\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\n\t\t#endif\n\n\t\t#ifdef USE_SPECULARCOLORMAP\n\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\n\t\t#endif\n\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\n\t#else\n\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\n\t#endif\n\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n\n#else\n\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\n\t#ifdef USE_CLEARCOATMAP\n\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n\t#endif\n\n\tmaterial.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\n\t#ifdef USE_IRIDESCENCEMAP\n\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\n\t#endif\n\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\n\t#else\n\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\n\t#endif\n\n#endif\n\n#ifdef USE_SHEEN\n\n\tmaterial.sheenColor = sheenColor;\n\n\t#ifdef USE_SHEENCOLORMAP\n\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\n\t#endif\n\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\n\t#ifdef USE_SHEENROUGHNESSMAP\n\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\n\t#endif\n\n#endif\n\n\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\n\tif ( material.iridescenceThickness == 0.0 ) {\n\n\t\tmaterial.iridescence = 0.0;\n\n\t} else {\n\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\n\t}\n\n\tif ( material.iridescence > 0.0 ) {\n\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\n\t\t// Iridescence F0 approximation\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\n\t}\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n\n\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\n\t#endif\n\n#endif\n\n\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n\n\n\t// modulation\n\t\n\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n\n#ifdef USE_TRANSMISSION\n\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\n\t#endif\n\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n\n#endif\n\n\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n\t#ifdef USE_SHEEN\n\n\t\t// Sheen energy compensation approximation calculation can be found at the end of\n\t\t// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\n\t#endif\n\n\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n\n// https://github.com/mrdoob/three.js/pull/22425\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\n\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n\n\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n\n\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n\n\n#ifdef DITHERING\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n\n\n}\n\n\n",
  cullMode: "back",
  lightModel: "standard",
  renderType: "opaque"
};

/***/ }),

/***/ "./src/game/fx/shaders/pinkGlow/pink-glowing.ts":
/*!******************************************************!*\
  !*** ./src/game/fx/shaders/pinkGlow/pink-glowing.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pinkGlowing": () => (/* binding */ pinkGlowing)
/* harmony export */ });
/* harmony import */ var _nodetoy_three_nodetoy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @nodetoy/three-nodetoy */ "./node_modules/@nodetoy/three-nodetoy/dist/three-nodetoy.es.js");
/* harmony import */ var _pinkGlow_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pinkGlow/data */ "./src/game/fx/shaders/pinkGlow/data.ts");


const pinkGlowing = () => {
  const material = new _nodetoy_three_nodetoy__WEBPACK_IMPORTED_MODULE_0__.NodeToyMaterial({
    // @ts-ignore
    data: _pinkGlow_data__WEBPACK_IMPORTED_MODULE_1__.data
  });
  return material;
};

/***/ }),

/***/ "./src/game/game-config.ts":
/*!*********************************!*\
  !*** ./src/game/game-config.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GameConfig": () => (/* binding */ GameConfig)
/* harmony export */ });
// this config for basic changes!
// for blocks to win etc
const GameConfig = {
  //block to win value: 15
  maxBlockToWin: 21,
  //size radius for weapon when it hit the blocks value:2
  radiusWeapon: 2,
  //count to block to destroy to hit value: 1
  maxDestroyBlocksOneHit: 2,
  //discord link value: "https://diamond-rush.vercel.app/#gameplay"
  discordUrl: "https://diamond-rush.vercel.app/#gameplay",
  //block base color value: 0x964b00
  blockColor: 0x964b00,
  //player main base color value:  0x000000
  characterMainColor: 0x000000,
  //player neon base color value:  0x00ffee
  characterNeonColor: 0xff00ee
};

/***/ }),

/***/ "./src/game/game-state/game-state.ts":
/*!*******************************************!*\
  !*** ./src/game/game-state/game-state.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GameStage": () => (/* binding */ GameStage),
/* harmony export */   "gameState": () => (/* binding */ gameState)
/* harmony export */ });
let GameStage;
(function (GameStage) {
  GameStage[GameStage["GAMENOTLOADED"] = 0] = "GAMENOTLOADED";
  GameStage[GameStage["GAMELOADED"] = 1] = "GAMELOADED";
  GameStage[GameStage["GAMESTART"] = 2] = "GAMESTART";
  GameStage[GameStage["ENDCARD"] = 3] = "ENDCARD";
  GameStage[GameStage["TIMEOUTENDCARD"] = 4] = "TIMEOUTENDCARD";
})(GameStage || (GameStage = {}));
const startState = {
  stage: GameStage.GAMENOTLOADED
};
class GameStateService {
  constructor() {
    this._state = startState;
  }
  get state() {
    return {
      ...this._state
    };
  }
  set state(newState) {
    if (newState instanceof Function) {
      this._state = newState({
        ...this.state
      });
    } else {
      this._state = {
        ...this._state,
        ...newState
      };
    }
  }
}

//game init
const gameState = new GameStateService();
window.state = gameState;

/***/ }),

/***/ "./src/game/game-state/state-machine.ts":
/*!**********************************************!*\
  !*** ./src/game/game-state/state-machine.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateMachine": () => (/* binding */ StateMachine)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/game-manager */ "./src/game/managers/game-manager.ts");


class StateMachine {
  constructor(_object) {
    this.currentAction = void 0;
    this.currentState = void 0;
    this.mixer = void 0;
    this.states = new Map();
    this.onLoopCallbacks = new Map();
    this.instantiate = object => {
      return new StateMachine(object);
    };
    this.handleAnimationFinished = () => {
      var _this$currentState, _this$currentAction, _this$currentAction2;
      if ((_this$currentState = this.currentState) !== null && _this$currentState !== void 0 && _this$currentState.onExit) {
        this.currentState.onExit();
      }
      (_this$currentAction = this.currentAction) === null || _this$currentAction === void 0 ? void 0 : _this$currentAction.stop();
      (_this$currentAction2 = this.currentAction) === null || _this$currentAction2 === void 0 ? void 0 : _this$currentAction2.reset();
      this.currentState = undefined;

      // Remove the 'finished' event listener for the current action on the mixer
      this.mixer.removeEventListener("finished", this.handleAnimationFinished);
    };
    this.object = _object;
    this.mixer = new three__WEBPACK_IMPORTED_MODULE_1__.AnimationMixer(_object);
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_0__.GameManager.GAMEUPDATESERVICE.register(this);
  }
  addState(state) {
    this.states.set(state.name, state);
  }
  setState(name) {
    var _this$currentState3;
    const state = this.states.get(name);
    this.executeOnLoopCallbacks();
    //#region
    if (!state) {
      console.warn(`State ${name} does not exist`);
      return;
    }

    //#endregion

    //#region on loop repeat
    if (this.getMaxDuration(name) - this.getCurrentTime() <= 0) {
      var _this$currentState2;
      if ((_this$currentState2 = this.currentState) !== null && _this$currentState2 !== void 0 && _this$currentState2.onLoop) {
        this.currentState.onLoop();
      }
    }
    //#endregion

    if (state === this.currentState) {
      return;
    }
    if ((_this$currentState3 = this.currentState) !== null && _this$currentState3 !== void 0 && _this$currentState3.onExit) {
      this.currentState.onExit();
    }
    const animationAction = this.mixer.clipAction(state.animation);
    if (this.currentState) {
      const previousState = this.currentState;
      const transition = previousState.transitions.get(name);
      if (transition) {
        var _state$settings;
        const crossFadeDuration = ((_state$settings = state.settings) === null || _state$settings === void 0 ? void 0 : _state$settings.fadeSpeed) ?? 0.5;
        animationAction.time = 0;
        animationAction.enabled = true;
        animationAction.crossFadeFrom(this.currentAction, crossFadeDuration, true);
        if (transition.onTransition) {
          console.log("set trans");
          transition.onTransition();
        }
      } else {
        var _this$currentAction3, _this$currentAction4;
        (_this$currentAction3 = this.currentAction) === null || _this$currentAction3 === void 0 ? void 0 : _this$currentAction3.stop();
        (_this$currentAction4 = this.currentAction) === null || _this$currentAction4 === void 0 ? void 0 : _this$currentAction4.reset();
        animationAction.setEffectiveTimeScale(1);
        animationAction.setEffectiveWeight(1);
        animationAction.setLoop(three__WEBPACK_IMPORTED_MODULE_1__.LoopRepeat, Infinity);
      }
    }
    this.currentAction = animationAction;
    this.currentState = state;
    if (this.currentState.onEnter) {
      this.currentState.onEnter();
    }
    this.updateAnimationSettings();
    this.currentAction.play();

    // Register the 'finished' event listener for the current action on the mixer
    this.mixer.addEventListener("finished", this.handleAnimationFinished);
  }
  update(delta, time) {
    this.mixer.update(delta);
    if (this.currentAction) {
      this.currentAction.time += delta;
    }
    if (this.currentState && this.currentState.onUpdate) {
      this.currentState.onUpdate();
    }
    if (this.currentState && this.currentState.settings && typeof this.currentState.settings.speed !== "undefined") {
      this.currentAction.setEffectiveTimeScale(this.currentState.settings.speed);
    }
  }
  getCurrentTime() {
    if (!this.currentAction) {
      return 0;
    }
    return this.currentAction.time;
  }
  getMaxDuration(stateName) {
    const state = Array.from(this.states.values()).find(state => state.name === stateName);
    if (state) {
      return state.animation.duration;
    }
    return 0;
  }
  repeatLoop() {
    var _this$currentState4;
    if ((_this$currentState4 = this.currentState) !== null && _this$currentState4 !== void 0 && _this$currentState4.onLoop) this.mixer.dispatchEvent({
      type: "repeatLoop"
    });
  }
  executeOnLoopCallbacks() {
    var _this$currentState5;
    if ((_this$currentState5 = this.currentState) !== null && _this$currentState5 !== void 0 && _this$currentState5.onLoop) {
      this.mixer.addEventListener("repeatLoop", () => {
        this.currentState.onLoop();
      });
    }
  }
  updateAnimationSettings() {
    var _this$currentState6;
    if (this.currentState === undefined) return;
    if ((_this$currentState6 = this.currentState) !== null && _this$currentState6 !== void 0 && _this$currentState6.settings) {
      const {
        speed,
        loop
      } = this.currentState.settings;
      if (typeof speed !== "undefined" && speed !== this.currentAction.getEffectiveTimeScale()) {
        this.currentAction.setEffectiveTimeScale(speed);
        // this.currentAction!.time = 0;
        // this.currentAction!.reset();
      }

      if (typeof loop !== "undefined") {
        if (loop) {
          this.currentAction.setLoop(three__WEBPACK_IMPORTED_MODULE_1__.LoopRepeat, Infinity);
        } else {
          this.currentAction.setLoop(three__WEBPACK_IMPORTED_MODULE_1__.LoopOnce, 1);
        }
      }
    }
  }
}

/***/ }),

/***/ "./src/game/game.ts":
/*!**************************!*\
  !*** ./src/game/game.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Game": () => (/* binding */ Game)
/* harmony export */ });
/* harmony import */ var _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game-state/game-state */ "./src/game/game-state/game-state.ts");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var _nodetoy_three_nodetoy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @nodetoy/three-nodetoy */ "./node_modules/@nodetoy/three-nodetoy/dist/three-nodetoy.es.js");
/* harmony import */ var _entities_create_light__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./entities/create-light */ "./src/game/entities/create-light.ts");
/* harmony import */ var _entities_create_camera__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./entities/create-camera */ "./src/game/entities/create-camera.ts");
/* harmony import */ var _entities_create_character__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entities/create-character */ "./src/game/entities/create-character.ts");
/* harmony import */ var _entities_create_scene__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./entities/create-scene */ "./src/game/entities/create-scene.ts");
/* harmony import */ var _entities_create_controller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./entities/create-controller */ "./src/game/entities/create-controller.ts");
/* harmony import */ var _entities_creat_sky_box__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./entities/creat-sky-box */ "./src/game/entities/creat-sky-box.ts");
/* harmony import */ var _entities_create_blocks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./entities/create-blocks */ "./src/game/entities/create-blocks.ts");
/* harmony import */ var _entities_create_walls__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./entities/create-walls */ "./src/game/entities/create-walls.ts");
/* harmony import */ var _entities_create_shader_grass__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./entities/create-shader-grass */ "./src/game/entities/create-shader-grass.ts");












class Game {
  //  private stats = new Stats();

  constructor() {
    this.initGameState = (() => {
      let {
        stage: prevGameStage
      } = _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__.gameState.state;
      return () => {
        const {
          stage
        } = _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__.gameState.state;
        if (stage === prevGameStage) {
          return;
        }
        prevGameStage = stage;
        if (stage === _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__.GameStage.GAMENOTLOADED) {
          console.log("NOTLOADED");
        }
        if (stage === _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__.GameStage.GAMELOADED) {
          console.log("LOADED");
        }
        if (stage === _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__.GameStage.GAMESTART) {
          console.log("GAMESTART");
        }
      };
    })();
    this.addEntities = () => {
      (0,_entities_create_scene__WEBPACK_IMPORTED_MODULE_6__.createScene)();
      (0,_entities_creat_sky_box__WEBPACK_IMPORTED_MODULE_8__.creatSkyBox)();
      (0,_entities_create_camera__WEBPACK_IMPORTED_MODULE_4__.createCamera)();
      (0,_entities_create_light__WEBPACK_IMPORTED_MODULE_3__.createLight)();

      //for control
      (0,_entities_create_controller__WEBPACK_IMPORTED_MODULE_7__.createController)();
      (0,_entities_create_character__WEBPACK_IMPORTED_MODULE_5__.createCharacter)();

      //init game object
      (0,_entities_create_walls__WEBPACK_IMPORTED_MODULE_10__.createWalls)();
      (0,_entities_create_blocks__WEBPACK_IMPORTED_MODULE_9__.createBlocks)();
      (0,_entities_create_shader_grass__WEBPACK_IMPORTED_MODULE_11__.createShaderGrass)();
    };
    this.animate = () => {
      requestAnimationFrame(this.animate);
      if (_managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.GAME.isPaused) return;
      _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.GAMEUPDATESERVICE.update();
    };
    requestAnimationFrame(this.animate);
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.GAMEUPDATESERVICE.register(this);
    this.addEntities();
    this.startTheGame();
  }

  //basic GameLoop
  async update(delta, time) {
    // this.stats.begin();
    this.initGameState();
    await _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.ENTITYWORLD.execute(time, delta);
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.tickHandler();
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.CANNON_WORLD.fixedStep();
    this.isNeedPostProcess(_managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.postProcessing);
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.CAMERA.updateMatrix();
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.CONTROLS.update();
    _nodetoy_three_nodetoy__WEBPACK_IMPORTED_MODULE_2__.NodeToyMaterial.tick();
    // this.stats.end();
  }

  reset() {
    _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.ENTITYWORLD.alive;
  }
  startTheGame() {
    //Game Starting
    setTimeout(() => {
      _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__.gameState.state = {
        stage: _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__.GameStage.GAMESTART
      };
    }, 2000);
  }
  isNeedPostProcess(isNeed) {
    switch (isNeed) {
      case true:
        {
          _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.RENDERER.clear();
          _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.COMPOSER.render();
          _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.RENDERER.clearDepth();
          break;
        }
      case false:
        {
          _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.RENDERER.render(_managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.SCENE, _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.CAMERA);
          break;
        }
    }
  }
}

/***/ }),

/***/ "./src/game/managers/assets-manager/prefabs-manager.ts":
/*!*************************************************************!*\
  !*** ./src/game/managers/assets-manager/prefabs-manager.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PrefabsManager)
/* harmony export */ });
/* harmony import */ var _raw_assets_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raw-assets-manager */ "./src/game/managers/assets-manager/raw-assets-manager.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_utils_SkeletonUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/utils/SkeletonUtils */ "./node_modules/three/examples/jsm/utils/SkeletonUtils.js");



const prefabStorageModels = new Map();
const prefabStorageFonts = new Map();
const prefabStorageMaterials = new Map();
const prefabStorageSprites = new Map();
class PrefabsManager {}
/**
 * Register prefab in PrefabManager
 * @constructor
 * @param {ModelPrefabs} name - used current name of ModelPrefabs {enum}.
 * @param {RawObject3D} model - vec3 position of gameObject.
 * @return {Object3D}
 */
PrefabsManager.registerObject3D = (name, model) => {
  prefabStorageModels.set(name, _raw_assets_manager__WEBPACK_IMPORTED_MODULE_0__.RawManager.getModel(model));
  return prefabStorageModels.get(name);
};
/**
 * Register custom-created (Object3D, Mesh) prefab in PrefabManager
 * @constructor
 * @param {ModelPrefabs} name - used current name of ModelPrefabs {enum}.
 * @param {Object3D|Mesh} model - vec3 position of gameObject.
 * @return {Object3D}
 */
PrefabsManager.registerMesh = (name, model) => {
  prefabStorageModels.set(name, model);
  return prefabStorageModels.get(name);
};
/**
 * Register material prefab in PrefabManager
 * @constructor
 * @param {MaterialPrefabs} name - used current name of MaterialPrefabs {enum}.
 * @param {Material} material - material with setting by THREE.js.
 * @return {Material}
 */
PrefabsManager.registerMaterial = (name, material) => {
  prefabStorageMaterials.set(name, material);
  return prefabStorageMaterials.get(name);
};
/**
 * Register material prefab in PrefabManager
 * @constructor
 * @param {FontPrefabs} name - used current name of FontPrefab {enum}.
 * @param {Font} font - font with setting by THREE.js.
 * @return {Font}
 */
PrefabsManager.registerFont = (name, font) => {
  prefabStorageFonts.set(name, font);
  return prefabStorageFonts.get(name);
};
/**
 * Register sprite prefab in PrefabManager
 * @constructor
 * @param {SpritePrefabs} name - used current name of SpritePrefabs {enum}.
 * @param {Sprite} sprite - sprite with setting by THREE.js.
 * @return {Sprite}
 */
PrefabsManager.registerSprite = (name, sprite) => {
  prefabStorageSprites.set(name, sprite);
  return prefabStorageSprites.get(name);
};
/**
 * get Object3D prefab in PrefabManager
 * @constructor
 * @param {ModelPrefabs} name - used current name of ModelPrefabs {enum}.
 * @return {Object3D}
 */
PrefabsManager.getObject3D = name => {
  const currentObject3D = prefabStorageModels.get(name);
  const animations = currentObject3D.animations;
  const newObject3D = (0,three_examples_jsm_utils_SkeletonUtils__WEBPACK_IMPORTED_MODULE_1__.clone)(currentObject3D);
  if (animations) {
    newObject3D.animations = animations;
  }
  return newObject3D;
};
/**
 * get Material prefab in PrefabManager
 * @constructor
 * @param {MaterialPrefabs} name - used current name of MaterialPrefabs {enum}.
 * @return {Material}
 */
PrefabsManager.getMaterial = name => {
  return prefabStorageMaterials.get(name);
};
/**
 * get Material prefab in PrefabManager
 * @constructor
 * @param {MaterialPrefabs} name - used current name of MaterialPrefabs {enum}.
 * @return {Material}
 */
PrefabsManager.getFont = name => {
  return prefabStorageFonts.get(name);
};
/**
 * get Multiply Materials prefab in PrefabManager
 * @constructor
 * @param {MaterialPrefabs} name - used current name of MaterialPrefabs {enum}.
 * @return {Material[]}
 */
PrefabsManager.getMultiplyMaterial = name => {
  return prefabStorageMaterials.get(name);
};
/**
 * get Sprite prefab in PrefabManager
 * @constructor
 * @param {SpritePrefabs} name - used current name of SpritePrefabs {enum}.
 * @return {Sprite}
 */
PrefabsManager.getSprite = name => {
  return prefabStorageSprites.get(name);
};
/**
 * clone prefab material and return it
 * @constructor
 * @param {MaterialPrefabs} name - used current name of MaterialPrefabs {enum}.
 * @return {Material}
 */
PrefabsManager.cloneMaterial = name => {
  const material = prefabStorageMaterials.get(name);
  if (material instanceof three__WEBPACK_IMPORTED_MODULE_2__.Material) {
    return material.clone();
  } else if (Array.isArray(material)) {
    return material.map(m => m.clone());
  } else {
    throw new Error(`Material '${name}' not found in storage.`);
  }
};
/**
 * clone prefab Object3D and return it.
 * !IMPORTANT!
 * ONLY FOR CLONE SIMPLE MESHES AND OBJECT3D, it does not provide animations and skeletons,
 * skinnedMesh
 * @constructor
 * @param {ModelPrefabs} name - used current name of MaterialPrefabs {enum}.
 * @return {Object3D}
 */
PrefabsManager.rawCloneObject3D = name => {
  const currentObject3D = prefabStorageModels.get(name).clone();
  return currentObject3D;
};

/***/ }),

/***/ "./src/game/managers/assets-manager/raw-assets-manager.ts":
/*!****************************************************************!*\
  !*** ./src/game/managers/assets-manager/raw-assets-manager.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawManager": () => (/* binding */ RawManager),
/* harmony export */   "fontLoader": () => (/* binding */ fontLoader),
/* harmony export */   "loadingManager": () => (/* binding */ loadingManager),
/* harmony export */   "object3DLoader": () => (/* binding */ object3DLoader),
/* harmony export */   "textureLoader": () => (/* binding */ textureLoader)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _asset_list_raw_assets_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../asset-list/raw-assets-list */ "./src/game/asset-list/raw-assets-list.ts");
/* harmony import */ var _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset-list/raw-assets/object3d-raw-asstes */ "./src/game/asset-list/raw-assets/object3d-raw-asstes.ts");
/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ "./node_modules/three/examples/jsm/loaders/GLTFLoader.js");
/* harmony import */ var _asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../asset-list/raw-assets/texture-raw-assets */ "./src/game/asset-list/raw-assets/texture-raw-assets.ts");
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");
/* harmony import */ var _prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../prefabs/object3d-prefabs */ "./src/game/prefabs/object3d-prefabs.ts");
/* harmony import */ var _prefabs_material_prefabs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../prefabs/material-prefabs */ "./src/game/prefabs/material-prefabs.ts");
/* harmony import */ var _prefabs_sprite_prefabs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../prefabs/sprite-prefabs */ "./src/game/prefabs/sprite-prefabs.ts");
/* harmony import */ var _asset_list_raw_assets_font_raw_assets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../asset-list/raw-assets/font-raw-assets */ "./src/game/asset-list/raw-assets/font-raw-assets.ts");
/* harmony import */ var three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! three/examples/jsm/loaders/FontLoader */ "./node_modules/three/examples/jsm/loaders/FontLoader.js");
/* harmony import */ var _prefabs_font_prefabs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../prefabs/font-prefabs */ "./src/game/prefabs/font-prefabs.ts");












const loadingManager = new three__WEBPACK_IMPORTED_MODULE_9__.LoadingManager();
const fontLoader = new three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_10__.FontLoader(loadingManager);
const textureLoader = new three__WEBPACK_IMPORTED_MODULE_9__.TextureLoader(loadingManager);
const object3DLoader = new three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_11__.GLTFLoader(loadingManager);

//update loading assets
loadingManager.onProgress = url => {
  // const modelNameElement = document.querySelector(".model-name") as HTMLElement;
  // modelNameElement.textContent = "Loading: " + `${getFilenameFromUrl(url)}`;
};
class RawAssetsManager {
  constructor() {
    this.loadedExternalAssets = new Map();
    this.loadedObject3DAssets = new Map();
    this.loadedFontAssets = new Map();
    this.promisedTexture = [];
    this.promisedObject3D = [];
    this.promisedFont = [];
    this.preloading = async cb => {
      //add promised Texture to array

      for (const [rawTexture, path] of Object.entries(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_2__.textureList)) {
        const texture = Number(rawTexture);
        this.promisedTexture.push(this.loadTexture(path, texture));
      }
      for (const [rawObject, path] of Object.entries(_asset_list_raw_assets_font_raw_assets__WEBPACK_IMPORTED_MODULE_7__.fontList)) {
        const font = Number(rawObject);
        this.promisedFont.push(this.loadFont(path, font));
      }
      for (const [rawObject, path] of Object.entries(_asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__.object3DList)) {
        const object = Number(rawObject);
        this.promisedObject3D.push(this.loadModels(path, object));
      }
      await Promise.all(this.promisedTexture);
      console.log("--------------all textures loaded---------------");
      await Promise.all(this.promisedObject3D);
      console.log("--------------all models loaded---------------");

      //await Promise.all(this.promisedFont);
      console.log("--------------all fonts loaded---------------");
      (0,_prefabs_material_prefabs__WEBPACK_IMPORTED_MODULE_5__.initPresetsMaterial)();
      (0,_prefabs_sprite_prefabs__WEBPACK_IMPORTED_MODULE_6__.initPresetsSprites)();
      (0,_prefabs_object3d_prefabs__WEBPACK_IMPORTED_MODULE_4__.initPresetsObject3D)();
      (0,_prefabs_font_prefabs__WEBPACK_IMPORTED_MODULE_8__.initPresetsFont)();
      if (cb) {
        cb();
      }
    };
    this.getTexture = assetName => {
      return this.loadedExternalAssets.get(assetName);
    };
    this.getFont = assetName => {
      return this.loadedFontAssets.get(assetName);
    };
    this.getModel = assetName => {
      return this.loadedObject3DAssets.get(assetName);
    };
    this.loadTexture = (path, asset) => {
      return new Promise(resolve => {
        if (path) {
          textureLoader.load(path, texture => {
            resolve(texture);
            this.loadedExternalAssets.set(asset, texture);
          });
        } else {
          textureLoader.load(_asset_list_raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevTextureName.MISSING_TEXTURE, errorTexture => {
            console.warn("U SEE A FAKE TEXTURE, fix path: " + `${path}`);
            resolve(errorTexture);
            this.loadedExternalAssets.set(asset, errorTexture);
          });
        }
      });
    };
    this.loadModels = (path, asset) => {
      return new Promise(resolve => {
        if (path) {
          object3DLoader.load(path, gltf => {
            const model = gltf.scene;
            _utils_assets_utils__WEBPACK_IMPORTED_MODULE_3__["default"].computeVertexNormals(model);
            _utils_assets_utils__WEBPACK_IMPORTED_MODULE_3__["default"].addAnimations(gltf);
            resolve(model);
            this.loadedObject3DAssets.set(asset, model);
          });
        } else {
          object3DLoader.load(_asset_list_raw_assets_list__WEBPACK_IMPORTED_MODULE_0__.DevModelName.GLTF_ERROR, errorModel => {
            console.warn("U SEE  A FAKE MODELS, fix path: " + `${path}`);
            const model = errorModel.scene;
            resolve(model);
            this.loadedObject3DAssets.set(asset, model);
          });
        }
      });
    };
    this.loadFont = (path, asset) => {
      return new Promise(resolve => {
        if (path) {
          fontLoader.load(path, font => {
            console.log("font", asset);
            resolve(font);
            console.log("font", font);
            this.loadedFontAssets.set(asset, font);
          }, err => {
            console.log("An error happened");
          });
        } else {
          fontLoader.load(path, font => {
            resolve(font);
            this.loadedFontAssets.set(asset, font);
          });
        }
      });
    };
  }
}
const RawManager = new RawAssetsManager();
function getFilenameFromUrl(url) {
  const startIndex = url.lastIndexOf("/") + 1; // find the last occurrence of "/" in the URL
  const filename = url.substring(startIndex); // extract the filename from the URL
  return filename;
}

/***/ }),

/***/ "./src/game/managers/game-manager.ts":
/*!*******************************************!*\
  !*** ./src/game/managers/game-manager.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GameManager": () => (/* binding */ GameManager),
/* harmony export */   "postProcessing": () => (/* binding */ postProcessing)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ "./src/index.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ "./node_modules/three/examples/jsm/controls/OrbitControls.js");
/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game */ "./src/game/game.ts");
/* harmony import */ var _services_resize_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../services/resize-service */ "./src/game/services/resize-service.ts");
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var three_examples_jsm_libs_stats_module__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! three/examples/jsm/libs/stats.module */ "./node_modules/three/examples/jsm/libs/stats.module.js");
/* harmony import */ var _game_state_game_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../game-state/game-state */ "./src/game/game-state/game-state.ts");
/* harmony import */ var _playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../playable-helper/ice-cream/ice-cream */ "./src/playable-helper/ice-cream/ice-cream.ts");
/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ "./node_modules/three/examples/jsm/postprocessing/EffectComposer.js");
/* harmony import */ var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass */ "./node_modules/three/examples/jsm/postprocessing/RenderPass.js");
/* harmony import */ var _services_update_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../services/update-service */ "./src/game/services/update-service.ts");
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _systems_define_all_systems__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../systems/define-all-systems */ "./src/game/systems/define-all-systems.ts");
/* harmony import */ var cannon_es_debugger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cannon-es-debugger */ "./node_modules/cannon-es-debugger/dist/cannon-es-debugger.js");
/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass */ "./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js");
















const sizes = {
  width: window.innerWidth,
  height: window.innerHeight
};
const DEBUG = false;
const postProcessing = false;
class GameManagers extends three__WEBPACK_IMPORTED_MODULE_8__.EventDispatcher {
  // private canvas = getCanvas()

  constructor() {
    super();
    this.currentFont = void 0;
    this.gameStatus = {
      alreadyPlayed: false,
      isPlaying: false,
      isPaused: false,
      isDown: false,
      isWin: false,
      isLose: false,
      isDebug: DEBUG
    };
    this.guiManager = void 0;
    this.renderer = void 0;
    this.renderTarget = void 0;
    this.composer = void 0;
    this.camera = void 0;
    this.orthographicCamera = void 0;
    this.scene = new three__WEBPACK_IMPORTED_MODULE_8__.Scene();
    this.orthographicScene = new three__WEBPACK_IMPORTED_MODULE_8__.Scene();
    this.cannonWorld = void 0;
    this.cannonDebugRenderer = void 0;
    this.controls = void 0;
    this.entityWorld = void 0;
    this.gameUpdateService = new _services_update_service__WEBPACK_IMPORTED_MODULE_5__.GameUpdateService();
    this.touchValues = {
      mousePosition: {
        x: 0,
        y: 0
      },
      oldPos: {
        x: 0,
        y: 0
      },
      isPlayerTouch: false,
      lastTouch: {
        x: 0,
        y: 0
      },
      movePlayerVelocity: 0
    };
    this.stage = void 0;
    this.stats = void 0;
    this.start = () => {
      this.gameStatus.isPlaying = true;
      _game_state_game_state__WEBPACK_IMPORTED_MODULE_3__.gameState.state = {
        stage: _game_state_game_state__WEBPACK_IMPORTED_MODULE_3__.GameStage.GAMESTART
      };
      if (window.network) {
        if (window.network.gameStart) window.network.gameStart();
        console.log("game_start");
      }
    };
  }
  get RENDERER() {
    return this.renderer;
  }
  get SCENE() {
    return this.scene;
  }
  get UISCENE() {
    return this.orthographicScene;
  }
  get CAMERA() {
    return this.camera;
  }
  get UICAMERA() {
    return this.orthographicCamera;
  }
  get RENDERTARGET() {
    return this.renderTarget;
  }
  get CONTROLS() {
    return this.controls;
  }
  get GUI() {
    return this.guiManager;
  }
  get ENTITYWORLD() {
    return this.entityWorld;
  }
  get COMPOSER() {
    if (this.composer && !postProcessing) return;
    return this.composer;
  }
  get ICEPARAMS() {
    return window._gameplay.creative;
  }
  get GAME() {
    return this.gameStatus;
  }
  get CANNON_WORLD() {
    return this.cannonWorld;
  }
  get GAMEUPDATESERVICE() {
    return this.gameUpdateService;
  }
  async setup() {
    this.renderer = this.setupRenderer();
    // this.renderTarget = this.setupRenderTarget();
    // this.renderer.autoClear = false;
    this.camera = this.setupCamera();
    //this.orthographicCamera = this.setupOrthographicCamera();
    this.setupOrbitControls();
    // this.guiManager = new GuiManager();
    if (postProcessing) {
      this.composer = this.setupPostprocessing();
    }
    this.cannonWorld = this.setupCannonWorld();
    if (this.cannonWorld) {
      this.setupCannonDebug();
    }
    this.entityWorld = await this.setupWorld();
    if (this.gameStatus.isDebug) {
      this.setupStats();
    }
    this.setupEventListeners();
    this.resize();
    this.stage = this.setupStage();
  }
  pause(paused) {
    this.GAME.isPaused = paused;
  }
  resize(w, h) {
    console.log(sizes.width, sizes.height);
    sizes.width = window.innerWidth || w;
    sizes.height = window.innerHeight || h;
    const camera = this.camera;
    const orthographicCamera = this.orthographicCamera;
    const cameraProperty = {
      left: -sizes.width / 2,
      right: sizes.width / 2,
      top: sizes.height / 2,
      bottom: -sizes.height / 2
    };
    if (camera) {
      camera.updateProjectionMatrix();
      camera.aspect = sizes.width / sizes.height;
    }
    if (orthographicCamera) {
      orthographicCamera.left = cameraProperty.left;
      orthographicCamera.right = cameraProperty.right;
      orthographicCamera.top = cameraProperty.top;
      orthographicCamera.bottom = cameraProperty.bottom;
      orthographicCamera.updateProjectionMatrix();
    }
    if (this.renderer) {
      this.renderer.setSize(sizes.width, sizes.height);
      this.renderer.setPixelRatio(2);
    }
    if (this.composer) {
      this.composer.setSize(sizes.width, sizes.height);
      this.composer.setPixelRatio(2);
    }
  }
  restart() {
    this.gameStatus = {
      alreadyPlayed: false,
      isPlaying: false,
      isPaused: false,
      isDown: false,
      isWin: false,
      isLose: false,
      isDebug: DEBUG
    };
    this.stage.reset();
  }
  setupCannonDebug() {
    const sceneGroup = new three__WEBPACK_IMPORTED_MODULE_8__.Group();
    sceneGroup.name = "debug";
    this.scene.add(sceneGroup);

    // @ts-ignore
    this.cannonDebugRenderer = new cannon_es_debugger__WEBPACK_IMPORTED_MODULE_9__["default"](sceneGroup, this.cannonWorld);
  }

  // HANDLERS
  tickHandler() {
    this.GAME.isDebug ? this.tickDebug() : this.tick();
  }
  setupStats() {
    this.stats = (0,three_examples_jsm_libs_stats_module__WEBPACK_IMPORTED_MODULE_10__["default"])();
    document.body.appendChild(this.stats.dom);
  }
  setupStage() {
    return new _game__WEBPACK_IMPORTED_MODULE_1__.Game();
  }
  async setupWorld() {
    this.entityWorld = await _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_6__.World.create({
      defs: _systems_define_all_systems__WEBPACK_IMPORTED_MODULE_7__.defineAllSystems
    });
    return this.entityWorld;
  }
  setupRenderer() {
    const renderer = new three__WEBPACK_IMPORTED_MODULE_8__.WebGLRenderer({
      canvas: (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCanvas)(),
      antialias: true
    });
    renderer.outputEncoding = three__WEBPACK_IMPORTED_MODULE_8__.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_8__.PCFSoftShadowMap;
    renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_8__.ReinhardToneMapping;
    renderer.toneMappingExposure = 2.3;
    // renderer.shadowMap.autoUpdate = true;

    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    return renderer;
  }
  setupRenderTarget() {
    const renderTarget = new three__WEBPACK_IMPORTED_MODULE_8__.WebGLRenderTarget(window.innerWidth * 2, window.innerHeight * 2);
    renderTarget.texture.minFilter = three__WEBPACK_IMPORTED_MODULE_8__.NearestFilter;
    renderTarget.texture.magFilter = three__WEBPACK_IMPORTED_MODULE_8__.NearestFilter;
    renderTarget.texture.generateMipmaps = false;
    renderTarget.stencilBuffer = false;
    if (!this.renderer.capabilities.isWebGL2 && !this.renderer.extensions.has("WEBGL_depth_texture")) {
      renderTarget.depthTexture = new three__WEBPACK_IMPORTED_MODULE_8__.DepthTexture(1, 1);
      renderTarget.depthTexture.type = three__WEBPACK_IMPORTED_MODULE_8__.UnsignedShortType;
      renderTarget.depthTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_8__.NearestFilter;
      renderTarget.depthTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_8__.NearestFilter;
    }
    renderTarget.depthTexture = new three__WEBPACK_IMPORTED_MODULE_8__.DepthTexture(0, 0);
    renderTarget.depthTexture.type = three__WEBPACK_IMPORTED_MODULE_8__.UnsignedShortType;
    renderTarget.depthTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_8__.NearestFilter;
    renderTarget.depthTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_8__.NearestFilter;
    return renderTarget;
  }
  setupPostprocessing() {
    const params = {
      exposure: 1,
      bloomStrength: 2,
      bloomThreshold: 1,
      bloomRadius: 1
    };
    const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_11__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_8__.Vector2(window.innerWidth, window.innerHeight), 10, 0.4, 0.85);
    bloomPass.threshold = params.bloomThreshold;
    bloomPass.strength = params.bloomStrength;
    bloomPass.radius = params.bloomRadius;
    const renderScene = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_12__.RenderPass(this.scene, this.camera);
    const composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_13__.EffectComposer(this.RENDERER);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    //SMAA
    // const pass = new SMAAPass(window.innerWidth * this.RENDERER.getPixelRatio(), window.innerHeight * this.RENDERER.getPixelRatio());
    // composer.addPass(pass);
    //fxaa
    // const fxaaPass = new ShaderPass(FXAAShader);
    // fxaaPass.material.uniforms["resolution"].value.x =
    //   1 / (window.innerWidth * 2);
    // fxaaPass.material.uniforms["resolution"].value.y =
    //   1 / (window.innerHeight * 2);
    // composer.addPass(fxaaPass);

    return composer;
  }
  setupCamera() {
    this.camera = new three__WEBPACK_IMPORTED_MODULE_8__.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
    this.camera.name = "Camera";
    _services_resize_service__WEBPACK_IMPORTED_MODULE_2__.responsiveHandlersRegistry.register({
      onLandscapeLayout: () => {
        // this.camera.zoom = 25
        this.camera.updateProjectionMatrix();
      },
      onPortraitLayout: () => {
        //  this.camera.zoom = 35
        this.camera.updateProjectionMatrix();
      }
    });
    return this.camera;
  }
  setupOrthographicCamera() {
    this.orthographicCamera = new three__WEBPACK_IMPORTED_MODULE_8__.OrthographicCamera(-sizes.width / 2, sizes.width / 2, sizes.height / 2, -sizes.height / 2, 1, 10);
    this.camera.position.z = 10;
    return this.orthographicCamera;
  }
  setupCannonWorld() {
    const world = new cannon_es__WEBPACK_IMPORTED_MODULE_14__.World({
      gravity: new cannon_es__WEBPACK_IMPORTED_MODULE_14__.Vec3(0, -9.82, 0)
    });
    const groundBody = new cannon_es__WEBPACK_IMPORTED_MODULE_14__.Body({
      type: cannon_es__WEBPACK_IMPORTED_MODULE_14__.Body.STATIC,
      // can also be achieved by  setting the mass to 0
      shape: new cannon_es__WEBPACK_IMPORTED_MODULE_14__.Plane()
    });
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // make it face up
    world.addBody(groundBody);
    const solver = new cannon_es__WEBPACK_IMPORTED_MODULE_14__.GSSolver();
    solver.iterations = 10;
    world.solver = new cannon_es__WEBPACK_IMPORTED_MODULE_14__.SplitSolver(solver);
    world.broadphase = new cannon_es__WEBPACK_IMPORTED_MODULE_14__.SAPBroadphase(world);
    return world;
  }
  setupEventListeners() {
    //gsap.ticker.add(() => this._tickHandler());

    window.addEventListener("touchstart", e => this.touchStartHandler(e), false);
    window.addEventListener("touchmove", e => this.touchMoveHandler(e), false);
    window.addEventListener("touchend", e => this.touchEndHandler(), false);
    window.addEventListener("mousedown", e => this.touchStartHandler(e), false);
    window.addEventListener("mousemove", e => this.touchMoveHandler(e), false);
    window.addEventListener("mouseup", e => this.touchEndHandler(), false);
    window.addEventListener("resize", () => this.resize());
  }
  tickDebug() {
    if (this.cannonDebugRenderer) {
      this.cannonDebugRenderer.update();
    }
    if (this.stats) {
      this.stats.update();
    }
    this.tick();
  }
  tick() {
    if (this.GAME.isPlaying) {
      if (this.GAME.isLose) {
        console.log("lose!");
        this.GAME.isPlaying = false;
        if (_playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_4__.ICECREAM) window._gameplayEvents.lose();
      }
      if (this.GAME.isWin) {
        console.log("win!");
        this.GAME.isPlaying = false;
        if (_playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_4__.ICECREAM) window._gameplayEvents.endGame("win");
      }

      // timeToStore.checkToEnd()
    }
  }

  touchStartHandler(e) {
    if (!_playable_helper_ice_cream_ice_cream__WEBPACK_IMPORTED_MODULE_4__.ICECREAM && !this.gameStatus.alreadyPlayed) {
      this.start();
    }
    this.gameStatus.alreadyPlayed = true;
    this.touchValues.isPlayerTouch = true;
    this.touchValues.mousePosition.x = e.touches ? e.touches[0].pageX : e.clientX;
    this.touchValues.mousePosition.y = e.touches ? e.touches[0].pageY : e.clientY;
    this.touchValues.oldPos.x = e.touches ? e.touches[0].pageX : e.pageX;
    this.touchValues.oldPos.y = e.touches ? e.touches[0].pageY : e.pageY;
    this.dispatchEvent({
      type: "touchStart",
      data: this.touchValues
    });
  }

  // DEBUG

  touchMoveHandler(e) {
    if (!this.touchValues.isPlayerTouch) return;
    this.touchValues.mousePosition.x = e.touches ? e.touches[0].pageX : e.pageX;
    this.touchValues.mousePosition.y = e.touches ? e.touches[0].pageY : e.pageY;
    if (this.touchValues.mousePosition.x < this.touchValues.oldPos.x && this.touchValues.isPlayerTouch) {
      this.touchValues.movePlayerVelocity = this.touchValues.mousePosition.x - this.touchValues.oldPos.x;
    } else if (this.touchValues.mousePosition.x > this.touchValues.oldPos.x && this.touchValues.isPlayerTouch) {
      this.touchValues.movePlayerVelocity = this.touchValues.mousePosition.x - this.touchValues.oldPos.x;
    }
    this.touchValues.oldPos.x = this.touchValues.mousePosition.x;
    this.touchValues.oldPos.y = this.touchValues.mousePosition.y;
    this.dispatchEvent({
      type: "touchMove",
      data: this.touchValues
    });
  }
  touchEndHandler() {
    this.touchValues.isPlayerTouch = false;
    this.touchValues.oldPos.x = 0;
    this.touchValues.oldPos.y = 0;
    this.touchValues.mousePosition.x = 0;
    this.touchValues.mousePosition.y = 0;
    this.touchValues.movePlayerVelocity = 0;
    this.dispatchEvent({
      type: "touchEnd",
      data: this.touchValues
    });
  }
  setupOrbitControls() {
    this.controls = new three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_15__.OrbitControls(this.camera, this.renderer.domElement);
    const control = this.controls;
    // control.rotateSpeed = 0;
    // control.maxPolarAngle = 0.9//Math.PI / 4;
    // control.minPolarAngle = 0.9 //Math.PI / 4;
    // control.autoRotate = false;
    // control.autoRotateSpeed = 0;
    // control.rotateSpeed = 0.4;
    // control.enableDamping = false;
    // control.dampingFactor = 0.1;
    // control.enableZoom = false;
    // control.enablePan = false;
    // control.minAzimuthAngle = 2.6 //Math.PI/4; // radians
    // control.maxAzimuthAngle = 2.6 //Math.PI/4  // radians
    control.update();
    _services_resize_service__WEBPACK_IMPORTED_MODULE_2__.responsiveHandlersRegistry.register({
      onLandscapeLayout: () => {
        this.controls.update();
      },
      onPortraitLayout: () => {
        this.controls.update();
      }
    });
  }
}
const GameManager = new GameManagers();

/***/ }),

/***/ "./src/game/pop-up/pop-up.ts":
/*!***********************************!*\
  !*** ./src/game/pop-up/pop-up.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PoPEnum": () => (/* binding */ PoPEnum),
/* harmony export */   "PopUp": () => (/* binding */ PopUp)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asset-list/raw-assets/texture-raw-assets */ "./src/game/asset-list/raw-assets/texture-raw-assets.ts");
/* harmony import */ var _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../managers/assets-manager/raw-assets-manager */ "./src/game/managers/assets-manager/raw-assets-manager.ts");
/* harmony import */ var _text_pop_up__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./text-pop-up */ "./src/game/pop-up/text-pop-up.ts");
/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! animejs */ "./node_modules/animejs/lib/anime.es.js");





let PoPEnum;
(function (PoPEnum) {
  PoPEnum[PoPEnum["GOLD"] = 0] = "GOLD";
  PoPEnum[PoPEnum["SAND"] = 1] = "SAND";
  PoPEnum[PoPEnum["ORE"] = 2] = "ORE";
  PoPEnum[PoPEnum["Crystal"] = 3] = "Crystal";
})(PoPEnum || (PoPEnum = {}));
class PopUp extends three__WEBPACK_IMPORTED_MODULE_4__.Group {
  constructor(loot = 0) {
    super();
    this.whiteBG = void 0;
    this.purpleBG = void 0;
    this.bitCoin = void 0;
    this.lootSprite = void 0;
    this.topText = void 0;
    this.bottomText = void 0;
    this.currentPopEnum = void 0;
    this.color = void 0;
    this.currentPopEnum = loot;
  }
  init() {
    //set sprite material
    // const white = AssetsUtils.fastFixAndGetTexture(RawTexture.DR_POPUP_WHITE);
    const white = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_1__.RawManager.getTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__.RawTexture.DR_POPUP_WHITE);
    //white.magFilter = filterMode;
    const whiteSprite = new three__WEBPACK_IMPORTED_MODULE_4__.SpriteMaterial({
      map: white,
      depthWrite: false,
      transparent: true
    });

    // const purple = AssetsUtils.fastFixAndGetTexture(RawTexture.DR_POPUP_PURPLE);
    const purple = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_1__.RawManager.getTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__.RawTexture.DR_POPUP_PURPLE);
    purple.encoding = three__WEBPACK_IMPORTED_MODULE_4__.sRGBEncoding;
    const purpleSprite = new three__WEBPACK_IMPORTED_MODULE_4__.SpriteMaterial({
      map: purple,
      depthWrite: false,
      transparent: true
    });
    purple.flipY = true;
    const bitCoin = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_1__.RawManager.getTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__.RawTexture.DR_POPUP_BITCOIN);
    bitCoin.encoding = three__WEBPACK_IMPORTED_MODULE_4__.sRGBEncoding;
    const bitCoinSprite = new three__WEBPACK_IMPORTED_MODULE_4__.SpriteMaterial({
      map: bitCoin,
      depthWrite: false,
      rotation: Math.PI / 12
    });
    if (this.currentPopEnum == 1) {
      const sand = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_1__.RawManager.getTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__.RawTexture.DR_POPUP_SAND);
      this.color = new three__WEBPACK_IMPORTED_MODULE_4__.Color().setHex(0x8c8256);
      sand.encoding = three__WEBPACK_IMPORTED_MODULE_4__.sRGBEncoding;
      const sandSprite = new three__WEBPACK_IMPORTED_MODULE_4__.SpriteMaterial({
        map: sand,
        depthWrite: false
      });
      this.lootSprite = new three__WEBPACK_IMPORTED_MODULE_4__.Sprite(sandSprite);
      this.topText = _text_pop_up__WEBPACK_IMPORTED_MODULE_2__["default"].createText("Sand", 0.0025);
      this.lootSprite.center.set(0.5, 0.4);
      this.bottomText = _text_pop_up__WEBPACK_IMPORTED_MODULE_2__["default"].createText("0.0023", 0.0022, 0xffffff);
    }
    if (this.currentPopEnum == 0) {
      const sand = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_1__.RawManager.getTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__.RawTexture.DR_POPUP_GOLD);
      sand.encoding = three__WEBPACK_IMPORTED_MODULE_4__.sRGBEncoding;
      const sandSprite = new three__WEBPACK_IMPORTED_MODULE_4__.SpriteMaterial({
        map: sand,
        depthWrite: false
      });
      this.lootSprite = new three__WEBPACK_IMPORTED_MODULE_4__.Sprite(sandSprite);
      this.lootSprite.scale.set(0.85, 0.85, 0);
      this.topText = _text_pop_up__WEBPACK_IMPORTED_MODULE_2__["default"].createText("Gold", 0.0025);
      this.lootSprite.center.set(0.5, 0.3);
      this.bottomText = _text_pop_up__WEBPACK_IMPORTED_MODULE_2__["default"].createText("0.0054", 0.0022, 0xffffff);
      this.color = new three__WEBPACK_IMPORTED_MODULE_4__.Color().setHex(0xffd700);
    }
    if (this.currentPopEnum == 3) {
      const crystal = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_1__.RawManager.getTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__.RawTexture.DR_POPUP_CRYSTAL);
      crystal.encoding = three__WEBPACK_IMPORTED_MODULE_4__.sRGBEncoding;
      const crystalSprite = new three__WEBPACK_IMPORTED_MODULE_4__.SpriteMaterial({
        map: crystal,
        depthWrite: false
      });
      this.lootSprite = new three__WEBPACK_IMPORTED_MODULE_4__.Sprite(crystalSprite);
      this.lootSprite.scale.set(0.5, 0.5, 0);
      this.topText = _text_pop_up__WEBPACK_IMPORTED_MODULE_2__["default"].createText("Crystal", 0.0025);
      this.lootSprite.center.set(0.5, 0.3);
      this.bottomText = _text_pop_up__WEBPACK_IMPORTED_MODULE_2__["default"].createText("1.0048", 0.0022, 0xffffff);
      this.color = new three__WEBPACK_IMPORTED_MODULE_4__.Color().setHex(0x603fef);
    }
    if (this.currentPopEnum == 2) {
      const crystal = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_1__.RawManager.getTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__.RawTexture.DR_POPUP_ORE);
      crystal.encoding = three__WEBPACK_IMPORTED_MODULE_4__.sRGBEncoding;
      const crystalSprite = new three__WEBPACK_IMPORTED_MODULE_4__.SpriteMaterial({
        map: crystal,
        depthWrite: false
      });
      this.lootSprite = new three__WEBPACK_IMPORTED_MODULE_4__.Sprite(crystalSprite);
      this.lootSprite.scale.set(0.5, 0.5, 0);
      this.topText = _text_pop_up__WEBPACK_IMPORTED_MODULE_2__["default"].createText("Ore", 0.0025);
      this.lootSprite.center.set(0.5, 0.3);
      this.bottomText = _text_pop_up__WEBPACK_IMPORTED_MODULE_2__["default"].createText("0.0036", 0.0022, 0xffffff);
      this.color = new three__WEBPACK_IMPORTED_MODULE_4__.Color().setHex(0x808080);
    }
    // else {
    //   const sand = RawManager.getTexture(RawTexture.DR_POPUP_SAND);
    //   this.color = new Color().setHex(0x8c8256);
    //   sand.encoding = sRGBEncoding;
    //   const sandSprite = new SpriteMaterial({
    //     map: sand,
    //     depthWrite: false,
    //   });
    //   this.lootSprite = new Sprite(sandSprite);
    //
    //   this.topText = TextPopUp.createText("Sand", 0.0025);
    //   this.lootSprite.center.set(0.5, 0.4);
    //   this.bottomText = TextPopUp.createText("0.0023", 0.0022, 0xffffff);
    // }

    if (this.lootSprite) {
      this.lootSprite.position.z = -0.01;
    }

    //add to sprites
    this.whiteBG = new three__WEBPACK_IMPORTED_MODULE_4__.Sprite(whiteSprite);
    this.purpleBG = new three__WEBPACK_IMPORTED_MODULE_4__.Sprite(purpleSprite);
    this.bitCoin = new three__WEBPACK_IMPORTED_MODULE_4__.Sprite(bitCoinSprite);

    //create text

    this.scale.set(0, 0, 0);
    this.setTexturePosition();
  }
  popIt() {
    const randDelay = Math.random() * 300;
    const currentAnimation = animejs__WEBPACK_IMPORTED_MODULE_3__["default"].timeline({
      easing: "easeInCubic",
      duration: 3200,
      delay: randDelay
    });
    (0,animejs__WEBPACK_IMPORTED_MODULE_3__["default"])({
      targets: [this.position],
      y: this.position.y + 5,
      easing: "easeInCubic",
      duration: 1250,
      delay: randDelay
    });
    currentAnimation.add({
      targets: [this.scale],
      x: 2,
      y: 2,
      z: 1,
      duration: 750
    }).add({
      targets: [this.scale],
      duration: 1250
    }).add({
      targets: [this.scale],
      x: 0,
      y: 0,
      z: 0,
      duration: 500
    });
  }
  finalPop() {
    const randDelay = Math.random() * 300;
    const currentAnimation = animejs__WEBPACK_IMPORTED_MODULE_3__["default"].timeline({
      easing: "easeInCubic",
      duration: 3200,
      delay: randDelay
    });
    (0,animejs__WEBPACK_IMPORTED_MODULE_3__["default"])({
      targets: [this.position],
      y: this.position.y + 5,
      easing: "easeInCubic",
      duration: 1250,
      delay: randDelay
    });
    currentAnimation.add({
      targets: [this.scale],
      x: 3,
      y: 3,
      z: 1.5,
      duration: 750
    });
  }
  destroy() {}
  getColor() {
    return this.color;
  }
  setTexturePosition() {
    if (!this.whiteBG && !this.purpleBG) return;
    this.whiteBG.scale.set(1, 1, 0);
    this.whiteBG.position.z = 0.01;
    this.purpleBG.scale.set(1, 0.3, 0);
    this.purpleBG.position.z = -0.01;
    this.purpleBG.center.set(0.5, 2.2);
    const radius = 0.197;
    this.bitCoin.scale.set(radius, radius, 0);
    this.bitCoin.center.set(3, 2.3);
    this.bitCoin.position.z = -0.012;
    this.topText.position.y = -0.3;
    this.topText.position.z = -0.45;
    this.topText.rotation.x = 0.9;
    this.topText.scale.z = 0;
    this.bottomText.position.y = -0.48;
    this.bottomText.position.z = -0.67;
    this.bottomText.position.x = -0.05;
    this.bottomText.rotation.x = 0.9;
    this.bottomText.scale.z = 0.2;
    this.add(...[this.whiteBG, this.purpleBG, this.bitCoin, this.lootSprite, this.topText, this.bottomText]);
  }
}
PopUp.id = 0;

/***/ }),

/***/ "./src/game/pop-up/text-pop-up.ts":
/*!****************************************!*\
  !*** ./src/game/pop-up/text-pop-up.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextPopUp)
/* harmony export */ });
/* harmony import */ var three_examples_jsm_geometries_TextGeometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/geometries/TextGeometry */ "./node_modules/three/examples/jsm/geometries/TextGeometry.js");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _prefabs_font_prefabs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../prefabs/font-prefabs */ "./src/game/prefabs/font-prefabs.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _asset_list_raw_assets_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asset-list/raw-assets-list */ "./src/game/asset-list/raw-assets-list.ts");





class TextPopUp {
  static createText(text, scale, color = 0x000000) {
    const font = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getFont(_prefabs_font_prefabs__WEBPACK_IMPORTED_MODULE_1__.FontPrefabs.ANTON);
    const height = 20 * scale,
      size = 70 * scale,
      hover = 20 * scale,
      curveSegments = 20,
      //4,
      bevelThickness = 0.00001,
      // 1 * scale,
      bevelSize = -0.001; //0.5 * scale;

    const textGeo = new three_examples_jsm_geometries_TextGeometry__WEBPACK_IMPORTED_MODULE_3__.TextGeometry(text, {
      font: font,
      size: size,
      height: height,
      curveSegments: curveSegments
      //
      // bevelThickness: bevelThickness,
      // bevelSize: bevelSize,
      // bevelEnabled: true,
    });

    textGeo.computeBoundingBox();
    textGeo.computeVertexNormals();
    const centerOffset = 0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
    const material = new three__WEBPACK_IMPORTED_MODULE_4__.MeshPhongMaterial({
      color: new three__WEBPACK_IMPORTED_MODULE_4__.Color().setHex(color).convertLinearToSRGB()
      // depthWrite: false,
    });

    const textMesh = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(textGeo, material);
    textMesh.position.x = centerOffset;
    textMesh.position.y = hover;
    textMesh.position.z = 0;
    textMesh.rotation.x = 0;
    textMesh.rotation.y = -Math.PI;
    const group = new three__WEBPACK_IMPORTED_MODULE_4__.Group();
    group.add(textMesh);
    return group;
  }
  static makeTextSprite(message, parameters) {
    if (parameters === undefined) parameters = {};
    // eslint-disable-next-line no-prototype-builtins
    const fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : _asset_list_raw_assets_list__WEBPACK_IMPORTED_MODULE_2__.DevFontName.ANTON_WOFF2;
    // eslint-disable-next-line no-prototype-builtins
    const fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
    // eslint-disable-next-line no-prototype-builtins
    const borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
    // eslint-disable-next-line no-prototype-builtins
    const borderColor = parameters.hasOwnProperty("borderColor") ? parameters["borderColor"] : {
      r: 0,
      g: 0,
      b: 0,
      a: 1.0
    };
    // eslint-disable-next-line no-prototype-builtins
    const backgroundColor = parameters.hasOwnProperty("backgroundColor") ? parameters["backgroundColor"] : {
      r: 0,
      g: 0,
      b: 255,
      a: 1.0
    };
    // eslint-disable-next-line no-prototype-builtins
    const textColor = parameters.hasOwnProperty("textColor") ? parameters["textColor"] : {
      r: 0,
      g: 0,
      b: 0,
      a: 1.0
    };
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    context.font = `${fontsize}px ${fontface}`;
    const metrics = context.measureText(message);
    const textWidth = metrics.width;
    context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
    context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
    context.fillStyle = `rgba(${textColor.r}, ${textColor.g}, ${textColor.b}, 1.0)`;
    context.fillText(message, borderThickness, fontsize + borderThickness);
    const texture = new three__WEBPACK_IMPORTED_MODULE_4__.Texture(canvas);
    texture.needsUpdate = true;
    texture.encoding = three__WEBPACK_IMPORTED_MODULE_4__.sRGBEncoding;
    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_4__.LinearFilter;
    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_4__.LinearFilter;
    const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.SpriteMaterial({
      map: texture
    });
    const sprite = new three__WEBPACK_IMPORTED_MODULE_4__.Sprite(spriteMaterial);
    sprite.scale.set(0.7 * fontsize, 0.25 * fontsize, 0.75 * fontsize);
    return sprite;
  }
}

/***/ }),

/***/ "./src/game/prefabs/font-prefabs.ts":
/*!******************************************!*\
  !*** ./src/game/prefabs/font-prefabs.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FontPrefabs": () => (/* binding */ FontPrefabs),
/* harmony export */   "initPresetsFont": () => (/* binding */ initPresetsFont)
/* harmony export */ });
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/loaders/FontLoader */ "./node_modules/three/examples/jsm/loaders/FontLoader.js");
/* harmony import */ var _asset_list_raw_assets_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asset-list/raw-assets-list */ "./src/game/asset-list/raw-assets-list.ts");



let FontPrefabs;
(function (FontPrefabs) {
  FontPrefabs[FontPrefabs["ANTON"] = 0] = "ANTON";
})(FontPrefabs || (FontPrefabs = {}));
const initPresetsFont = () => {
  const antonFont = new three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_2__.Font(_asset_list_raw_assets_list__WEBPACK_IMPORTED_MODULE_1__.DevFontName.ANTONTTF);
  _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].registerFont(FontPrefabs.ANTON, antonFont);
};

/***/ }),

/***/ "./src/game/prefabs/material-group-prefabs/add-diamond-rush-material.ts":
/*!******************************************************************************!*\
  !*** ./src/game/prefabs/material-group-prefabs/add-diamond-rush-material.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addDiamondRushMaterial": () => (/* binding */ addDiamondRushMaterial)
/* harmony export */ });
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");
/* harmony import */ var _asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset-list/raw-assets/texture-raw-assets */ "./src/game/asset-list/raw-assets/texture-raw-assets.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _material_prefabs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../material-prefabs */ "./src/game/prefabs/material-prefabs.ts");
/* harmony import */ var _game_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../game-config */ "./src/game/game-config.ts");






const addDiamondRushMaterial = () => {
  const normal_map_character_texture = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_0__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__.RawTexture.DR_CHARACTER_NORMAL);
  const emmisive_character_texture = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_0__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__.RawTexture.DR_CHARACTER_EMMISIVE);
  const roughness_character_texture = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_0__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__.RawTexture.DR_CHARACTER_ROUGHNES);
  const characterMaterial = new three__WEBPACK_IMPORTED_MODULE_5__.MeshStandardMaterial({
    color: new three__WEBPACK_IMPORTED_MODULE_5__.Color(_game_config__WEBPACK_IMPORTED_MODULE_4__.GameConfig.characterMainColor).convertLinearToSRGB(),
    //map: emmisive_character_texture,
    emissiveMap: emmisive_character_texture,
    toneMapped: false,
    emissiveIntensity: 1,
    roughnessMap: roughness_character_texture,
    roughness: 0.005,
    //   normalMap: normal_map_character_texture,
    //   normalMapType: 0,
    metalness: 0.5,
    emissive: new three__WEBPACK_IMPORTED_MODULE_5__.Color(_game_config__WEBPACK_IMPORTED_MODULE_4__.GameConfig.characterNeonColor).convertLinearToSRGB()
  });
  _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__["default"].registerMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_3__.MaterialPrefabs.DR_CHARACTER_MATERIAL, characterMaterial);

  //terrain
  const terrainTexture = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_0__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__.RawTexture.DR_TERRAIN_GRASS, 6);
  const terrainMaterial = new three__WEBPACK_IMPORTED_MODULE_5__.MeshStandardMaterial({
    map: terrainTexture,
    side: three__WEBPACK_IMPORTED_MODULE_5__.DoubleSide
  });
  _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__["default"].registerMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_3__.MaterialPrefabs.DR_TERRAIN_GRASS, terrainMaterial);

  //ground
  const groundBlockTexture = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_0__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__.RawTexture.DR_BLOCK_TEXTURE, 4);
  const groundBlockMaterial = new three__WEBPACK_IMPORTED_MODULE_5__.MeshStandardMaterial({
    map: groundBlockTexture
  });
  _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__["default"].registerMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_3__.MaterialPrefabs.DR_GROUND_MATERIAL, groundBlockMaterial);

  //blocks
  const blockMaterial = new three__WEBPACK_IMPORTED_MODULE_5__.MeshStandardMaterial({
    color: new three__WEBPACK_IMPORTED_MODULE_5__.Color().setHex(_game_config__WEBPACK_IMPORTED_MODULE_4__.GameConfig.blockColor),
    //  flatShading: true,
    side: three__WEBPACK_IMPORTED_MODULE_5__.DoubleSide
  });
  _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__["default"].registerMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_3__.MaterialPrefabs.DR_BLOCK_MATERIAL, blockMaterial);
};

/***/ }),

/***/ "./src/game/prefabs/material-group-prefabs/add-dungeon-material.ts":
/*!*************************************************************************!*\
  !*** ./src/game/prefabs/material-group-prefabs/add-dungeon-material.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addDungeonMaterials": () => (/* binding */ addDungeonMaterials)
/* harmony export */ });
const addDungeonMaterials = () => {};

/***/ }),

/***/ "./src/game/prefabs/material-group-prefabs/add-sky-box-material.ts":
/*!*************************************************************************!*\
  !*** ./src/game/prefabs/material-group-prefabs/add-sky-box-material.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSkyBoxMaterial": () => (/* binding */ addSkyBoxMaterial)
/* harmony export */ });
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");
/* harmony import */ var _asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset-list/raw-assets/texture-raw-assets */ "./src/game/asset-list/raw-assets/texture-raw-assets.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _material_prefabs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../material-prefabs */ "./src/game/prefabs/material-prefabs.ts");





const addSkyBoxMaterial = () => {
  const blueTexture = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_0__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__.RawTexture.DR_BLUE_SKYBOX, 1, three__WEBPACK_IMPORTED_MODULE_4__.ClampToEdgeWrapping);
  const blueMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.MeshBasicMaterial({
    map: blueTexture,
    side: three__WEBPACK_IMPORTED_MODULE_4__.BackSide
  });
  _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__["default"].registerMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_3__.MaterialPrefabs.DR_BLUE_SKYBOX_MATERIAL, blueMaterial);
};

/***/ }),

/***/ "./src/game/prefabs/material-prefabs.ts":
/*!**********************************************!*\
  !*** ./src/game/prefabs/material-prefabs.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaterialPrefabs": () => (/* binding */ MaterialPrefabs),
/* harmony export */   "initPresetsMaterial": () => (/* binding */ initPresetsMaterial)
/* harmony export */ });
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _fx_shaders_meteor_meteor_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/shaders/meteor/meteor-material */ "./src/game/fx/shaders/meteor/meteor-material.ts");
/* harmony import */ var _texture_group_prefabs_add_error_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture-group-prefabs/add-error-material */ "./src/game/prefabs/texture-group-prefabs/add-error-material.ts");
/* harmony import */ var _material_group_prefabs_add_dungeon_material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./material-group-prefabs/add-dungeon-material */ "./src/game/prefabs/material-group-prefabs/add-dungeon-material.ts");
/* harmony import */ var _material_group_prefabs_add_diamond_rush_material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./material-group-prefabs/add-diamond-rush-material */ "./src/game/prefabs/material-group-prefabs/add-diamond-rush-material.ts");
/* harmony import */ var _material_group_prefabs_add_sky_box_material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./material-group-prefabs/add-sky-box-material */ "./src/game/prefabs/material-group-prefabs/add-sky-box-material.ts");
/* harmony import */ var _fx_shaders_pinkGlow_pink_glowing__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../fx/shaders/pinkGlow/pink-glowing */ "./src/game/fx/shaders/pinkGlow/pink-glowing.ts");







let MaterialPrefabs;
(function (MaterialPrefabs) {
  MaterialPrefabs[MaterialPrefabs["ERRORMATERIAL"] = 0] = "ERRORMATERIAL";
  MaterialPrefabs[MaterialPrefabs["METEORSHADER"] = 1] = "METEORSHADER";
  MaterialPrefabs[MaterialPrefabs["PINKGLOWSHADER"] = 2] = "PINKGLOWSHADER";
  MaterialPrefabs[MaterialPrefabs["DUNGEONMATERIAL"] = 3] = "DUNGEONMATERIAL";
  MaterialPrefabs[MaterialPrefabs["DR_CHARACTER_MATERIAL"] = 4] = "DR_CHARACTER_MATERIAL";
  MaterialPrefabs[MaterialPrefabs["DR_SKYBOX_MATERIAL"] = 5] = "DR_SKYBOX_MATERIAL";
  MaterialPrefabs[MaterialPrefabs["DR_BLUE_SKYBOX_MATERIAL"] = 6] = "DR_BLUE_SKYBOX_MATERIAL";
  MaterialPrefabs[MaterialPrefabs["DR_TERRAIN_GRASS"] = 7] = "DR_TERRAIN_GRASS";
  MaterialPrefabs[MaterialPrefabs["DR_BLOCK_MATERIAL"] = 8] = "DR_BLOCK_MATERIAL";
  MaterialPrefabs[MaterialPrefabs["DR_GROUND_MATERIAL"] = 9] = "DR_GROUND_MATERIAL";
})(MaterialPrefabs || (MaterialPrefabs = {}));
const initPresetsMaterial = () => {
  (0,_texture_group_prefabs_add_error_material__WEBPACK_IMPORTED_MODULE_2__.addErrorMaterial)();
  (0,_material_group_prefabs_add_dungeon_material__WEBPACK_IMPORTED_MODULE_3__.addDungeonMaterials)();
  (0,_material_group_prefabs_add_diamond_rush_material__WEBPACK_IMPORTED_MODULE_4__.addDiamondRushMaterial)();
  (0,_material_group_prefabs_add_sky_box_material__WEBPACK_IMPORTED_MODULE_5__.addSkyBoxMaterial)();
  //lava shader material

  // const waterTexture = RawManager.getTexture(RawTexture.WATER);
  // const waterShader = PrefabsManager.registerMaterial(
  //   MaterialPrefabs.WATERSHADER,
  //   createLavaMaterial(waterTexture)
  // );

  const meteorShader = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].registerMaterial(MaterialPrefabs.METEORSHADER, (0,_fx_shaders_meteor_meteor_material__WEBPACK_IMPORTED_MODULE_1__.meteorMaterial)());
  const pinkGlowShader = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].registerMaterial(MaterialPrefabs.PINKGLOWSHADER, (0,_fx_shaders_pinkGlow_pink_glowing__WEBPACK_IMPORTED_MODULE_6__.pinkGlowing)());
};

/***/ }),

/***/ "./src/game/prefabs/object3d-group-prefabs/add-base-objects3d.ts":
/*!***********************************************************************!*\
  !*** ./src/game/prefabs/object3d-group-prefabs/add-base-objects3d.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addBaseObjects3d": () => (/* binding */ addBaseObjects3d)
/* harmony export */ });
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset-list/raw-assets/object3d-raw-asstes */ "./src/game/asset-list/raw-assets/object3d-raw-asstes.ts");
/* harmony import */ var _material_prefabs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../material-prefabs */ "./src/game/prefabs/material-prefabs.ts");
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");
/* harmony import */ var _object3d_prefabs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../object3d-prefabs */ "./src/game/prefabs/object3d-prefabs.ts");





const addBaseObjects3d = () => {
  const cube = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].registerObject3D(_object3d_prefabs__WEBPACK_IMPORTED_MODULE_4__.ModelPrefabs.ERRORMODEL, _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__.RawObject3D.ERRORMODEL);
  const errorMaterial = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_2__.MaterialPrefabs.ERRORMATERIAL);
  _utils_assets_utils__WEBPACK_IMPORTED_MODULE_3__["default"].addMaterial(cube, errorMaterial);
};

/***/ }),

/***/ "./src/game/prefabs/object3d-group-prefabs/add-characters.ts":
/*!*******************************************************************!*\
  !*** ./src/game/prefabs/object3d-group-prefabs/add-characters.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addCharacters": () => (/* binding */ addCharacters)
/* harmony export */ });
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset-list/raw-assets/object3d-raw-asstes */ "./src/game/asset-list/raw-assets/object3d-raw-asstes.ts");
/* harmony import */ var _utils_animation_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/animation-utils */ "./src/game/utils/animation-utils.ts");
/* harmony import */ var _object3d_prefabs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../object3d-prefabs */ "./src/game/prefabs/object3d-prefabs.ts");
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");
/* harmony import */ var _material_prefabs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../material-prefabs */ "./src/game/prefabs/material-prefabs.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");







const addCharacters = () => {
  //DR character
  const tron = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].registerObject3D(_object3d_prefabs__WEBPACK_IMPORTED_MODULE_3__.ModelPrefabs.DR_TRON, _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__.RawObject3D.DR_CHARACTER);
  const tron_material = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_5__.MaterialPrefabs.DR_CHARACTER_MATERIAL);
  const tron_animation = _utils_animation_utils__WEBPACK_IMPORTED_MODULE_2__["default"].registerAnimations({
    idle: _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__.RawObject3D.ANIMATION_DR_IDLE,
    jump: _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__.RawObject3D.ANIMATION_DR_JUMP,
    attack: _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__.RawObject3D.ANIMATION_DR_ATTACK,
    walk: _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__.RawObject3D.ANIMATION_DR_WALK,
    run: _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__.RawObject3D.ANIMATION_DR_RUN
  }, tron);
  _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__["default"].addMaterial(tron, tron_material);
  const weaponMaterial = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_5__.MaterialPrefabs.PINKGLOWSHADER);
  const weapon = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].registerObject3D(_object3d_prefabs__WEBPACK_IMPORTED_MODULE_3__.ModelPrefabs.DR_WEAPON, _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_1__.RawObject3D.DR_WEAPON_PICKAXE);
  weapon.name = "weapon";
  _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__["default"].addMaterial(weapon, weaponMaterial);
  const rightHand = tron.getObjectByName("mixamorigRightHand");
  rightHand === null || rightHand === void 0 ? void 0 : rightHand.add(weapon);
  const weaponPosition = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(0.12, 0.75, -0.03);
  const weaponRotation = new three__WEBPACK_IMPORTED_MODULE_6__.Euler(-1.04, 2.1, -0.02);
  weapon.position.copy(weaponPosition);
  weapon.rotation.copy(weaponRotation);
};

/***/ }),

/***/ "./src/game/prefabs/object3d-group-prefabs/add-environment-prefabs.ts":
/*!****************************************************************************!*\
  !*** ./src/game/prefabs/object3d-group-prefabs/add-environment-prefabs.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addEnvironmentPrefabs": () => (/* binding */ addEnvironmentPrefabs)
/* harmony export */ });
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _material_prefabs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../material-prefabs */ "./src/game/prefabs/material-prefabs.ts");
/* harmony import */ var _object3d_prefabs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object3d-prefabs */ "./src/game/prefabs/object3d-prefabs.ts");
/* harmony import */ var _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../asset-list/raw-assets/object3d-raw-asstes */ "./src/game/asset-list/raw-assets/object3d-raw-asstes.ts");
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");





const addEnvironmentPrefabs = () => {
  const blocksMaterial = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_1__.MaterialPrefabs.DR_BLOCK_MATERIAL);
  const blocks = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].registerObject3D(_object3d_prefabs__WEBPACK_IMPORTED_MODULE_2__.ModelPrefabs.DR_BLOCKS, _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_3__.RawObject3D.DR_FLOATINGISLAND);
  _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__["default"].addMaterial(blocks, blocksMaterial);
  const groundMaterial = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_1__.MaterialPrefabs.DR_GROUND_MATERIAL);
  const career = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].registerObject3D(_object3d_prefabs__WEBPACK_IMPORTED_MODULE_2__.ModelPrefabs.DR_CAREER, _asset_list_raw_assets_object3d_raw_asstes__WEBPACK_IMPORTED_MODULE_3__.RawObject3D.DR_CAREER);
  _utils_assets_utils__WEBPACK_IMPORTED_MODULE_4__["default"].addMaterial(career, groundMaterial);
};

/***/ }),

/***/ "./src/game/prefabs/object3d-group-prefabs/add-sky-box-prefab.ts":
/*!***********************************************************************!*\
  !*** ./src/game/prefabs/object3d-group-prefabs/add-sky-box-prefab.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSkyBoxPrefab": () => (/* binding */ addSkyBoxPrefab)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var _material_prefabs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../material-prefabs */ "./src/game/prefabs/material-prefabs.ts");
/* harmony import */ var _object3d_prefabs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object3d-prefabs */ "./src/game/prefabs/object3d-prefabs.ts");




const addSkyBoxPrefab = () => {
  const size = 1000;

  //blue skybox
  const sphereGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(size);
  const blueSkyMaterial = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_1__.MaterialPrefabs.DR_BLUE_SKYBOX_MATERIAL);
  const sphere = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sphereGeometry, blueSkyMaterial);
  _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_0__["default"].registerMesh(_object3d_prefabs__WEBPACK_IMPORTED_MODULE_2__.ModelPrefabs.DR_SKY_SPHERE, sphere);
};

/***/ }),

/***/ "./src/game/prefabs/object3d-prefabs.ts":
/*!**********************************************!*\
  !*** ./src/game/prefabs/object3d-prefabs.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ModelPrefabs": () => (/* binding */ ModelPrefabs),
/* harmony export */   "initPresetsObject3D": () => (/* binding */ initPresetsObject3D)
/* harmony export */ });
/* harmony import */ var _object3d_group_prefabs_add_characters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object3d-group-prefabs/add-characters */ "./src/game/prefabs/object3d-group-prefabs/add-characters.ts");
/* harmony import */ var _object3d_group_prefabs_add_base_objects3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./object3d-group-prefabs/add-base-objects3d */ "./src/game/prefabs/object3d-group-prefabs/add-base-objects3d.ts");
/* harmony import */ var _object3d_group_prefabs_add_sky_box_prefab__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object3d-group-prefabs/add-sky-box-prefab */ "./src/game/prefabs/object3d-group-prefabs/add-sky-box-prefab.ts");
/* harmony import */ var _object3d_group_prefabs_add_environment_prefabs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./object3d-group-prefabs/add-environment-prefabs */ "./src/game/prefabs/object3d-group-prefabs/add-environment-prefabs.ts");





/*eslint-disable @typescript-eslint/no-unused-vars */

let ModelPrefabs;
(function (ModelPrefabs) {
  ModelPrefabs[ModelPrefabs["ERRORMODEL"] = 0] = "ERRORMODEL";
  ModelPrefabs[ModelPrefabs["DR_TRON"] = 1] = "DR_TRON";
  ModelPrefabs[ModelPrefabs["DR_SKY_SPHERE"] = 2] = "DR_SKY_SPHERE";
  ModelPrefabs[ModelPrefabs["DR_BLOCKS"] = 3] = "DR_BLOCKS";
  ModelPrefabs[ModelPrefabs["DR_WEAPON"] = 4] = "DR_WEAPON";
  ModelPrefabs[ModelPrefabs["DR_CAREER"] = 5] = "DR_CAREER";
})(ModelPrefabs || (ModelPrefabs = {}));
const initPresetsObject3D = () => {
  (0,_object3d_group_prefabs_add_sky_box_prefab__WEBPACK_IMPORTED_MODULE_2__.addSkyBoxPrefab)();
  (0,_object3d_group_prefabs_add_base_objects3d__WEBPACK_IMPORTED_MODULE_1__.addBaseObjects3d)();
  (0,_object3d_group_prefabs_add_characters__WEBPACK_IMPORTED_MODULE_0__.addCharacters)();
  (0,_object3d_group_prefabs_add_environment_prefabs__WEBPACK_IMPORTED_MODULE_3__.addEnvironmentPrefabs)();
};

/***/ }),

/***/ "./src/game/prefabs/sprite-prefabs.ts":
/*!********************************************!*\
  !*** ./src/game/prefabs/sprite-prefabs.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpritePrefabs": () => (/* binding */ SpritePrefabs),
/* harmony export */   "initPresetsSprites": () => (/* binding */ initPresetsSprites)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/assets-manager/raw-assets-manager */ "./src/game/managers/assets-manager/raw-assets-manager.ts");
/* harmony import */ var _asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asset-list/raw-assets/texture-raw-assets */ "./src/game/asset-list/raw-assets/texture-raw-assets.ts");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");




/*eslint-disable @typescript-eslint/no-unused-vars */

let SpritePrefabs;
(function (SpritePrefabs) {
  SpritePrefabs[SpritePrefabs["ERRORSPRITE"] = 0] = "ERRORSPRITE";
  SpritePrefabs[SpritePrefabs["HEALTHSPRITE"] = 1] = "HEALTHSPRITE";
})(SpritePrefabs || (SpritePrefabs = {}));
const initPresetsSprites = () => {
  //error sprite
  const errorTexture = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_0__.RawManager.getTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_1__.RawTexture.ERROR);
  const errorMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({
    map: errorTexture
  });
  const errorSprite = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__["default"].registerSprite(SpritePrefabs.ERRORSPRITE, new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(errorMaterial));
  const gradientCanvas = document.createElement("canvas");
  gradientCanvas.width = 1;
  gradientCanvas.height = 256;
  const gradientCtx = gradientCanvas.getContext("2d");
  // create a gradient that goes from green to red
  const gradient = gradientCtx.createLinearGradient(0, 0, 0, 256);
  gradient.addColorStop(0, "green");
  // fill the canvas with the gradient
  gradientCtx.fillStyle = gradient;
  gradientCtx.fillRect(0, 0, 1, 256);
  const gradientTexture = new three__WEBPACK_IMPORTED_MODULE_3__.CanvasTexture(gradientCanvas);

  // create a sprite material for the health bar
  const healthBarMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({
    map: gradientTexture,
    color: 0xffffff,
    transparent: true,
    opacity: 0.7
  });
  const healthBarSprite = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_2__["default"].registerSprite(SpritePrefabs.HEALTHSPRITE, new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(healthBarMaterial));
  healthBarSprite.scale.set(1, 0.1, 1);
};

/***/ }),

/***/ "./src/game/prefabs/texture-group-prefabs/add-error-material.ts":
/*!**********************************************************************!*\
  !*** ./src/game/prefabs/texture-group-prefabs/add-error-material.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addErrorMaterial": () => (/* binding */ addErrorMaterial)
/* harmony export */ });
/* harmony import */ var _asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../asset-list/raw-assets/texture-raw-assets */ "./src/game/asset-list/raw-assets/texture-raw-assets.ts");
/* harmony import */ var _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../managers/assets-manager/prefabs-manager */ "./src/game/managers/assets-manager/prefabs-manager.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _material_prefabs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../material-prefabs */ "./src/game/prefabs/material-prefabs.ts");
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");





const addErrorMaterial = () => {
  const errorTexture = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_3__["default"].fastFixAndGetTexture(_asset_list_raw_assets_texture_raw_assets__WEBPACK_IMPORTED_MODULE_0__.RawTexture.ERROR, 8);
  const errorMaterial = _managers_assets_manager_prefabs_manager__WEBPACK_IMPORTED_MODULE_1__["default"].registerMaterial(_material_prefabs__WEBPACK_IMPORTED_MODULE_2__.MaterialPrefabs.ERRORMATERIAL, new three__WEBPACK_IMPORTED_MODULE_4__.MeshLambertMaterial({
    map: errorTexture,
    transparent: true,
    opacity: 0.5
  }));
};

/***/ }),

/***/ "./src/game/services/resize-service.ts":
/*!*********************************************!*\
  !*** ./src/game/services/resize-service.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "responsiveHandlersRegistry": () => (/* binding */ responsiveHandlersRegistry)
/* harmony export */ });
/* harmony import */ var _responsive_handlers_registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./responsive-handlers-registry */ "./src/game/services/responsive-handlers-registry.ts");

var Screen;
(function (Screen) {
  Screen[Screen["LANDSCAPE"] = 0] = "LANDSCAPE";
  Screen[Screen["PORTRAIT"] = 1] = "PORTRAIT";
})(Screen || (Screen = {}));
class ResponsiveHandlersRegistry {
  constructor() {
    this.handleOrientationChange = (onPortrait, onLandscape, rect) => {
      const {
        windowSize: {
          width,
          height
        }
      } = rect;
      const newScreen = width > height ? Screen.LANDSCAPE : Screen.PORTRAIT;
      if (newScreen === Screen.PORTRAIT) {
        onPortrait(rect);
      } else {
        onLandscape(rect);
      }
    };
  }
  register(handler) {
    _responsive_handlers_registry__WEBPACK_IMPORTED_MODULE_0__.containerSizeService.addResizeCallback(rect => this.handleOrientationChange(handler.onPortraitLayout, handler.onLandscapeLayout, rect));
  }
}
const responsiveHandlersRegistry = new ResponsiveHandlersRegistry();

/***/ }),

/***/ "./src/game/services/responsive-handlers-registry.ts":
/*!***********************************************************!*\
  !*** ./src/game/services/responsive-handlers-registry.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "containerSizeService": () => (/* binding */ containerSizeService)
/* harmony export */ });
const screenRation = () => {
  return window.innerHeight / window.innerWidth;
};
class GameRatio {
  constructor() {
    this.canvas = void 0;
    this.latestGameSize = void 0;
    this.resizeCallbacks = [];
    this.handleResize = rect => {
      this.resizeCallbacks.forEach(cb => cb(rect));
    };
    /*
     * Can be used to manually trigger resize. Useful for networks, that provide a callback with new size
     * */
    this.triggerResize = (width, height) => {
      this.handleResize(windowSize(width, height));
    };
    window.addEventListener("resize", () => this.onSizeChange());
    window.addEventListener("orientationchange", () => this.onSizeChange());
  }
  getCanvasSize() {
    // const canvas = this.validateCanvas(this.canvas);
    // console.log('canvas')
    // console.log(canvas)
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
  addResizeCallback(cb) {
    this.latestGameSize = windowSize(this.getCanvasSize().width, this.getCanvasSize().height);
    cb(windowSize(this.getCanvasSize().width, this.getCanvasSize().height));
    this.resizeCallbacks.push(cb);
  }
  reset() {
    this.resizeCallbacks = [];
  }
  setCanvas(canvas) {
    this.canvas = canvas;
  }
  validateCanvas(canvas) {
    if (!canvas) {
      throw new Error(`GameRatio: canvas is not defined.`);
    }
    return canvas;
  }
  onSizeChange() {
    setTimeout(() => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      if (!width || !height) {
        return;
      }
      if (width === height) {
        return;
      }
      this.latestGameSize = windowSize();
      this.handleResize(this.latestGameSize);
    });
  }
}
const windowSize = (width, height) => {
  const gameSize = {
    windowSize: {
      width: window.innerWidth || width,
      height: window.innerHeight || height
    },
    ratio: screenRation(),
    isLandscape: window.innerWidth > window.innerHeight
  };
  return gameSize;
};
const containerSizeService = new GameRatio();

/***/ }),

/***/ "./src/game/services/update-service.ts":
/*!*********************************************!*\
  !*** ./src/game/services/update-service.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GameUpdateService": () => (/* binding */ GameUpdateService)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

class GameUpdateService {
  constructor() {
    this.objectUpdate = new Set();
    this.clock = new three__WEBPACK_IMPORTED_MODULE_0__.Clock();
    this.delta = 0;
    //fps lock
    this.interval = 1 / 300;
  }
  register(item) {
    this.objectUpdate.add(item);
  }
  unregister(item) {
    //this.objectsToUpdate.splice(item.id!, 1)
    this.objectUpdate.delete(item);
  }
  update() {
    this.delta += this.clock.getDelta();
    if (this.delta > this.interval) {
      this.objectUpdate.forEach(item => {
        ;
        item.update(this.delta, this.clock.elapsedTime);
      });
      this.delta = this.delta % this.interval;
    }
  }
}

/***/ }),

/***/ "./src/game/systems/attack-block-system.ts":
/*!*************************************************!*\
  !*** ./src/game/systems/attack-block-system.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttackBlockSystem": () => (/* binding */ AttackBlockSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/bhv-components/sphere-collider-component */ "./src/game/components/bhv-components/sphere-collider-component.ts");
/* harmony import */ var _bhv_weapon_collider_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bhv/weapon-collider-system */ "./src/game/systems/bhv/weapon-collider-system.ts");
var _dec, _class;




let AttackBlockSystem = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(s => s.after(_bhv_weapon_collider_system__WEBPACK_IMPORTED_MODULE_3__.WeaponColliderSystem)), _dec(_class = class AttackBlockSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.blocks = this.query(q => q.addedOrChanged.with(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent).read.and.with(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform).and.with(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.HpBlock).write.and.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.DestroyBlock).write.and.with(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.damageBlock).trackWrites.write);
  }
  execute() {
    for (const block of this.blocks.addedOrChanged) {
      const hp = block.read(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.HpBlock).value;
      const damage = block.read(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.damageBlock).value;
      const currentHP = hp - damage;
      block.write(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.HpBlock).value = currentHP;
      if (hp == 1) {
        block.add(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.DestroyBlock);
      }
      //#region remove hp after attack

      block.remove(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.damageBlock);
      //#endregion remove hp after attack
    }
  }
}) || _class);

/***/ }),

/***/ "./src/game/systems/basic/camera-system.ts":
/*!*************************************************!*\
  !*** ./src/game/systems/basic/camera-system.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CameraSystem": () => (/* binding */ CameraSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_camera_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/camera-component */ "./src/game/components/camera-component.ts");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/tag-components */ "./src/game/components/tag-components.ts");
/* harmony import */ var _components_camera_shake_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/camera-shake-component */ "./src/game/components/camera-shake-component.ts");
var _class;





let CameraSystem = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(_class = class CameraSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.cameras = this.query(q => q.addedOrChanged.with(_components_camera_component__WEBPACK_IMPORTED_MODULE_2__.CameraComponent).and.with(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform).trackWrites.and.using(_components_camera_shake_component__WEBPACK_IMPORTED_MODULE_4__.CameraShakeComponent).write);
    this.playerTag = this.query(q => q.addedOrChanged.with(_components_tag_components__WEBPACK_IMPORTED_MODULE_3__.PlayerTag).and.with(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform).trackWrites);
  }
  execute() {
    for (const currentCamera of this.cameras.addedOrChanged) {
      const transform = currentCamera.read(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform);
      const {
        camera,
        offSet,
        isFollow
      } = currentCamera.read(_components_camera_component__WEBPACK_IMPORTED_MODULE_2__.CameraComponent);
      if (!isFollow) {
        camera.position.x = transform.position.x;
        camera.position.y = transform.position.y;
        camera.position.z = transform.position.z;
        camera.rotation.x = transform.rotation.x;
        camera.rotation.y = transform.rotation.y;
        camera.rotation.z = transform.rotation.z;
        camera.scale.x = transform.scale.x;
        camera.scale.y = transform.scale.y;
        camera.scale.z = transform.scale.z;
      }

      //only if camera isFollow, camera will follow player tag
      if (!isFollow) return;
      for (const player of this.playerTag.addedOrChanged) {
        const {
          position
        } = player.read(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform);
        if (currentCamera.has(_components_camera_shake_component__WEBPACK_IMPORTED_MODULE_4__.CameraShakeComponent)) {
          const shakeComponent = currentCamera.write(_components_camera_shake_component__WEBPACK_IMPORTED_MODULE_4__.CameraShakeComponent);

          // Apply camera shake effect to camera position
          if (shakeComponent.duration > 0) {
            const shakeIntensity = Math.random() * shakeComponent.intensity - shakeComponent.intensity / 2;
            camera.position.x = position.x + offSet.x + shakeIntensity;
            camera.position.y = position.y + offSet.y + shakeIntensity;
            camera.position.z = position.z + offSet.z + shakeIntensity;
            shakeComponent.duration -= this.delta; // Subtract elapsed time from the duration
          } else {
            currentCamera.remove(_components_camera_shake_component__WEBPACK_IMPORTED_MODULE_4__.CameraShakeComponent); // Remove the camera shake component
          }
        } else {
          camera.position.x = position.x + offSet.x;
          camera.position.y = position.y + offSet.y;
          camera.position.z = position.z + offSet.z;
        }
        camera.lookAt(position);
      }
    }
  }
}) || _class;

/***/ }),

/***/ "./src/game/systems/basic/input-controller-system.ts":
/*!***********************************************************!*\
  !*** ./src/game/systems/basic/input-controller-system.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InputControllerSystem": () => (/* binding */ InputControllerSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_input_controller_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/input-controller-component */ "./src/game/components/input-controller-component.ts");
/* harmony import */ var nipplejs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nipplejs */ "./node_modules/nipplejs/dist/nipplejs.js");
/* harmony import */ var nipplejs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(nipplejs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../index */ "./src/index.ts");
var _class;





let InputControllerSystem = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(_class = class InputControllerSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.inputControllerComponent = this.singleton.write(_components_input_controller_component__WEBPACK_IMPORTED_MODULE_1__.InputControllerComponent);
  }
  initialize() {
    const element = (0,_index__WEBPACK_IMPORTED_MODULE_3__.getCanvas)();
    this.inputControllerComponent.controller = nipplejs__WEBPACK_IMPORTED_MODULE_2___default().create({
      zone: element
    });
    this.inputControllerComponent.direction = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();

    //event on move
    this.inputControllerComponent.controller.on("move", (evt, data) => {
      let force = Math.max(Math.abs(data.vector.x), Math.abs(data.vector.y));
      if (this.inputControllerComponent.isBlocked) {
        this.inputControllerComponent.direction = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0);
        force = 0;
        return;
      }
      this.inputControllerComponent.direction.set(-data.vector.x, 0, data.vector.y);
      this.inputControllerComponent.force = force;
    });

    //event on end move
    this.inputControllerComponent.controller.on("end", (evt, data) => {
      this.inputControllerComponent.force = 0;
      this.inputControllerComponent.direction = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0);
    });
  }
}) || _class;

/***/ }),

/***/ "./src/game/systems/basic/movement-collision-system.ts":
/*!*************************************************************!*\
  !*** ./src/game/systems/basic/movement-collision-system.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MovementCollisionSystem": () => (/* binding */ MovementCollisionSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/bhv-components/ground-collision */ "./src/game/components/bhv-components/ground-collision.ts");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/tag-components */ "./src/game/components/tag-components.ts");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/core/MeshBVH.js");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js");
/* harmony import */ var _utils_assets_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/assets-utils */ "./src/game/utils/assets-utils.ts");
/* harmony import */ var three_examples_jsm_utils_BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! three/examples/jsm/utils/BufferGeometryUtils */ "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var _components_input_controller_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/input-controller-component */ "./src/game/components/input-controller-component.ts");
/* harmony import */ var _components_velocity_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../components/velocity-component */ "./src/game/components/velocity-component.ts");
/* harmony import */ var _movement_system__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./movement-system */ "./src/game/systems/basic/movement-system.ts");
var _dec, _class;













three__WEBPACK_IMPORTED_MODULE_10__.Mesh.prototype.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_11__.acceleratedRaycast;
three__WEBPACK_IMPORTED_MODULE_10__.BufferGeometry.prototype.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_11__.computeBoundsTree;
three__WEBPACK_IMPORTED_MODULE_10__.BufferGeometry.prototype.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_11__.disposeBoundsTree;
let MovementCollisionSystem = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(s => s.after(_movement_system__WEBPACK_IMPORTED_MODULE_9__.MovementSystem)), _dec(_class = class MovementCollisionSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.playerIsOnGround = false;
    this.playerVelocity = new three__WEBPACK_IMPORTED_MODULE_10__.Vector3();
    this.tempVector = new three__WEBPACK_IMPORTED_MODULE_10__.Vector3();
    this.tempVector2 = new three__WEBPACK_IMPORTED_MODULE_10__.Vector3();
    this.allGeometryID = new Map();
    this.tempSegment = new three__WEBPACK_IMPORTED_MODULE_10__.Line3();
    this.tempBox = new three__WEBPACK_IMPORTED_MODULE_10__.Box3();
    this.tempMat = new three__WEBPACK_IMPORTED_MODULE_10__.Matrix4();
    this.allMeshes = new three__WEBPACK_IMPORTED_MODULE_10__.Group();
    this.visual = void 0;
    this.collider = new three__WEBPACK_IMPORTED_MODULE_10__.Mesh();
    this.movables = this.query(q => q.current.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable).read.and.with(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform).write.with(_components_tag_components__WEBPACK_IMPORTED_MODULE_4__.PlayerTag).read.and.with(_components_velocity_component__WEBPACK_IMPORTED_MODULE_8__.VelocityComponent).write);
    this.createGround = this.query(q => q.addedOrChanged.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable).read.and.with(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform).read.with(_components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_3__.GroundCollisionComponent).trackWrites);
    this.removeGround = this.query(q => q.removed.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable).read.and.with(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform).read.with(_components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_3__.GroundCollisionComponent).write);
    this.inputControllerComponent = this.singleton.read(_components_input_controller_component__WEBPACK_IMPORTED_MODULE_7__.InputControllerComponent);
  }
  execute() {
    let i = 0;
    for (const groundObject of this.createGround.addedOrChanged) {
      i++;
      const {
        scale: s,
        position,
        rotation
      } = groundObject.read(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform);
      const {
        id,
        mesh: block
      } = groundObject.read(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable);
      const isAttached = groundObject.read(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable).isAttachToScene;
      const geometry = _utils_assets_utils__WEBPACK_IMPORTED_MODULE_5__["default"].getObjectGeometry(block);
      const cloneGeometry = geometry.clone();
      const parent = groundObject.read(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable).parent;
      //if u didnt attach to scene ( mean attached to other object)
      if (!isAttached && parent) {
        const {
          scale: parentScale,
          position: parentPosition,
          rotation: parentRotation
        } = parent;

        // Create local transformation matrix for the block
        const localTransform = new three__WEBPACK_IMPORTED_MODULE_10__.Matrix4().makeScale(s.x, s.y, s.z).multiply(new three__WEBPACK_IMPORTED_MODULE_10__.Matrix4().makeRotationFromEuler(new three__WEBPACK_IMPORTED_MODULE_10__.Euler(rotation.x, rotation.y, rotation.z))).setPosition(position);

        // Create the parent's transformation matrix
        const parentTransform = new three__WEBPACK_IMPORTED_MODULE_10__.Matrix4().makeScale(parentScale.x, parentScale.y, parentScale.z).multiply(new three__WEBPACK_IMPORTED_MODULE_10__.Matrix4().makeRotationFromEuler(new three__WEBPACK_IMPORTED_MODULE_10__.Euler(parentRotation.x, parentRotation.y, parentRotation.z))).setPosition(parentPosition);

        // Multiply the local transformation matrix with the parent's transformation matrix
        const globalTransform = new three__WEBPACK_IMPORTED_MODULE_10__.Matrix4().multiplyMatrices(parentTransform, localTransform);
        cloneGeometry.applyMatrix4(globalTransform);
      } else {
        const localTransform = new three__WEBPACK_IMPORTED_MODULE_10__.Matrix4().makeScale(s.x, s.y, s.z).multiply(new three__WEBPACK_IMPORTED_MODULE_10__.Matrix4().makeRotationFromEuler(new three__WEBPACK_IMPORTED_MODULE_10__.Euler(rotation.x, rotation.y, rotation.z))).setPosition(position);
        cloneGeometry.applyMatrix4(localTransform);
      }
      cloneGeometry.computeBoundsTree();
      this.allGeometryID.set(id, cloneGeometry);
      if (i >= this.createGround.addedOrChanged.length) {
        const newGeom = (0,three_examples_jsm_utils_BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_12__.mergeBufferGeometries)([...this.allGeometryID.values()]);
        const newMesh = new three__WEBPACK_IMPORTED_MODULE_10__.Mesh(newGeom, new three__WEBPACK_IMPORTED_MODULE_10__.MeshStandardMaterial({
          color: 0x00ff00,
          shadowSide: 2
        }));
        this.allMeshes.add(newMesh);
        const staticGenerator = new three_mesh_bvh__WEBPACK_IMPORTED_MODULE_13__.StaticGeometryGenerator(this.allMeshes);
        staticGenerator.attributes = ["position"];
        const mergedGeometry = staticGenerator.generate();
        mergedGeometry.boundsTree = new three_mesh_bvh__WEBPACK_IMPORTED_MODULE_14__.MeshBVH(mergedGeometry);
        const collider = new three__WEBPACK_IMPORTED_MODULE_10__.Mesh(mergedGeometry);
        collider.material.wireframe = true;
        collider.material.opacity = 0.5;
        collider.material.transparent = true;
        collider.visible = false;
        this.visual = new three_mesh_bvh__WEBPACK_IMPORTED_MODULE_15__.MeshBVHVisualizer(collider, 10);
        this.collider = collider;
        _managers_game_manager__WEBPACK_IMPORTED_MODULE_6__.GameManager.SCENE.add(this.collider);
      }
    }
    let blockRemoved = 0;
    for (const block of this.removeGround.removed) {
      const {
        id
      } = block.read(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable);
      blockRemoved++;
      this.allGeometryID.delete(id);
      if (blockRemoved >= this.removeGround.removed.length) {
        const geometry = (0,three_examples_jsm_utils_BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_12__.mergeBufferGeometries)([...this.allGeometryID.values()]);
        const mesh = new three__WEBPACK_IMPORTED_MODULE_10__.Mesh(geometry, new three__WEBPACK_IMPORTED_MODULE_10__.MeshStandardMaterial({
          color: 0x00ff00,
          shadowSide: 2
        }));
        this.allMeshes.traverse(e => {
          var _e$parent;
          (_e$parent = e.parent) === null || _e$parent === void 0 ? void 0 : _e$parent.remove(e);
        });
        this.collider.traverse(e => {
          var _e$parent2;
          (_e$parent2 = e.parent) === null || _e$parent2 === void 0 ? void 0 : _e$parent2.remove(e);
        });
        this.collider.geometry.disposeBoundsTree();
        this.allMeshes.add(mesh);
        const staticGenerator = new three_mesh_bvh__WEBPACK_IMPORTED_MODULE_13__.StaticGeometryGenerator(this.allMeshes);
        staticGenerator.attributes = ["position"];
        const mergedGeometry = staticGenerator.generate();
        mergedGeometry.boundsTree = new three_mesh_bvh__WEBPACK_IMPORTED_MODULE_14__.MeshBVH(mergedGeometry);
        const collider = new three__WEBPACK_IMPORTED_MODULE_10__.Mesh(mergedGeometry);
        collider.material.wireframe = true;
        collider.material.opacity = 0.5;
        collider.material.transparent = true;
        collider.visible = false;
        this.visual = new three_mesh_bvh__WEBPACK_IMPORTED_MODULE_15__.MeshBVHVisualizer(collider, 10);
        this.collider = collider;
        _managers_game_manager__WEBPACK_IMPORTED_MODULE_6__.GameManager.SCENE.add(this.collider);
      }
    }
    const physicsSteps = 2;
    const delta = Math.min(this.delta, 0.1) / physicsSteps;
    const gravity = -30;
    const playerSpeed = 13;
    //
    for (const movable of this.movables.current) {
      const player = movable.read(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable).mesh;
      const position = movable.write(_components_transform__WEBPACK_IMPORTED_MODULE_1__.Transform).position;
      const playerPosition = player.position;
      let {
        vx,
        vy,
        vz
      } = movable.write(_components_velocity_component__WEBPACK_IMPORTED_MODULE_8__.VelocityComponent);
      if (this.playerIsOnGround) {
        this.playerVelocity.y = delta * gravity;
      } else {
        this.playerVelocity.y += delta * gravity;
      }
      position.addScaledVector(this.playerVelocity, delta);

      //
      const direction = this.inputControllerComponent.direction;
      this.tempVector = new three__WEBPACK_IMPORTED_MODULE_10__.Vector3(direction.x, 0, direction.z);
      position.addScaledVector(this.tempVector, playerSpeed * delta);
      vx = this.tempVector.x * playerSpeed * delta;
      vz = this.tempVector.z * playerSpeed * delta;
      vy = this.playerVelocity.y;

      //
      const capsuleInfo = player.capsuleInfo;
      this.tempBox.makeEmpty();
      this.tempMat.copy(this.collider.matrixWorld).invert();
      this.tempSegment.copy(capsuleInfo.segment);
      //
      this.tempSegment.start.applyMatrix4(player.matrixWorld).applyMatrix4(this.tempMat);
      this.tempSegment.end.applyMatrix4(player.matrixWorld).applyMatrix4(this.tempMat);
      //
      // get the axis aligned bounding box of the capsule
      this.tempBox.expandByPoint(this.tempSegment.start);
      this.tempBox.expandByPoint(this.tempSegment.end);
      //
      this.tempBox.min.addScalar(-capsuleInfo.radius);
      this.tempBox.max.addScalar(capsuleInfo.radius);
      //
      if (!this.collider.geometry.boundsTree) return;
      this.collider.geometry.boundsTree.shapecast({
        intersectsBounds: box => box.intersectsBox(this.tempBox),
        intersectsTriangle: tri => {
          // check if the triangle is intersecting the capsule and adjust the
          // capsule position if it is.
          const triPoint = this.tempVector;
          const capsulePoint = this.tempVector2;
          const distance = tri.closestPointToSegment(this.tempSegment, triPoint, capsulePoint);
          if (distance < capsuleInfo.radius) {
            const depth = capsuleInfo.radius - distance;
            const direction = capsulePoint.sub(triPoint).normalize();
            this.tempSegment.start.addScaledVector(direction, depth);
            this.tempSegment.end.addScaledVector(direction, depth);
          }
        }
      });
      //
      const newPosition = this.tempVector;
      newPosition.copy(this.tempSegment.start).applyMatrix4(this.collider.matrixWorld);

      // check how much the collider was moved
      const deltaVector = this.tempVector2;
      deltaVector.subVectors(newPosition, playerPosition);

      // // if the player was primarily adjusted vertically we assume it's on something we should consider ground
      this.playerIsOnGround = deltaVector.y > Math.abs(delta * this.playerVelocity.y * 0.25);
      const offset = Math.max(0.0, deltaVector.length() - 1e-5);
      deltaVector.normalize().multiplyScalar(offset);
      position.add(deltaVector);
      if (!this.playerIsOnGround) {
        deltaVector.normalize();
        this.playerVelocity.addScaledVector(deltaVector, -deltaVector.dot(this.playerVelocity));
      } else {
        this.playerVelocity.set(0, 0, 0);
      }
    }
  }
}) || _class);

/***/ }),

/***/ "./src/game/systems/basic/movement-system.ts":
/*!***************************************************!*\
  !*** ./src/game/systems/basic/movement-system.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MovementSystem": () => (/* binding */ MovementSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_velocity_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/velocity-component */ "./src/game/components/velocity-component.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/tag-components */ "./src/game/components/tag-components.ts");
var _class;




let MovementSystem = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(_class = class MovementSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.movables = this.query(q => q.current.with(_components_velocity_component__WEBPACK_IMPORTED_MODULE_1__.VelocityComponent).and.with(_components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform).write.without(_components_tag_components__WEBPACK_IMPORTED_MODULE_3__.PlayerTag).read);
  }
  execute() {
    for (const movable of this.movables.current) {
      const velocity = movable.read(_components_velocity_component__WEBPACK_IMPORTED_MODULE_1__.VelocityComponent);
      const {
        position
      } = movable.write(_components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform);
      position.x += this.delta * velocity.vx;
      position.y += this.delta * velocity.vy;
      position.z += this.delta * velocity.vz;
    }
  }
}) || _class;

/***/ }),

/***/ "./src/game/systems/basic/renderer-system.ts":
/*!***************************************************!*\
  !*** ./src/game/systems/basic/renderer-system.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RendererSystem": () => (/* binding */ RendererSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_singletons_scene_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/singletons/scene-component */ "./src/game/components/singletons/scene-component.ts");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../managers/game-manager */ "./src/game/managers/game-manager.ts");
var _class;





let RendererSystem = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(_class = class RendererSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.scene = this.singleton.write(_components_singletons_scene_component__WEBPACK_IMPORTED_MODULE_3__.SceneComponent);
    this.renderables = this.query(q => q.addedOrChanged.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable).and.with(_components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform).trackWrites.and.using(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.OnSceneComponent).write);
  }
  initialize() {
    this.scene.scene = _managers_game_manager__WEBPACK_IMPORTED_MODULE_4__.GameManager.SCENE;
  }
  execute() {
    for (const renderable of this.renderables.addedOrChanged) {
      const transform = renderable.read(_components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform);
      const {
        mesh,
        isAttachToScene
      } = renderable.read(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable);

      // We update directly to avoid creating a new Vector3
      mesh.position.x = transform.position.x;
      mesh.position.y = transform.position.y;
      mesh.position.z = transform.position.z;
      mesh.rotation.x = transform.rotation.x;
      mesh.rotation.y = transform.rotation.y;
      mesh.rotation.z = transform.rotation.z;
      mesh.scale.x = transform.scale.x;
      mesh.scale.y = transform.scale.y;
      mesh.scale.z = transform.scale.z;
      mesh.updateMatrixWorld();
      if (isAttachToScene) {
        //it is not needed but want block it for future
        if (!renderable.has(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.OnSceneComponent)) {
          renderable.add(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.OnSceneComponent);
          this.scene.scene.add(mesh);
        }
      }
    }
  }
}) || _class;

/***/ }),

/***/ "./src/game/systems/basic/rotate-direction-system.ts":
/*!***********************************************************!*\
  !*** ./src/game/systems/basic/rotate-direction-system.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RotateDirectionSystem": () => (/* binding */ RotateDirectionSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _components_face_direction_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/face-direction-component */ "./src/game/components/face-direction-component.ts");
/* harmony import */ var _components_velocity_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/velocity-component */ "./src/game/components/velocity-component.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _movement_collision_system__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./movement-collision-system */ "./src/game/systems/basic/movement-collision-system.ts");
var _dec, _class;







let RotateDirectionSystem = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(s => s.after(_movement_collision_system__WEBPACK_IMPORTED_MODULE_5__.MovementCollisionSystem)), _dec(_class = class RotateDirectionSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.faceDirection = this.query(q => q.addedOrChanged.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable).and.with(_components_face_direction_component__WEBPACK_IMPORTED_MODULE_3__.FaceDirectionComponent).write.and.with(_components_velocity_component__WEBPACK_IMPORTED_MODULE_4__.VelocityComponent).trackWrites.and.with(_components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform).write);
    this.selfRotation = this.query(q => q.current.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable).and.with(_components_velocity_component__WEBPACK_IMPORTED_MODULE_4__.VelocityComponent).read.and.with(_components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform).write.and.without(_components_face_direction_component__WEBPACK_IMPORTED_MODULE_3__.FaceDirectionComponent));
  }
  execute() {
    for (const face of this.faceDirection.addedOrChanged) {
      const {
        mesh
      } = face.read(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable);
      const position = mesh.position;
      //   const { position } = face.read(Transform);
      const {
        rotation
      } = face.write(_components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform);
      const {
        vx,
        vy,
        vz
      } = face.read(_components_velocity_component__WEBPACK_IMPORTED_MODULE_4__.VelocityComponent);
      const {
        rotationSpeed,
        currentRotationSpeed
      } = face.write(_components_face_direction_component__WEBPACK_IMPORTED_MODULE_3__.FaceDirectionComponent);
      let {
        futurePosition
      } = face.write(_components_face_direction_component__WEBPACK_IMPORTED_MODULE_3__.FaceDirectionComponent);
      const futurePos = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(position.x + vx, position.y + vy, position.z + vz);
      futurePosition = futurePos;

      // Calculate the direction from the current position to the future position
      const dir = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3().subVectors(futurePos, position).normalize();
      // Calculate the rotation to face the future position
      const up = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 0, 1); // Use y as the "up" direction by z
      const axis = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3().crossVectors(up, dir).normalize();
      const angle = Math.acos(up.dot(dir));
      const quaternion = new three__WEBPACK_IMPORTED_MODULE_6__.Quaternion().setFromAxisAngle(axis, angle);
      const rot = new three__WEBPACK_IMPORTED_MODULE_6__.Euler().setFromQuaternion(quaternion);
      if (!position.clone().normalize().equals(futurePosition.clone().normalize())) {
        if (!dir.equals(new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 0, 0))) {
          const currentQuaternion = new three__WEBPACK_IMPORTED_MODULE_6__.Quaternion().setFromEuler(new three__WEBPACK_IMPORTED_MODULE_6__.Euler(rotation.x, rotation.y, rotation.z));
          const lerpAmount = Math.min(this.delta * currentRotationSpeed, 1);
          const lerpedQuaternion = currentQuaternion.clone().slerp(quaternion, lerpAmount);
          const targetEuler = new three__WEBPACK_IMPORTED_MODULE_6__.Euler().setFromQuaternion(lerpedQuaternion);
          rotation.x = targetEuler.x;
          rotation.y = targetEuler.y;
          rotation.z = targetEuler.z;

          // Update  speed with damping
          const dampingFactor = 0.1;
          const targetRotationSpeed = dir.length() > 0 ? rotationSpeed : 0;
          face.write(_components_face_direction_component__WEBPACK_IMPORTED_MODULE_3__.FaceDirectionComponent).currentRotationSpeed = three__WEBPACK_IMPORTED_MODULE_6__.MathUtils.lerp(currentRotationSpeed, targetRotationSpeed, dampingFactor);
        }
      } else {
        // If we're already facing the target position, set the rotation speed to 0
        face.write(_components_face_direction_component__WEBPACK_IMPORTED_MODULE_3__.FaceDirectionComponent).currentRotationSpeed = 0;
      }
    }
    for (const mesh of this.selfRotation.current) {
      const {
        rotation
      } = mesh.write(_components_transform__WEBPACK_IMPORTED_MODULE_2__.Transform);
      const {
        rx,
        ry,
        rz
      } = mesh.read(_components_velocity_component__WEBPACK_IMPORTED_MODULE_4__.VelocityComponent);
      rotation.x += this.delta * rx;
      rotation.y += this.delta * ry;
      rotation.z += this.delta * rz;
    }
  }
}) || _class);

/***/ }),

/***/ "./src/game/systems/basic/simple-behavior-system.ts":
/*!**********************************************************!*\
  !*** ./src/game/systems/basic/simple-behavior-system.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleBehaviorSystem": () => (/* binding */ SimpleBehaviorSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_animation_state_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/animation-state-component */ "./src/game/components/animation-state-component.ts");
/* harmony import */ var _state_animation_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./state-animation-system */ "./src/game/systems/basic/state-animation-system.ts");
/* harmony import */ var _components_velocity_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/velocity-component */ "./src/game/components/velocity-component.ts");
/* harmony import */ var _components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/bhv-components/vision-collider-component */ "./src/game/components/bhv-components/vision-collider-component.ts");
/* harmony import */ var _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/character-stats/states/world-states-components */ "./src/game/components/character-stats/states/world-states-components.ts");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/tag-components */ "./src/game/components/tag-components.ts");
/* harmony import */ var _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/bhv-components/sphere-collider-component */ "./src/game/components/bhv-components/sphere-collider-component.ts");
var _dec, _class;








let SimpleBehaviorSystem = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(s => s.before(_state_animation_system__WEBPACK_IMPORTED_MODULE_2__.StateAnimationSystem)), _dec(_class = class SimpleBehaviorSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.animations = this.query(q => q.current.with(_components_animation_state_component__WEBPACK_IMPORTED_MODULE_1__.AnimationStateComponent).write.and.with(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.VelocityComponent).read.and.using(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_4__.VisionColliderHit).read.and.using(_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.IdleStateComponent).write.and.using(_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.RunStateComponent).write.and.using(_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.WalkStateComponent).write.and.using(_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.AttackStateComponent).write);
    this.attackAnimation = this.query(q => q.added.with(_components_tag_components__WEBPACK_IMPORTED_MODULE_6__.AttackComponent).write.and.with(_components_animation_state_component__WEBPACK_IMPORTED_MODULE_1__.AnimationStateComponent).read.and.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_7__.HitComponentTag).write.and.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_7__.IsHitBlock).write);
  }
  execute() {
    for (const query of this.attackAnimation.added) {
      const {
        stateManager,
        states
      } = query.read(_components_animation_state_component__WEBPACK_IMPORTED_MODULE_1__.AnimationStateComponent);
      const attack = states.get("attack");
      const counter = query.write(_components_tag_components__WEBPACK_IMPORTED_MODULE_6__.AttackComponent);
      attack.onLoop = () => {
        counter.attackCount += 1;
        if (query.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_7__.HitComponentTag)) {
          query.remove(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_7__.HitComponentTag);
        }
      };
      attack.onExit = () => {
        counter.attackCount = 0;
      };
    }
    for (const query of this.animations.current) {
      const {
        stateManager,
        states
      } = query.read(_components_animation_state_component__WEBPACK_IMPORTED_MODULE_1__.AnimationStateComponent);
      const {
        vx,
        vy,
        vz
      } = query.read(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.VelocityComponent);
      const maxPower = Math.max(Math.abs(vx), Math.abs(vy), Math.abs(vz));
      const statesByCondition = [{
        condition: maxPower => maxPower > 0.35,
        state: "run",
        componentsToAdd: [_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.RunStateComponent],
        componentsToRemove: [_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.WalkStateComponent, _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.IdleStateComponent, _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.AttackStateComponent]
      }, {
        condition: maxPower => maxPower > 0 && maxPower < 0.35,
        state: "walk",
        componentsToAdd: [_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.WalkStateComponent],
        componentsToRemove: [_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.RunStateComponent, _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.IdleStateComponent, _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.AttackStateComponent]
      }, {
        condition: (maxPower, query) => maxPower <= 0 && query.has(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_4__.VisionColliderHit),
        state: "attack",
        componentsToAdd: [_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.AttackStateComponent],
        componentsToRemove: [_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.RunStateComponent, _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.WalkStateComponent, _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.IdleStateComponent]
      }, {
        condition: maxPower => true,
        state: "idle",
        componentsToAdd: [_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.IdleStateComponent],
        componentsToRemove: [_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.RunStateComponent, _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.WalkStateComponent, _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_5__.AttackStateComponent]
      }];
      for (const {
        condition,
        state,
        componentsToAdd,
        componentsToRemove
      } of statesByCondition) {
        if (condition(maxPower, query)) {
          stateManager.setState(state);
          for (const component of componentsToAdd) {
            if (!query.has(component)) {
              query.add(component);
            }
          }
          for (const component of componentsToRemove) {
            if (query.has(component)) {
              query.remove(component);
            }
          }
          break;
        }
      }
    }
  }
}) || _class);

/***/ }),

/***/ "./src/game/systems/basic/state-animation-system.ts":
/*!**********************************************************!*\
  !*** ./src/game/systems/basic/state-animation-system.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateAnimationSystem": () => (/* binding */ StateAnimationSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _components_animation_state_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/animation-state-component */ "./src/game/components/animation-state-component.ts");
var _class;



let StateAnimationSystem = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(_class = class StateAnimationSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.animations = this.query(q => q.addedOrChanged.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_1__.MeshRenderable).and.with(_components_animation_state_component__WEBPACK_IMPORTED_MODULE_2__.AnimationStateComponent).trackWrites);
  }
  execute() {
    for (const animation of this.animations.addedOrChanged) {
      const {
        currentState,
        stateManager,
        states
      } = animation.read(_components_animation_state_component__WEBPACK_IMPORTED_MODULE_2__.AnimationStateComponent);
    }
  }
}) || _class;

/***/ }),

/***/ "./src/game/systems/basic/velocity-system.ts":
/*!***************************************************!*\
  !*** ./src/game/systems/basic/velocity-system.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PlayerVelocitySystem": () => (/* binding */ PlayerVelocitySystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_input_controller_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/input-controller-component */ "./src/game/components/input-controller-component.ts");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _components_velocity_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/velocity-component */ "./src/game/components/velocity-component.ts");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/tag-components */ "./src/game/components/tag-components.ts");
/* harmony import */ var _components_camera_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/camera-component */ "./src/game/components/camera-component.ts");
/* harmony import */ var _components_pathfinding_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/pathfinding-component */ "./src/game/components/pathfinding-component.ts");
/* harmony import */ var _movement_collision_system__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./movement-collision-system */ "./src/game/systems/basic/movement-collision-system.ts");
var _dec, _class;








let PlayerVelocitySystem = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(s => s.before(_movement_collision_system__WEBPACK_IMPORTED_MODULE_7__.MovementCollisionSystem)), _dec(_class = class PlayerVelocitySystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.inputControllerComponent = this.singleton.read(_components_input_controller_component__WEBPACK_IMPORTED_MODULE_1__.InputControllerComponent);
    this.playerVelocity = this.query(q => q.current.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_2__.MeshRenderable).read.and.with(_components_tag_components__WEBPACK_IMPORTED_MODULE_4__.PlayerTag).and.with(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.VelocityComponent).write);
    this.cameraVelocity = this.query(q => q.current.with(_components_camera_component__WEBPACK_IMPORTED_MODULE_5__.CameraComponent).read.and.with(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.VelocityComponent).write);
    this.pathFinder = this.query(q => q.current.with(_components_pathfinding_component__WEBPACK_IMPORTED_MODULE_6__.PathfindingComponent).read.and.with(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.VelocityComponent).write.with(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.TargetVelocityComponent).write);
    //this number base on what speed do u want see in ur game depends on an ur scale, world speed etc.
    this.speedMod = 10;
  }
  execute() {
    for (const player of this.playerVelocity.current) {
      const velocity = player.write(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.VelocityComponent);
      velocity.vx = this.inputControllerComponent.direction.x * this.speedMod;
      velocity.vz = this.inputControllerComponent.direction.z * this.speedMod;
    }
    for (const camera of this.cameraVelocity.current) {
      const velocity = camera.write(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.VelocityComponent);
      const {
        isFollow
      } = camera.read(_components_camera_component__WEBPACK_IMPORTED_MODULE_5__.CameraComponent);
      if (!isFollow) {
        velocity.vx = this.inputControllerComponent.direction.x * this.speedMod;
        velocity.vz = this.inputControllerComponent.direction.z * this.speedMod;
      }
    }
    for (const entity of this.pathFinder.current) {
      const velocity = entity.write(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.VelocityComponent);
      const targetVelocity = entity.read(_components_velocity_component__WEBPACK_IMPORTED_MODULE_3__.TargetVelocityComponent);
      velocity.vx = targetVelocity.vx;
      velocity.vz = targetVelocity.vz;
    }
  }
}) || _class);

/***/ }),

/***/ "./src/game/systems/bhv/vision-collider-system.ts":
/*!********************************************************!*\
  !*** ./src/game/systems/bhv/vision-collider-system.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VisionColliderSystem": () => (/* binding */ VisionColliderSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/tag-components */ "./src/game/components/tag-components.ts");
/* harmony import */ var _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/bhv-components/sphere-collider-component */ "./src/game/components/bhv-components/sphere-collider-component.ts");
/* harmony import */ var _components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/bhv-components/vision-collider-component */ "./src/game/components/bhv-components/vision-collider-component.ts");
/* harmony import */ var _weapon_collider_system__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./weapon-collider-system */ "./src/game/systems/bhv/weapon-collider-system.ts");
var _dec, _class;







three__WEBPACK_IMPORTED_MODULE_5__.Mesh.prototype.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_6__.acceleratedRaycast;
three__WEBPACK_IMPORTED_MODULE_5__.BufferGeometry.prototype.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_6__.computeBoundsTree;
three__WEBPACK_IMPORTED_MODULE_5__.BufferGeometry.prototype.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_6__.disposeBoundsTree;
let VisionColliderSystem = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(s => s.after(_weapon_collider_system__WEBPACK_IMPORTED_MODULE_4__.WeaponColliderSystem)), _dec(_class = class VisionColliderSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.boxes = this.query(q => q.current.with(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderComponent).write.and.using(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.registerVisionColliderTag).write);
    this.obstacles = this.query(q => q.current.with(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent).write.and.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag).write.without(_components_tag_components__WEBPACK_IMPORTED_MODULE_1__.PlayerTag));
    this.fov = this.query(q => q.current.with(_components_tag_components__WEBPACK_IMPORTED_MODULE_1__.PlayerTag).with(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderComponent).write.and.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag).write.and.using(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderHit).write);
  }
  execute() {
    //register
    for (const fovBox of this.boxes.current) {
      if (!fovBox.has(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.registerVisionColliderTag)) {
        fovBox.add(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.registerVisionColliderTag);
        const {
          radius,
          parent,
          position
        } = fovBox.read(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderComponent);
        const fovBoxMesh = fovBox.write(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderComponent).boxMesh;
        const geometry = fovBoxMesh.geometry;
        geometry.computeBoundsTree();
        parent.add(fovBoxMesh);
        fovBoxMesh.position.copy(position);
        fovBoxMesh.visible = false;
        console.log("here");
      }
    }
    for (const fovCollider of this.fov.current) {
      if (!fovCollider.has(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.registerVisionColliderTag)) continue;
      const {
        boxMesh: fovBox
      } = fovCollider.read(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderComponent);
      let hit = false;
      for (const obstacles of this.obstacles.current) {
        if (!obstacles.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag)) continue;
        const {
          sphereMesh
        } = obstacles.read(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent);
        const transformMatrix = new three__WEBPACK_IMPORTED_MODULE_5__.Matrix4().copy(fovBox.matrixWorld).invert().multiply(sphereMesh.matrixWorld);
        const isHit = fovBox.geometry.boundsTree.intersectsGeometry(sphereMesh.geometry, transformMatrix);
        if (isHit) {
          hit = true;
          break;
        }
      }
      if (hit) {
        // Если есть пересечение, добавляем компонент VisionColliderHit
        if (!fovCollider.has(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderHit)) {
          fovCollider.add(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderHit);
        }
      } else {
        // Если нет пересечений, удаляем компонент VisionColliderHit
        if (fovCollider.has(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderHit)) {
          fovCollider.remove(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderHit);
        }
      }

      // Проверяем наличие компонента VisionColliderHit на fovBox и обновляем его материалы
      if (fovCollider.has(_components_bhv_components_vision_collider_component__WEBPACK_IMPORTED_MODULE_3__.VisionColliderHit)) {
        fovBox.material.color.set(0xe91e63);
        fovBox.material.emissive.set(0xe91e63).multiplyScalar(0.25);
      } else {
        fovBox.material.color.set(0x666666);
        fovBox.material.emissive.set(0x000000);
      }
    }
    //use colliders
  }
}) || _class);

/***/ }),

/***/ "./src/game/systems/bhv/weapon-collider-system.ts":
/*!********************************************************!*\
  !*** ./src/game/systems/bhv/weapon-collider-system.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WeaponColliderSystem": () => (/* binding */ WeaponColliderSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/tag-components */ "./src/game/components/tag-components.ts");
/* harmony import */ var _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/bhv-components/sphere-collider-component */ "./src/game/components/bhv-components/sphere-collider-component.ts");
/* harmony import */ var _components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/character-stats/states/world-states-components */ "./src/game/components/character-stats/states/world-states-components.ts");
/* harmony import */ var _components_animation_state_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/animation-state-component */ "./src/game/components/animation-state-component.ts");
/* harmony import */ var _basic_simple_behavior_system__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../basic/simple-behavior-system */ "./src/game/systems/basic/simple-behavior-system.ts");
/* harmony import */ var _game_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../game-config */ "./src/game/game-config.ts");
var _dec, _class;









three__WEBPACK_IMPORTED_MODULE_7__.Mesh.prototype.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_8__.acceleratedRaycast;
three__WEBPACK_IMPORTED_MODULE_7__.BufferGeometry.prototype.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_8__.computeBoundsTree;
three__WEBPACK_IMPORTED_MODULE_7__.BufferGeometry.prototype.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_8__.disposeBoundsTree;
let WeaponColliderSystem = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(s => s.after(_basic_simple_behavior_system__WEBPACK_IMPORTED_MODULE_5__.SimpleBehaviorSystem)), _dec(_class = class WeaponColliderSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.currentHitBlocks = 0;
    this.spheres = this.query(q => q.current.with(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent).write.and.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag).write);
    this.weapon = this.query(q => q.current.with(_components_tag_components__WEBPACK_IMPORTED_MODULE_1__.PlayerTag).with(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent).write.and.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag).write.using(_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_3__.AttackStateComponent).read.and.with(_components_animation_state_component__WEBPACK_IMPORTED_MODULE_4__.AnimationStateComponent).read.and.with(_components_tag_components__WEBPACK_IMPORTED_MODULE_1__.AttackComponent).read.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.HitComponentTag).write);
    this.blocks = this.query(q => q.current.without(_components_tag_components__WEBPACK_IMPORTED_MODULE_1__.PlayerTag).with(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent).write.and.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag).write.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.IsHitBlock).write.and.using(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.damageBlock).write);
  }
  execute() {
    //#region "Register Collision Meshes"
    for (const sphere of this.spheres.current) {
      if (!sphere.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag)) {
        sphere.add(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag);
        const {
          radius,
          parent,
          position
        } = sphere.read(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent);
        const sphereMesh = sphere.write(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent).sphereMesh;
        const geometry = sphereMesh.geometry;
        geometry.computeBoundsTree();
        parent.add(sphereMesh);
        sphereMesh.position.copy(position);
        sphereMesh.visible = true;
      }
    }
    //#endregion "Register Collision Meshes"

    //#region "Collision Hit"
    for (const weaponSphere of this.weapon.current) {
      if (!weaponSphere.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag)) return;
      if (!weaponSphere.has(_components_character_stats_states_world_states_components__WEBPACK_IMPORTED_MODULE_3__.AttackStateComponent)) return;
      const stateManager = weaponSphere.read(_components_animation_state_component__WEBPACK_IMPORTED_MODULE_4__.AnimationStateComponent).stateManager;
      const attackDuration = stateManager.getMaxDuration("attack");
      const currentAttackTime = stateManager.getCurrentTime();
      const maxCountOfHitPerAttack = _game_config__WEBPACK_IMPORTED_MODULE_6__.GameConfig.maxDestroyBlocksOneHit;
      const {
        sphereMesh: weaponMesh
      } = weaponSphere.read(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent);
      const attackState = weaponSphere.read(_components_animation_state_component__WEBPACK_IMPORTED_MODULE_4__.AnimationStateComponent).states.get("attack");

      //reset
      attackState.onLoop = () => {
        this.currentHitBlocks = 0;
        if (weaponSphere.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.HitComponentTag)) {
          weaponSphere.remove(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.HitComponentTag);
        }
        for (const block of this.blocks.current) {
          if (!block.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.IsHitBlock)) continue;
          block.remove(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.IsHitBlock);
        }
      };

      //#region every block check on Hit
      for (const blocks of this.blocks.current) {
        if (weaponSphere.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.HitComponentTag)) continue;
        if (!blocks.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.registerSphereColliderTag)) continue;
        if (this.currentHitBlocks == maxCountOfHitPerAttack) continue;
        //start attack animation
        if (currentAttackTime < attackDuration * 0.37) continue;
        //end attack animation
        if (currentAttackTime > attackDuration * 0.6) continue;
        const {
          sphereMesh: blockMesh
        } = blocks.read(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.SphereColliderComponent);
        const transformMatrix = new three__WEBPACK_IMPORTED_MODULE_7__.Matrix4().copy(weaponMesh.matrixWorld).invert().multiply(blockMesh.matrixWorld);
        const isHit = weaponMesh.geometry.boundsTree.intersectsGeometry(blockMesh.geometry, transformMatrix);
        if (isHit) {
          if (blocks.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.IsHitBlock)) continue;
          this.currentHitBlocks += 1;
          blocks.add(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.IsHitBlock);
          blocks.add(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.damageBlock);
          console.log("hit block");
        }
      }
      if (this.currentHitBlocks == maxCountOfHitPerAttack) {
        if (!weaponSphere.has(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.HitComponentTag)) {
          weaponSphere.add(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_2__.HitComponentTag);
        }
      }

      //#endregion every block check on Hit
    }
    //#endregion "Collision Hit"
  }
}) || _class);

/***/ }),

/***/ "./src/game/systems/define-all-systems.ts":
/*!************************************************!*\
  !*** ./src/game/systems/define-all-systems.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defineAllSystems": () => (/* binding */ defineAllSystems)
/* harmony export */ });
/* harmony import */ var _basic_renderer_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basic/renderer-system */ "./src/game/systems/basic/renderer-system.ts");
/* harmony import */ var _basic_camera_system__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic/camera-system */ "./src/game/systems/basic/camera-system.ts");
/* harmony import */ var _basic_state_animation_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic/state-animation-system */ "./src/game/systems/basic/state-animation-system.ts");
/* harmony import */ var _basic_input_controller_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basic/input-controller-system */ "./src/game/systems/basic/input-controller-system.ts");
/* harmony import */ var _bhv_vision_collider_system__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bhv/vision-collider-system */ "./src/game/systems/bhv/vision-collider-system.ts");
/* harmony import */ var _bhv_weapon_collider_system__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bhv/weapon-collider-system */ "./src/game/systems/bhv/weapon-collider-system.ts");
/* harmony import */ var _attack_block_system__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attack-block-system */ "./src/game/systems/attack-block-system.ts");
/* harmony import */ var _destroy_block_system__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./destroy-block-system */ "./src/game/systems/destroy-block-system.ts");
/* harmony import */ var _basic_movement_collision_system__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./basic/movement-collision-system */ "./src/game/systems/basic/movement-collision-system.ts");
/* harmony import */ var _basic_rotate_direction_system__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./basic/rotate-direction-system */ "./src/game/systems/basic/rotate-direction-system.ts");
/* harmony import */ var _basic_velocity_system__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./basic/velocity-system */ "./src/game/systems/basic/velocity-system.ts");
/* harmony import */ var _basic_movement_system__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./basic/movement-system */ "./src/game/systems/basic/movement-system.ts");
/* harmony import */ var _basic_simple_behavior_system__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./basic/simple-behavior-system */ "./src/game/systems/basic/simple-behavior-system.ts");













const defineAllSystems = [_basic_renderer_system__WEBPACK_IMPORTED_MODULE_0__.RendererSystem, _basic_camera_system__WEBPACK_IMPORTED_MODULE_1__.CameraSystem, _basic_state_animation_system__WEBPACK_IMPORTED_MODULE_2__.StateAnimationSystem, _basic_input_controller_system__WEBPACK_IMPORTED_MODULE_3__.InputControllerSystem, _basic_velocity_system__WEBPACK_IMPORTED_MODULE_10__.PlayerVelocitySystem, _basic_movement_system__WEBPACK_IMPORTED_MODULE_11__.MovementSystem, _basic_movement_collision_system__WEBPACK_IMPORTED_MODULE_8__.MovementCollisionSystem, _basic_rotate_direction_system__WEBPACK_IMPORTED_MODULE_9__.RotateDirectionSystem, _basic_simple_behavior_system__WEBPACK_IMPORTED_MODULE_12__.SimpleBehaviorSystem, _bhv_weapon_collider_system__WEBPACK_IMPORTED_MODULE_5__.WeaponColliderSystem, _bhv_vision_collider_system__WEBPACK_IMPORTED_MODULE_4__.VisionColliderSystem, _attack_block_system__WEBPACK_IMPORTED_MODULE_6__.AttackBlockSystem, _destroy_block_system__WEBPACK_IMPORTED_MODULE_7__.DestroyBlockSystem];

/***/ }),

/***/ "./src/game/systems/destroy-block-system.ts":
/*!**************************************************!*\
  !*** ./src/game/systems/destroy-block-system.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DestroyBlockSystem": () => (/* binding */ DestroyBlockSystem)
/* harmony export */ });
/* harmony import */ var _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lastolivegames/becsy */ "./node_modules/@lastolivegames/becsy/index.js");
/* harmony import */ var _components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/bhv-components/sphere-collider-component */ "./src/game/components/bhv-components/sphere-collider-component.ts");
/* harmony import */ var _attack_block_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attack-block-system */ "./src/game/systems/attack-block-system.ts");
/* harmony import */ var _bhv_vision_collider_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bhv/vision-collider-system */ "./src/game/systems/bhv/vision-collider-system.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! three-mesh-bvh */ "./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js");
/* harmony import */ var _components_mesh_renderable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/mesh-renderable */ "./src/game/components/mesh-renderable.ts");
/* harmony import */ var _components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/bhv-components/ground-collision */ "./src/game/components/bhv-components/ground-collision.ts");
/* harmony import */ var _basic_rotate_direction_system__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./basic/rotate-direction-system */ "./src/game/systems/basic/rotate-direction-system.ts");
/* harmony import */ var _components_transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/transform */ "./src/game/components/transform.ts");
/* harmony import */ var _pop_up_pop_up__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pop-up/pop-up */ "./src/game/pop-up/pop-up.ts");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var _fx_explosion_voxel_explosion__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../fx/explosion-voxel/explosion */ "./src/game/fx/explosion-voxel/explosion.ts");
/* harmony import */ var _components_camera_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../components/camera-component */ "./src/game/components/camera-component.ts");
/* harmony import */ var _components_camera_shake_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../components/camera-shake-component */ "./src/game/components/camera-shake-component.ts");
/* harmony import */ var _basic_camera_system__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./basic/camera-system */ "./src/game/systems/basic/camera-system.ts");
/* harmony import */ var _components_tag_components__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../components/tag-components */ "./src/game/components/tag-components.ts");
/* harmony import */ var _playable_helper_discord_helpers__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../playable-helper/discord-helpers */ "./src/playable-helper/discord-helpers.ts");
/* harmony import */ var _components_input_controller_component__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../components/input-controller-component */ "./src/game/components/input-controller-component.ts");
/* harmony import */ var _basic_input_controller_system__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./basic/input-controller-system */ "./src/game/systems/basic/input-controller-system.ts");
/* harmony import */ var _game_config__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../game-config */ "./src/game/game-config.ts");
var _dec, _class;





















three__WEBPACK_IMPORTED_MODULE_19__.Mesh.prototype.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_20__.acceleratedRaycast;
three__WEBPACK_IMPORTED_MODULE_19__.BufferGeometry.prototype.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_20__.computeBoundsTree;
three__WEBPACK_IMPORTED_MODULE_19__.BufferGeometry.prototype.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_20__.disposeBoundsTree;
let DestroyBlockSystem = (_dec = (0,_lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.system)(s => s.after(_attack_block_system__WEBPACK_IMPORTED_MODULE_2__.AttackBlockSystem).after(_bhv_vision_collider_system__WEBPACK_IMPORTED_MODULE_3__.VisionColliderSystem).after(_basic_rotate_direction_system__WEBPACK_IMPORTED_MODULE_6__.RotateDirectionSystem).after(_basic_camera_system__WEBPACK_IMPORTED_MODULE_13__.CameraSystem).after(_basic_input_controller_system__WEBPACK_IMPORTED_MODULE_17__.InputControllerSystem)), _dec(_class = class DestroyBlockSystem extends _lastolivegames_becsy__WEBPACK_IMPORTED_MODULE_0__.System {
  constructor(...args) {
    super(...args);
    this.blocks = this.query(q => q.addedOrChanged.and.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_4__.MeshRenderable).read.with(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_1__.SphereColliderComponent).write.and.with(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_1__.DestroyBlock).trackWrites.write.with(_components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_5__.GroundCollisionComponent).write.and.with(_components_transform__WEBPACK_IMPORTED_MODULE_7__.Transform).read);
    this.player = this.query(q => q.current.and.with(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_4__.MeshRenderable).and.with(_components_transform__WEBPACK_IMPORTED_MODULE_7__.Transform).read.and.with(_components_tag_components__WEBPACK_IMPORTED_MODULE_14__.PlayerTag));
    this.cameras = this.query(q => q.current.with(_components_camera_component__WEBPACK_IMPORTED_MODULE_11__.CameraComponent).and.using(_components_camera_shake_component__WEBPACK_IMPORTED_MODULE_12__.CameraShakeComponent).write);
    this.inputControllerComponent = this.singleton.write(_components_input_controller_component__WEBPACK_IMPORTED_MODULE_16__.InputControllerComponent);
    this.maxCountToWin = _game_config__WEBPACK_IMPORTED_MODULE_18__.GameConfig.maxBlockToWin;
  }
  execute() {
    if (this.maxCountToWin < 0) return;
    for (const block of this.blocks.addedOrChanged) {
      var _mesh$parent;
      const {
        mesh
      } = block.read(_components_mesh_renderable__WEBPACK_IMPORTED_MODULE_4__.MeshRenderable);
      const {
        position
      } = block.read(_components_transform__WEBPACK_IMPORTED_MODULE_7__.Transform);
      this.maxCountToWin--;
      let popup;
      if (this.maxCountToWin >= 0) {
        const randomNum = Math.floor(Math.random() * 3);
        popup = new _pop_up_pop_up__WEBPACK_IMPORTED_MODULE_8__.PopUp(randomNum);
        popup.init();
        popup.position.copy(mesh.position);
        popup.popIt();
      } else {
        popup = new _pop_up_pop_up__WEBPACK_IMPORTED_MODULE_8__.PopUp(3);
        popup.init();
        popup.position.copy(mesh.position);
        popup.finalPop();
        setTimeout(() => {
          (0,_playable_helper_discord_helpers__WEBPACK_IMPORTED_MODULE_15__.showDiscordPanel)();
          this.inputControllerComponent.isBlocked = true;
        }, 3000);
      }
      _managers_game_manager__WEBPACK_IMPORTED_MODULE_9__.GameManager.SCENE.add(popup);
      const color = popup.getColor();
      let playerPosition = new three__WEBPACK_IMPORTED_MODULE_19__.Vector3();
      for (const player of this.player.current) {
        playerPosition = player.read(_components_transform__WEBPACK_IMPORTED_MODULE_7__.Transform).position;
      }
      const explosion = new _fx_explosion_voxel_explosion__WEBPACK_IMPORTED_MODULE_10__.Explosion(mesh, 0.3, 1, 45, color, playerPosition);
      explosion.position.y = 2;
      explosion.position.copy(mesh.position);
      _managers_game_manager__WEBPACK_IMPORTED_MODULE_9__.GameManager.SCENE.add(explosion);
      setTimeout(() => {
        explosion.start();
      }, 25);
      block.remove(_components_bhv_components_sphere_collider_component__WEBPACK_IMPORTED_MODULE_1__.SphereColliderComponent);
      block.remove(_components_bhv_components_ground_collision__WEBPACK_IMPORTED_MODULE_5__.GroundCollisionComponent);
      mesh.remove(mesh.children[0]);
      //#region remove hp after attack

      (_mesh$parent = mesh.parent) === null || _mesh$parent === void 0 ? void 0 : _mesh$parent.remove(mesh);
      mesh.visible = false;

      //  console.log(mesh);
      //#endregion remove hp after attack

      //shake camera

      for (const camera of this.cameras.current) {
        if (camera.has(_components_camera_shake_component__WEBPACK_IMPORTED_MODULE_12__.CameraShakeComponent)) return;
        camera.add(_components_camera_shake_component__WEBPACK_IMPORTED_MODULE_12__.CameraShakeComponent);
      }
    }
  }
}) || _class);

/***/ }),

/***/ "./src/game/utils/animation-utils.ts":
/*!*******************************************!*\
  !*** ./src/game/utils/animation-utils.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationUtils)
/* harmony export */ });
/* harmony import */ var _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/assets-manager/raw-assets-manager */ "./src/game/managers/assets-manager/raw-assets-manager.ts");
/* harmony import */ var three_examples_jsm_utils_SkeletonUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/utils/SkeletonUtils */ "./node_modules/three/examples/jsm/utils/SkeletonUtils.js");


class AnimationUtils {
  static registerAnimations(modelAnimations, animationType) {
    const arrayAnimation = [];
    for (const [key, value] of Object.entries(modelAnimations)) {
      const animations = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_0__.RawManager.getModel(value).animations;
      //this only for 1 animation per model
      animations[0].name = `${key}`;
      animationType.animations.push(...animations);
      arrayAnimation.push(...animationType.animations);
    }
    return arrayAnimation;
  }
  static getSkinnedMeshWithAnimation(prefab, name) {
    const tempNodes = [];
    const obj = (0,three_examples_jsm_utils_SkeletonUtils__WEBPACK_IMPORTED_MODULE_1__.clone)(prefab);
    obj.animations.push(...prefab.animations);
    obj.traverse(node => {
      if (node.name == "Scene") return;
      if (node.name == "scene") return;
      if (node.name == "Root_Scene") return;
      if (node.name == "RootNode") return;
      if (node.name == "Root") return;
      if (node.isBone) return;
      if (node.name !== name) {
        //    console.log(node.name);
        node.visible = false;
        tempNodes.push(node);
      }
    });
    tempNodes.forEach(e => {
      if (e.parent) {
        e.parent.remove(e);
      }
    });
    return obj;
  }
}

/***/ }),

/***/ "./src/game/utils/assets-utils.ts":
/*!****************************************!*\
  !*** ./src/game/utils/assets-utils.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AssetsUtils)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_utils_SkeletonUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/utils/SkeletonUtils */ "./node_modules/three/examples/jsm/utils/SkeletonUtils.js");
/* harmony import */ var _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/assets-manager/raw-assets-manager */ "./src/game/managers/assets-manager/raw-assets-manager.ts");
/* harmony import */ var _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../managers/game-manager */ "./src/game/managers/game-manager.ts");




class AssetsUtils {
  /**
   * Create animations [].
   * @constructor
   * @param {GLTF} gltf - gltf data for animations.
   */

  /**
   * Create array of MeshBasicMaterials (used for skyBox)
   * @constructor
   * @param {Texture[]} textureArray - data texture for creating material
   * @return {}
   */
  static createMaterialArray(textureArray) {
    const materialArray = textureArray.map(image => {
      return new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({
        map: image,
        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide
      });
    });
    return materialArray;
  }

  /**
   * Add Shadows
   * @constructor
   * @param {Object3D} object3d - 3d Models.
   */

  /**
   * Change material transparent
   * @constructor
   * @param {Object3D} object3d - 3d Models.
   * @param {number} opacity - 0-1 to change opacity
   * @param {boolean} transparent - default true
   */

  static setMaterialTransparent(object, opacity, transparent = true) {
    object.traverse(child => {
      if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {
        // If the child is a mesh, set its material properties
        child.material.needsUpdate = true;
        const clone = child.material.clone();
        clone.transparent = transparent;
        clone.opacity = opacity;
        child.material = clone;
      }
    });
  }

  /**
   * Add Materials
   * @constructor
   * @param {Object3D} object3d - 3d Models.
   * @param {Material} material - three js materials for put in model
   */

  /**
   * Sets the initial scale and rotation of an Object3D.
   *
   * @param object - The Object3D to set the initial scale and rotation for.
   * @param newScale - The new scale to set for the object.
   * @param newRotation - The new rotation to set for the object.
   */
  static setInitScaleAndRotation(object, newScale, newRotation) {
    object.traverse(child => {
      if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {
        // Change object scale
        child.scale.copy(newScale);
        // Change object rotation
        const position = object.localToWorld(child.position.clone());
        child.position.copy(position);
        // Optional: rotate the geometry
        child.geometry.rotateX(newRotation.x);
        child.geometry.rotateY(newRotation.y);
        child.geometry.rotateZ(newRotation.z);

        // Update the object's geometry
        const geometry = child.geometry;
        geometry.computeVertexNormals();
        geometry.computeBoundingBox();
        geometry.computeBoundingSphere();
      }
    });

    // Update the object's matrix world
    object.updateMatrixWorld();
  }

  /**
     Testing for raw changed material
     */

  /**
   * Fast fixed problem textures to base
   * @constructor
   * @param {Object3D} object - Texture asset from Raw.
   * @param outputType
   * @return Mesh[]
   */
  static extracMeshes(object, outputType = "array") {
    const meshes = [];
    object.traverse(child => {
      if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {
        meshes.push(child);
      }
    });
    if (outputType === "single") {
      return meshes.length > 0 ? meshes[0] : null;
    }
    return meshes;
  }

  /**
   * Get geometry from
   * @constructor
   * @param {Object3D} obj - Object3D from three.js
   * @return BufferGeometry
   */
  static getObjectGeometry(obj) {
    if (obj instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {
      return obj.geometry;
    } else if (obj instanceof three__WEBPACK_IMPORTED_MODULE_2__.Points) {
      return obj.geometry;
    } else if (obj.children.length > 0) {
      for (let i = 0; i < obj.children.length; i++) {
        const childGeometry = AssetsUtils.getObjectGeometry(obj.children[i]);
        if (childGeometry !== null) {
          return childGeometry;
        }
      }
    }
    return null;
  }

  /**
   * Traverse object hierarchy and compute vertex normals for each geometry found
   * @constructor
   * @param {Object3D} obj - Object3D from three.js
   */
  static computeVertexNormals(obj) {
    obj.traverse(child => {
      if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh || child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Points) {
        child.geometry.computeVertexNormals();
      }
    });
  }

  /**
   * Get center and return Box3
   * @constructor
   * @param {Object3D} object3d - 3d Models.
   * @returns {Box3} - center Object3D
   */
  getCenterBox3(object) {
    const box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(object);
    const center = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();
    box.getCenter(center);
    object.worldToLocal(center);
    box.translate(center.negate());
    return box;
  }
}
AssetsUtils.addAnimations = gltf => {
  const root = gltf.scene;
  root.animations = gltf.animations;
};
AssetsUtils.addShadows = object3d => {
  object3d.traverse(object => {
    if (object.isMesh || object.isSkinnedMesh) {
      object.castShadow = true;
      object.reciveShadow = true;
    }
  });
  object3d.castShadow = true;
  object3d.receiveShadow = true;
};
/**
 * Fast fixed problem textures to base
 * @constructor
 * @param {rawTexture} rawTexture - Texture asset from Raw.
 * @return Texture
 */
AssetsUtils.fastFixAndGetTexture = (rawTexture, s = 1, w = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping) => {
  const texture = _managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_0__.RawManager.getTexture(rawTexture);
  texture.wrapS = texture.wrapT = w;
  //texture.offset.set(0, 0);
  texture.repeat.set(s, s);
  texture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter; // use nearest-neighbor filtering
  texture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;
  texture.flipY = false;
  texture.encoding = three__WEBPACK_IMPORTED_MODULE_2__.sRGBEncoding;
  texture.needsUpdate = true;
  return texture;
};
AssetsUtils.addMaterial = (object3d, material) => {
  object3d.traverse(object => {
    if (object.isMesh || object.isSkinnedMesh) {
      object.material = material.clone();
    }
  });
};
/**
 * Add Materials only on mesh by his name
 * @constructor
 * @param {Object3D} object3d - 3d Models.
 * @param {Material} material - three js materials for put in model
 * @param {string} partName - name of the mesh in Object3D
 */
AssetsUtils.addMaterialByName = (object3d, material, partName) => {
  object3d.traverse(object => {
    if ((object.isMesh || object.isSkinnedMesh) && object.name === partName) {
      object.material = material.clone();
    }
  });
};
AssetsUtils.changeTypeOfMaterial = (object3d, material) => {
  object3d.traverse(object => {
    if (object.isMesh || object.isSkinnedMesh) {
      object.material = material;
    }
  });
};
/**
 * Add callBack if you need for smth special
 * @constructor
 * @param {Object3D} object3d - 3d Models.
 * @param {string} partName - name of the mesh in Object3D
 * @param {() => void} cb - put ur methods for smth special
 */
AssetsUtils.addCallBackByName = (object3d, partName, cb) => {
  object3d.traverse(object => {
    if ((object.isMesh || object.isSkinnedMesh) && object.name === partName) {
      cb();
    }
  });
};
/**
 * Wrapping S|T texture
 * @constructor
 * @param {Texture} texture - three js texture.
 */
AssetsUtils.wrappingTexture = texture => {
  texture.wrapS = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;
  texture.wrapT = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;
  texture.flipY = false;
};
/**
 * Clone Skinned Mesh (Model with rig and animations)
 * @constructor
 * @param {Object3D} object3d - 3d Models.
 * @returns {Object3D} object3dCloned - skinned Object3D
 */
AssetsUtils.cloneSkinnedMesh = object3d => {
  const model = three_examples_jsm_utils_SkeletonUtils__WEBPACK_IMPORTED_MODULE_3__.clone(object3d);
  model.traverse(mesh => {
    mesh.frustumCulled = false;
  });
  model.animations = object3d.animations;
  return model;
};
/**
 * Fast clone 3d Models with instancing
 * @constructor
 * @param {Object3D} object3d - 3d Models.
 * @returns {Object3D} newObject3D - instanced Object3D
 */
AssetsUtils.instancedMesh = object3d => {
  const dummy = new three__WEBPACK_IMPORTED_MODULE_2__.Object3D();
  const newObject3D = new three__WEBPACK_IMPORTED_MODULE_2__.Group();
  newObject3D.name = "instanced_" + object3d.name;
  object3d.traverse(object => {
    if (object.isMesh) {
      const mesh = object;
      const geometry = mesh.geometry;
      const material = mesh.material;
      const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh(geometry, material, 2);
      dummy.position.set(0, 0, 0);
      dummy.updateMatrix();
      instancedMesh.setMatrixAt(1, mesh.matrix);
      instancedMesh.instanceMatrix.setUsage(three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage);
      newObject3D.add(instancedMesh);
    }
  });
  newObject3D.visible = false;
  return newObject3D;
};
/**
 * Get size h: height, w: width, d: dept
 * @constructor
 * @param {Object3D} object3d - 3d Models.
 * @returns {number, number, number} {w,h,d} - size width, height, dept
 */
AssetsUtils.getSize = (object3d, scalar = 100) => {
  const box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(object3d);
  const dept = box.max.z - box.min.z;
  const width = box.max.x - box.min.x;
  const height = box.max.y - box.min.y;
  return {
    h: height * scalar,
    w: width * scalar,
    d: dept * scalar
  };
};
/**
 * Get center of Object3D
 * @constructor
 * @param {Object3D} object3d - 3d Models.
 * @returns {Vector3} - center
 */
AssetsUtils.getCenter = object3d => {
  const box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(object3d);
  const center = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();
  return box.getCenter(center);
};
/**
 * Put on scene, and return this Object3D,
 * use it for debug
 * @constructor
 * @param {Object3D} object3d - 3d Models.
 * @param {Vector3} position - 3d Models.
 * @param {Euler} rotation - 3d Models.
 * @returns {Object3D} - center
 */
AssetsUtils.putOnScene = (object, position, rotation, scale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 1, 1)) => {
  object.position.copy(position);
  object.rotation.copy(rotation);
  object.scale.copy(scale);
  _managers_game_manager__WEBPACK_IMPORTED_MODULE_1__.GameManager.SCENE.add(object);
  return object;
};

/***/ }),

/***/ "./src/game/utils/mesh-capsule.ts":
/*!****************************************!*\
  !*** ./src/game/utils/mesh-capsule.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshCapsule": () => (/* binding */ MeshCapsule)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

class MeshCapsule extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {
  constructor(geometry, material, capsuleInfo) {
    super(geometry, material);
    this.capsuleInfo = void 0;
    this.capsuleInfo = capsuleInfo;
  }
}

/***/ }),

/***/ "./src/game/utils/preloading-callbacks.ts":
/*!************************************************!*\
  !*** ./src/game/utils/preloading-callbacks.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cancelPreloading": () => (/* binding */ cancelPreloading),
/* harmony export */   "startPreloading": () => (/* binding */ startPreloading)
/* harmony export */ });
/* harmony import */ var _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game-state/game-state */ "./src/game/game-state/game-state.ts");

function cancelPreloading() {
  const loadingScreen = document.getElementById("loading-screen");
  loadingScreen === null || loadingScreen === void 0 ? void 0 : loadingScreen.classList.add("fade-out");
  // @ts-ignore
  loadingScreen.remove();
  // // @ts-ignore
  // loadingScreen?.style.zIndex = -1
  if (document.getElementById("loading")) document.getElementById("loading").style.display = "none";
  _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__.gameState.state = {
    stage: _game_state_game_state__WEBPACK_IMPORTED_MODULE_0__.GameStage.GAMELOADED
  };
}
function startPreloading() {
  const loadingScreen = document.getElementById("loading-screen");
  loadingScreen === null || loadingScreen === void 0 ? void 0 : loadingScreen.classList.add("fade");
}

/***/ }),

/***/ "./src/game/utils/uuid-generator.ts":
/*!******************************************!*\
  !*** ./src/game/utils/uuid-generator.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UuidGenerator)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");

class UuidGenerator {
  static generateUniqueNumericId() {
    const uuid = (0,uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
    return UuidGenerator.hashCode(uuid);
  }
  static hashCode(s) {
    let h = 0;
    for (let i = 0; i < s.length; i++) {
      h = Math.imul(31, h) + s.charCodeAt(i) | 0;
    }
    return h;
  }
}

/***/ }),

/***/ "./src/game/voxeling/simple-mesh-grid.ts":
/*!***********************************************!*\
  !*** ./src/game/voxeling/simple-mesh-grid.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleMeshGrid": () => (/* binding */ SimpleMeshGrid)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

class SimpleMeshGrid {
  constructor(mesh, radius, scale, maxCubes, color) {
    this.arrayOfBoxes = [];
    const boxGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(radius, radius, radius);
    const boxMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({
      color: color
    });
    let cubeCount = 0;
    while (cubeCount < maxCubes) {
      const position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3((Math.random() - 0.5) * radius, (Math.random() - 0.5) * radius, (Math.random() - 0.5) * radius);
      const rotation = new three__WEBPACK_IMPORTED_MODULE_0__.Euler(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
      const boxMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(boxGeometry, boxMaterial);
      boxMesh.position.copy(position);
      boxMesh.rotation.copy(rotation);
      boxMesh.scale.set(scale, scale, scale);
      this.arrayOfBoxes.push(boxMesh);
      cubeCount++;
    }
  }
  getBoxes() {
    return this.arrayOfBoxes;
  }
}

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ICECREAM": () => (/* binding */ ICECREAM),
/* harmony export */   "app": () => (/* binding */ app),
/* harmony export */   "getCanvas": () => (/* binding */ getCanvas)
/* harmony export */ });
/* harmony import */ var _styles_index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/index.css */ "./src/styles/index.css");
/* harmony import */ var _styles_discord_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/discord.css */ "./src/styles/discord.css");
/* harmony import */ var _styles_pre_loader_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles/pre-loader.css */ "./src/styles/pre-loader.css");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_proposals_reflect_metadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/proposals/reflect-metadata */ "./node_modules/core-js/proposals/reflect-metadata.js");
/* harmony import */ var core_js_proposals_reflect_metadata__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_proposals_reflect_metadata__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _game_utils_preloading_callbacks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./game/utils/preloading-callbacks */ "./src/game/utils/preloading-callbacks.ts");
/* harmony import */ var _game_asset_list_raw_assets_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./game/asset-list/raw-assets-list */ "./src/game/asset-list/raw-assets-list.ts");
/* harmony import */ var _game_managers_game_manager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./game/managers/game-manager */ "./src/game/managers/game-manager.ts");
/* harmony import */ var _game_managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./game/managers/assets-manager/raw-assets-manager */ "./src/game/managers/assets-manager/raw-assets-manager.ts");
 //init styles here for transpiling css not in html
 //init styles here for transpiling css not in html







const ICECREAM = "MISSING_ENV_VAR"["ICECREAM"] == "ready";
function getCanvas() {
  const elementId = ".canvas";
  const canvas = document.querySelector(elementId);
  if (!canvas) {
    throw new Error(`Canvas with id ${elementId} doesn't exist mmm`);
  }
  return canvas;
}
class app {
  constructor() {
    //scroll fix
    setTimeout(() => window.scrollTo(0, 1), 10);
    //loading externalAssets and after load main assets
    _game_managers_assets_manager_raw_assets_manager__WEBPACK_IMPORTED_MODULE_8__.RawManager.preloading().then(() => {
      this.gameInit();
    });
    this.fullScreen();
    //  this.focusBlur()
  }

  resize(w, h) {
    _game_managers_game_manager__WEBPACK_IMPORTED_MODULE_7__.GameManager.resize(w, h);
  }
  gameInit() {
    const newFont = _game_asset_list_raw_assets_list__WEBPACK_IMPORTED_MODULE_6__.DevFontName.RUSSONEWOFF;
    _game_managers_game_manager__WEBPACK_IMPORTED_MODULE_7__.GameManager.setup().then(r => setTimeout(() => {
      (0,_game_utils_preloading_callbacks__WEBPACK_IMPORTED_MODULE_5__.cancelPreloading)();
    }, 500));
  }
  fullScreen() {
    window.addEventListener("dblclick", () => {
      const fullscreenElement =
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      //@ts-ignore
      document.fullscreenElement || document.webkitFullscreenElement;
      if (!fullscreenElement) {
        if (getCanvas().requestFullscreen) {
          getCanvas().requestFullscreen();
          //@ts-ignore
        } else if (getCanvas().webkitRequestFullScreen) {
          //@ts-ignore
          canvas.webkitRequestFullScreen();
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
          //@ts-ignore
        } else if (document.webkitExitFullscreen()) {
          //@ts-ignore
          Document.webkitExitFullscreen();
        }
      }
    });
  }
  focusBlur() {
    window.addEventListener("blur", () => {
      _game_managers_game_manager__WEBPACK_IMPORTED_MODULE_7__.GameManager.pause(true);
      // GameManager.ENTITYWORLD.execute()
    });

    window.addEventListener("focus", () => {
      _game_managers_game_manager__WEBPACK_IMPORTED_MODULE_7__.GameManager.pause(false);
    });
  }
}

/***/ }),

/***/ "./src/playable-helper/discord-helpers.ts":
/*!************************************************!*\
  !*** ./src/playable-helper/discord-helpers.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "showDiscordPanel": () => (/* binding */ showDiscordPanel)
/* harmony export */ });
/* harmony import */ var _game_game_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/game-config */ "./src/game/game-config.ts");

const showDiscordPanel = () => {
  const discordPanel = document.getElementsByClassName("panel")[0];
  if (!discordPanel) return;
  setupLink();
  blurScreen();
  discordPanel.classList.remove("discord-hidden");
};
const blurScreen = () => {
  const canvas = document.querySelector("canvas");
  if (canvas) canvas.style.filter = "blur(8px)"; // Adjust the blur strength as desired
};

const setupLink = () => {
  const inviteButton = document.getElementById("inviteButton");
  const discordLink = document.getElementById("discordLink");
  // @ts-ignore
  discordLink.href = _game_game_config__WEBPACK_IMPORTED_MODULE_0__.GameConfig.discordUrl;
  if (!discordLink) return;
  if (inviteButton) inviteButton.addEventListener("click", () => {
    discordLink.click();
  });
};

/***/ }),

/***/ "./src/playable-helper/ice-cream/ice-cream.ts":
/*!****************************************************!*\
  !*** ./src/playable-helper/ice-cream/ice-cream.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ICECREAM": () => (/* binding */ ICECREAM)
/* harmony export */ });
let ICECREAM = "MISSING_ENV_VAR"["ICECREAM"] == "ready";

//  environmentColor: "{{creative.environmentColor}}",
//  oilColor = "{{creative.oilColor}}",
//  mainBarrelColor = "{{creative.mainBarrelColor}}",
//  playerMainColor: "{{creative.playerMainColor}}",
//  headColor: "{{creative.headColor}}",
//  backPackColor: "{{creative.backPackColor}}",
//  mainBuildColor: "{{creative.mainBuildColor}}",
//  solarColor: "{{creative.solarColor}}",
//  littleParts: "{{creative.littleParts}}",
//  bigParts: "{{creative.bigParts}}",
//  offColor: "{{creative.offColor}}"

/***/ }),

/***/ "./node_modules/cannon-es-debugger/dist/cannon-es-debugger.js":
/*!********************************************************************!*\
  !*** ./node_modules/cannon-es-debugger/dist/cannon-es-debugger.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonDebugger)
/* harmony export */ });
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");



function CannonDebugger(scene, world, _temp) {
  let {
    color = 0x00ff00,
    scale = 1,
    onInit,
    onUpdate
  } = _temp === void 0 ? {} : _temp;
  const _meshes = [];

  const _material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
    color: color != null ? color : 0x00ff00,
    wireframe: true
  });

  const _tempVec0 = new cannon_es__WEBPACK_IMPORTED_MODULE_1__.Vec3();

  const _tempVec1 = new cannon_es__WEBPACK_IMPORTED_MODULE_1__.Vec3();

  const _tempVec2 = new cannon_es__WEBPACK_IMPORTED_MODULE_1__.Vec3();

  const _tempQuat0 = new cannon_es__WEBPACK_IMPORTED_MODULE_1__.Quaternion();

  const _sphereGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(1);

  const _boxGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(1, 1, 1);

  const _planeGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(10, 10, 10, 10); // Move the planeGeometry forward a little bit to prevent z-fighting


  _planeGeometry.translate(0, 0, 0.0001);

  function createConvexPolyhedronGeometry(shape) {
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(); // Add vertices

    const positions = [];

    for (let i = 0; i < shape.vertices.length; i++) {
      const vertex = shape.vertices[i];
      positions.push(vertex.x, vertex.y, vertex.z);
    }

    geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions, 3)); // Add faces

    const indices = [];

    for (let i = 0; i < shape.faces.length; i++) {
      const face = shape.faces[i];
      const a = face[0];

      for (let j = 1; j < face.length - 1; j++) {
        const b = face[j];
        const c = face[j + 1];
        indices.push(a, b, c);
      }
    }

    geometry.setIndex(indices);
    geometry.computeBoundingSphere();
    geometry.computeVertexNormals();
    return geometry;
  }

  function createTrimeshGeometry(shape) {
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    const positions = [];
    const v0 = _tempVec0;
    const v1 = _tempVec1;
    const v2 = _tempVec2;

    for (let i = 0; i < shape.indices.length / 3; i++) {
      shape.getTriangleVertices(i, v0, v1, v2);
      positions.push(v0.x, v0.y, v0.z);
      positions.push(v1.x, v1.y, v1.z);
      positions.push(v2.x, v2.y, v2.z);
    }

    geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    geometry.computeVertexNormals();
    return geometry;
  }

  function createHeightfieldGeometry(shape) {
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    const s = shape.elementSize || 1; // assumes square heightfield, else i*x, j*y

    const positions = shape.data.flatMap((row, i) => row.flatMap((z, j) => [i * s, j * s, z]));
    const indices = [];

    for (let xi = 0; xi < shape.data.length - 1; xi++) {
      for (let yi = 0; yi < shape.data[xi].length - 1; yi++) {
        const stride = shape.data[xi].length;
        const index = xi * stride + yi;
        indices.push(index + 1, index + stride, index + stride + 1);
        indices.push(index + stride, index + 1, index);
      }
    }

    geometry.setIndex(indices);
    geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    geometry.computeVertexNormals();
    return geometry;
  }

  function createMesh(shape) {
    let mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh();
    const {
      SPHERE,
      BOX,
      PLANE,
      CYLINDER,
      CONVEXPOLYHEDRON,
      TRIMESH,
      HEIGHTFIELD
    } = cannon_es__WEBPACK_IMPORTED_MODULE_1__.Shape.types;

    switch (shape.type) {
      case SPHERE:
        {
          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(_sphereGeometry, _material);
          break;
        }

      case BOX:
        {
          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(_boxGeometry, _material);
          break;
        }

      case PLANE:
        {
          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(_planeGeometry, _material);
          break;
        }

      case CYLINDER:
        {
          const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(shape.radiusTop, shape.radiusBottom, shape.height, shape.numSegments);
          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, _material);
          shape.geometryId = geometry.id;
          break;
        }

      case CONVEXPOLYHEDRON:
        {
          const geometry = createConvexPolyhedronGeometry(shape);
          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, _material);
          shape.geometryId = geometry.id;
          break;
        }

      case TRIMESH:
        {
          const geometry = createTrimeshGeometry(shape);
          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, _material);
          shape.geometryId = geometry.id;
          break;
        }

      case HEIGHTFIELD:
        {
          const geometry = createHeightfieldGeometry(shape);
          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, _material);
          shape.geometryId = geometry.id;
          break;
        }
    }

    scene.add(mesh);
    return mesh;
  }

  function scaleMesh(mesh, shape) {
    const {
      SPHERE,
      BOX,
      PLANE,
      CYLINDER,
      CONVEXPOLYHEDRON,
      TRIMESH,
      HEIGHTFIELD
    } = cannon_es__WEBPACK_IMPORTED_MODULE_1__.Shape.types;

    switch (shape.type) {
      case SPHERE:
        {
          const {
            radius
          } = shape;
          mesh.scale.set(radius * scale, radius * scale, radius * scale);
          break;
        }

      case BOX:
        {
          mesh.scale.copy(shape.halfExtents);
          mesh.scale.multiplyScalar(2 * scale);
          break;
        }

      case PLANE:
        {
          break;
        }

      case CYLINDER:
        {
          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);
          break;
        }

      case CONVEXPOLYHEDRON:
        {
          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);
          break;
        }

      case TRIMESH:
        {
          mesh.scale.copy(shape.scale).multiplyScalar(scale);
          break;
        }

      case HEIGHTFIELD:
        {
          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);
          break;
        }
    }
  }

  function typeMatch(mesh, shape) {
    if (!mesh) return false;
    const {
      geometry
    } = mesh;
    return geometry instanceof three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry && shape.type === cannon_es__WEBPACK_IMPORTED_MODULE_1__.Shape.types.SPHERE || geometry instanceof three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry && shape.type === cannon_es__WEBPACK_IMPORTED_MODULE_1__.Shape.types.BOX || geometry instanceof three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry && shape.type === cannon_es__WEBPACK_IMPORTED_MODULE_1__.Shape.types.PLANE || geometry.id === shape.geometryId && shape.type === cannon_es__WEBPACK_IMPORTED_MODULE_1__.Shape.types.CYLINDER || geometry.id === shape.geometryId && shape.type === cannon_es__WEBPACK_IMPORTED_MODULE_1__.Shape.types.CONVEXPOLYHEDRON || geometry.id === shape.geometryId && shape.type === cannon_es__WEBPACK_IMPORTED_MODULE_1__.Shape.types.TRIMESH || geometry.id === shape.geometryId && shape.type === cannon_es__WEBPACK_IMPORTED_MODULE_1__.Shape.types.HEIGHTFIELD;
  }

  function updateMesh(index, shape) {
    let mesh = _meshes[index];
    let didCreateNewMesh = false;

    if (!typeMatch(mesh, shape)) {
      if (mesh) scene.remove(mesh);
      _meshes[index] = mesh = createMesh(shape);
      didCreateNewMesh = true;
    }

    scaleMesh(mesh, shape);
    return didCreateNewMesh;
  }

  function update() {
    const meshes = _meshes;
    const shapeWorldPosition = _tempVec0;
    const shapeWorldQuaternion = _tempQuat0;
    let meshIndex = 0;

    for (const body of world.bodies) {
      for (let i = 0; i !== body.shapes.length; i++) {
        const shape = body.shapes[i];
        const didCreateNewMesh = updateMesh(meshIndex, shape);
        const mesh = meshes[meshIndex];

        if (mesh) {
          // Get world position
          body.quaternion.vmult(body.shapeOffsets[i], shapeWorldPosition);
          body.position.vadd(shapeWorldPosition, shapeWorldPosition); // Get world quaternion

          body.quaternion.mult(body.shapeOrientations[i], shapeWorldQuaternion); // Copy to meshes

          mesh.position.copy(shapeWorldPosition);
          mesh.quaternion.copy(shapeWorldQuaternion);
          if (didCreateNewMesh && onInit instanceof Function) onInit(body, mesh, shape);
          if (!didCreateNewMesh && onUpdate instanceof Function) onUpdate(body, mesh, shape);
        }

        meshIndex++;
      }
    }

    for (let i = meshIndex; i < meshes.length; i++) {
      const mesh = meshes[i];
      if (mesh) scene.remove(mesh);
    }

    meshes.length = meshIndex;
  }

  return {
    update
  };
}




/***/ }),

/***/ "./node_modules/cannon-es/dist/cannon-es.js":
/*!**************************************************!*\
  !*** ./node_modules/cannon-es/dist/cannon-es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AABB": () => (/* binding */ AABB),
/* harmony export */   "ArrayCollisionMatrix": () => (/* binding */ ArrayCollisionMatrix),
/* harmony export */   "BODY_SLEEP_STATES": () => (/* binding */ BODY_SLEEP_STATES),
/* harmony export */   "BODY_TYPES": () => (/* binding */ BODY_TYPES),
/* harmony export */   "Body": () => (/* binding */ Body),
/* harmony export */   "Box": () => (/* binding */ Box),
/* harmony export */   "Broadphase": () => (/* binding */ Broadphase),
/* harmony export */   "COLLISION_TYPES": () => (/* binding */ COLLISION_TYPES),
/* harmony export */   "ConeTwistConstraint": () => (/* binding */ ConeTwistConstraint),
/* harmony export */   "Constraint": () => (/* binding */ Constraint),
/* harmony export */   "ContactEquation": () => (/* binding */ ContactEquation),
/* harmony export */   "ContactMaterial": () => (/* binding */ ContactMaterial),
/* harmony export */   "ConvexPolyhedron": () => (/* binding */ ConvexPolyhedron),
/* harmony export */   "Cylinder": () => (/* binding */ Cylinder),
/* harmony export */   "DistanceConstraint": () => (/* binding */ DistanceConstraint),
/* harmony export */   "Equation": () => (/* binding */ Equation),
/* harmony export */   "EventTarget": () => (/* binding */ EventTarget),
/* harmony export */   "FrictionEquation": () => (/* binding */ FrictionEquation),
/* harmony export */   "GSSolver": () => (/* binding */ GSSolver),
/* harmony export */   "GridBroadphase": () => (/* binding */ GridBroadphase),
/* harmony export */   "Heightfield": () => (/* binding */ Heightfield),
/* harmony export */   "HingeConstraint": () => (/* binding */ HingeConstraint),
/* harmony export */   "JacobianElement": () => (/* binding */ JacobianElement),
/* harmony export */   "LockConstraint": () => (/* binding */ LockConstraint),
/* harmony export */   "Mat3": () => (/* binding */ Mat3),
/* harmony export */   "Material": () => (/* binding */ Material),
/* harmony export */   "NaiveBroadphase": () => (/* binding */ NaiveBroadphase),
/* harmony export */   "Narrowphase": () => (/* binding */ Narrowphase),
/* harmony export */   "ObjectCollisionMatrix": () => (/* binding */ ObjectCollisionMatrix),
/* harmony export */   "Particle": () => (/* binding */ Particle),
/* harmony export */   "Plane": () => (/* binding */ Plane),
/* harmony export */   "PointToPointConstraint": () => (/* binding */ PointToPointConstraint),
/* harmony export */   "Pool": () => (/* binding */ Pool),
/* harmony export */   "Quaternion": () => (/* binding */ Quaternion),
/* harmony export */   "RAY_MODES": () => (/* binding */ RAY_MODES),
/* harmony export */   "Ray": () => (/* binding */ Ray),
/* harmony export */   "RaycastResult": () => (/* binding */ RaycastResult),
/* harmony export */   "RaycastVehicle": () => (/* binding */ RaycastVehicle),
/* harmony export */   "RigidVehicle": () => (/* binding */ RigidVehicle),
/* harmony export */   "RotationalEquation": () => (/* binding */ RotationalEquation),
/* harmony export */   "RotationalMotorEquation": () => (/* binding */ RotationalMotorEquation),
/* harmony export */   "SAPBroadphase": () => (/* binding */ SAPBroadphase),
/* harmony export */   "SHAPE_TYPES": () => (/* binding */ SHAPE_TYPES),
/* harmony export */   "SPHSystem": () => (/* binding */ SPHSystem),
/* harmony export */   "Shape": () => (/* binding */ Shape),
/* harmony export */   "Solver": () => (/* binding */ Solver),
/* harmony export */   "Sphere": () => (/* binding */ Sphere),
/* harmony export */   "SplitSolver": () => (/* binding */ SplitSolver),
/* harmony export */   "Spring": () => (/* binding */ Spring),
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "Trimesh": () => (/* binding */ Trimesh),
/* harmony export */   "Vec3": () => (/* binding */ Vec3),
/* harmony export */   "Vec3Pool": () => (/* binding */ Vec3Pool),
/* harmony export */   "WheelInfo": () => (/* binding */ WheelInfo),
/* harmony export */   "World": () => (/* binding */ World)
/* harmony export */ });
/**
 * Records what objects are colliding with each other
 */
class ObjectCollisionMatrix {
  /**
   * The matrix storage.
   */

  /**
   * @todo Remove useless constructor
   */
  constructor() {
    this.matrix = {};
  }
  /**
   * get
   */


  get(bi, bj) {
    let {
      id: i
    } = bi;
    let {
      id: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    return `${i}-${j}` in this.matrix;
  }
  /**
   * set
   */


  set(bi, bj, value) {
    let {
      id: i
    } = bi;
    let {
      id: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    if (value) {
      this.matrix[`${i}-${j}`] = true;
    } else {
      delete this.matrix[`${i}-${j}`];
    }
  }
  /**
   * Empty the matrix
   */


  reset() {
    this.matrix = {};
  }
  /**
   * Set max number of objects
   */


  setNumObjects(n) {}

}

/**
 * A 3x3 matrix.
 * Authored by {@link http://github.com/schteppe/ schteppe}
 */
class Mat3 {
  /**
   * A vector of length 9, containing all matrix elements.
   */

  /**
   * @param elements A vector of length 9, containing all matrix elements.
   */
  constructor(elements) {
    if (elements === void 0) {
      elements = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    this.elements = elements;
  }
  /**
   * Sets the matrix to identity
   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
   * @todo Create another function that immediately creates an identity matrix eg. `eye()`
   */


  identity() {
    const e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 1;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
  }
  /**
   * Set all elements to zero
   */


  setZero() {
    const e = this.elements;
    e[0] = 0;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
  }
  /**
   * Sets the matrix diagonal elements from a Vec3
   */


  setTrace(vector) {
    const e = this.elements;
    e[0] = vector.x;
    e[4] = vector.y;
    e[8] = vector.z;
  }
  /**
   * Gets the matrix diagonal elements
   */


  getTrace(target) {
    if (target === void 0) {
      target = new Vec3();
    }

    const e = this.elements;
    target.x = e[0];
    target.y = e[4];
    target.z = e[8];
    return target;
  }
  /**
   * Matrix-Vector multiplication
   * @param v The vector to multiply with
   * @param target Optional, target to save the result in.
   */


  vmult(v, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    const e = this.elements;
    const x = v.x;
    const y = v.y;
    const z = v.z;
    target.x = e[0] * x + e[1] * y + e[2] * z;
    target.y = e[3] * x + e[4] * y + e[5] * z;
    target.z = e[6] * x + e[7] * y + e[8] * z;
    return target;
  }
  /**
   * Matrix-scalar multiplication
   */


  smult(s) {
    for (let i = 0; i < this.elements.length; i++) {
      this.elements[i] *= s;
    }
  }
  /**
   * Matrix multiplication
   * @param matrix Matrix to multiply with from left side.
   */


  mmult(matrix, target) {
    if (target === void 0) {
      target = new Mat3();
    }

    const A = this.elements;
    const B = matrix.elements;
    const T = target.elements;
    const a11 = A[0],
          a12 = A[1],
          a13 = A[2],
          a21 = A[3],
          a22 = A[4],
          a23 = A[5],
          a31 = A[6],
          a32 = A[7],
          a33 = A[8];
    const b11 = B[0],
          b12 = B[1],
          b13 = B[2],
          b21 = B[3],
          b22 = B[4],
          b23 = B[5],
          b31 = B[6],
          b32 = B[7],
          b33 = B[8];
    T[0] = a11 * b11 + a12 * b21 + a13 * b31;
    T[1] = a11 * b12 + a12 * b22 + a13 * b32;
    T[2] = a11 * b13 + a12 * b23 + a13 * b33;
    T[3] = a21 * b11 + a22 * b21 + a23 * b31;
    T[4] = a21 * b12 + a22 * b22 + a23 * b32;
    T[5] = a21 * b13 + a22 * b23 + a23 * b33;
    T[6] = a31 * b11 + a32 * b21 + a33 * b31;
    T[7] = a31 * b12 + a32 * b22 + a33 * b32;
    T[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return target;
  }
  /**
   * Scale each column of the matrix
   */


  scale(vector, target) {
    if (target === void 0) {
      target = new Mat3();
    }

    const e = this.elements;
    const t = target.elements;

    for (let i = 0; i !== 3; i++) {
      t[3 * i + 0] = vector.x * e[3 * i + 0];
      t[3 * i + 1] = vector.y * e[3 * i + 1];
      t[3 * i + 2] = vector.z * e[3 * i + 2];
    }

    return target;
  }
  /**
   * Solve Ax=b
   * @param b The right hand side
   * @param target Optional. Target vector to save in.
   * @return The solution x
   * @todo should reuse arrays
   */


  solve(b, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    // Construct equations
    const nr = 3; // num rows

    const nc = 4; // num cols

    const eqns = [];
    let i;
    let j;

    for (i = 0; i < nr * nc; i++) {
      eqns.push(0);
    }

    for (i = 0; i < 3; i++) {
      for (j = 0; j < 3; j++) {
        eqns[i + nc * j] = this.elements[i + 3 * j];
      }
    }

    eqns[3 + 4 * 0] = b.x;
    eqns[3 + 4 * 1] = b.y;
    eqns[3 + 4 * 2] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination

    let n = 3;
    const k = n;
    let np;
    const kp = 4; // num rows

    let p;

    do {
      i = k - n;

      if (eqns[i + nc * i] === 0) {
        // the pivot is null, swap lines
        for (j = i + 1; j < k; j++) {
          if (eqns[i + nc * j] !== 0) {
            np = kp;

            do {
              // do ligne( i ) = ligne( i ) + ligne( k )
              p = kp - np;
              eqns[p + nc * i] += eqns[p + nc * j];
            } while (--np);

            break;
          }
        }
      }

      if (eqns[i + nc * i] !== 0) {
        for (j = i + 1; j < k; j++) {
          const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
          np = kp;

          do {
            // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
            p = kp - np;
            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
          } while (--np);
        }
      }
    } while (--n); // Get the solution


    target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
    target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
    target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];

    if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
      throw `Could not solve equation! Got x=[${target.toString()}], b=[${b.toString()}], A=[${this.toString()}]`;
    }

    return target;
  }
  /**
   * Get an element in the matrix by index. Index starts at 0, not 1!!!
   * @param value If provided, the matrix element will be set to this value.
   */


  e(row, column, value) {
    if (value === undefined) {
      return this.elements[column + 3 * row];
    } else {
      // Set value
      this.elements[column + 3 * row] = value;
    }
  }
  /**
   * Copy another matrix into this matrix object.
   */


  copy(matrix) {
    for (let i = 0; i < matrix.elements.length; i++) {
      this.elements[i] = matrix.elements[i];
    }

    return this;
  }
  /**
   * Returns a string representation of the matrix.
   */


  toString() {
    let r = '';
    const sep = ',';

    for (let i = 0; i < 9; i++) {
      r += this.elements[i] + sep;
    }

    return r;
  }
  /**
   * reverse the matrix
   * @param target Target matrix to save in.
   * @return The solution x
   */


  reverse(target) {
    if (target === void 0) {
      target = new Mat3();
    }

    // Construct equations
    const nr = 3; // num rows

    const nc = 6; // num cols

    const eqns = reverse_eqns;
    let i;
    let j;

    for (i = 0; i < 3; i++) {
      for (j = 0; j < 3; j++) {
        eqns[i + nc * j] = this.elements[i + 3 * j];
      }
    }

    eqns[3 + 6 * 0] = 1;
    eqns[3 + 6 * 1] = 0;
    eqns[3 + 6 * 2] = 0;
    eqns[4 + 6 * 0] = 0;
    eqns[4 + 6 * 1] = 1;
    eqns[4 + 6 * 2] = 0;
    eqns[5 + 6 * 0] = 0;
    eqns[5 + 6 * 1] = 0;
    eqns[5 + 6 * 2] = 1; // Compute right upper triangular version of the matrix - Gauss elimination

    let n = 3;
    const k = n;
    let np;
    const kp = nc; // num rows

    let p;

    do {
      i = k - n;

      if (eqns[i + nc * i] === 0) {
        // the pivot is null, swap lines
        for (j = i + 1; j < k; j++) {
          if (eqns[i + nc * j] !== 0) {
            np = kp;

            do {
              // do line( i ) = line( i ) + line( k )
              p = kp - np;
              eqns[p + nc * i] += eqns[p + nc * j];
            } while (--np);

            break;
          }
        }
      }

      if (eqns[i + nc * i] !== 0) {
        for (j = i + 1; j < k; j++) {
          const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
          np = kp;

          do {
            // do line( k ) = line( k ) - multiplier * line( i )
            p = kp - np;
            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
          } while (--np);
        }
      }
    } while (--n); // eliminate the upper left triangle of the matrix


    i = 2;

    do {
      j = i - 1;

      do {
        const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
        np = nc;

        do {
          p = nc - np;
          eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
        } while (--np);
      } while (j--);
    } while (--i); // operations on the diagonal


    i = 2;

    do {
      const multiplier = 1 / eqns[i + nc * i];
      np = nc;

      do {
        p = nc - np;
        eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
      } while (--np);
    } while (i--);

    i = 2;

    do {
      j = 2;

      do {
        p = eqns[nr + j + nc * i];

        if (isNaN(p) || p === Infinity) {
          throw `Could not reverse! A=[${this.toString()}]`;
        }

        target.e(i, j, p);
      } while (j--);
    } while (i--);

    return target;
  }
  /**
   * Set the matrix from a quaterion
   */


  setRotationFromQuaternion(q) {
    const x = q.x;
    const y = q.y;
    const z = q.z;
    const w = q.w;
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    const e = this.elements;
    e[3 * 0 + 0] = 1 - (yy + zz);
    e[3 * 0 + 1] = xy - wz;
    e[3 * 0 + 2] = xz + wy;
    e[3 * 1 + 0] = xy + wz;
    e[3 * 1 + 1] = 1 - (xx + zz);
    e[3 * 1 + 2] = yz - wx;
    e[3 * 2 + 0] = xz - wy;
    e[3 * 2 + 1] = yz + wx;
    e[3 * 2 + 2] = 1 - (xx + yy);
    return this;
  }
  /**
   * Transpose the matrix
   * @param target Optional. Where to store the result.
   * @return The target Mat3, or a new Mat3 if target was omitted.
   */


  transpose(target) {
    if (target === void 0) {
      target = new Mat3();
    }

    const M = this.elements;
    const T = target.elements;
    let tmp; //Set diagonals

    T[0] = M[0];
    T[4] = M[4];
    T[8] = M[8];
    tmp = M[1];
    T[1] = M[3];
    T[3] = tmp;
    tmp = M[2];
    T[2] = M[6];
    T[6] = tmp;
    tmp = M[5];
    T[5] = M[7];
    T[7] = tmp;
    return target;
  }

}
const reverse_eqns = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

/**
 * 3-dimensional vector
 * @example
 *     const v = new Vec3(1, 2, 3)
 *     console.log('x=' + v.x) // x=1
 */

class Vec3 {
  constructor(x, y, z) {
    if (x === void 0) {
      x = 0.0;
    }

    if (y === void 0) {
      y = 0.0;
    }

    if (z === void 0) {
      z = 0.0;
    }

    this.x = x;
    this.y = y;
    this.z = z;
  }
  /**
   * Vector cross product
   * @param target Optional target to save in.
   */


  cross(vector, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    const vx = vector.x;
    const vy = vector.y;
    const vz = vector.z;
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = y * vz - z * vy;
    target.y = z * vx - x * vz;
    target.z = x * vy - y * vx;
    return target;
  }
  /**
   * Set the vectors' 3 elements
   */


  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  /**
   * Set all components of the vector to zero.
   */


  setZero() {
    this.x = this.y = this.z = 0;
  }
  /**
   * Vector addition
   */


  vadd(vector, target) {
    if (target) {
      target.x = vector.x + this.x;
      target.y = vector.y + this.y;
      target.z = vector.z + this.z;
    } else {
      return new Vec3(this.x + vector.x, this.y + vector.y, this.z + vector.z);
    }
  }
  /**
   * Vector subtraction
   * @param target Optional target to save in.
   */


  vsub(vector, target) {
    if (target) {
      target.x = this.x - vector.x;
      target.y = this.y - vector.y;
      target.z = this.z - vector.z;
    } else {
      return new Vec3(this.x - vector.x, this.y - vector.y, this.z - vector.z);
    }
  }
  /**
   * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
   *
   * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Umeå University Lecture}
   */


  crossmat() {
    return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  /**
   * Normalize the vector. Note that this changes the values in the vector.
    * @return Returns the norm of the vector
   */


  normalize() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const n = Math.sqrt(x * x + y * y + z * z);

    if (n > 0.0) {
      const invN = 1 / n;
      this.x *= invN;
      this.y *= invN;
      this.z *= invN;
    } else {
      // Make something up
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }

    return n;
  }
  /**
   * Get the version of this vector that is of length 1.
   * @param target Optional target to save in
   * @return Returns the unit vector
   */


  unit(target) {
    if (target === void 0) {
      target = new Vec3();
    }

    const x = this.x;
    const y = this.y;
    const z = this.z;
    let ninv = Math.sqrt(x * x + y * y + z * z);

    if (ninv > 0.0) {
      ninv = 1.0 / ninv;
      target.x = x * ninv;
      target.y = y * ninv;
      target.z = z * ninv;
    } else {
      target.x = 1;
      target.y = 0;
      target.z = 0;
    }

    return target;
  }
  /**
   * Get the length of the vector
   */


  length() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Get the squared length of the vector.
   */


  lengthSquared() {
    return this.dot(this);
  }
  /**
   * Get distance from this point to another point
   */


  distanceTo(p) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const px = p.x;
    const py = p.y;
    const pz = p.z;
    return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
  }
  /**
   * Get squared distance from this point to another point
   */


  distanceSquared(p) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const px = p.x;
    const py = p.y;
    const pz = p.z;
    return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
  }
  /**
   * Multiply all the components of the vector with a scalar.
   * @param target The vector to save the result in.
   */


  scale(scalar, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = scalar * x;
    target.y = scalar * y;
    target.z = scalar * z;
    return target;
  }
  /**
   * Multiply the vector with an other vector, component-wise.
   * @param target The vector to save the result in.
   */


  vmul(vector, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    target.x = vector.x * this.x;
    target.y = vector.y * this.y;
    target.z = vector.z * this.z;
    return target;
  }
  /**
   * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
   * @param target The vector to save the result in.
   */


  addScaledVector(scalar, vector, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    target.x = this.x + scalar * vector.x;
    target.y = this.y + scalar * vector.y;
    target.z = this.z + scalar * vector.z;
    return target;
  }
  /**
   * Calculate dot product
   * @param vector
   */


  dot(vector) {
    return this.x * vector.x + this.y * vector.y + this.z * vector.z;
  }

  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  /**
   * Make the vector point in the opposite direction.
   * @param target Optional target to save in
   */


  negate(target) {
    if (target === void 0) {
      target = new Vec3();
    }

    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    return target;
  }
  /**
   * Compute two artificial tangents to the vector
   * @param t1 Vector object to save the first tangent in
   * @param t2 Vector object to save the second tangent in
   */


  tangents(t1, t2) {
    const norm = this.length();

    if (norm > 0.0) {
      const n = Vec3_tangents_n;
      const inorm = 1 / norm;
      n.set(this.x * inorm, this.y * inorm, this.z * inorm);
      const randVec = Vec3_tangents_randVec;

      if (Math.abs(n.x) < 0.9) {
        randVec.set(1, 0, 0);
        n.cross(randVec, t1);
      } else {
        randVec.set(0, 1, 0);
        n.cross(randVec, t1);
      }

      n.cross(t1, t2);
    } else {
      // The normal length is zero, make something up
      t1.set(1, 0, 0);
      t2.set(0, 1, 0);
    }
  }
  /**
   * Converts to a more readable format
   */


  toString() {
    return `${this.x},${this.y},${this.z}`;
  }
  /**
   * Converts to an array
   */


  toArray() {
    return [this.x, this.y, this.z];
  }
  /**
   * Copies value of source to this vector.
   */


  copy(vector) {
    this.x = vector.x;
    this.y = vector.y;
    this.z = vector.z;
    return this;
  }
  /**
   * Do a linear interpolation between two vectors
   * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
   */


  lerp(vector, t, target) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = x + (vector.x - x) * t;
    target.y = y + (vector.y - y) * t;
    target.z = z + (vector.z - z) * t;
  }
  /**
   * Check if a vector equals is almost equal to another one.
   */


  almostEquals(vector, precision) {
    if (precision === void 0) {
      precision = 1e-6;
    }

    if (Math.abs(this.x - vector.x) > precision || Math.abs(this.y - vector.y) > precision || Math.abs(this.z - vector.z) > precision) {
      return false;
    }

    return true;
  }
  /**
   * Check if a vector is almost zero
   */


  almostZero(precision) {
    if (precision === void 0) {
      precision = 1e-6;
    }

    if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) {
      return false;
    }

    return true;
  }
  /**
   * Check if the vector is anti-parallel to another vector.
   * @param precision Set to zero for exact comparisons
   */


  isAntiparallelTo(vector, precision) {
    this.negate(antip_neg);
    return antip_neg.almostEquals(vector, precision);
  }
  /**
   * Clone the vector
   */


  clone() {
    return new Vec3(this.x, this.y, this.z);
  }

}
Vec3.ZERO = new Vec3(0, 0, 0);
Vec3.UNIT_X = new Vec3(1, 0, 0);
Vec3.UNIT_Y = new Vec3(0, 1, 0);
Vec3.UNIT_Z = new Vec3(0, 0, 1);
const Vec3_tangents_n = new Vec3();
const Vec3_tangents_randVec = new Vec3();
const antip_neg = new Vec3();

/**
 * Axis aligned bounding box class.
 */
class AABB {
  /**
   * The lower bound of the bounding box
   */

  /**
   * The upper bound of the bounding box
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }

    this.lowerBound = new Vec3();
    this.upperBound = new Vec3();

    if (options.lowerBound) {
      this.lowerBound.copy(options.lowerBound);
    }

    if (options.upperBound) {
      this.upperBound.copy(options.upperBound);
    }
  }
  /**
   * Set the AABB bounds from a set of points.
   * @param points An array of Vec3's.
   * @return The self object
   */


  setFromPoints(points, position, quaternion, skinSize) {
    const l = this.lowerBound;
    const u = this.upperBound;
    const q = quaternion; // Set to the first point

    l.copy(points[0]);

    if (q) {
      q.vmult(l, l);
    }

    u.copy(l);

    for (let i = 1; i < points.length; i++) {
      let p = points[i];

      if (q) {
        q.vmult(p, tmp$1);
        p = tmp$1;
      }

      if (p.x > u.x) {
        u.x = p.x;
      }

      if (p.x < l.x) {
        l.x = p.x;
      }

      if (p.y > u.y) {
        u.y = p.y;
      }

      if (p.y < l.y) {
        l.y = p.y;
      }

      if (p.z > u.z) {
        u.z = p.z;
      }

      if (p.z < l.z) {
        l.z = p.z;
      }
    } // Add offset


    if (position) {
      position.vadd(l, l);
      position.vadd(u, u);
    }

    if (skinSize) {
      l.x -= skinSize;
      l.y -= skinSize;
      l.z -= skinSize;
      u.x += skinSize;
      u.y += skinSize;
      u.z += skinSize;
    }

    return this;
  }
  /**
   * Copy bounds from an AABB to this AABB
   * @param aabb Source to copy from
   * @return The this object, for chainability
   */


  copy(aabb) {
    this.lowerBound.copy(aabb.lowerBound);
    this.upperBound.copy(aabb.upperBound);
    return this;
  }
  /**
   * Clone an AABB
   */


  clone() {
    return new AABB().copy(this);
  }
  /**
   * Extend this AABB so that it covers the given AABB too.
   */


  extend(aabb) {
    this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
    this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
    this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
    this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
    this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
    this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
  }
  /**
   * Returns true if the given AABB overlaps this AABB.
   */


  overlaps(aabb) {
    const l1 = this.lowerBound;
    const u1 = this.upperBound;
    const l2 = aabb.lowerBound;
    const u2 = aabb.upperBound; //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    const overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;
    const overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;
    const overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;
    return overlapsX && overlapsY && overlapsZ;
  } // Mostly for debugging


  volume() {
    const l = this.lowerBound;
    const u = this.upperBound;
    return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
  }
  /**
   * Returns true if the given AABB is fully contained in this AABB.
   */


  contains(aabb) {
    const l1 = this.lowerBound;
    const u1 = this.upperBound;
    const l2 = aabb.lowerBound;
    const u2 = aabb.upperBound; //      l2        u2
    //      |---------|
    // |---------------|
    // l1              u1

    return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
  }

  getCorners(a, b, c, d, e, f, g, h) {
    const l = this.lowerBound;
    const u = this.upperBound;
    a.copy(l);
    b.set(u.x, l.y, l.z);
    c.set(u.x, u.y, l.z);
    d.set(l.x, u.y, u.z);
    e.set(u.x, l.y, u.z);
    f.set(l.x, u.y, l.z);
    g.set(l.x, l.y, u.z);
    h.copy(u);
  }
  /**
   * Get the representation of an AABB in another frame.
   * @return The "target" AABB object.
   */


  toLocalFrame(frame, target) {
    const corners = transformIntoFrame_corners;
    const a = corners[0];
    const b = corners[1];
    const c = corners[2];
    const d = corners[3];
    const e = corners[4];
    const f = corners[5];
    const g = corners[6];
    const h = corners[7]; // Get corners in current frame

    this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

    for (let i = 0; i !== 8; i++) {
      const corner = corners[i];
      frame.pointToLocal(corner, corner);
    }

    return target.setFromPoints(corners);
  }
  /**
   * Get the representation of an AABB in the global frame.
   * @return The "target" AABB object.
   */


  toWorldFrame(frame, target) {
    const corners = transformIntoFrame_corners;
    const a = corners[0];
    const b = corners[1];
    const c = corners[2];
    const d = corners[3];
    const e = corners[4];
    const f = corners[5];
    const g = corners[6];
    const h = corners[7]; // Get corners in current frame

    this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

    for (let i = 0; i !== 8; i++) {
      const corner = corners[i];
      frame.pointToWorld(corner, corner);
    }

    return target.setFromPoints(corners);
  }
  /**
   * Check if the AABB is hit by a ray.
   */


  overlapsRay(ray) {
    const {
      direction,
      from
    } = ray; // const t = 0
    // ray.direction is unit direction vector of ray

    const dirFracX = 1 / direction.x;
    const dirFracY = 1 / direction.y;
    const dirFracZ = 1 / direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner

    const t1 = (this.lowerBound.x - from.x) * dirFracX;
    const t2 = (this.upperBound.x - from.x) * dirFracX;
    const t3 = (this.lowerBound.y - from.y) * dirFracY;
    const t4 = (this.upperBound.y - from.y) * dirFracY;
    const t5 = (this.lowerBound.z - from.z) * dirFracZ;
    const t6 = (this.upperBound.z - from.z) * dirFracZ; // const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
    // const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));

    const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us

    if (tmax < 0) {
      //t = tmax;
      return false;
    } // if tmin > tmax, ray doesn't intersect AABB


    if (tmin > tmax) {
      //t = tmax;
      return false;
    }

    return true;
  }

}
const tmp$1 = new Vec3();
const transformIntoFrame_corners = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

/**
 * Collision "matrix".
 * It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
 */
class ArrayCollisionMatrix {
  /**
   * The matrix storage.
   */
  constructor() {
    this.matrix = [];
  }
  /**
   * Get an element
   */


  get(bi, bj) {
    let {
      index: i
    } = bi;
    let {
      index: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    return this.matrix[(i * (i + 1) >> 1) + j - 1];
  }
  /**
   * Set an element
   */


  set(bi, bj, value) {
    let {
      index: i
    } = bi;
    let {
      index: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
  }
  /**
   * Sets all elements to zero
   */


  reset() {
    for (let i = 0, l = this.matrix.length; i !== l; i++) {
      this.matrix[i] = 0;
    }
  }
  /**
   * Sets the max number of objects
   */


  setNumObjects(n) {
    this.matrix.length = n * (n - 1) >> 1;
  }

}

/**
 * Base class for objects that dispatches events.
 */
class EventTarget {
  /**
   * Add an event listener
   * @return The self object, for chainability.
   */
  addEventListener(type, listener) {
    if (this._listeners === undefined) {
      this._listeners = {};
    }

    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (!listeners[type].includes(listener)) {
      listeners[type].push(listener);
    }

    return this;
  }
  /**
   * Check if an event listener is added
   */


  hasEventListener(type, listener) {
    if (this._listeners === undefined) {
      return false;
    }

    const listeners = this._listeners;

    if (listeners[type] !== undefined && listeners[type].includes(listener)) {
      return true;
    }

    return false;
  }
  /**
   * Check if any event listener of the given type is added
   */


  hasAnyEventListener(type) {
    if (this._listeners === undefined) {
      return false;
    }

    const listeners = this._listeners;
    return listeners[type] !== undefined;
  }
  /**
   * Remove an event listener
   * @return The self object, for chainability.
   */


  removeEventListener(type, listener) {
    if (this._listeners === undefined) {
      return this;
    }

    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      return this;
    }

    const index = listeners[type].indexOf(listener);

    if (index !== -1) {
      listeners[type].splice(index, 1);
    }

    return this;
  }
  /**
   * Emit an event.
   * @return The self object, for chainability.
   */


  dispatchEvent(event) {
    if (this._listeners === undefined) {
      return this;
    }

    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this;

      for (let i = 0, l = listenerArray.length; i < l; i++) {
        listenerArray[i].call(this, event);
      }
    }

    return this;
  }

}

/**
 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
 * @param x Multiplier of the imaginary basis vector i.
 * @param y Multiplier of the imaginary basis vector j.
 * @param z Multiplier of the imaginary basis vector k.
 * @param w Multiplier of the real part.
 * @see http://en.wikipedia.org/wiki/Quaternion
 */

class Quaternion {
  constructor(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }

    if (y === void 0) {
      y = 0;
    }

    if (z === void 0) {
      z = 0;
    }

    if (w === void 0) {
      w = 1;
    }

    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  /**
   * Set the value of the quaternion.
   */


  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  /**
   * Convert to a readable format
   * @return "x,y,z,w"
   */


  toString() {
    return `${this.x},${this.y},${this.z},${this.w}`;
  }
  /**
   * Convert to an Array
   * @return [x, y, z, w]
   */


  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  /**
   * Set the quaternion components given an axis and an angle in radians.
   */


  setFromAxisAngle(vector, angle) {
    const s = Math.sin(angle * 0.5);
    this.x = vector.x * s;
    this.y = vector.y * s;
    this.z = vector.z * s;
    this.w = Math.cos(angle * 0.5);
    return this;
  }
  /**
   * Converts the quaternion to [ axis, angle ] representation.
   * @param targetAxis A vector object to reuse for storing the axis.
   * @return An array, first element is the axis and the second is the angle in radians.
   */


  toAxisAngle(targetAxis) {
    if (targetAxis === void 0) {
      targetAxis = new Vec3();
    }

    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised

    const angle = 2 * Math.acos(this.w);
    const s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.

    if (s < 0.001) {
      // test to avoid divide by zero, s is always positive due to sqrt
      // if s close to zero then direction of axis not important
      targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;

      targetAxis.y = this.y;
      targetAxis.z = this.z;
    } else {
      targetAxis.x = this.x / s; // normalise axis

      targetAxis.y = this.y / s;
      targetAxis.z = this.z / s;
    }

    return [targetAxis, angle];
  }
  /**
   * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
   */


  setFromVectors(u, v) {
    if (u.isAntiparallelTo(v)) {
      const t1 = sfv_t1;
      const t2 = sfv_t2;
      u.tangents(t1, t2);
      this.setFromAxisAngle(t1, Math.PI);
    } else {
      const a = u.cross(v);
      this.x = a.x;
      this.y = a.y;
      this.z = a.z;
      this.w = Math.sqrt(u.length() ** 2 * v.length() ** 2) + u.dot(v);
      this.normalize();
    }

    return this;
  }
  /**
   * Multiply the quaternion with an other quaternion.
   */


  mult(quat, target) {
    if (target === void 0) {
      target = new Quaternion();
    }

    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    const bx = quat.x;
    const by = quat.y;
    const bz = quat.z;
    const bw = quat.w;
    target.x = ax * bw + aw * bx + ay * bz - az * by;
    target.y = ay * bw + aw * by + az * bx - ax * bz;
    target.z = az * bw + aw * bz + ax * by - ay * bx;
    target.w = aw * bw - ax * bx - ay * by - az * bz;
    return target;
  }
  /**
   * Get the inverse quaternion rotation.
   */


  inverse(target) {
    if (target === void 0) {
      target = new Quaternion();
    }

    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;
    this.conjugate(target);
    const inorm2 = 1 / (x * x + y * y + z * z + w * w);
    target.x *= inorm2;
    target.y *= inorm2;
    target.z *= inorm2;
    target.w *= inorm2;
    return target;
  }
  /**
   * Get the quaternion conjugate
   */


  conjugate(target) {
    if (target === void 0) {
      target = new Quaternion();
    }

    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    target.w = this.w;
    return target;
  }
  /**
   * Normalize the quaternion. Note that this changes the values of the quaternion.
   */


  normalize() {
    let l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

    if (l === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    } else {
      l = 1 / l;
      this.x *= l;
      this.y *= l;
      this.z *= l;
      this.w *= l;
    }

    return this;
  }
  /**
   * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
   * @author unphased, https://github.com/unphased
   */


  normalizeFast() {
    const f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;

    if (f === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    } else {
      this.x *= f;
      this.y *= f;
      this.z *= f;
      this.w *= f;
    }

    return this;
  }
  /**
   * Multiply the quaternion by a vector
   */


  vmult(v, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    const x = v.x;
    const y = v.y;
    const z = v.z;
    const qx = this.x;
    const qy = this.y;
    const qz = this.z;
    const qw = this.w; // q*v

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return target;
  }
  /**
   * Copies value of source to this quaternion.
   * @return this
   */


  copy(quat) {
    this.x = quat.x;
    this.y = quat.y;
    this.z = quat.z;
    this.w = quat.w;
    return this;
  }
  /**
   * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
   * @param order Three-character string, defaults to "YZX"
   */


  toEuler(target, order) {
    if (order === void 0) {
      order = 'YZX';
    }

    let heading;
    let attitude;
    let bank;
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;

    switch (order) {
      case 'YZX':
        const test = x * y + z * w;

        if (test > 0.499) {
          // singularity at north pole
          heading = 2 * Math.atan2(x, w);
          attitude = Math.PI / 2;
          bank = 0;
        }

        if (test < -0.499) {
          // singularity at south pole
          heading = -2 * Math.atan2(x, w);
          attitude = -Math.PI / 2;
          bank = 0;
        }

        if (heading === undefined) {
          const sqx = x * x;
          const sqy = y * y;
          const sqz = z * z;
          heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading

          attitude = Math.asin(2 * test); // attitude

          bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank
        }

        break;

      default:
        throw new Error(`Euler order ${order} not supported yet.`);
    }

    target.y = heading;
    target.z = attitude;
    target.x = bank;
  }
  /**
   * Set the quaternion components given Euler angle representation.
   *
   * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
   *
   * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
   */


  setFromEuler(x, y, z, order) {
    if (order === void 0) {
      order = 'XYZ';
    }

    const c1 = Math.cos(x / 2);
    const c2 = Math.cos(y / 2);
    const c3 = Math.cos(z / 2);
    const s1 = Math.sin(x / 2);
    const s2 = Math.sin(y / 2);
    const s3 = Math.sin(z / 2);

    if (order === 'XYZ') {
      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'YXZ') {
      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'ZXY') {
      this.x = s1 * c2 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'ZYX') {
      this.x = s1 * c2 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'YZX') {
      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'XZY') {
      this.x = s1 * c2 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;
    }

    return this;
  }

  clone() {
    return new Quaternion(this.x, this.y, this.z, this.w);
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param toQuat second operand
   * @param t interpolation amount between the self quaternion and toQuat
   * @param target A quaternion to store the result in. If not provided, a new one will be created.
   * @returns {Quaternion} The "target" object
   */


  slerp(toQuat, t, target) {
    if (target === void 0) {
      target = new Quaternion();
    }

    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    let bx = toQuat.x;
    let by = toQuat.y;
    let bz = toQuat.z;
    let bw = toQuat.w;
    let omega;
    let cosom;
    let sinom;
    let scale0;
    let scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > 0.000001) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    target.x = scale0 * ax + scale1 * bx;
    target.y = scale0 * ay + scale1 * by;
    target.z = scale0 * az + scale1 * bz;
    target.w = scale0 * aw + scale1 * bw;
    return target;
  }
  /**
   * Rotate an absolute orientation quaternion given an angular velocity and a time step.
   */


  integrate(angularVelocity, dt, angularFactor, target) {
    if (target === void 0) {
      target = new Quaternion();
    }

    const ax = angularVelocity.x * angularFactor.x,
          ay = angularVelocity.y * angularFactor.y,
          az = angularVelocity.z * angularFactor.z,
          bx = this.x,
          by = this.y,
          bz = this.z,
          bw = this.w;
    const half_dt = dt * 0.5;
    target.x += half_dt * (ax * bw + ay * bz - az * by);
    target.y += half_dt * (ay * bw + az * bx - ax * bz);
    target.z += half_dt * (az * bw + ax * by - ay * bx);
    target.w += half_dt * (-ax * bx - ay * by - az * bz);
    return target;
  }

}
const sfv_t1 = new Vec3();
const sfv_t2 = new Vec3();

/**
 * The available shape types.
 */
const SHAPE_TYPES = {
  /** SPHERE */
  SPHERE: 1,

  /** PLANE */
  PLANE: 2,

  /** BOX */
  BOX: 4,

  /** COMPOUND */
  COMPOUND: 8,

  /** CONVEXPOLYHEDRON */
  CONVEXPOLYHEDRON: 16,

  /** HEIGHTFIELD */
  HEIGHTFIELD: 32,

  /** PARTICLE */
  PARTICLE: 64,

  /** CYLINDER */
  CYLINDER: 128,

  /** TRIMESH */
  TRIMESH: 256
};
/**
 * ShapeType
 */

/**
 * Base class for shapes
 */
class Shape {
  /**
   * Identifier of the Shape.
   */

  /**
   * The type of this shape. Must be set to an int > 0 by subclasses.
   */

  /**
   * The local bounding sphere radius of this shape.
   */

  /**
   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
   * @default true
   */

  /**
   * @default 1
   */

  /**
   * @default -1
   */

  /**
   * Optional material of the shape that regulates contact properties.
   */

  /**
   * The body to which the shape is added to.
   */

  /**
   * All the Shape types.
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }

    this.id = Shape.idCounter++;
    this.type = options.type || 0;
    this.boundingSphereRadius = 0;
    this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;
    this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;
    this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;
    this.material = options.material ? options.material : null;
    this.body = null;
  }
  /**
   * Computes the bounding sphere radius.
   * The result is stored in the property `.boundingSphereRadius`
   */


  updateBoundingSphereRadius() {
    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
  }
  /**
   * Get the volume of this shape
   */


  volume() {
    throw `volume() not implemented for shape type ${this.type}`;
  }
  /**
   * Calculates the inertia in the local frame for this shape.
   * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */


  calculateLocalInertia(mass, target) {
    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
  }
  /**
   * @todo use abstract for these kind of methods
   */


  calculateWorldAABB(pos, quat, min, max) {
    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
  }

}
Shape.idCounter = 0;
Shape.types = SHAPE_TYPES;

/**
 * Transformation utilities.
 */
class Transform {
  /**
   * position
   */

  /**
   * quaternion
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }

    this.position = new Vec3();
    this.quaternion = new Quaternion();

    if (options.position) {
      this.position.copy(options.position);
    }

    if (options.quaternion) {
      this.quaternion.copy(options.quaternion);
    }
  }
  /**
   * Get a global point in local transform coordinates.
   */


  pointToLocal(worldPoint, result) {
    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
  }
  /**
   * Get a local point in global transform coordinates.
   */


  pointToWorld(localPoint, result) {
    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
  }
  /**
   * vectorToWorldFrame
   */


  vectorToWorldFrame(localVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }

    this.quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * pointToLocalFrame
   */


  static pointToLocalFrame(position, quaternion, worldPoint, result) {
    if (result === void 0) {
      result = new Vec3();
    }

    worldPoint.vsub(position, result);
    quaternion.conjugate(tmpQuat$1);
    tmpQuat$1.vmult(result, result);
    return result;
  }
  /**
   * pointToWorldFrame
   */


  static pointToWorldFrame(position, quaternion, localPoint, result) {
    if (result === void 0) {
      result = new Vec3();
    }

    quaternion.vmult(localPoint, result);
    result.vadd(position, result);
    return result;
  }
  /**
   * vectorToWorldFrame
   */


  static vectorToWorldFrame(quaternion, localVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }

    quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * vectorToLocalFrame
   */


  static vectorToLocalFrame(position, quaternion, worldVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }

    quaternion.w *= -1;
    quaternion.vmult(worldVector, result);
    quaternion.w *= -1;
    return result;
  }

}
const tmpQuat$1 = new Quaternion();

/**
 * A set of polygons describing a convex shape.
 *
 * The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
 * in the same 3D plane), instead these should be merged into one polygon.
 *
 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
 * @author schteppe / https://github.com/schteppe
 * @see https://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
 *
 * @todo Move the clipping functions to ContactGenerator?
 * @todo Automatically merge coplanar polygons in constructor.
 * @example
 *     const convexShape = new CANNON.ConvexPolyhedron({ vertices, faces })
 *     const convexBody = new CANNON.Body({ mass: 1, shape: convexShape })
 *     world.addBody(convexBody)
 */
class ConvexPolyhedron extends Shape {
  /** vertices */

  /**
   * Array of integer arrays, indicating which vertices each face consists of
   */

  /** faceNormals */

  /** worldVertices */

  /** worldVerticesNeedsUpdate */

  /** worldFaceNormals */

  /** worldFaceNormalsNeedsUpdate */

  /**
   * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
   */

  /** uniqueEdges */

  /**
   * @param vertices An array of Vec3's
   * @param faces Array of integer arrays, describing which vertices that is included in each face.
   */
  constructor(props) {
    if (props === void 0) {
      props = {};
    }

    const {
      vertices = [],
      faces = [],
      normals = [],
      axes,
      boundingSphereRadius
    } = props;
    super({
      type: Shape.types.CONVEXPOLYHEDRON
    });
    this.vertices = vertices;
    this.faces = faces;
    this.faceNormals = normals;

    if (this.faceNormals.length === 0) {
      this.computeNormals();
    }

    if (!boundingSphereRadius) {
      this.updateBoundingSphereRadius();
    } else {
      this.boundingSphereRadius = boundingSphereRadius;
    }

    this.worldVertices = []; // World transformed version of .vertices

    this.worldVerticesNeedsUpdate = true;
    this.worldFaceNormals = []; // World transformed version of .faceNormals

    this.worldFaceNormalsNeedsUpdate = true;
    this.uniqueAxes = axes ? axes.slice() : null;
    this.uniqueEdges = [];
    this.computeEdges();
  }
  /**
   * Computes uniqueEdges
   */


  computeEdges() {
    const faces = this.faces;
    const vertices = this.vertices;
    const edges = this.uniqueEdges;
    edges.length = 0;
    const edge = new Vec3();

    for (let i = 0; i !== faces.length; i++) {
      const face = faces[i];
      const numVertices = face.length;

      for (let j = 0; j !== numVertices; j++) {
        const k = (j + 1) % numVertices;
        vertices[face[j]].vsub(vertices[face[k]], edge);
        edge.normalize();
        let found = false;

        for (let p = 0; p !== edges.length; p++) {
          if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
            found = true;
            break;
          }
        }

        if (!found) {
          edges.push(edge.clone());
        }
      }
    }
  }
  /**
   * Compute the normals of the faces.
   * Will reuse existing Vec3 objects in the `faceNormals` array if they exist.
   */


  computeNormals() {
    this.faceNormals.length = this.faces.length; // Generate normals

    for (let i = 0; i < this.faces.length; i++) {
      // Check so all vertices exists for this face
      for (let j = 0; j < this.faces[i].length; j++) {
        if (!this.vertices[this.faces[i][j]]) {
          throw new Error(`Vertex ${this.faces[i][j]} not found!`);
        }
      }

      const n = this.faceNormals[i] || new Vec3();
      this.getFaceNormal(i, n);
      n.negate(n);
      this.faceNormals[i] = n;
      const vertex = this.vertices[this.faces[i][0]];

      if (n.dot(vertex) < 0) {
        console.error(`.faceNormals[${i}] = Vec3(${n.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);

        for (let j = 0; j < this.faces[i].length; j++) {
          console.warn(`.vertices[${this.faces[i][j]}] = Vec3(${this.vertices[this.faces[i][j]].toString()})`);
        }
      }
    }
  }
  /**
   * Compute the normal of a face from its vertices
   */


  getFaceNormal(i, target) {
    const f = this.faces[i];
    const va = this.vertices[f[0]];
    const vb = this.vertices[f[1]];
    const vc = this.vertices[f[2]];
    ConvexPolyhedron.computeNormal(va, vb, vc, target);
  }
  /**
   * Get face normal given 3 vertices
   */


  static computeNormal(va, vb, vc, target) {
    const cb = new Vec3();
    const ab = new Vec3();
    vb.vsub(va, ab);
    vc.vsub(vb, cb);
    cb.cross(ab, target);

    if (!target.isZero()) {
      target.normalize();
    }
  }
  /**
   * @param minDist Clamp distance
   * @param result The an array of contact point objects, see clipFaceAgainstHull
   */


  clipAgainstHull(posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
    const WorldNormal = new Vec3();
    let closestFaceB = -1;
    let dmax = -Number.MAX_VALUE;

    for (let face = 0; face < hullB.faces.length; face++) {
      WorldNormal.copy(hullB.faceNormals[face]);
      quatB.vmult(WorldNormal, WorldNormal);
      const d = WorldNormal.dot(separatingNormal);

      if (d > dmax) {
        dmax = d;
        closestFaceB = face;
      }
    }

    const worldVertsB1 = [];

    for (let i = 0; i < hullB.faces[closestFaceB].length; i++) {
      const b = hullB.vertices[hullB.faces[closestFaceB][i]];
      const worldb = new Vec3();
      worldb.copy(b);
      quatB.vmult(worldb, worldb);
      posB.vadd(worldb, worldb);
      worldVertsB1.push(worldb);
    }

    if (closestFaceB >= 0) {
      this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
    }
  }
  /**
   * Find the separating axis between this hull and another
   * @param target The target vector to save the axis in
   * @return Returns false if a separation is found, else true
   */


  findSeparatingAxis(hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
    const faceANormalWS3 = new Vec3();
    const Worldnormal1 = new Vec3();
    const deltaC = new Vec3();
    const worldEdge0 = new Vec3();
    const worldEdge1 = new Vec3();
    const Cross = new Vec3();
    let dmin = Number.MAX_VALUE;
    const hullA = this;

    if (!hullA.uniqueAxes) {
      const numFacesA = faceListA ? faceListA.length : hullA.faces.length; // Test face normals from hullA

      for (let i = 0; i < numFacesA; i++) {
        const fi = faceListA ? faceListA[i] : i; // Get world face normal

        faceANormalWS3.copy(hullA.faceNormals[fi]);
        quatA.vmult(faceANormalWS3, faceANormalWS3);
        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(faceANormalWS3);
        }
      }
    } else {
      // Test unique axes
      for (let i = 0; i !== hullA.uniqueAxes.length; i++) {
        // Get world axis
        quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);
        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(faceANormalWS3);
        }
      }
    }

    if (!hullB.uniqueAxes) {
      // Test face normals from hullB
      const numFacesB = faceListB ? faceListB.length : hullB.faces.length;

      for (let i = 0; i < numFacesB; i++) {
        const fi = faceListB ? faceListB[i] : i;
        Worldnormal1.copy(hullB.faceNormals[fi]);
        quatB.vmult(Worldnormal1, Worldnormal1);
        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(Worldnormal1);
        }
      }
    } else {
      // Test unique axes in B
      for (let i = 0; i !== hullB.uniqueAxes.length; i++) {
        quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(Worldnormal1);
        }
      }
    } // Test edges


    for (let e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
      // Get world edge
      quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);

      for (let e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
        // Get world edge 2
        quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
        worldEdge0.cross(worldEdge1, Cross);

        if (!Cross.almostZero()) {
          Cross.normalize();
          const dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);

          if (dist === false) {
            return false;
          }

          if (dist < dmin) {
            dmin = dist;
            target.copy(Cross);
          }
        }
      }
    }

    posB.vsub(posA, deltaC);

    if (deltaC.dot(target) > 0.0) {
      target.negate(target);
    }

    return true;
  }
  /**
   * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
   * @return The overlap depth, or FALSE if no penetration.
   */


  testSepAxis(axis, hullB, posA, quatA, posB, quatB) {
    const hullA = this;
    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
    const maxA = maxminA[0];
    const minA = maxminA[1];
    const maxB = maxminB[0];
    const minB = maxminB[1];

    if (maxA < minB || maxB < minA) {
      return false; // Separated
    }

    const d0 = maxA - minB;
    const d1 = maxB - minA;
    const depth = d0 < d1 ? d0 : d1;
    return depth;
  }
  /**
   * calculateLocalInertia
   */


  calculateLocalInertia(mass, target) {
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    const aabbmax = new Vec3();
    const aabbmin = new Vec3();
    this.computeLocalAABB(aabbmin, aabbmax);
    const x = aabbmax.x - aabbmin.x;
    const y = aabbmax.y - aabbmin.y;
    const z = aabbmax.z - aabbmin.z;
    target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
    target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
    target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
  }
  /**
   * @param face_i Index of the face
   */


  getPlaneConstantOfFace(face_i) {
    const f = this.faces[face_i];
    const n = this.faceNormals[face_i];
    const v = this.vertices[f[0]];
    const c = -n.dot(v);
    return c;
  }
  /**
   * Clip a face against a hull.
   * @param worldVertsB1 An array of Vec3 with vertices in the world frame.
   * @param minDist Distance clamping
   * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
   */


  clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
    const faceANormalWS = new Vec3();
    const edge0 = new Vec3();
    const WorldEdge0 = new Vec3();
    const worldPlaneAnormal1 = new Vec3();
    const planeNormalWS1 = new Vec3();
    const worldA1 = new Vec3();
    const localPlaneNormal = new Vec3();
    const planeNormalWS = new Vec3();
    const hullA = this;
    const worldVertsB2 = [];
    const pVtxIn = worldVertsB1;
    const pVtxOut = worldVertsB2;
    let closestFaceA = -1;
    let dmin = Number.MAX_VALUE; // Find the face with normal closest to the separating axis

    for (let face = 0; face < hullA.faces.length; face++) {
      faceANormalWS.copy(hullA.faceNormals[face]);
      quatA.vmult(faceANormalWS, faceANormalWS);
      const d = faceANormalWS.dot(separatingNormal);

      if (d < dmin) {
        dmin = d;
        closestFaceA = face;
      }
    }

    if (closestFaceA < 0) {
      return;
    } // Get the face and construct connected faces


    const polyA = hullA.faces[closestFaceA];
    polyA.connectedFaces = [];

    for (let i = 0; i < hullA.faces.length; i++) {
      for (let j = 0; j < hullA.faces[i].length; j++) {
        if (
        /* Sharing a vertex*/
        polyA.indexOf(hullA.faces[i][j]) !== -1 &&
        /* Not the one we are looking for connections from */
        i !== closestFaceA &&
        /* Not already added */
        polyA.connectedFaces.indexOf(i) === -1) {
          polyA.connectedFaces.push(i);
        }
      }
    } // Clip the polygon to the back of the planes of all faces of hull A,
    // that are adjacent to the witness face


    const numVerticesA = polyA.length;

    for (let i = 0; i < numVerticesA; i++) {
      const a = hullA.vertices[polyA[i]];
      const b = hullA.vertices[polyA[(i + 1) % numVerticesA]];
      a.vsub(b, edge0);
      WorldEdge0.copy(edge0);
      quatA.vmult(WorldEdge0, WorldEdge0);
      posA.vadd(WorldEdge0, WorldEdge0);
      worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);
      quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
      posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
      WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
      planeNormalWS1.negate(planeNormalWS1);
      worldA1.copy(a);
      quatA.vmult(worldA1, worldA1);
      posA.vadd(worldA1, worldA1);
      const otherFace = polyA.connectedFaces[i];
      localPlaneNormal.copy(this.faceNormals[otherFace]);
      const localPlaneEq = this.getPlaneConstantOfFace(otherFace);
      planeNormalWS.copy(localPlaneNormal);
      quatA.vmult(planeNormalWS, planeNormalWS);
      const planeEqWS = localPlaneEq - planeNormalWS.dot(posA); // Clip face against our constructed plane

      this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS); // Throw away all clipped points, but save the remaining until next clip

      while (pVtxIn.length) {
        pVtxIn.shift();
      }

      while (pVtxOut.length) {
        pVtxIn.push(pVtxOut.shift());
      }
    } // only keep contact points that are behind the witness face


    localPlaneNormal.copy(this.faceNormals[closestFaceA]);
    const localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
    planeNormalWS.copy(localPlaneNormal);
    quatA.vmult(planeNormalWS, planeNormalWS);
    const planeEqWS = localPlaneEq - planeNormalWS.dot(posA);

    for (let i = 0; i < pVtxIn.length; i++) {
      let depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; // ???

      if (depth <= minDist) {
        console.log(`clamped: depth=${depth} to minDist=${minDist}`);
        depth = minDist;
      }

      if (depth <= maxDist) {
        const point = pVtxIn[i];

        if (depth <= 1e-6) {
          const p = {
            point,
            normal: planeNormalWS,
            depth
          };
          result.push(p);
        }
      }
    }
  }
  /**
   * Clip a face in a hull against the back of a plane.
   * @param planeConstant The constant in the mathematical plane equation
   */


  clipFaceAgainstPlane(inVertices, outVertices, planeNormal, planeConstant) {
    let n_dot_first;
    let n_dot_last;
    const numVerts = inVertices.length;

    if (numVerts < 2) {
      return outVertices;
    }

    let firstVertex = inVertices[inVertices.length - 1];
    let lastVertex = inVertices[0];
    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

    for (let vi = 0; vi < numVerts; vi++) {
      lastVertex = inVertices[vi];
      n_dot_last = planeNormal.dot(lastVertex) + planeConstant;

      if (n_dot_first < 0) {
        if (n_dot_last < 0) {
          // Start < 0, end < 0, so output lastVertex
          const newv = new Vec3();
          newv.copy(lastVertex);
          outVertices.push(newv);
        } else {
          // Start < 0, end >= 0, so output intersection
          const newv = new Vec3();
          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
          outVertices.push(newv);
        }
      } else {
        if (n_dot_last < 0) {
          // Start >= 0, end < 0 so output intersection and end
          const newv = new Vec3();
          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
          outVertices.push(newv);
          outVertices.push(lastVertex);
        }
      }

      firstVertex = lastVertex;
      n_dot_first = n_dot_last;
    }

    return outVertices;
  }
  /**
   * Updates `.worldVertices` and sets `.worldVerticesNeedsUpdate` to false.
   */


  computeWorldVertices(position, quat) {
    while (this.worldVertices.length < this.vertices.length) {
      this.worldVertices.push(new Vec3());
    }

    const verts = this.vertices;
    const worldVerts = this.worldVertices;

    for (let i = 0; i !== this.vertices.length; i++) {
      quat.vmult(verts[i], worldVerts[i]);
      position.vadd(worldVerts[i], worldVerts[i]);
    }

    this.worldVerticesNeedsUpdate = false;
  }

  computeLocalAABB(aabbmin, aabbmax) {
    const vertices = this.vertices;
    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

    for (let i = 0; i < this.vertices.length; i++) {
      const v = vertices[i];

      if (v.x < aabbmin.x) {
        aabbmin.x = v.x;
      } else if (v.x > aabbmax.x) {
        aabbmax.x = v.x;
      }

      if (v.y < aabbmin.y) {
        aabbmin.y = v.y;
      } else if (v.y > aabbmax.y) {
        aabbmax.y = v.y;
      }

      if (v.z < aabbmin.z) {
        aabbmin.z = v.z;
      } else if (v.z > aabbmax.z) {
        aabbmax.z = v.z;
      }
    }
  }
  /**
   * Updates `worldVertices` and sets `worldVerticesNeedsUpdate` to false.
   */


  computeWorldFaceNormals(quat) {
    const N = this.faceNormals.length;

    while (this.worldFaceNormals.length < N) {
      this.worldFaceNormals.push(new Vec3());
    }

    const normals = this.faceNormals;
    const worldNormals = this.worldFaceNormals;

    for (let i = 0; i !== N; i++) {
      quat.vmult(normals[i], worldNormals[i]);
    }

    this.worldFaceNormalsNeedsUpdate = false;
  }
  /**
   * updateBoundingSphereRadius
   */


  updateBoundingSphereRadius() {
    // Assume points are distributed with local (0,0,0) as center
    let max2 = 0;
    const verts = this.vertices;

    for (let i = 0; i !== verts.length; i++) {
      const norm2 = verts[i].lengthSquared();

      if (norm2 > max2) {
        max2 = norm2;
      }
    }

    this.boundingSphereRadius = Math.sqrt(max2);
  }
  /**
   * calculateWorldAABB
   */


  calculateWorldAABB(pos, quat, min, max) {
    const verts = this.vertices;
    let minx;
    let miny;
    let minz;
    let maxx;
    let maxy;
    let maxz;
    let tempWorldVertex = new Vec3();

    for (let i = 0; i < verts.length; i++) {
      tempWorldVertex.copy(verts[i]);
      quat.vmult(tempWorldVertex, tempWorldVertex);
      pos.vadd(tempWorldVertex, tempWorldVertex);
      const v = tempWorldVertex;

      if (minx === undefined || v.x < minx) {
        minx = v.x;
      }

      if (maxx === undefined || v.x > maxx) {
        maxx = v.x;
      }

      if (miny === undefined || v.y < miny) {
        miny = v.y;
      }

      if (maxy === undefined || v.y > maxy) {
        maxy = v.y;
      }

      if (minz === undefined || v.z < minz) {
        minz = v.z;
      }

      if (maxz === undefined || v.z > maxz) {
        maxz = v.z;
      }
    }

    min.set(minx, miny, minz);
    max.set(maxx, maxy, maxz);
  }
  /**
   * Get approximate convex volume
   */


  volume() {
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
  }
  /**
   * Get an average of all the vertices positions
   */


  getAveragePointLocal(target) {
    if (target === void 0) {
      target = new Vec3();
    }

    const verts = this.vertices;

    for (let i = 0; i < verts.length; i++) {
      target.vadd(verts[i], target);
    }

    target.scale(1 / verts.length, target);
    return target;
  }
  /**
   * Transform all local points. Will change the .vertices
   */


  transformAllPoints(offset, quat) {
    const n = this.vertices.length;
    const verts = this.vertices; // Apply rotation

    if (quat) {
      // Rotate vertices
      for (let i = 0; i < n; i++) {
        const v = verts[i];
        quat.vmult(v, v);
      } // Rotate face normals


      for (let i = 0; i < this.faceNormals.length; i++) {
        const v = this.faceNormals[i];
        quat.vmult(v, v);
      }
      /*
            // Rotate edges
            for(let i=0; i<this.uniqueEdges.length; i++){
                const v = this.uniqueEdges[i];
                quat.vmult(v,v);
            }*/

    } // Apply offset


    if (offset) {
      for (let i = 0; i < n; i++) {
        const v = verts[i];
        v.vadd(offset, v);
      }
    }
  }
  /**
   * Checks whether p is inside the polyhedra. Must be in local coords.
   * The point lies outside of the convex hull of the other points if and only if the direction
   * of all the vectors from it to those other points are on less than one half of a sphere around it.
   * @param p A point given in local coordinates
   */


  pointIsInside(p) {
    const verts = this.vertices;
    const faces = this.faces;
    const normals = this.faceNormals;
    const positiveResult = null;
    const pointInside = new Vec3();
    this.getAveragePointLocal(pointInside);

    for (let i = 0; i < this.faces.length; i++) {
      let n = normals[i];
      const v = verts[faces[i][0]]; // We only need one point in the face
      // This dot product determines which side of the edge the point is

      const vToP = new Vec3();
      p.vsub(v, vToP);
      const r1 = n.dot(vToP);
      const vToPointInside = new Vec3();
      pointInside.vsub(v, vToPointInside);
      const r2 = n.dot(vToPointInside);

      if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) {
        return false; // Encountered some other sign. Exit.
      }
    } // If we got here, all dot products were of the same sign.


    return positiveResult ? 1 : -1;
  }
  /**
   * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.
   * Results are saved in the array maxmin.
   * @param result result[0] and result[1] will be set to maximum and minimum, respectively.
   */


  static project(shape, axis, pos, quat, result) {
    const n = shape.vertices.length;
    project_worldVertex;
    const localAxis = project_localAxis;
    let max = 0;
    let min = 0;
    const localOrigin = project_localOrigin;
    const vs = shape.vertices;
    localOrigin.setZero(); // Transform the axis to local

    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
    const add = localOrigin.dot(localAxis);
    min = max = vs[0].dot(localAxis);

    for (let i = 1; i < n; i++) {
      const val = vs[i].dot(localAxis);

      if (val > max) {
        max = val;
      }

      if (val < min) {
        min = val;
      }
    }

    min -= add;
    max -= add;

    if (min > max) {
      // Inconsistent - swap
      const temp = min;
      min = max;
      max = temp;
    } // Output


    result[0] = max;
    result[1] = min;
  }

}
const maxminA = [];
const maxminB = [];
const project_worldVertex = new Vec3();
const project_localAxis = new Vec3();
const project_localOrigin = new Vec3();

/**
 * A 3d box shape.
 * @example
 *     const size = 1
 *     const halfExtents = new CANNON.Vec3(size, size, size)
 *     const boxShape = new CANNON.Box(halfExtents)
 *     const boxBody = new CANNON.Body({ mass: 1, shape: boxShape })
 *     world.addBody(boxBody)
 */
class Box extends Shape {
  /**
   * The half extents of the box.
   */

  /**
   * Used by the contact generator to make contacts with other convex polyhedra for example.
   */
  constructor(halfExtents) {
    super({
      type: Shape.types.BOX
    });
    this.halfExtents = halfExtents;
    this.convexPolyhedronRepresentation = null;
    this.updateConvexPolyhedronRepresentation();
    this.updateBoundingSphereRadius();
  }
  /**
   * Updates the local convex polyhedron representation used for some collisions.
   */


  updateConvexPolyhedronRepresentation() {
    const sx = this.halfExtents.x;
    const sy = this.halfExtents.y;
    const sz = this.halfExtents.z;
    const V = Vec3;
    const vertices = [new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz)];
    const faces = [[3, 2, 1, 0], // -z
    [4, 5, 6, 7], // +z
    [5, 4, 0, 1], // -y
    [2, 3, 7, 6], // +y
    [0, 4, 7, 3], // -x
    [1, 2, 6, 5] // +x
    ];
    const axes = [new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0)];
    const h = new ConvexPolyhedron({
      vertices,
      faces,
      axes
    });
    this.convexPolyhedronRepresentation = h;
    h.material = this.material;
  }
  /**
   * Calculate the inertia of the box.
   */


  calculateLocalInertia(mass, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    Box.calculateInertia(this.halfExtents, mass, target);
    return target;
  }

  static calculateInertia(halfExtents, mass, target) {
    const e = halfExtents;
    target.x = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
    target.y = 1.0 / 12.0 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
    target.z = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
  }
  /**
   * Get the box 6 side normals
   * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
   * @param quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
   */


  getSideNormals(sixTargetVectors, quat) {
    const sides = sixTargetVectors;
    const ex = this.halfExtents;
    sides[0].set(ex.x, 0, 0);
    sides[1].set(0, ex.y, 0);
    sides[2].set(0, 0, ex.z);
    sides[3].set(-ex.x, 0, 0);
    sides[4].set(0, -ex.y, 0);
    sides[5].set(0, 0, -ex.z);

    if (quat !== undefined) {
      for (let i = 0; i !== sides.length; i++) {
        quat.vmult(sides[i], sides[i]);
      }
    }

    return sides;
  }
  /**
   * Returns the volume of the box.
   */


  volume() {
    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
  }
  /**
   * updateBoundingSphereRadius
   */


  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.halfExtents.length();
  }
  /**
   * forEachWorldCorner
   */


  forEachWorldCorner(pos, quat, callback) {
    const e = this.halfExtents;
    const corners = [[e.x, e.y, e.z], [-e.x, e.y, e.z], [-e.x, -e.y, e.z], [-e.x, -e.y, -e.z], [e.x, -e.y, -e.z], [e.x, e.y, -e.z], [-e.x, e.y, -e.z], [e.x, -e.y, e.z]];

    for (let i = 0; i < corners.length; i++) {
      worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);
      quat.vmult(worldCornerTempPos, worldCornerTempPos);
      pos.vadd(worldCornerTempPos, worldCornerTempPos);
      callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
    }
  }
  /**
   * calculateWorldAABB
   */


  calculateWorldAABB(pos, quat, min, max) {
    const e = this.halfExtents;
    worldCornersTemp[0].set(e.x, e.y, e.z);
    worldCornersTemp[1].set(-e.x, e.y, e.z);
    worldCornersTemp[2].set(-e.x, -e.y, e.z);
    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
    worldCornersTemp[4].set(e.x, -e.y, -e.z);
    worldCornersTemp[5].set(e.x, e.y, -e.z);
    worldCornersTemp[6].set(-e.x, e.y, -e.z);
    worldCornersTemp[7].set(e.x, -e.y, e.z);
    const wc = worldCornersTemp[0];
    quat.vmult(wc, wc);
    pos.vadd(wc, wc);
    max.copy(wc);
    min.copy(wc);

    for (let i = 1; i < 8; i++) {
      const wc = worldCornersTemp[i];
      quat.vmult(wc, wc);
      pos.vadd(wc, wc);
      const x = wc.x;
      const y = wc.y;
      const z = wc.z;

      if (x > max.x) {
        max.x = x;
      }

      if (y > max.y) {
        max.y = y;
      }

      if (z > max.z) {
        max.z = z;
      }

      if (x < min.x) {
        min.x = x;
      }

      if (y < min.y) {
        min.y = y;
      }

      if (z < min.z) {
        min.z = z;
      }
    } // Get each axis max
    // min.set(Infinity,Infinity,Infinity);
    // max.set(-Infinity,-Infinity,-Infinity);
    // this.forEachWorldCorner(pos,quat,function(x,y,z){
    //     if(x > max.x){
    //         max.x = x;
    //     }
    //     if(y > max.y){
    //         max.y = y;
    //     }
    //     if(z > max.z){
    //         max.z = z;
    //     }
    //     if(x < min.x){
    //         min.x = x;
    //     }
    //     if(y < min.y){
    //         min.y = y;
    //     }
    //     if(z < min.z){
    //         min.z = z;
    //     }
    // });

  }

}
const worldCornerTempPos = new Vec3();
const worldCornersTemp = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

/**
 * BODY_TYPES
 */
const BODY_TYPES = {
  /** DYNAMIC */
  DYNAMIC: 1,

  /** STATIC */
  STATIC: 2,

  /** KINEMATIC */
  KINEMATIC: 4
};
/**
 * BodyType
 */

/**
 * BODY_SLEEP_STATES
 */
const BODY_SLEEP_STATES = {
  /** AWAKE */
  AWAKE: 0,

  /** SLEEPY */
  SLEEPY: 1,

  /** SLEEPING */
  SLEEPING: 2
};
/**
 * BodySleepState
 */

/**
 * Base class for all body types.
 * @example
 *     const shape = new CANNON.Sphere(1)
 *     const body = new CANNON.Body({
 *       mass: 1,
 *       shape,
 *     })
 *     world.addBody(body)
 */
class Body extends EventTarget {
  /**
   * Dispatched after two bodies collide. This event is dispatched on each
   * of the two bodies involved in the collision.
   * @event collide
   * @param body The body that was involved in the collision.
   * @param contact The details of the collision.
   */

  /**
   * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
   */

  /**
   * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
   */

  /**
   * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
   */

  /**
   * AWAKE
   */

  /**
   * SLEEPY
   */

  /**
   * SLEEPING
   */

  /**
   * Dispatched after a sleeping body has woken up.
   * @event wakeup
   */

  /**
   * Dispatched after a body has gone in to the sleepy state.
   * @event sleepy
   */

  /**
   * Dispatched after a body has fallen asleep.
   * @event sleep
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }

    super();
    this.id = Body.idCounter++;
    this.index = -1;
    this.world = null;
    this.vlambda = new Vec3();
    this.collisionFilterGroup = typeof options.collisionFilterGroup === 'number' ? options.collisionFilterGroup : 1;
    this.collisionFilterMask = typeof options.collisionFilterMask === 'number' ? options.collisionFilterMask : -1;
    this.collisionResponse = typeof options.collisionResponse === 'boolean' ? options.collisionResponse : true;
    this.position = new Vec3();
    this.previousPosition = new Vec3();
    this.interpolatedPosition = new Vec3();
    this.initPosition = new Vec3();

    if (options.position) {
      this.position.copy(options.position);
      this.previousPosition.copy(options.position);
      this.interpolatedPosition.copy(options.position);
      this.initPosition.copy(options.position);
    }

    this.velocity = new Vec3();

    if (options.velocity) {
      this.velocity.copy(options.velocity);
    }

    this.initVelocity = new Vec3();
    this.force = new Vec3();
    const mass = typeof options.mass === 'number' ? options.mass : 0;
    this.mass = mass;
    this.invMass = mass > 0 ? 1.0 / mass : 0;
    this.material = options.material || null;
    this.linearDamping = typeof options.linearDamping === 'number' ? options.linearDamping : 0.01;
    this.type = mass <= 0.0 ? Body.STATIC : Body.DYNAMIC;

    if (typeof options.type === typeof Body.STATIC) {
      this.type = options.type;
    }

    this.allowSleep = typeof options.allowSleep !== 'undefined' ? options.allowSleep : true;
    this.sleepState = Body.AWAKE;
    this.sleepSpeedLimit = typeof options.sleepSpeedLimit !== 'undefined' ? options.sleepSpeedLimit : 0.1;
    this.sleepTimeLimit = typeof options.sleepTimeLimit !== 'undefined' ? options.sleepTimeLimit : 1;
    this.timeLastSleepy = 0;
    this.wakeUpAfterNarrowphase = false;
    this.torque = new Vec3();
    this.quaternion = new Quaternion();
    this.initQuaternion = new Quaternion();
    this.previousQuaternion = new Quaternion();
    this.interpolatedQuaternion = new Quaternion();

    if (options.quaternion) {
      this.quaternion.copy(options.quaternion);
      this.initQuaternion.copy(options.quaternion);
      this.previousQuaternion.copy(options.quaternion);
      this.interpolatedQuaternion.copy(options.quaternion);
    }

    this.angularVelocity = new Vec3();

    if (options.angularVelocity) {
      this.angularVelocity.copy(options.angularVelocity);
    }

    this.initAngularVelocity = new Vec3();
    this.shapes = [];
    this.shapeOffsets = [];
    this.shapeOrientations = [];
    this.inertia = new Vec3();
    this.invInertia = new Vec3();
    this.invInertiaWorld = new Mat3();
    this.invMassSolve = 0;
    this.invInertiaSolve = new Vec3();
    this.invInertiaWorldSolve = new Mat3();
    this.fixedRotation = typeof options.fixedRotation !== 'undefined' ? options.fixedRotation : false;
    this.angularDamping = typeof options.angularDamping !== 'undefined' ? options.angularDamping : 0.01;
    this.linearFactor = new Vec3(1, 1, 1);

    if (options.linearFactor) {
      this.linearFactor.copy(options.linearFactor);
    }

    this.angularFactor = new Vec3(1, 1, 1);

    if (options.angularFactor) {
      this.angularFactor.copy(options.angularFactor);
    }

    this.aabb = new AABB();
    this.aabbNeedsUpdate = true;
    this.boundingRadius = 0;
    this.wlambda = new Vec3();
    this.isTrigger = Boolean(options.isTrigger);

    if (options.shape) {
      this.addShape(options.shape);
    }

    this.updateMassProperties();
  }
  /**
   * Wake the body up.
   */


  wakeUp() {
    const prevState = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.wakeUpAfterNarrowphase = false;

    if (prevState === Body.SLEEPING) {
      this.dispatchEvent(Body.wakeupEvent);
    }
  }
  /**
   * Force body sleep
   */


  sleep() {
    this.sleepState = Body.SLEEPING;
    this.velocity.set(0, 0, 0);
    this.angularVelocity.set(0, 0, 0);
    this.wakeUpAfterNarrowphase = false;
  }
  /**
   * Called every timestep to update internal sleep timer and change sleep state if needed.
   * @param time The world time in seconds
   */


  sleepTick(time) {
    if (this.allowSleep) {
      const sleepState = this.sleepState;
      const speedSquared = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared();
      const speedLimitSquared = this.sleepSpeedLimit ** 2;

      if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
        this.sleepState = Body.SLEEPY; // Sleepy

        this.timeLastSleepy = time;
        this.dispatchEvent(Body.sleepyEvent);
      } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {
        this.wakeUp(); // Wake up
      } else if (sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit) {
        this.sleep(); // Sleeping

        this.dispatchEvent(Body.sleepEvent);
      }
    }
  }
  /**
   * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
   */


  updateSolveMassProperties() {
    if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
      this.invMassSolve = 0;
      this.invInertiaSolve.setZero();
      this.invInertiaWorldSolve.setZero();
    } else {
      this.invMassSolve = this.invMass;
      this.invInertiaSolve.copy(this.invInertia);
      this.invInertiaWorldSolve.copy(this.invInertiaWorld);
    }
  }
  /**
   * Convert a world point to local body frame.
   */


  pointToLocalFrame(worldPoint, result) {
    if (result === void 0) {
      result = new Vec3();
    }

    worldPoint.vsub(this.position, result);
    this.quaternion.conjugate().vmult(result, result);
    return result;
  }
  /**
   * Convert a world vector to local body frame.
   */


  vectorToLocalFrame(worldVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }

    this.quaternion.conjugate().vmult(worldVector, result);
    return result;
  }
  /**
   * Convert a local body point to world frame.
   */


  pointToWorldFrame(localPoint, result) {
    if (result === void 0) {
      result = new Vec3();
    }

    this.quaternion.vmult(localPoint, result);
    result.vadd(this.position, result);
    return result;
  }
  /**
   * Convert a local body point to world frame.
   */


  vectorToWorldFrame(localVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }

    this.quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * Add a shape to the body with a local offset and orientation.
   * @return The body object, for chainability.
   */


  addShape(shape, _offset, _orientation) {
    const offset = new Vec3();
    const orientation = new Quaternion();

    if (_offset) {
      offset.copy(_offset);
    }

    if (_orientation) {
      orientation.copy(_orientation);
    }

    this.shapes.push(shape);
    this.shapeOffsets.push(offset);
    this.shapeOrientations.push(orientation);
    this.updateMassProperties();
    this.updateBoundingRadius();
    this.aabbNeedsUpdate = true;
    shape.body = this;
    return this;
  }
  /**
   * Remove a shape from the body.
   * @return The body object, for chainability.
   */


  removeShape(shape) {
    const index = this.shapes.indexOf(shape);

    if (index === -1) {
      console.warn('Shape does not belong to the body');
      return this;
    }

    this.shapes.splice(index, 1);
    this.shapeOffsets.splice(index, 1);
    this.shapeOrientations.splice(index, 1);
    this.updateMassProperties();
    this.updateBoundingRadius();
    this.aabbNeedsUpdate = true;
    shape.body = null;
    return this;
  }
  /**
   * Update the bounding radius of the body. Should be done if any of the shapes are changed.
   */


  updateBoundingRadius() {
    const shapes = this.shapes;
    const shapeOffsets = this.shapeOffsets;
    const N = shapes.length;
    let radius = 0;

    for (let i = 0; i !== N; i++) {
      const shape = shapes[i];
      shape.updateBoundingSphereRadius();
      const offset = shapeOffsets[i].length();
      const r = shape.boundingSphereRadius;

      if (offset + r > radius) {
        radius = offset + r;
      }
    }

    this.boundingRadius = radius;
  }
  /**
   * Updates the .aabb
   */


  updateAABB() {
    const shapes = this.shapes;
    const shapeOffsets = this.shapeOffsets;
    const shapeOrientations = this.shapeOrientations;
    const N = shapes.length;
    const offset = tmpVec;
    const orientation = tmpQuat;
    const bodyQuat = this.quaternion;
    const aabb = this.aabb;
    const shapeAABB = updateAABB_shapeAABB;

    for (let i = 0; i !== N; i++) {
      const shape = shapes[i]; // Get shape world position

      bodyQuat.vmult(shapeOffsets[i], offset);
      offset.vadd(this.position, offset); // Get shape world quaternion

      bodyQuat.mult(shapeOrientations[i], orientation); // Get shape AABB

      shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

      if (i === 0) {
        aabb.copy(shapeAABB);
      } else {
        aabb.extend(shapeAABB);
      }
    }

    this.aabbNeedsUpdate = false;
  }
  /**
   * Update `.inertiaWorld` and `.invInertiaWorld`
   */


  updateInertiaWorld(force) {
    const I = this.invInertia;

    if (I.x === I.y && I.y === I.z && !force) ; else {
      const m1 = uiw_m1;
      const m2 = uiw_m2;
      uiw_m3;
      m1.setRotationFromQuaternion(this.quaternion);
      m1.transpose(m2);
      m1.scale(I, m1);
      m1.mmult(m2, this.invInertiaWorld);
    }
  }
  /**
   * Apply force to a point of the body. This could for example be a point on the Body surface.
   * Applying force this way will add to Body.force and Body.torque.
   * @param force The amount of force to add.
   * @param relativePoint A point relative to the center of mass to apply the force on.
   */


  applyForce(force, relativePoint) {
    if (relativePoint === void 0) {
      relativePoint = new Vec3();
    }

    // Needed?
    if (this.type !== Body.DYNAMIC) {
      return;
    }

    if (this.sleepState === Body.SLEEPING) {
      this.wakeUp();
    } // Compute produced rotational force


    const rotForce = Body_applyForce_rotForce;
    relativePoint.cross(force, rotForce); // Add linear force

    this.force.vadd(force, this.force); // Add rotational force

    this.torque.vadd(rotForce, this.torque);
  }
  /**
   * Apply force to a local point in the body.
   * @param force The force vector to apply, defined locally in the body frame.
   * @param localPoint A local point in the body to apply the force on.
   */


  applyLocalForce(localForce, localPoint) {
    if (localPoint === void 0) {
      localPoint = new Vec3();
    }

    if (this.type !== Body.DYNAMIC) {
      return;
    }

    const worldForce = Body_applyLocalForce_worldForce;
    const relativePointWorld = Body_applyLocalForce_relativePointWorld; // Transform the force vector to world space

    this.vectorToWorldFrame(localForce, worldForce);
    this.vectorToWorldFrame(localPoint, relativePointWorld);
    this.applyForce(worldForce, relativePointWorld);
  }
  /**
   * Apply torque to the body.
   * @param torque The amount of torque to add.
   */


  applyTorque(torque) {
    if (this.type !== Body.DYNAMIC) {
      return;
    }

    if (this.sleepState === Body.SLEEPING) {
      this.wakeUp();
    } // Add rotational force


    this.torque.vadd(torque, this.torque);
  }
  /**
   * Apply impulse to a point of the body. This could for example be a point on the Body surface.
   * An impulse is a force added to a body during a short period of time (impulse = force * time).
   * Impulses will be added to Body.velocity and Body.angularVelocity.
   * @param impulse The amount of impulse to add.
   * @param relativePoint A point relative to the center of mass to apply the force on.
   */


  applyImpulse(impulse, relativePoint) {
    if (relativePoint === void 0) {
      relativePoint = new Vec3();
    }

    if (this.type !== Body.DYNAMIC) {
      return;
    }

    if (this.sleepState === Body.SLEEPING) {
      this.wakeUp();
    } // Compute point position relative to the body center


    const r = relativePoint; // Compute produced central impulse velocity

    const velo = Body_applyImpulse_velo;
    velo.copy(impulse);
    velo.scale(this.invMass, velo); // Add linear impulse

    this.velocity.vadd(velo, this.velocity); // Compute produced rotational impulse velocity

    const rotVelo = Body_applyImpulse_rotVelo;
    r.cross(impulse, rotVelo);
    /*
     rotVelo.x *= this.invInertia.x;
     rotVelo.y *= this.invInertia.y;
     rotVelo.z *= this.invInertia.z;
     */

    this.invInertiaWorld.vmult(rotVelo, rotVelo); // Add rotational Impulse

    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
  }
  /**
   * Apply locally-defined impulse to a local point in the body.
   * @param force The force vector to apply, defined locally in the body frame.
   * @param localPoint A local point in the body to apply the force on.
   */


  applyLocalImpulse(localImpulse, localPoint) {
    if (localPoint === void 0) {
      localPoint = new Vec3();
    }

    if (this.type !== Body.DYNAMIC) {
      return;
    }

    const worldImpulse = Body_applyLocalImpulse_worldImpulse;
    const relativePointWorld = Body_applyLocalImpulse_relativePoint; // Transform the force vector to world space

    this.vectorToWorldFrame(localImpulse, worldImpulse);
    this.vectorToWorldFrame(localPoint, relativePointWorld);
    this.applyImpulse(worldImpulse, relativePointWorld);
  }
  /**
   * Should be called whenever you change the body shape or mass.
   */


  updateMassProperties() {
    const halfExtents = Body_updateMassProperties_halfExtents;
    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
    const I = this.inertia;
    const fixed = this.fixedRotation; // Approximate with AABB box

    this.updateAABB();
    halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
    Box.calculateInertia(halfExtents, this.mass, I);
    this.invInertia.set(I.x > 0 && !fixed ? 1.0 / I.x : 0, I.y > 0 && !fixed ? 1.0 / I.y : 0, I.z > 0 && !fixed ? 1.0 / I.z : 0);
    this.updateInertiaWorld(true);
  }
  /**
   * Get world velocity of a point in the body.
   * @param worldPoint
   * @param result
   * @return The result vector.
   */


  getVelocityAtWorldPoint(worldPoint, result) {
    const r = new Vec3();
    worldPoint.vsub(this.position, r);
    this.angularVelocity.cross(r, result);
    this.velocity.vadd(result, result);
    return result;
  }
  /**
   * Move the body forward in time.
   * @param dt Time step
   * @param quatNormalize Set to true to normalize the body quaternion
   * @param quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
   */


  integrate(dt, quatNormalize, quatNormalizeFast) {
    // Save previous position
    this.previousPosition.copy(this.position);
    this.previousQuaternion.copy(this.quaternion);

    if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) {
      // Only for dynamic
      return;
    }

    const velo = this.velocity;
    const angularVelo = this.angularVelocity;
    const pos = this.position;
    const force = this.force;
    const torque = this.torque;
    const quat = this.quaternion;
    const invMass = this.invMass;
    const invInertia = this.invInertiaWorld;
    const linearFactor = this.linearFactor;
    const iMdt = invMass * dt;
    velo.x += force.x * iMdt * linearFactor.x;
    velo.y += force.y * iMdt * linearFactor.y;
    velo.z += force.z * iMdt * linearFactor.z;
    const e = invInertia.elements;
    const angularFactor = this.angularFactor;
    const tx = torque.x * angularFactor.x;
    const ty = torque.y * angularFactor.y;
    const tz = torque.z * angularFactor.z;
    angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
    angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
    angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz); // Use new velocity  - leap frog

    pos.x += velo.x * dt;
    pos.y += velo.y * dt;
    pos.z += velo.z * dt;
    quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);

    if (quatNormalize) {
      if (quatNormalizeFast) {
        quat.normalizeFast();
      } else {
        quat.normalize();
      }
    }

    this.aabbNeedsUpdate = true; // Update world inertia

    this.updateInertiaWorld();
  }

}
Body.idCounter = 0;
Body.COLLIDE_EVENT_NAME = 'collide';
Body.DYNAMIC = BODY_TYPES.DYNAMIC;
Body.STATIC = BODY_TYPES.STATIC;
Body.KINEMATIC = BODY_TYPES.KINEMATIC;
Body.AWAKE = BODY_SLEEP_STATES.AWAKE;
Body.SLEEPY = BODY_SLEEP_STATES.SLEEPY;
Body.SLEEPING = BODY_SLEEP_STATES.SLEEPING;
Body.wakeupEvent = {
  type: 'wakeup'
};
Body.sleepyEvent = {
  type: 'sleepy'
};
Body.sleepEvent = {
  type: 'sleep'
};
const tmpVec = new Vec3();
const tmpQuat = new Quaternion();
const updateAABB_shapeAABB = new AABB();
const uiw_m1 = new Mat3();
const uiw_m2 = new Mat3();
const uiw_m3 = new Mat3();
const Body_applyForce_rotForce = new Vec3();
const Body_applyLocalForce_worldForce = new Vec3();
const Body_applyLocalForce_relativePointWorld = new Vec3();
const Body_applyImpulse_velo = new Vec3();
const Body_applyImpulse_rotVelo = new Vec3();
const Body_applyLocalImpulse_worldImpulse = new Vec3();
const Body_applyLocalImpulse_relativePoint = new Vec3();
const Body_updateMassProperties_halfExtents = new Vec3();

/**
 * Base class for broadphase implementations
 * @author schteppe
 */
class Broadphase {
  /**
   * The world to search for collisions in.
   */

  /**
   * If set to true, the broadphase uses bounding boxes for intersection tests, else it uses bounding spheres.
   */

  /**
   * Set to true if the objects in the world moved.
   */
  constructor() {
    this.world = null;
    this.useBoundingBoxes = false;
    this.dirty = true;
  }
  /**
   * Get the collision pairs from the world
   * @param world The world to search in
   * @param p1 Empty array to be filled with body objects
   * @param p2 Empty array to be filled with body objects
   */


  collisionPairs(world, p1, p2) {
    throw new Error('collisionPairs not implemented for this BroadPhase class!');
  }
  /**
   * Check if a body pair needs to be intersection tested at all.
   */


  needBroadphaseCollision(bodyA, bodyB) {
    // Check collision filter masks
    if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {
      return false;
    } // Check types


    if (((bodyA.type & Body.STATIC) !== 0 || bodyA.sleepState === Body.SLEEPING) && ((bodyB.type & Body.STATIC) !== 0 || bodyB.sleepState === Body.SLEEPING)) {
      // Both bodies are static or sleeping. Skip.
      return false;
    }

    return true;
  }
  /**
   * Check if the bounding volumes of two bodies intersect.
   */


  intersectionTest(bodyA, bodyB, pairs1, pairs2) {
    if (this.useBoundingBoxes) {
      this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
    } else {
      this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
    }
  }
  /**
   * Check if the bounding spheres of two bodies are intersecting.
   * @param pairs1 bodyA is appended to this array if intersection
   * @param pairs2 bodyB is appended to this array if intersection
   */


  doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2) {
    const r = Broadphase_collisionPairs_r;
    bodyB.position.vsub(bodyA.position, r);
    const boundingRadiusSum2 = (bodyA.boundingRadius + bodyB.boundingRadius) ** 2;
    const norm2 = r.lengthSquared();

    if (norm2 < boundingRadiusSum2) {
      pairs1.push(bodyA);
      pairs2.push(bodyB);
    }
  }
  /**
   * Check if the bounding boxes of two bodies are intersecting.
   */


  doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2) {
    if (bodyA.aabbNeedsUpdate) {
      bodyA.updateAABB();
    }

    if (bodyB.aabbNeedsUpdate) {
      bodyB.updateAABB();
    } // Check AABB / AABB


    if (bodyA.aabb.overlaps(bodyB.aabb)) {
      pairs1.push(bodyA);
      pairs2.push(bodyB);
    }
  }
  /**
   * Removes duplicate pairs from the pair arrays.
   */


  makePairsUnique(pairs1, pairs2) {
    const t = Broadphase_makePairsUnique_temp;
    const p1 = Broadphase_makePairsUnique_p1;
    const p2 = Broadphase_makePairsUnique_p2;
    const N = pairs1.length;

    for (let i = 0; i !== N; i++) {
      p1[i] = pairs1[i];
      p2[i] = pairs2[i];
    }

    pairs1.length = 0;
    pairs2.length = 0;

    for (let i = 0; i !== N; i++) {
      const id1 = p1[i].id;
      const id2 = p2[i].id;
      const key = id1 < id2 ? `${id1},${id2}` : `${id2},${id1}`;
      t[key] = i;
      t.keys.push(key);
    }

    for (let i = 0; i !== t.keys.length; i++) {
      const key = t.keys.pop();
      const pairIndex = t[key];
      pairs1.push(p1[pairIndex]);
      pairs2.push(p2[pairIndex]);
      delete t[key];
    }
  }
  /**
   * To be implemented by subcasses
   */


  setWorld(world) {}
  /**
   * Check if the bounding spheres of two bodies overlap.
   */


  static boundingSphereCheck(bodyA, bodyB) {
    const dist = new Vec3(); // bsc_dist;

    bodyA.position.vsub(bodyB.position, dist);
    const sa = bodyA.shapes[0];
    const sb = bodyB.shapes[0];
    return Math.pow(sa.boundingSphereRadius + sb.boundingSphereRadius, 2) > dist.lengthSquared();
  }
  /**
   * Returns all the bodies within the AABB.
   */


  aabbQuery(world, aabb, result) {
    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
    return [];
  }

} // Temp objects

const Broadphase_collisionPairs_r = new Vec3();
new Vec3();
new Quaternion();
new Vec3();
const Broadphase_makePairsUnique_temp = {
  keys: []
};
const Broadphase_makePairsUnique_p1 = [];
const Broadphase_makePairsUnique_p2 = [];
new Vec3();

/**
 * Axis aligned uniform grid broadphase.
 * @todo Needs support for more than just planes and spheres.
 */
class GridBroadphase extends Broadphase {
  /**
   * Number of boxes along x
   */

  /**
   * Number of boxes along y
   */

  /**
   * Number of boxes along z
   */

  /**
   * aabbMin
   */

  /**
   * aabbMax
   */

  /**
   * bins
   */

  /**
   * binLengths
   */

  /**
   * @param nx Number of boxes along x.
   * @param ny Number of boxes along y.
   * @param nz Number of boxes along z.
   */
  constructor(aabbMin, aabbMax, nx, ny, nz) {
    if (aabbMin === void 0) {
      aabbMin = new Vec3(100, 100, 100);
    }

    if (aabbMax === void 0) {
      aabbMax = new Vec3(-100, -100, -100);
    }

    if (nx === void 0) {
      nx = 10;
    }

    if (ny === void 0) {
      ny = 10;
    }

    if (nz === void 0) {
      nz = 10;
    }

    super();
    this.nx = nx;
    this.ny = ny;
    this.nz = nz;
    this.aabbMin = aabbMin;
    this.aabbMax = aabbMax;
    const nbins = this.nx * this.ny * this.nz;

    if (nbins <= 0) {
      throw "GridBroadphase: Each dimension's n must be >0";
    }

    this.bins = [];
    this.binLengths = []; // Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow

    this.bins.length = nbins;
    this.binLengths.length = nbins;

    for (let i = 0; i < nbins; i++) {
      this.bins[i] = [];
      this.binLengths[i] = 0;
    }
  }
  /**
   * Get all the collision pairs in the physics world
   */


  collisionPairs(world, pairs1, pairs2) {
    const N = world.bodies.length;
    const bodies = world.bodies;
    const max = this.aabbMax;
    const min = this.aabbMin;
    const nx = this.nx;
    const ny = this.ny;
    const nz = this.nz;
    const xstep = ny * nz;
    const ystep = nz;
    const zstep = 1;
    const xmax = max.x;
    const ymax = max.y;
    const zmax = max.z;
    const xmin = min.x;
    const ymin = min.y;
    const zmin = min.z;
    const xmult = nx / (xmax - xmin);
    const ymult = ny / (ymax - ymin);
    const zmult = nz / (zmax - zmin);
    const binsizeX = (xmax - xmin) / nx;
    const binsizeY = (ymax - ymin) / ny;
    const binsizeZ = (zmax - zmin) / nz;
    const binRadius = Math.sqrt(binsizeX * binsizeX + binsizeY * binsizeY + binsizeZ * binsizeZ) * 0.5;
    const types = Shape.types;
    const SPHERE = types.SPHERE;
    const PLANE = types.PLANE;
    types.BOX;
    types.COMPOUND;
    types.CONVEXPOLYHEDRON;
    const bins = this.bins;
    const binLengths = this.binLengths;
    const Nbins = this.bins.length; // Reset bins

    for (let i = 0; i !== Nbins; i++) {
      binLengths[i] = 0;
    }

    const ceil = Math.ceil;

    function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
      let xoff0 = (x0 - xmin) * xmult | 0;
      let yoff0 = (y0 - ymin) * ymult | 0;
      let zoff0 = (z0 - zmin) * zmult | 0;
      let xoff1 = ceil((x1 - xmin) * xmult);
      let yoff1 = ceil((y1 - ymin) * ymult);
      let zoff1 = ceil((z1 - zmin) * zmult);

      if (xoff0 < 0) {
        xoff0 = 0;
      } else if (xoff0 >= nx) {
        xoff0 = nx - 1;
      }

      if (yoff0 < 0) {
        yoff0 = 0;
      } else if (yoff0 >= ny) {
        yoff0 = ny - 1;
      }

      if (zoff0 < 0) {
        zoff0 = 0;
      } else if (zoff0 >= nz) {
        zoff0 = nz - 1;
      }

      if (xoff1 < 0) {
        xoff1 = 0;
      } else if (xoff1 >= nx) {
        xoff1 = nx - 1;
      }

      if (yoff1 < 0) {
        yoff1 = 0;
      } else if (yoff1 >= ny) {
        yoff1 = ny - 1;
      }

      if (zoff1 < 0) {
        zoff1 = 0;
      } else if (zoff1 >= nz) {
        zoff1 = nz - 1;
      }

      xoff0 *= xstep;
      yoff0 *= ystep;
      zoff0 *= zstep;
      xoff1 *= xstep;
      yoff1 *= ystep;
      zoff1 *= zstep;

      for (let xoff = xoff0; xoff <= xoff1; xoff += xstep) {
        for (let yoff = yoff0; yoff <= yoff1; yoff += ystep) {
          for (let zoff = zoff0; zoff <= zoff1; zoff += zstep) {
            const idx = xoff + yoff + zoff;
            bins[idx][binLengths[idx]++] = bi;
          }
        }
      }
    } // Put all bodies into the bins


    for (let i = 0; i !== N; i++) {
      const bi = bodies[i];
      const si = bi.shapes[0];

      switch (si.type) {
        case SPHERE:
          {
            const shape = si; // Put in bin
            // check if overlap with other bins

            const x = bi.position.x;
            const y = bi.position.y;
            const z = bi.position.z;
            const r = shape.radius;
            addBoxToBins(x - r, y - r, z - r, x + r, y + r, z + r, bi);
            break;
          }

        case PLANE:
          {
            const shape = si;

            if (shape.worldNormalNeedsUpdate) {
              shape.computeWorldNormal(bi.quaternion);
            }

            const planeNormal = shape.worldNormal; //Relative position from origin of plane object to the first bin
            //Incremented as we iterate through the bins

            const xreset = xmin + binsizeX * 0.5 - bi.position.x;
            const yreset = ymin + binsizeY * 0.5 - bi.position.y;
            const zreset = zmin + binsizeZ * 0.5 - bi.position.z;
            const d = GridBroadphase_collisionPairs_d;
            d.set(xreset, yreset, zreset);

            for (let xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
              for (let yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
                for (let zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
                  if (d.dot(planeNormal) < binRadius) {
                    const idx = xoff + yoff + zoff;
                    bins[idx][binLengths[idx]++] = bi;
                  }
                }
              }
            }

            break;
          }

        default:
          {
            if (bi.aabbNeedsUpdate) {
              bi.updateAABB();
            }

            addBoxToBins(bi.aabb.lowerBound.x, bi.aabb.lowerBound.y, bi.aabb.lowerBound.z, bi.aabb.upperBound.x, bi.aabb.upperBound.y, bi.aabb.upperBound.z, bi);
            break;
          }
      }
    } // Check each bin


    for (let i = 0; i !== Nbins; i++) {
      const binLength = binLengths[i]; //Skip bins with no potential collisions

      if (binLength > 1) {
        const bin = bins[i]; // Do N^2 broadphase inside

        for (let xi = 0; xi !== binLength; xi++) {
          const bi = bin[xi];

          for (let yi = 0; yi !== xi; yi++) {
            const bj = bin[yi];

            if (this.needBroadphaseCollision(bi, bj)) {
              this.intersectionTest(bi, bj, pairs1, pairs2);
            }
          }
        }
      }
    } //	for (let zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
    //		console.log("layer "+zi);
    //		for (let yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
    //			const row = '';
    //			for (let xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
    //				const idx = xoff + yoff + zoff;
    //				row += ' ' + binLengths[idx];
    //			}
    //			console.log(row);
    //		}
    //	}


    this.makePairsUnique(pairs1, pairs2);
  }

}
const GridBroadphase_collisionPairs_d = new Vec3();
new Vec3();

/**
 * Naive broadphase implementation, used in lack of better ones.
 *
 * The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 _(which is bad)_
 */
class NaiveBroadphase extends Broadphase {
  /**
   * @todo Remove useless constructor
   */
  constructor() {
    super();
  }
  /**
   * Get all the collision pairs in the physics world
   */


  collisionPairs(world, pairs1, pairs2) {
    const bodies = world.bodies;
    const n = bodies.length;
    let bi;
    let bj; // Naive N^2 ftw!

    for (let i = 0; i !== n; i++) {
      for (let j = 0; j !== i; j++) {
        bi = bodies[i];
        bj = bodies[j];

        if (!this.needBroadphaseCollision(bi, bj)) {
          continue;
        }

        this.intersectionTest(bi, bj, pairs1, pairs2);
      }
    }
  }
  /**
   * Returns all the bodies within an AABB.
   * @param result An array to store resulting bodies in.
   */


  aabbQuery(world, aabb, result) {
    if (result === void 0) {
      result = [];
    }

    for (let i = 0; i < world.bodies.length; i++) {
      const b = world.bodies[i];

      if (b.aabbNeedsUpdate) {
        b.updateAABB();
      } // Ugly hack until Body gets aabb


      if (b.aabb.overlaps(aabb)) {
        result.push(b);
      }
    }

    return result;
  }

}

/**
 * Storage for Ray casting data
 */
class RaycastResult {
  /**
   * rayFromWorld
   */

  /**
   * rayToWorld
   */

  /**
   * hitNormalWorld
   */

  /**
   * hitPointWorld
   */

  /**
   * hasHit
   */

  /**
   * shape
   */

  /**
   * body
   */

  /**
   * The index of the hit triangle, if the hit shape was a trimesh
   */

  /**
   * Distance to the hit. Will be set to -1 if there was no hit
   */

  /**
   * If the ray should stop traversing the bodies
   */
  constructor() {
    this.rayFromWorld = new Vec3();
    this.rayToWorld = new Vec3();
    this.hitNormalWorld = new Vec3();
    this.hitPointWorld = new Vec3();
    this.hasHit = false;
    this.shape = null;
    this.body = null;
    this.hitFaceIndex = -1;
    this.distance = -1;
    this.shouldStop = false;
  }
  /**
   * Reset all result data.
   */


  reset() {
    this.rayFromWorld.setZero();
    this.rayToWorld.setZero();
    this.hitNormalWorld.setZero();
    this.hitPointWorld.setZero();
    this.hasHit = false;
    this.shape = null;
    this.body = null;
    this.hitFaceIndex = -1;
    this.distance = -1;
    this.shouldStop = false;
  }
  /**
   * abort
   */


  abort() {
    this.shouldStop = true;
  }
  /**
   * Set result data.
   */


  set(rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {
    this.rayFromWorld.copy(rayFromWorld);
    this.rayToWorld.copy(rayToWorld);
    this.hitNormalWorld.copy(hitNormalWorld);
    this.hitPointWorld.copy(hitPointWorld);
    this.shape = shape;
    this.body = body;
    this.distance = distance;
  }

}

let _Shape$types$SPHERE, _Shape$types$PLANE, _Shape$types$BOX, _Shape$types$CYLINDER, _Shape$types$CONVEXPO, _Shape$types$HEIGHTFI, _Shape$types$TRIMESH;

/**
 * RAY_MODES
 */
const RAY_MODES = {
  /** CLOSEST */
  CLOSEST: 1,

  /** ANY */
  ANY: 2,

  /** ALL */
  ALL: 4
};
/**
 * RayMode
 */

_Shape$types$SPHERE = Shape.types.SPHERE;
_Shape$types$PLANE = Shape.types.PLANE;
_Shape$types$BOX = Shape.types.BOX;
_Shape$types$CYLINDER = Shape.types.CYLINDER;
_Shape$types$CONVEXPO = Shape.types.CONVEXPOLYHEDRON;
_Shape$types$HEIGHTFI = Shape.types.HEIGHTFIELD;
_Shape$types$TRIMESH = Shape.types.TRIMESH;

/**
 * A line in 3D space that intersects bodies and return points.
 */
class Ray {
  /**
   * from
   */

  /**
   * to
   */

  /**
   * direction
   */

  /**
   * The precision of the ray. Used when checking parallelity etc.
   * @default 0.0001
   */

  /**
   * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
   * @default true
   */

  /**
   * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
   * @default false
   */

  /**
   * collisionFilterMask
   * @default -1
   */

  /**
   * collisionFilterGroup
   * @default -1
   */

  /**
   * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
   * @default RAY.ANY
   */

  /**
   * Current result object.
   */

  /**
   * Will be set to `true` during intersectWorld() if the ray hit anything.
   */

  /**
   * User-provided result callback. Will be used if mode is Ray.ALL.
   */

  /**
   * CLOSEST
   */

  /**
   * ANY
   */

  /**
   * ALL
   */
  get [_Shape$types$SPHERE]() {
    return this._intersectSphere;
  }

  get [_Shape$types$PLANE]() {
    return this._intersectPlane;
  }

  get [_Shape$types$BOX]() {
    return this._intersectBox;
  }

  get [_Shape$types$CYLINDER]() {
    return this._intersectConvex;
  }

  get [_Shape$types$CONVEXPO]() {
    return this._intersectConvex;
  }

  get [_Shape$types$HEIGHTFI]() {
    return this._intersectHeightfield;
  }

  get [_Shape$types$TRIMESH]() {
    return this._intersectTrimesh;
  }

  constructor(from, to) {
    if (from === void 0) {
      from = new Vec3();
    }

    if (to === void 0) {
      to = new Vec3();
    }

    this.from = from.clone();
    this.to = to.clone();
    this.direction = new Vec3();
    this.precision = 0.0001;
    this.checkCollisionResponse = true;
    this.skipBackfaces = false;
    this.collisionFilterMask = -1;
    this.collisionFilterGroup = -1;
    this.mode = Ray.ANY;
    this.result = new RaycastResult();
    this.hasHit = false;

    this.callback = result => {};
  }
  /**
   * Do itersection against all bodies in the given World.
   * @return True if the ray hit anything, otherwise false.
   */


  intersectWorld(world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;
    this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;
    this.checkCollisionResponse = typeof options.checkCollisionResponse !== 'undefined' ? options.checkCollisionResponse : true;

    if (options.from) {
      this.from.copy(options.from);
    }

    if (options.to) {
      this.to.copy(options.to);
    }

    this.callback = options.callback || (() => {});

    this.hasHit = false;
    this.result.reset();
    this.updateDirection();
    this.getAABB(tmpAABB$1);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB$1, tmpArray);
    this.intersectBodies(tmpArray);
    return this.hasHit;
  }
  /**
   * Shoot a ray at a body, get back information about the hit.
   * @deprecated @param result set the result property of the Ray instead.
   */


  intersectBody(body, result) {
    if (result) {
      this.result = result;
      this.updateDirection();
    }

    const checkCollisionResponse = this.checkCollisionResponse;

    if (checkCollisionResponse && !body.collisionResponse) {
      return;
    }

    if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {
      return;
    }

    const xi = intersectBody_xi;
    const qi = intersectBody_qi;

    for (let i = 0, N = body.shapes.length; i < N; i++) {
      const shape = body.shapes[i];

      if (checkCollisionResponse && !shape.collisionResponse) {
        continue; // Skip
      }

      body.quaternion.mult(body.shapeOrientations[i], qi);
      body.quaternion.vmult(body.shapeOffsets[i], xi);
      xi.vadd(body.position, xi);
      this.intersectShape(shape, qi, xi, body);

      if (this.result.shouldStop) {
        break;
      }
    }
  }
  /**
   * Shoot a ray at an array bodies, get back information about the hit.
   * @param bodies An array of Body objects.
   * @deprecated @param result set the result property of the Ray instead.
   *
   */


  intersectBodies(bodies, result) {
    if (result) {
      this.result = result;
      this.updateDirection();
    }

    for (let i = 0, l = bodies.length; !this.result.shouldStop && i < l; i++) {
      this.intersectBody(bodies[i]);
    }
  }
  /**
   * Updates the direction vector.
   */


  updateDirection() {
    this.to.vsub(this.from, this.direction);
    this.direction.normalize();
  }

  intersectShape(shape, quat, position, body) {
    const from = this.from; // Checking boundingSphere

    const distance = distanceFromIntersection(from, this.direction, position);

    if (distance > shape.boundingSphereRadius) {
      return;
    }

    const intersectMethod = this[shape.type];

    if (intersectMethod) {
      intersectMethod.call(this, shape, quat, position, body, shape);
    }
  }

  _intersectBox(box, quat, position, body, reportedShape) {
    return this._intersectConvex(box.convexPolyhedronRepresentation, quat, position, body, reportedShape);
  }

  _intersectPlane(shape, quat, position, body, reportedShape) {
    const from = this.from;
    const to = this.to;
    const direction = this.direction; // Get plane normal

    const worldNormal = new Vec3(0, 0, 1);
    quat.vmult(worldNormal, worldNormal);
    const len = new Vec3();
    from.vsub(position, len);
    const planeToFrom = len.dot(worldNormal);
    to.vsub(position, len);
    const planeToTo = len.dot(worldNormal);

    if (planeToFrom * planeToTo > 0) {
      // "from" and "to" are on the same side of the plane... bail out
      return;
    }

    if (from.distanceTo(to) < planeToFrom) {
      return;
    }

    const n_dot_dir = worldNormal.dot(direction);

    if (Math.abs(n_dot_dir) < this.precision) {
      // No intersection
      return;
    }

    const planePointToFrom = new Vec3();
    const dir_scaled_with_t = new Vec3();
    const hitPointWorld = new Vec3();
    from.vsub(position, planePointToFrom);
    const t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
    direction.scale(t, dir_scaled_with_t);
    from.vadd(dir_scaled_with_t, hitPointWorld);
    this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
  }
  /**
   * Get the world AABB of the ray.
   */


  getAABB(aabb) {
    const {
      lowerBound,
      upperBound
    } = aabb;
    const to = this.to;
    const from = this.from;
    lowerBound.x = Math.min(to.x, from.x);
    lowerBound.y = Math.min(to.y, from.y);
    lowerBound.z = Math.min(to.z, from.z);
    upperBound.x = Math.max(to.x, from.x);
    upperBound.y = Math.max(to.y, from.y);
    upperBound.z = Math.max(to.z, from.z);
  }

  _intersectHeightfield(shape, quat, position, body, reportedShape) {
    shape.data;
    shape.elementSize; // Convert the ray to local heightfield coordinates

    const localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);

    localRay.from.copy(this.from);
    localRay.to.copy(this.to);
    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
    localRay.updateDirection(); // Get the index of the data points to test against

    const index = intersectHeightfield_index;
    let iMinX;
    let iMinY;
    let iMaxX;
    let iMaxY; // Set to max

    iMinX = iMinY = 0;
    iMaxX = iMaxY = shape.data.length - 1;
    const aabb = new AABB();
    localRay.getAABB(aabb);
    shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
    iMinX = Math.max(iMinX, index[0]);
    iMinY = Math.max(iMinY, index[1]);
    shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
    iMaxX = Math.min(iMaxX, index[0] + 1);
    iMaxY = Math.min(iMaxY, index[1] + 1);

    for (let i = iMinX; i < iMaxX; i++) {
      for (let j = iMinY; j < iMaxY; j++) {
        if (this.result.shouldStop) {
          return;
        }

        shape.getAabbAtIndex(i, j, aabb);

        if (!aabb.overlapsRay(localRay)) {
          continue;
        } // Lower triangle


        shape.getConvexTrianglePillar(i, j, false);
        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);

        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);

        if (this.result.shouldStop) {
          return;
        } // Upper triangle


        shape.getConvexTrianglePillar(i, j, true);
        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);

        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
      }
    }
  }

  _intersectSphere(sphere, quat, position, body, reportedShape) {
    const from = this.from;
    const to = this.to;
    const r = sphere.radius;
    const a = (to.x - from.x) ** 2 + (to.y - from.y) ** 2 + (to.z - from.z) ** 2;
    const b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
    const c = (from.x - position.x) ** 2 + (from.y - position.y) ** 2 + (from.z - position.z) ** 2 - r ** 2;
    const delta = b ** 2 - 4 * a * c;
    const intersectionPoint = Ray_intersectSphere_intersectionPoint;
    const normal = Ray_intersectSphere_normal;

    if (delta < 0) {
      // No intersection
      return;
    } else if (delta === 0) {
      // single intersection point
      from.lerp(to, delta, intersectionPoint);
      intersectionPoint.vsub(position, normal);
      normal.normalize();
      this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
    } else {
      const d1 = (-b - Math.sqrt(delta)) / (2 * a);
      const d2 = (-b + Math.sqrt(delta)) / (2 * a);

      if (d1 >= 0 && d1 <= 1) {
        from.lerp(to, d1, intersectionPoint);
        intersectionPoint.vsub(position, normal);
        normal.normalize();
        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
      }

      if (this.result.shouldStop) {
        return;
      }

      if (d2 >= 0 && d2 <= 1) {
        from.lerp(to, d2, intersectionPoint);
        intersectionPoint.vsub(position, normal);
        normal.normalize();
        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
      }
    }
  }

  _intersectConvex(shape, quat, position, body, reportedShape, options) {
    intersectConvex_minDistNormal;
    const normal = intersectConvex_normal;
    const vector = intersectConvex_vector;
    intersectConvex_minDistIntersect;
    const faceList = options && options.faceList || null; // Checking faces

    const faces = shape.faces;
    const vertices = shape.vertices;
    const normals = shape.faceNormals;
    const direction = this.direction;
    const from = this.from;
    const to = this.to;
    const fromToDistance = from.distanceTo(to);
    const Nfaces = faceList ? faceList.length : faces.length;
    const result = this.result;

    for (let j = 0; !result.shouldStop && j < Nfaces; j++) {
      const fi = faceList ? faceList[j] : j;
      const face = faces[fi];
      const faceNormal = normals[fi];
      const q = quat;
      const x = position; // determine if ray intersects the plane of the face
      // note: this works regardless of the direction of the face normal
      // Get plane point in world coordinates...

      vector.copy(vertices[face[0]]);
      q.vmult(vector, vector);
      vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.

      vector.vsub(from, vector); // Get plane normal

      q.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting

      const dot = direction.dot(normal); // Bail out if ray and plane are parallel

      if (Math.abs(dot) < this.precision) {
        continue;
      } // calc distance to plane


      const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

      if (scalar < 0) {
        continue;
      } // if (dot < 0) {
      // Intersection point is from + direction * scalar


      direction.scale(scalar, intersectPoint);
      intersectPoint.vadd(from, intersectPoint); // a is the point we compare points b and c with.

      a.copy(vertices[face[0]]);
      q.vmult(a, a);
      x.vadd(a, a);

      for (let i = 1; !result.shouldStop && i < face.length - 1; i++) {
        // Transform 3 vertices to world coords
        b.copy(vertices[face[i]]);
        c.copy(vertices[face[i + 1]]);
        q.vmult(b, b);
        q.vmult(c, c);
        x.vadd(b, b);
        x.vadd(c, c);
        const distance = intersectPoint.distanceTo(from);

        if (!(Ray.pointInTriangle(intersectPoint, a, b, c) || Ray.pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {
          continue;
        }

        this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
      } // }

    }
  }
  /**
   * @todo Optimize by transforming the world to local space first.
   * @todo Use Octree lookup
   */


  _intersectTrimesh(mesh, quat, position, body, reportedShape, options) {
    const normal = intersectTrimesh_normal;
    const triangles = intersectTrimesh_triangles;
    const treeTransform = intersectTrimesh_treeTransform;
    const vector = intersectConvex_vector;
    const localDirection = intersectTrimesh_localDirection;
    const localFrom = intersectTrimesh_localFrom;
    const localTo = intersectTrimesh_localTo;
    const worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
    const worldNormal = intersectTrimesh_worldNormal; // Checking faces

    const indices = mesh.indices;
    mesh.vertices; // const normals = mesh.faceNormals

    const from = this.from;
    const to = this.to;
    const direction = this.direction;
    treeTransform.position.copy(position);
    treeTransform.quaternion.copy(quat); // Transform ray to local space!

    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
    Transform.pointToLocalFrame(position, quat, from, localFrom);
    Transform.pointToLocalFrame(position, quat, to, localTo);
    localTo.x *= mesh.scale.x;
    localTo.y *= mesh.scale.y;
    localTo.z *= mesh.scale.z;
    localFrom.x *= mesh.scale.x;
    localFrom.y *= mesh.scale.y;
    localFrom.z *= mesh.scale.z;
    localTo.vsub(localFrom, localDirection);
    localDirection.normalize();
    const fromToDistanceSquared = localFrom.distanceSquared(localTo);
    mesh.tree.rayQuery(this, treeTransform, triangles);

    for (let i = 0, N = triangles.length; !this.result.shouldStop && i !== N; i++) {
      const trianglesIndex = triangles[i];
      mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face
      // note: this works regardless of the direction of the face normal
      // Get plane point in world coordinates...

      mesh.getVertex(indices[trianglesIndex * 3], a); // ...but make it relative to the ray from. We'll fix this later.

      a.vsub(localFrom, vector); // If this dot product is negative, we have something interesting

      const dot = localDirection.dot(normal); // Bail out if ray and plane are parallel
      // if (Math.abs( dot ) < this.precision){
      //     continue;
      // }
      // calc distance to plane

      const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

      if (scalar < 0) {
        continue;
      } // Intersection point is from + direction * scalar


      localDirection.scale(scalar, intersectPoint);
      intersectPoint.vadd(localFrom, intersectPoint); // Get triangle vertices

      mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
      mesh.getVertex(indices[trianglesIndex * 3 + 2], c);
      const squaredDistance = intersectPoint.distanceSquared(localFrom);

      if (!(Ray.pointInTriangle(intersectPoint, b, a, c) || Ray.pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {
        continue;
      } // transform intersectpoint and normal to world


      Transform.vectorToWorldFrame(quat, normal, worldNormal);
      Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
      this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
    }

    triangles.length = 0;
  }
  /**
   * @return True if the intersections should continue
   */


  reportIntersection(normal, hitPointWorld, shape, body, hitFaceIndex) {
    const from = this.from;
    const to = this.to;
    const distance = from.distanceTo(hitPointWorld);
    const result = this.result; // Skip back faces?

    if (this.skipBackfaces && normal.dot(this.direction) > 0) {
      return;
    }

    result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;

    switch (this.mode) {
      case Ray.ALL:
        this.hasHit = true;
        result.set(from, to, normal, hitPointWorld, shape, body, distance);
        result.hasHit = true;
        this.callback(result);
        break;

      case Ray.CLOSEST:
        // Store if closer than current closest
        if (distance < result.distance || !result.hasHit) {
          this.hasHit = true;
          result.hasHit = true;
          result.set(from, to, normal, hitPointWorld, shape, body, distance);
        }

        break;

      case Ray.ANY:
        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(from, to, normal, hitPointWorld, shape, body, distance);
        result.shouldStop = true;
        break;
    }
  }
  /**
   * As per "Barycentric Technique" as named
   * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
   */


  static pointInTriangle(p, a, b, c) {
    c.vsub(a, v0);
    b.vsub(a, v1);
    p.vsub(a, v2);
    const dot00 = v0.dot(v0);
    const dot01 = v0.dot(v1);
    const dot02 = v0.dot(v2);
    const dot11 = v1.dot(v1);
    const dot12 = v1.dot(v2);
    let u;
    let v;
    return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;
  }

}
Ray.CLOSEST = RAY_MODES.CLOSEST;
Ray.ANY = RAY_MODES.ANY;
Ray.ALL = RAY_MODES.ALL;
const tmpAABB$1 = new AABB();
const tmpArray = [];
const v1 = new Vec3();
const v2 = new Vec3();
const intersectBody_xi = new Vec3();
const intersectBody_qi = new Quaternion();
const intersectPoint = new Vec3();
const a = new Vec3();
const b = new Vec3();
const c = new Vec3();
new Vec3();
new RaycastResult();
const intersectConvexOptions = {
  faceList: [0]
};
const worldPillarOffset = new Vec3();
const intersectHeightfield_localRay = new Ray();
const intersectHeightfield_index = [];
const Ray_intersectSphere_intersectionPoint = new Vec3();
const Ray_intersectSphere_normal = new Vec3();
const intersectConvex_normal = new Vec3();
const intersectConvex_minDistNormal = new Vec3();
const intersectConvex_minDistIntersect = new Vec3();
const intersectConvex_vector = new Vec3();
const intersectTrimesh_normal = new Vec3();
const intersectTrimesh_localDirection = new Vec3();
const intersectTrimesh_localFrom = new Vec3();
const intersectTrimesh_localTo = new Vec3();
const intersectTrimesh_worldNormal = new Vec3();
const intersectTrimesh_worldIntersectPoint = new Vec3();
new AABB();
const intersectTrimesh_triangles = [];
const intersectTrimesh_treeTransform = new Transform();
const v0 = new Vec3();
const intersect = new Vec3();

function distanceFromIntersection(from, direction, position) {
  // v0 is vector from from to position
  position.vsub(from, v0);
  const dot = v0.dot(direction); // intersect = direction*dot + from

  direction.scale(dot, intersect);
  intersect.vadd(from, intersect);
  const distance = position.distanceTo(intersect);
  return distance;
}

/**
 * Sweep and prune broadphase along one axis.
 */
class SAPBroadphase extends Broadphase {
  /**
   * List of bodies currently in the broadphase.
   */

  /**
   * The world to search in.
   */

  /**
   * Axis to sort the bodies along.
   * Set to 0 for x axis, and 1 for y axis.
   * For best performance, pick the axis where bodies are most distributed.
   */

  /**
   * Check if the bounds of two bodies overlap, along the given SAP axis.
   */
  static checkBounds(bi, bj, axisIndex) {
    let biPos;
    let bjPos;

    if (axisIndex === 0) {
      biPos = bi.position.x;
      bjPos = bj.position.x;
    } else if (axisIndex === 1) {
      biPos = bi.position.y;
      bjPos = bj.position.y;
    } else if (axisIndex === 2) {
      biPos = bi.position.z;
      bjPos = bj.position.z;
    }

    const ri = bi.boundingRadius,
          rj = bj.boundingRadius,
          boundA2 = biPos + ri,
          boundB1 = bjPos - rj;
    return boundB1 < boundA2;
  } // Note: these are identical, save for x/y/z lowerbound

  /**
   * insertionSortX
   */


  static insertionSortX(a) {
    for (let i = 1, l = a.length; i < l; i++) {
      const v = a[i];
      let j;

      for (j = i - 1; j >= 0; j--) {
        if (a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x) {
          break;
        }

        a[j + 1] = a[j];
      }

      a[j + 1] = v;
    }

    return a;
  }
  /**
   * insertionSortY
   */


  static insertionSortY(a) {
    for (let i = 1, l = a.length; i < l; i++) {
      const v = a[i];
      let j;

      for (j = i - 1; j >= 0; j--) {
        if (a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y) {
          break;
        }

        a[j + 1] = a[j];
      }

      a[j + 1] = v;
    }

    return a;
  }
  /**
   * insertionSortZ
   */


  static insertionSortZ(a) {
    for (let i = 1, l = a.length; i < l; i++) {
      const v = a[i];
      let j;

      for (j = i - 1; j >= 0; j--) {
        if (a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z) {
          break;
        }

        a[j + 1] = a[j];
      }

      a[j + 1] = v;
    }

    return a;
  }

  constructor(world) {
    super();
    this.axisList = [];
    this.world = null;
    this.axisIndex = 0;
    const axisList = this.axisList;

    this._addBodyHandler = event => {
      axisList.push(event.body);
    };

    this._removeBodyHandler = event => {
      const idx = axisList.indexOf(event.body);

      if (idx !== -1) {
        axisList.splice(idx, 1);
      }
    };

    if (world) {
      this.setWorld(world);
    }
  }
  /**
   * Change the world
   */


  setWorld(world) {
    // Clear the old axis array
    this.axisList.length = 0; // Add all bodies from the new world

    for (let i = 0; i < world.bodies.length; i++) {
      this.axisList.push(world.bodies[i]);
    } // Remove old handlers, if any


    world.removeEventListener('addBody', this._addBodyHandler);
    world.removeEventListener('removeBody', this._removeBodyHandler); // Add handlers to update the list of bodies.

    world.addEventListener('addBody', this._addBodyHandler);
    world.addEventListener('removeBody', this._removeBodyHandler);
    this.world = world;
    this.dirty = true;
  }
  /**
   * Collect all collision pairs
   */


  collisionPairs(world, p1, p2) {
    const bodies = this.axisList;
    const N = bodies.length;
    const axisIndex = this.axisIndex;
    let i;
    let j;

    if (this.dirty) {
      this.sortList();
      this.dirty = false;
    } // Look through the list


    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      for (j = i + 1; j < N; j++) {
        const bj = bodies[j];

        if (!this.needBroadphaseCollision(bi, bj)) {
          continue;
        }

        if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) {
          break;
        }

        this.intersectionTest(bi, bj, p1, p2);
      }
    }
  }

  sortList() {
    const axisList = this.axisList;
    const axisIndex = this.axisIndex;
    const N = axisList.length; // Update AABBs

    for (let i = 0; i !== N; i++) {
      const bi = axisList[i];

      if (bi.aabbNeedsUpdate) {
        bi.updateAABB();
      }
    } // Sort the list


    if (axisIndex === 0) {
      SAPBroadphase.insertionSortX(axisList);
    } else if (axisIndex === 1) {
      SAPBroadphase.insertionSortY(axisList);
    } else if (axisIndex === 2) {
      SAPBroadphase.insertionSortZ(axisList);
    }
  }
  /**
   * Computes the variance of the body positions and estimates the best axis to use.
   * Will automatically set property `axisIndex`.
   */


  autoDetectAxis() {
    let sumX = 0;
    let sumX2 = 0;
    let sumY = 0;
    let sumY2 = 0;
    let sumZ = 0;
    let sumZ2 = 0;
    const bodies = this.axisList;
    const N = bodies.length;
    const invN = 1 / N;

    for (let i = 0; i !== N; i++) {
      const b = bodies[i];
      const centerX = b.position.x;
      sumX += centerX;
      sumX2 += centerX * centerX;
      const centerY = b.position.y;
      sumY += centerY;
      sumY2 += centerY * centerY;
      const centerZ = b.position.z;
      sumZ += centerZ;
      sumZ2 += centerZ * centerZ;
    }

    const varianceX = sumX2 - sumX * sumX * invN;
    const varianceY = sumY2 - sumY * sumY * invN;
    const varianceZ = sumZ2 - sumZ * sumZ * invN;

    if (varianceX > varianceY) {
      if (varianceX > varianceZ) {
        this.axisIndex = 0;
      } else {
        this.axisIndex = 2;
      }
    } else if (varianceY > varianceZ) {
      this.axisIndex = 1;
    } else {
      this.axisIndex = 2;
    }
  }
  /**
   * Returns all the bodies within an AABB.
   * @param result An array to store resulting bodies in.
   */


  aabbQuery(world, aabb, result) {
    if (result === void 0) {
      result = [];
    }

    if (this.dirty) {
      this.sortList();
      this.dirty = false;
    }

    const axisIndex = this.axisIndex;
    let axis = 'x';

    if (axisIndex === 1) {
      axis = 'y';
    }

    if (axisIndex === 2) {
      axis = 'z';
    }

    const axisList = this.axisList;
    aabb.lowerBound[axis];
    aabb.upperBound[axis];

    for (let i = 0; i < axisList.length; i++) {
      const b = axisList[i];

      if (b.aabbNeedsUpdate) {
        b.updateAABB();
      }

      if (b.aabb.overlaps(aabb)) {
        result.push(b);
      }
    }

    return result;
  }

}

class Utils {
  /**
   * Extend an options object with default values.
   * @param options The options object. May be falsy: in this case, a new object is created and returned.
   * @param defaults An object containing default values.
   * @return The modified options object.
   */
  static defaults(options, defaults) {
    if (options === void 0) {
      options = {};
    }

    for (let key in defaults) {
      if (!(key in options)) {
        options[key] = defaults[key];
      }
    }

    return options;
  }

}

/**
 * Constraint base class
 */
class Constraint {
  /**
   * Equations to be solved in this constraint.
   */

  /**
   * Body A.
   */

  /**
   * Body B.
   */

  /**
   * Set to false if you don't want the bodies to collide when they are connected.
   */
  constructor(bodyA, bodyB, options) {
    if (options === void 0) {
      options = {};
    }

    options = Utils.defaults(options, {
      collideConnected: true,
      wakeUpBodies: true
    });
    this.equations = [];
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.id = Constraint.idCounter++;
    this.collideConnected = options.collideConnected;

    if (options.wakeUpBodies) {
      if (bodyA) {
        bodyA.wakeUp();
      }

      if (bodyB) {
        bodyB.wakeUp();
      }
    }
  }
  /**
   * Update all the equations with data.
   */


  update() {
    throw new Error('method update() not implmemented in this Constraint subclass!');
  }
  /**
   * Enables all equations in the constraint.
   */


  enable() {
    const eqs = this.equations;

    for (let i = 0; i < eqs.length; i++) {
      eqs[i].enabled = true;
    }
  }
  /**
   * Disables all equations in the constraint.
   */


  disable() {
    const eqs = this.equations;

    for (let i = 0; i < eqs.length; i++) {
      eqs[i].enabled = false;
    }
  }

}
Constraint.idCounter = 0;

/**
 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
 */

class JacobianElement {
  /**
   * spatial
   */

  /**
   * rotational
   */
  constructor() {
    this.spatial = new Vec3();
    this.rotational = new Vec3();
  }
  /**
   * Multiply with other JacobianElement
   */


  multiplyElement(element) {
    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
  }
  /**
   * Multiply with two vectors
   */


  multiplyVectors(spatial, rotational) {
    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
  }

}

/**
 * Equation base class.
 *
 * `a`, `b` and `eps` are {@link https://www8.cs.umu.se/kurser/5DV058/VT15/lectures/SPOOKlabnotes.pdf SPOOK} parameters that default to `0.0`. See {@link https://github.com/schteppe/cannon.js/issues/238#issuecomment-147172327 this exchange} for more details on Cannon's physics implementation.
 */
class Equation {
  /**
   * Minimum (read: negative max) force to be applied by the constraint.
   */

  /**
   * Maximum (read: positive max) force to be applied by the constraint.
   */

  /**
   * SPOOK parameter
   */

  /**
   * SPOOK parameter
   */

  /**
   * SPOOK parameter
   */

  /**
   * A number, proportional to the force added to the bodies.
   */
  constructor(bi, bj, minForce, maxForce) {
    if (minForce === void 0) {
      minForce = -1e6;
    }

    if (maxForce === void 0) {
      maxForce = 1e6;
    }

    this.id = Equation.idCounter++;
    this.minForce = minForce;
    this.maxForce = maxForce;
    this.bi = bi;
    this.bj = bj;
    this.a = 0.0; // SPOOK parameter

    this.b = 0.0; // SPOOK parameter

    this.eps = 0.0; // SPOOK parameter

    this.jacobianElementA = new JacobianElement();
    this.jacobianElementB = new JacobianElement();
    this.enabled = true;
    this.multiplier = 0;
    this.setSpookParams(1e7, 4, 1 / 60); // Set typical spook params
  }
  /**
   * Recalculates a, b, and eps.
   *
   * The Equation constructor sets typical SPOOK parameters as such:
   * * `stiffness` = 1e7
   * * `relaxation` = 4
   * * `timeStep`= 1 / 60, _note the hardcoded refresh rate._
   */


  setSpookParams(stiffness, relaxation, timeStep) {
    const d = relaxation;
    const k = stiffness;
    const h = timeStep;
    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = 4.0 * d / (1 + 4 * d);
    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
  }
  /**
   * Computes the right hand side of the SPOOK equation
   */


  computeB(a, b, h) {
    const GW = this.computeGW();
    const Gq = this.computeGq();
    const GiMf = this.computeGiMf();
    return -Gq * a - GW * b - GiMf * h;
  }
  /**
   * Computes G*q, where q are the generalized body coordinates
   */


  computeGq() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const xi = bi.position;
    const xj = bj.position;
    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
  }
  /**
   * Computes G*W, where W are the body velocities
   */


  computeGW() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const vi = bi.velocity;
    const vj = bj.velocity;
    const wi = bi.angularVelocity;
    const wj = bj.angularVelocity;
    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
  }
  /**
   * Computes G*Wlambda, where W are the body velocities
   */


  computeGWlambda() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const vi = bi.vlambda;
    const vj = bj.vlambda;
    const wi = bi.wlambda;
    const wj = bj.wlambda;
    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
  }
  /**
   * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
   */


  computeGiMf() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const fi = bi.force;
    const ti = bi.torque;
    const fj = bj.force;
    const tj = bj.torque;
    const invMassi = bi.invMassSolve;
    const invMassj = bj.invMassSolve;
    fi.scale(invMassi, iMfi);
    fj.scale(invMassj, iMfj);
    bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
    bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
    return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
  }
  /**
   * Computes G*inv(M)*G'
   */


  computeGiMGt() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const invMassi = bi.invMassSolve;
    const invMassj = bj.invMassSolve;
    const invIi = bi.invInertiaWorldSolve;
    const invIj = bj.invInertiaWorldSolve;
    let result = invMassi + invMassj;
    invIi.vmult(GA.rotational, tmp);
    result += tmp.dot(GA.rotational);
    invIj.vmult(GB.rotational, tmp);
    result += tmp.dot(GB.rotational);
    return result;
  }
  /**
   * Add constraint velocity to the bodies.
   */


  addToWlambda(deltalambda) {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const temp = addToWlambda_temp; // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G

    bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
    bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda); // Add to angular velocity

    bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
    bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
    bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
    bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
  }
  /**
   * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
   */


  computeC() {
    return this.computeGiMGt() + this.eps;
  }

}
Equation.idCounter = 0;
const iMfi = new Vec3();
const iMfj = new Vec3();
const invIi_vmult_taui = new Vec3();
const invIj_vmult_tauj = new Vec3();
const tmp = new Vec3();
const addToWlambda_temp = new Vec3();

/**
 * Contact/non-penetration constraint equation
 */
class ContactEquation extends Equation {
  /**
   * "bounciness": u1 = -e*u0
   */

  /**
   * World-oriented vector that goes from the center of bi to the contact point.
   */

  /**
   * World-oriented vector that starts in body j position and goes to the contact point.
   */

  /**
   * Contact normal, pointing out of body i.
   */
  constructor(bodyA, bodyB, maxForce) {
    if (maxForce === void 0) {
      maxForce = 1e6;
    }

    super(bodyA, bodyB, 0, maxForce);
    this.restitution = 0.0;
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.ni = new Vec3();
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const bi = this.bi;
    const bj = this.bj;
    const ri = this.ri;
    const rj = this.rj;
    const rixn = ContactEquation_computeB_temp1;
    const rjxn = ContactEquation_computeB_temp2;
    const vi = bi.velocity;
    const wi = bi.angularVelocity;
    bi.force;
    bi.torque;
    const vj = bj.velocity;
    const wj = bj.angularVelocity;
    bj.force;
    bj.torque;
    const penetrationVec = ContactEquation_computeB_temp3;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const n = this.ni; // Caluclate cross products

    ri.cross(n, rixn);
    rj.cross(n, rjxn); // g = xj+rj -(xi+ri)
    // G = [ -ni  -rixn  ni  rjxn ]

    n.negate(GA.spatial);
    rixn.negate(GA.rotational);
    GB.spatial.copy(n);
    GB.rotational.copy(rjxn); // Calculate the penetration vector

    penetrationVec.copy(bj.position);
    penetrationVec.vadd(rj, penetrationVec);
    penetrationVec.vsub(bi.position, penetrationVec);
    penetrationVec.vsub(ri, penetrationVec);
    const g = n.dot(penetrationVec); // Compute iteration

    const ePlusOne = this.restitution + 1;
    const GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
    const GiMf = this.computeGiMf();
    const B = -g * a - GW * b - h * GiMf;
    return B;
  }
  /**
   * Get the current relative velocity in the contact point.
   */


  getImpactVelocityAlongNormal() {
    const vi = ContactEquation_getImpactVelocityAlongNormal_vi;
    const vj = ContactEquation_getImpactVelocityAlongNormal_vj;
    const xi = ContactEquation_getImpactVelocityAlongNormal_xi;
    const xj = ContactEquation_getImpactVelocityAlongNormal_xj;
    const relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
    this.bi.position.vadd(this.ri, xi);
    this.bj.position.vadd(this.rj, xj);
    this.bi.getVelocityAtWorldPoint(xi, vi);
    this.bj.getVelocityAtWorldPoint(xj, vj);
    vi.vsub(vj, relVel);
    return this.ni.dot(relVel);
  }

}
const ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors

const ContactEquation_computeB_temp2 = new Vec3();
const ContactEquation_computeB_temp3 = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();

/**
 * Connects two bodies at given offset points.
 * @example
 *     const bodyA = new Body({ mass: 1 })
 *     const bodyB = new Body({ mass: 1 })
 *     bodyA.position.set(-1, 0, 0)
 *     bodyB.position.set(1, 0, 0)
 *     bodyA.addShape(shapeA)
 *     bodyB.addShape(shapeB)
 *     world.addBody(bodyA)
 *     world.addBody(bodyB)
 *     const localPivotA = new Vec3(1, 0, 0)
 *     const localPivotB = new Vec3(-1, 0, 0)
 *     const constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB)
 *     world.addConstraint(constraint)
 */
class PointToPointConstraint extends Constraint {
  /**
   * Pivot, defined locally in bodyA.
   */

  /**
   * Pivot, defined locally in bodyB.
   */

  /**
   * @param pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
   * @param bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
   * @param pivotB The point relative to the center of mass of bodyB which bodyB is constrained to.
   * @param maxForce The maximum force that should be applied to constrain the bodies.
   */
  constructor(bodyA, pivotA, bodyB, pivotB, maxForce) {
    if (pivotA === void 0) {
      pivotA = new Vec3();
    }

    if (pivotB === void 0) {
      pivotB = new Vec3();
    }

    if (maxForce === void 0) {
      maxForce = 1e6;
    }

    super(bodyA, bodyB);
    this.pivotA = pivotA.clone();
    this.pivotB = pivotB.clone();
    const x = this.equationX = new ContactEquation(bodyA, bodyB);
    const y = this.equationY = new ContactEquation(bodyA, bodyB);
    const z = this.equationZ = new ContactEquation(bodyA, bodyB); // Equations to be fed to the solver

    this.equations.push(x, y, z); // Make the equations bidirectional

    x.minForce = y.minForce = z.minForce = -maxForce;
    x.maxForce = y.maxForce = z.maxForce = maxForce;
    x.ni.set(1, 0, 0);
    y.ni.set(0, 1, 0);
    z.ni.set(0, 0, 1);
  }

  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const x = this.equationX;
    const y = this.equationY;
    const z = this.equationZ; // Rotate the pivots to world space

    bodyA.quaternion.vmult(this.pivotA, x.ri);
    bodyB.quaternion.vmult(this.pivotB, x.rj);
    y.ri.copy(x.ri);
    y.rj.copy(x.rj);
    z.ri.copy(x.ri);
    z.rj.copy(x.rj);
  }

}

/**
 * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
 */
class ConeEquation extends Equation {
  /**
   * Local axis in A
   */

  /**
   * Local axis in B
   */

  /**
   * The "cone angle" to keep
   */
  constructor(bodyA, bodyB, options) {
    if (options === void 0) {
      options = {};
    }

    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
    super(bodyA, bodyB, -maxForce, maxForce);
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
    this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const ni = this.axisA;
    const nj = this.axisB;
    const nixnj = tmpVec1$2;
    const njxni = tmpVec2$2;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB; // Caluclate cross products

    ni.cross(nj, nixnj);
    nj.cross(ni, njxni); // The angle between two vector is:
    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b
    // g = a * b
    // gdot = (b x a) * wi + (a x b) * wj
    // G = [0 bxa 0 axb]
    // W = [vi wi vj wj]

    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);
    const g = Math.cos(this.angle) - ni.dot(nj);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B = -g * a - GW * b - h * GiMf;
    return B;
  }

}
const tmpVec1$2 = new Vec3();
const tmpVec2$2 = new Vec3();

/**
 * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
 */
class RotationalEquation extends Equation {
  /**
   * World oriented rotational axis.
   */

  /**
   * World oriented rotational axis.
   */

  /**
   * maxAngle
   */
  constructor(bodyA, bodyB, options) {
    if (options === void 0) {
      options = {};
    }

    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
    super(bodyA, bodyB, -maxForce, maxForce);
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
    this.maxAngle = Math.PI / 2;
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const ni = this.axisA;
    const nj = this.axisB;
    const nixnj = tmpVec1$1;
    const njxni = tmpVec2$1;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB; // Caluclate cross products

    ni.cross(nj, nixnj);
    nj.cross(ni, njxni); // g = ni * nj
    // gdot = (nj x ni) * wi + (ni x nj) * wj
    // G = [0 njxni 0 nixnj]
    // W = [vi wi vj wj]

    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);
    const g = Math.cos(this.maxAngle) - ni.dot(nj);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B = -g * a - GW * b - h * GiMf;
    return B;
  }

}
const tmpVec1$1 = new Vec3();
const tmpVec2$1 = new Vec3();

/**
 * A Cone Twist constraint, useful for ragdolls.
 */
class ConeTwistConstraint extends PointToPointConstraint {
  /**
   * The axis direction for the constraint of the body A.
   */

  /**
   * The axis direction for the constraint of the body B.
   */

  /**
   * The aperture angle of the cone.
   */

  /**
   * The twist angle of the joint.
   */
  constructor(bodyA, bodyB, options) {
    if (options === void 0) {
      options = {};
    }

    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

    const pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    const pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    super(bodyA, pivotA, bodyB, pivotB, maxForce);
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3();
    this.collideConnected = !!options.collideConnected;
    this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
    const c = this.coneEquation = new ConeEquation(bodyA, bodyB, options);
    const t = this.twistEquation = new RotationalEquation(bodyA, bodyB, options);
    this.twistAngle = typeof options.twistAngle !== 'undefined' ? options.twistAngle : 0; // Make the cone equation push the bodies toward the cone axis, not outward

    c.maxForce = 0;
    c.minForce = -maxForce; // Make the twist equation add torque toward the initial position

    t.maxForce = 0;
    t.minForce = -maxForce;
    this.equations.push(c, t);
  }

  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const cone = this.coneEquation;
    const twist = this.twistEquation;
    super.update(); // Update the axes to the cone constraint

    bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
    bodyB.vectorToWorldFrame(this.axisB, cone.axisB); // Update the world axes in the twist constraint

    this.axisA.tangents(twist.axisA, twist.axisA);
    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);
    this.axisB.tangents(twist.axisB, twist.axisB);
    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);
    cone.angle = this.angle;
    twist.maxAngle = this.twistAngle;
  }

}
new Vec3();
new Vec3();

/**
 * Constrains two bodies to be at a constant distance from each others center of mass.
 */
class DistanceConstraint extends Constraint {
  /**
   * The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
   */

  /**
   * @param distance The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB.
   * @param maxForce The maximum force that should be applied to constrain the bodies.
   */
  constructor(bodyA, bodyB, distance, maxForce) {
    if (maxForce === void 0) {
      maxForce = 1e6;
    }

    super(bodyA, bodyB);

    if (typeof distance === 'undefined') {
      distance = bodyA.position.distanceTo(bodyB.position);
    }

    this.distance = distance;
    const eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
    this.equations.push(eq); // Make it bidirectional

    eq.minForce = -maxForce;
    eq.maxForce = maxForce;
  }
  /**
   * update
   */


  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const eq = this.distanceEquation;
    const halfDist = this.distance * 0.5;
    const normal = eq.ni;
    bodyB.position.vsub(bodyA.position, normal);
    normal.normalize();
    normal.scale(halfDist, eq.ri);
    normal.scale(-halfDist, eq.rj);
  }

}

/**
 * Lock constraint. Will remove all degrees of freedom between the bodies.
 */
class LockConstraint extends PointToPointConstraint {
  constructor(bodyA, bodyB, options) {
    if (options === void 0) {
      options = {};
    }

    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

    const pivotA = new Vec3();
    const pivotB = new Vec3();
    const halfWay = new Vec3();
    bodyA.position.vadd(bodyB.position, halfWay);
    halfWay.scale(0.5, halfWay);
    bodyB.pointToLocalFrame(halfWay, pivotB);
    bodyA.pointToLocalFrame(halfWay, pivotA); // The point-to-point constraint will keep a point shared between the bodies

    super(bodyA, pivotA, bodyB, pivotB, maxForce); // Store initial rotation of the bodies as unit vectors in the local body spaces

    this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);
    this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);
    this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);
    this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);
    this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);
    this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z); // ...and the following rotational equations will keep all rotational DOF's in place

    const r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
    const r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
    const r3 = this.rotationalEquation3 = new RotationalEquation(bodyA, bodyB, options);
    this.equations.push(r1, r2, r3);
  }
  /**
   * update
   */


  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    this.motorEquation;
    const r1 = this.rotationalEquation1;
    const r2 = this.rotationalEquation2;
    const r3 = this.rotationalEquation3;
    LockConstraint_update_tmpVec1;
    LockConstraint_update_tmpVec2;
    super.update(); // These vector pairs must be orthogonal

    bodyA.vectorToWorldFrame(this.xA, r1.axisA);
    bodyB.vectorToWorldFrame(this.yB, r1.axisB);
    bodyA.vectorToWorldFrame(this.yA, r2.axisA);
    bodyB.vectorToWorldFrame(this.zB, r2.axisB);
    bodyA.vectorToWorldFrame(this.zA, r3.axisA);
    bodyB.vectorToWorldFrame(this.xB, r3.axisB);
  }

}
const LockConstraint_update_tmpVec1 = new Vec3();
const LockConstraint_update_tmpVec2 = new Vec3();

/**
 * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
 */
class RotationalMotorEquation extends Equation {
  /**
   * World oriented rotational axis.
   */

  /**
   * World oriented rotational axis.
   */

  /**
   * Motor velocity.
   */
  constructor(bodyA, bodyB, maxForce) {
    if (maxForce === void 0) {
      maxForce = 1e6;
    }

    super(bodyA, bodyB, -maxForce, maxForce);
    this.axisA = new Vec3();
    this.axisB = new Vec3();
    this.targetVelocity = 0;
  }

  computeB(h) {
    this.a;
    const b = this.b;
    this.bi;
    this.bj;
    const axisA = this.axisA;
    const axisB = this.axisB;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB; // g = 0
    // gdot = axisA * wi - axisB * wj
    // gdot = G * W = G * [vi wi vj wj]
    // =>
    // G = [0 axisA 0 -axisB]

    GA.rotational.copy(axisA);
    axisB.negate(GB.rotational);
    const GW = this.computeGW() - this.targetVelocity;
    const GiMf = this.computeGiMf();
    const B = -GW * b - h * GiMf;
    return B;
  }

}

/**
 * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
 */
class HingeConstraint extends PointToPointConstraint {
  /**
   * Rotation axis, defined locally in bodyA.
   */

  /**
   * Rotation axis, defined locally in bodyB.
   */
  constructor(bodyA, bodyB, options) {
    if (options === void 0) {
      options = {};
    }

    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
    const pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    const pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    super(bodyA, pivotA, bodyB, pivotB, maxForce);
    const axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    axisA.normalize();
    const axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1, 0, 0);
    axisB.normalize();
    this.collideConnected = !!options.collideConnected;
    const rotational1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
    const rotational2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
    const motor = this.motorEquation = new RotationalMotorEquation(bodyA, bodyB, maxForce);
    motor.enabled = false; // Not enabled by default
    // Equations to be fed to the solver

    this.equations.push(rotational1, rotational2, motor);
  }
  /**
   * enableMotor
   */


  enableMotor() {
    this.motorEquation.enabled = true;
  }
  /**
   * disableMotor
   */


  disableMotor() {
    this.motorEquation.enabled = false;
  }
  /**
   * setMotorSpeed
   */


  setMotorSpeed(speed) {
    this.motorEquation.targetVelocity = speed;
  }
  /**
   * setMotorMaxForce
   */


  setMotorMaxForce(maxForce) {
    this.motorEquation.maxForce = maxForce;
    this.motorEquation.minForce = -maxForce;
  }
  /**
   * update
   */


  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const motor = this.motorEquation;
    const r1 = this.rotationalEquation1;
    const r2 = this.rotationalEquation2;
    const worldAxisA = HingeConstraint_update_tmpVec1;
    const worldAxisB = HingeConstraint_update_tmpVec2;
    const axisA = this.axisA;
    const axisB = this.axisB;
    super.update(); // Get world axes

    bodyA.quaternion.vmult(axisA, worldAxisA);
    bodyB.quaternion.vmult(axisB, worldAxisB);
    worldAxisA.tangents(r1.axisA, r2.axisA);
    r1.axisB.copy(worldAxisB);
    r2.axisB.copy(worldAxisB);

    if (this.motorEquation.enabled) {
      bodyA.quaternion.vmult(this.axisA, motor.axisA);
      bodyB.quaternion.vmult(this.axisB, motor.axisB);
    }
  }

}
const HingeConstraint_update_tmpVec1 = new Vec3();
const HingeConstraint_update_tmpVec2 = new Vec3();

/**
 * Constrains the slipping in a contact along a tangent
 */
class FrictionEquation extends Equation {
  // Tangent

  /**
   * @param slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
   */
  constructor(bodyA, bodyB, slipForce) {
    super(bodyA, bodyB, -slipForce, slipForce);
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.t = new Vec3();
  }

  computeB(h) {
    this.a;
    const b = this.b;
    this.bi;
    this.bj;
    const ri = this.ri;
    const rj = this.rj;
    const rixt = FrictionEquation_computeB_temp1;
    const rjxt = FrictionEquation_computeB_temp2;
    const t = this.t; // Caluclate cross products

    ri.cross(t, rixt);
    rj.cross(t, rjxt); // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!

    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    t.negate(GA.spatial);
    rixt.negate(GA.rotational);
    GB.spatial.copy(t);
    GB.rotational.copy(rjxt);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B = -GW * b - h * GiMf;
    return B;
  }

}
const FrictionEquation_computeB_temp1 = new Vec3();
const FrictionEquation_computeB_temp2 = new Vec3();

/**
 * Defines what happens when two materials meet.
 * @todo Refactor materials to materialA and materialB
 */
class ContactMaterial {
  /**
   * Identifier of this material.
   */

  /**
   * Participating materials.
   */

  /**
   * Friction coefficient.
   * @default 0.3
   */

  /**
   * Restitution coefficient.
   * @default 0.3
   */

  /**
   * Stiffness of the produced contact equations.
   * @default 1e7
   */

  /**
   * Relaxation time of the produced contact equations.
   * @default 3
   */

  /**
   * Stiffness of the produced friction equations.
   * @default 1e7
   */

  /**
   * Relaxation time of the produced friction equations
   * @default 3
   */
  constructor(m1, m2, options) {
    options = Utils.defaults(options, {
      friction: 0.3,
      restitution: 0.3,
      contactEquationStiffness: 1e7,
      contactEquationRelaxation: 3,
      frictionEquationStiffness: 1e7,
      frictionEquationRelaxation: 3
    });
    this.id = ContactMaterial.idCounter++;
    this.materials = [m1, m2];
    this.friction = options.friction;
    this.restitution = options.restitution;
    this.contactEquationStiffness = options.contactEquationStiffness;
    this.contactEquationRelaxation = options.contactEquationRelaxation;
    this.frictionEquationStiffness = options.frictionEquationStiffness;
    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
  }

}
ContactMaterial.idCounter = 0;

/**
 * Defines a physics material.
 */
class Material {
  /**
   * Material name.
   * If options is a string, name will be set to that string.
   * @todo Deprecate this
   */

  /** Material id. */

  /**
   * Friction for this material.
   * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
   */

  /**
   * Restitution for this material.
   * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }

    let name = ''; // Backwards compatibility fix

    if (typeof options === 'string') {
      //console.warn(`Passing a string to MaterialOptions is deprecated, and has no effect`)
      name = options;
      options = {};
    }

    this.name = name;
    this.id = Material.idCounter++;
    this.friction = typeof options.friction !== 'undefined' ? options.friction : -1;
    this.restitution = typeof options.restitution !== 'undefined' ? options.restitution : -1;
  }

}
Material.idCounter = 0;

/**
 * A spring, connecting two bodies.
 * @example
 *     const spring = new Spring(boxBody, sphereBody, {
 *       restLength: 0,
 *       stiffness: 50,
 *       damping: 1,
 *     })
 *
 *     // Compute the force after each step
 *     world.addEventListener('postStep', (event) => {
 *       spring.applyForce()
 *     })
 */
class Spring {
  /**
   * Rest length of the spring. A number > 0.
   * @default 1
   */

  /**
   * Stiffness of the spring. A number >= 0.
   * @default 100
   */

  /**
   * Damping of the spring. A number >= 0.
   * @default 1
   */

  /**
   * First connected body.
   */

  /**
   * Second connected body.
   */

  /**
   * Anchor for bodyA in local bodyA coordinates.
   * Where to hook the spring to body A, in local body coordinates.
   * @default new Vec3()
   */

  /**
   * Anchor for bodyB in local bodyB coordinates.
   * Where to hook the spring to body B, in local body coordinates.
   * @default new Vec3()
   */
  constructor(bodyA, bodyB, options) {
    if (options === void 0) {
      options = {};
    }

    this.restLength = typeof options.restLength === 'number' ? options.restLength : 1;
    this.stiffness = options.stiffness || 100;
    this.damping = options.damping || 1;
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.localAnchorA = new Vec3();
    this.localAnchorB = new Vec3();

    if (options.localAnchorA) {
      this.localAnchorA.copy(options.localAnchorA);
    }

    if (options.localAnchorB) {
      this.localAnchorB.copy(options.localAnchorB);
    }

    if (options.worldAnchorA) {
      this.setWorldAnchorA(options.worldAnchorA);
    }

    if (options.worldAnchorB) {
      this.setWorldAnchorB(options.worldAnchorB);
    }
  }
  /**
   * Set the anchor point on body A, using world coordinates.
   */


  setWorldAnchorA(worldAnchorA) {
    this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
  }
  /**
   * Set the anchor point on body B, using world coordinates.
   */


  setWorldAnchorB(worldAnchorB) {
    this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
  }
  /**
   * Get the anchor point on body A, in world coordinates.
   * @param result The vector to store the result in.
   */


  getWorldAnchorA(result) {
    this.bodyA.pointToWorldFrame(this.localAnchorA, result);
  }
  /**
   * Get the anchor point on body B, in world coordinates.
   * @param result The vector to store the result in.
   */


  getWorldAnchorB(result) {
    this.bodyB.pointToWorldFrame(this.localAnchorB, result);
  }
  /**
   * Apply the spring force to the connected bodies.
   */


  applyForce() {
    const k = this.stiffness;
    const d = this.damping;
    const l = this.restLength;
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const r = applyForce_r;
    const r_unit = applyForce_r_unit;
    const u = applyForce_u;
    const f = applyForce_f;
    const tmp = applyForce_tmp;
    const worldAnchorA = applyForce_worldAnchorA;
    const worldAnchorB = applyForce_worldAnchorB;
    const ri = applyForce_ri;
    const rj = applyForce_rj;
    const ri_x_f = applyForce_ri_x_f;
    const rj_x_f = applyForce_rj_x_f; // Get world anchors

    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB); // Get offset points

    worldAnchorA.vsub(bodyA.position, ri);
    worldAnchorB.vsub(bodyB.position, rj); // Compute distance vector between world anchor points

    worldAnchorB.vsub(worldAnchorA, r);
    const rlen = r.length();
    r_unit.copy(r);
    r_unit.normalize(); // Compute relative velocity of the anchor points, u

    bodyB.velocity.vsub(bodyA.velocity, u); // Add rotational velocity

    bodyB.angularVelocity.cross(rj, tmp);
    u.vadd(tmp, u);
    bodyA.angularVelocity.cross(ri, tmp);
    u.vsub(tmp, u); // F = - k * ( x - L ) - D * ( u )

    r_unit.scale(-k * (rlen - l) - d * u.dot(r_unit), f); // Add forces to bodies

    bodyA.force.vsub(f, bodyA.force);
    bodyB.force.vadd(f, bodyB.force); // Angular force

    ri.cross(f, ri_x_f);
    rj.cross(f, rj_x_f);
    bodyA.torque.vsub(ri_x_f, bodyA.torque);
    bodyB.torque.vadd(rj_x_f, bodyB.torque);
  }

}
const applyForce_r = new Vec3();
const applyForce_r_unit = new Vec3();
const applyForce_u = new Vec3();
const applyForce_f = new Vec3();
const applyForce_worldAnchorA = new Vec3();
const applyForce_worldAnchorB = new Vec3();
const applyForce_ri = new Vec3();
const applyForce_rj = new Vec3();
const applyForce_ri_x_f = new Vec3();
const applyForce_rj_x_f = new Vec3();
const applyForce_tmp = new Vec3();

/**
 * WheelInfo
 */
class WheelInfo {
  /**
   * Max travel distance of the suspension, in meters.
   * @default 1
   */

  /**
   * Speed to apply to the wheel rotation when the wheel is sliding.
   * @default -0.1
   */

  /**
   * If the customSlidingRotationalSpeed should be used.
   * @default false
   */

  /**
   * sliding
   */

  /**
   * Connection point, defined locally in the chassis body frame.
   */

  /**
   * chassisConnectionPointWorld
   */

  /**
   * directionLocal
   */

  /**
   * directionWorld
   */

  /**
   * axleLocal
   */

  /**
   * axleWorld
   */

  /**
   * suspensionRestLength
   * @default 1
   */

  /**
   * suspensionMaxLength
   * @default 2
   */

  /**
   * radius
   * @default 1
   */

  /**
   * suspensionStiffness
   * @default 100
   */

  /**
   * dampingCompression
   * @default 10
   */

  /**
   * dampingRelaxation
   * @default 10
   */

  /**
   * frictionSlip
   * @default 10.5
   */

  /** forwardAcceleration */

  /** sideAcceleration */

  /**
   * steering
   * @default 0
   */

  /**
   * Rotation value, in radians.
   * @default 0
   */

  /**
   * deltaRotation
   * @default 0
   */

  /**
   * rollInfluence
   * @default 0.01
   */

  /**
   * maxSuspensionForce
   */

  /**
   * engineForce
   */

  /**
   * brake
   */

  /**
   * isFrontWheel
   * @default true
   */

  /**
   * clippedInvContactDotSuspension
   * @default 1
   */

  /**
   * suspensionRelativeVelocity
   * @default 0
   */

  /**
   * suspensionForce
   * @default 0
   */

  /**
   * slipInfo
   */

  /**
   * skidInfo
   * @default 0
   */

  /**
   * suspensionLength
   * @default 0
   */

  /**
   * sideImpulse
   */

  /**
   * forwardImpulse
   */

  /**
   * The result from raycasting.
   */

  /**
   * Wheel world transform.
   */

  /**
   * isInContact
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }

    options = Utils.defaults(options, {
      chassisConnectionPointLocal: new Vec3(),
      chassisConnectionPointWorld: new Vec3(),
      directionLocal: new Vec3(),
      directionWorld: new Vec3(),
      axleLocal: new Vec3(),
      axleWorld: new Vec3(),
      suspensionRestLength: 1,
      suspensionMaxLength: 2,
      radius: 1,
      suspensionStiffness: 100,
      dampingCompression: 10,
      dampingRelaxation: 10,
      frictionSlip: 10.5,
      forwardAcceleration: 1,
      sideAcceleration: 1,
      steering: 0,
      rotation: 0,
      deltaRotation: 0,
      rollInfluence: 0.01,
      maxSuspensionForce: Number.MAX_VALUE,
      isFrontWheel: true,
      clippedInvContactDotSuspension: 1,
      suspensionRelativeVelocity: 0,
      suspensionForce: 0,
      slipInfo: 0,
      skidInfo: 0,
      suspensionLength: 0,
      maxSuspensionTravel: 1,
      useCustomSlidingRotationalSpeed: false,
      customSlidingRotationalSpeed: -0.1
    });
    this.maxSuspensionTravel = options.maxSuspensionTravel;
    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
    this.sliding = false;
    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();
    this.directionLocal = options.directionLocal.clone();
    this.directionWorld = options.directionWorld.clone();
    this.axleLocal = options.axleLocal.clone();
    this.axleWorld = options.axleWorld.clone();
    this.suspensionRestLength = options.suspensionRestLength;
    this.suspensionMaxLength = options.suspensionMaxLength;
    this.radius = options.radius;
    this.suspensionStiffness = options.suspensionStiffness;
    this.dampingCompression = options.dampingCompression;
    this.dampingRelaxation = options.dampingRelaxation;
    this.frictionSlip = options.frictionSlip;
    this.forwardAcceleration = options.forwardAcceleration;
    this.sideAcceleration = options.sideAcceleration;
    this.steering = 0;
    this.rotation = 0;
    this.deltaRotation = 0;
    this.rollInfluence = options.rollInfluence;
    this.maxSuspensionForce = options.maxSuspensionForce;
    this.engineForce = 0;
    this.brake = 0;
    this.isFrontWheel = options.isFrontWheel;
    this.clippedInvContactDotSuspension = 1;
    this.suspensionRelativeVelocity = 0;
    this.suspensionForce = 0;
    this.slipInfo = 0;
    this.skidInfo = 0;
    this.suspensionLength = 0;
    this.sideImpulse = 0;
    this.forwardImpulse = 0;
    this.raycastResult = new RaycastResult();
    this.worldTransform = new Transform();
    this.isInContact = false;
  }

  updateWheel(chassis) {
    const raycastResult = this.raycastResult;

    if (this.isInContact) {
      const project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
      raycastResult.hitPointWorld.vsub(chassis.position, relpos);
      chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
      const projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

      if (project >= -0.1) {
        this.suspensionRelativeVelocity = 0.0;
        this.clippedInvContactDotSuspension = 1.0 / 0.1;
      } else {
        const inv = -1 / project;
        this.suspensionRelativeVelocity = projVel * inv;
        this.clippedInvContactDotSuspension = inv;
      }
    } else {
      // Not in contact : position wheel in a nice (rest length) position
      raycastResult.suspensionLength = this.suspensionRestLength;
      this.suspensionRelativeVelocity = 0.0;
      raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
      this.clippedInvContactDotSuspension = 1.0;
    }
  }

}
const chassis_velocity_at_contactPoint = new Vec3();
const relpos = new Vec3();

/**
 * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
 */
class RaycastVehicle {
  /** The car chassis body. */

  /** The wheels. */

  /** Will be set to true if the car is sliding. */

  /** Index of the right axis. x=0, y=1, z=2 */

  /** Index of the forward axis. x=0, y=1, z=2 */

  /** Index of the up axis. x=0, y=1, z=2 */

  /** The constraints. */

  /** Optional pre-step callback. */

  /** Number of wheels on the ground. */
  constructor(options) {
    this.chassisBody = options.chassisBody;
    this.wheelInfos = [];
    this.sliding = false;
    this.world = null;
    this.indexRightAxis = typeof options.indexRightAxis !== 'undefined' ? options.indexRightAxis : 2;
    this.indexForwardAxis = typeof options.indexForwardAxis !== 'undefined' ? options.indexForwardAxis : 0;
    this.indexUpAxis = typeof options.indexUpAxis !== 'undefined' ? options.indexUpAxis : 1;
    this.constraints = [];

    this.preStepCallback = () => {};

    this.currentVehicleSpeedKmHour = 0;
    this.numWheelsOnGround = 0;
  }
  /**
   * Add a wheel. For information about the options, see `WheelInfo`.
   */


  addWheel(options) {
    if (options === void 0) {
      options = {};
    }

    const info = new WheelInfo(options);
    const index = this.wheelInfos.length;
    this.wheelInfos.push(info);
    return index;
  }
  /**
   * Set the steering value of a wheel.
   */


  setSteeringValue(value, wheelIndex) {
    const wheel = this.wheelInfos[wheelIndex];
    wheel.steering = value;
  }
  /**
   * Set the wheel force to apply on one of the wheels each time step
   */


  applyEngineForce(value, wheelIndex) {
    this.wheelInfos[wheelIndex].engineForce = value;
  }
  /**
   * Set the braking force of a wheel
   */


  setBrake(brake, wheelIndex) {
    this.wheelInfos[wheelIndex].brake = brake;
  }
  /**
   * Add the vehicle including its constraints to the world.
   */


  addToWorld(world) {
    world.addBody(this.chassisBody);
    const that = this;

    this.preStepCallback = () => {
      that.updateVehicle(world.dt);
    };

    world.addEventListener('preStep', this.preStepCallback);
    this.world = world;
  }
  /**
   * Get one of the wheel axles, world-oriented.
   */


  getVehicleAxisWorld(axisIndex, result) {
    result.set(axisIndex === 0 ? 1 : 0, axisIndex === 1 ? 1 : 0, axisIndex === 2 ? 1 : 0);
    this.chassisBody.vectorToWorldFrame(result, result);
  }

  updateVehicle(timeStep) {
    const wheelInfos = this.wheelInfos;
    const numWheels = wheelInfos.length;
    const chassisBody = this.chassisBody;

    for (let i = 0; i < numWheels; i++) {
      this.updateWheelTransform(i);
    }

    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.length();
    const forwardWorld = new Vec3();
    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

    if (forwardWorld.dot(chassisBody.velocity) < 0) {
      this.currentVehicleSpeedKmHour *= -1;
    } // simulate suspension


    for (let i = 0; i < numWheels; i++) {
      this.castRay(wheelInfos[i]);
    }

    this.updateSuspension(timeStep);
    const impulse = new Vec3();
    const relpos = new Vec3();

    for (let i = 0; i < numWheels; i++) {
      //apply suspension force
      const wheel = wheelInfos[i];
      let suspensionForce = wheel.suspensionForce;

      if (suspensionForce > wheel.maxSuspensionForce) {
        suspensionForce = wheel.maxSuspensionForce;
      }

      wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);
      wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
      chassisBody.applyImpulse(impulse, relpos);
    }

    this.updateFriction(timeStep);
    const hitNormalWorldScaledWithProj = new Vec3();
    const fwd = new Vec3();
    const vel = new Vec3();

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i]; //const relpos = new Vec3();
      //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);

      chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel); // Hack to get the rotation in the correct direction

      let m = 1;

      switch (this.indexUpAxis) {
        case 1:
          m = -1;
          break;
      }

      if (wheel.isInContact) {
        this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
        const proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
        wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);
        fwd.vsub(hitNormalWorldScaledWithProj, fwd);
        const proj2 = fwd.dot(vel);
        wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
      }

      if ((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed) {
        // Apply custom rotation when accelerating and sliding
        wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
      } // Lock wheels


      if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {
        wheel.deltaRotation = 0;
      }

      wheel.rotation += wheel.deltaRotation; // Use the old value

      wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
    }
  }

  updateSuspension(deltaTime) {
    const chassisBody = this.chassisBody;
    const chassisMass = chassisBody.mass;
    const wheelInfos = this.wheelInfos;
    const numWheels = wheelInfos.length;

    for (let w_it = 0; w_it < numWheels; w_it++) {
      const wheel = wheelInfos[w_it];

      if (wheel.isInContact) {
        let force; // Spring

        const susp_length = wheel.suspensionRestLength;
        const current_length = wheel.suspensionLength;
        const length_diff = susp_length - current_length;
        force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension; // Damper

        const projected_rel_vel = wheel.suspensionRelativeVelocity;
        let susp_damping;

        if (projected_rel_vel < 0) {
          susp_damping = wheel.dampingCompression;
        } else {
          susp_damping = wheel.dampingRelaxation;
        }

        force -= susp_damping * projected_rel_vel;
        wheel.suspensionForce = force * chassisMass;

        if (wheel.suspensionForce < 0) {
          wheel.suspensionForce = 0;
        }
      } else {
        wheel.suspensionForce = 0;
      }
    }
  }
  /**
   * Remove the vehicle including its constraints from the world.
   */


  removeFromWorld(world) {
    this.constraints;
    world.removeBody(this.chassisBody);
    world.removeEventListener('preStep', this.preStepCallback);
    this.world = null;
  }

  castRay(wheel) {
    const rayvector = castRay_rayvector;
    const target = castRay_target;
    this.updateWheelTransformWorld(wheel);
    const chassisBody = this.chassisBody;
    let depth = -1;
    const raylen = wheel.suspensionRestLength + wheel.radius;
    wheel.directionWorld.scale(raylen, rayvector);
    const source = wheel.chassisConnectionPointWorld;
    source.vadd(rayvector, target);
    const raycastResult = wheel.raycastResult;
    raycastResult.reset(); // Turn off ray collision with the chassis temporarily

    const oldState = chassisBody.collisionResponse;
    chassisBody.collisionResponse = false; // Cast ray against world

    this.world.rayTest(source, target, raycastResult);
    chassisBody.collisionResponse = oldState;
    const object = raycastResult.body;
    wheel.raycastResult.groundObject = 0;

    if (object) {
      depth = raycastResult.distance;
      wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld;
      wheel.isInContact = true;
      const hitDistance = raycastResult.distance;
      wheel.suspensionLength = hitDistance - wheel.radius; // clamp on max suspension travel

      const minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
      const maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;

      if (wheel.suspensionLength < minSuspensionLength) {
        wheel.suspensionLength = minSuspensionLength;
      }

      if (wheel.suspensionLength > maxSuspensionLength) {
        wheel.suspensionLength = maxSuspensionLength;
        wheel.raycastResult.reset();
      }

      const denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);
      const chassis_velocity_at_contactPoint = new Vec3();
      chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
      const projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

      if (denominator >= -0.1) {
        wheel.suspensionRelativeVelocity = 0;
        wheel.clippedInvContactDotSuspension = 1 / 0.1;
      } else {
        const inv = -1 / denominator;
        wheel.suspensionRelativeVelocity = projVel * inv;
        wheel.clippedInvContactDotSuspension = inv;
      }
    } else {
      //put wheel info as in rest position
      wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
      wheel.suspensionRelativeVelocity = 0.0;
      wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
      wheel.clippedInvContactDotSuspension = 1.0;
    }

    return depth;
  }

  updateWheelTransformWorld(wheel) {
    wheel.isInContact = false;
    const chassisBody = this.chassisBody;
    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
  }
  /**
   * Update one of the wheel transform.
   * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
   * @param wheelIndex The wheel index to update.
   */


  updateWheelTransform(wheelIndex) {
    const up = tmpVec4;
    const right = tmpVec5;
    const fwd = tmpVec6;
    const wheel = this.wheelInfos[wheelIndex];
    this.updateWheelTransformWorld(wheel);
    wheel.directionLocal.scale(-1, up);
    right.copy(wheel.axleLocal);
    up.cross(right, fwd);
    fwd.normalize();
    right.normalize(); // Rotate around steering over the wheelAxle

    const steering = wheel.steering;
    const steeringOrn = new Quaternion();
    steeringOrn.setFromAxisAngle(up, steering);
    const rotatingOrn = new Quaternion();
    rotatingOrn.setFromAxisAngle(right, wheel.rotation); // World rotation of the wheel

    const q = wheel.worldTransform.quaternion;
    this.chassisBody.quaternion.mult(steeringOrn, q);
    q.mult(rotatingOrn, q);
    q.normalize(); // world position of the wheel

    const p = wheel.worldTransform.position;
    p.copy(wheel.directionWorld);
    p.scale(wheel.suspensionLength, p);
    p.vadd(wheel.chassisConnectionPointWorld, p);
  }
  /**
   * Get the world transform of one of the wheels
   */


  getWheelTransformWorld(wheelIndex) {
    return this.wheelInfos[wheelIndex].worldTransform;
  }

  updateFriction(timeStep) {
    const surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj; //calculate the impulse, so that the wheels don't move sidewards

    const wheelInfos = this.wheelInfos;
    const numWheels = wheelInfos.length;
    const chassisBody = this.chassisBody;
    const forwardWS = updateFriction_forwardWS;
    const axle = updateFriction_axle;
    this.numWheelsOnGround = 0;

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const groundObject = wheel.raycastResult.body;

      if (groundObject) {
        this.numWheelsOnGround++;
      }

      wheel.sideImpulse = 0;
      wheel.forwardImpulse = 0;

      if (!forwardWS[i]) {
        forwardWS[i] = new Vec3();
      }

      if (!axle[i]) {
        axle[i] = new Vec3();
      }
    }

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const groundObject = wheel.raycastResult.body;

      if (groundObject) {
        const axlei = axle[i];
        const wheelTrans = this.getWheelTransformWorld(i); // Get world axle

        wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);
        const surfNormalWS = wheel.raycastResult.hitNormalWorld;
        const proj = axlei.dot(surfNormalWS);
        surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
        axlei.vsub(surfNormalWS_scaled_proj, axlei);
        axlei.normalize();
        surfNormalWS.cross(axlei, forwardWS[i]);
        forwardWS[i].normalize();
        wheel.sideImpulse = resolveSingleBilateral(chassisBody, wheel.raycastResult.hitPointWorld, groundObject, wheel.raycastResult.hitPointWorld, axlei);
        wheel.sideImpulse *= sideFrictionStiffness2;
      }
    }

    const sideFactor = 1;
    const fwdFactor = 0.5;
    this.sliding = false;

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const groundObject = wheel.raycastResult.body;
      let rollingFriction = 0;
      wheel.slipInfo = 1;

      if (groundObject) {
        const defaultRollingFrictionImpulse = 0;
        const maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse; // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
        // rollingFriction = calcRollingFriction(contactPt);

        rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);
        rollingFriction += wheel.engineForce * timeStep; // rollingFriction = 0;

        const factor = maxImpulse / rollingFriction;
        wheel.slipInfo *= factor;
      } //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)


      wheel.forwardImpulse = 0;
      wheel.skidInfo = 1;

      if (groundObject) {
        wheel.skidInfo = 1;
        const maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
        const maximpSide = maximp;
        const maximpSquared = maximp * maximpSide;
        wheel.forwardImpulse = rollingFriction; //wheelInfo.engineForce* timeStep;

        const x = wheel.forwardImpulse * fwdFactor / wheel.forwardAcceleration;
        const y = wheel.sideImpulse * sideFactor / wheel.sideAcceleration;
        const impulseSquared = x * x + y * y;
        wheel.sliding = false;

        if (impulseSquared > maximpSquared) {
          this.sliding = true;
          wheel.sliding = true;
          const factor = maximp / Math.sqrt(impulseSquared);
          wheel.skidInfo *= factor;
        }
      }
    }

    if (this.sliding) {
      for (let i = 0; i < numWheels; i++) {
        const wheel = wheelInfos[i];

        if (wheel.sideImpulse !== 0) {
          if (wheel.skidInfo < 1) {
            wheel.forwardImpulse *= wheel.skidInfo;
            wheel.sideImpulse *= wheel.skidInfo;
          }
        }
      }
    } // apply the impulses


    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const rel_pos = new Vec3();
      wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos); // cannons applyimpulse is using world coord for the position
      //rel_pos.copy(wheel.raycastResult.hitPointWorld);

      if (wheel.forwardImpulse !== 0) {
        const impulse = new Vec3();
        forwardWS[i].scale(wheel.forwardImpulse, impulse);
        chassisBody.applyImpulse(impulse, rel_pos);
      }

      if (wheel.sideImpulse !== 0) {
        const groundObject = wheel.raycastResult.body;
        const rel_pos2 = new Vec3();
        wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2); //rel_pos2.copy(wheel.raycastResult.hitPointWorld);

        const sideImp = new Vec3();
        axle[i].scale(wheel.sideImpulse, sideImp); // Scale the relative position in the up direction with rollInfluence.
        // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).

        chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
        rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
        chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
        chassisBody.applyImpulse(sideImp, rel_pos); //apply friction impulse on the ground

        sideImp.scale(-1, sideImp);
        groundObject.applyImpulse(sideImp, rel_pos2);
      }
    }
  }

}
new Vec3();
new Vec3();
new Vec3();
const tmpVec4 = new Vec3();
const tmpVec5 = new Vec3();
const tmpVec6 = new Vec3();
new Ray();
new Vec3();
const castRay_rayvector = new Vec3();
const castRay_target = new Vec3();
const directions = [new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1)];
const updateFriction_surfNormalWS_scaled_proj = new Vec3();
const updateFriction_axle = [];
const updateFriction_forwardWS = [];
const sideFrictionStiffness2 = 1;
const calcRollingFriction_vel1 = new Vec3();
const calcRollingFriction_vel2 = new Vec3();
const calcRollingFriction_vel = new Vec3();

function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
  let j1 = 0;
  const contactPosWorld = frictionPosWorld; // const rel_pos1 = new Vec3();
  // const rel_pos2 = new Vec3();

  const vel1 = calcRollingFriction_vel1;
  const vel2 = calcRollingFriction_vel2;
  const vel = calcRollingFriction_vel; // contactPosWorld.vsub(body0.position, rel_pos1);
  // contactPosWorld.vsub(body1.position, rel_pos2);

  body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
  body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
  vel1.vsub(vel2, vel);
  const vrel = frictionDirectionWorld.dot(vel);
  const denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
  const denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
  const relaxation = 1;
  const jacDiagABInv = relaxation / (denom0 + denom1); // calculate j that moves us to zero relative velocity

  j1 = -vrel * jacDiagABInv;

  if (maxImpulse < j1) {
    j1 = maxImpulse;
  }

  if (j1 < -maxImpulse) {
    j1 = -maxImpulse;
  }

  return j1;
}

const computeImpulseDenominator_r0 = new Vec3();
const computeImpulseDenominator_c0 = new Vec3();
const computeImpulseDenominator_vec = new Vec3();
const computeImpulseDenominator_m = new Vec3();

function computeImpulseDenominator(body, pos, normal) {
  const r0 = computeImpulseDenominator_r0;
  const c0 = computeImpulseDenominator_c0;
  const vec = computeImpulseDenominator_vec;
  const m = computeImpulseDenominator_m;
  pos.vsub(body.position, r0);
  r0.cross(normal, c0);
  body.invInertiaWorld.vmult(c0, m);
  m.cross(r0, vec);
  return body.invMass + normal.dot(vec);
}

const resolveSingleBilateral_vel1 = new Vec3();
const resolveSingleBilateral_vel2 = new Vec3();
const resolveSingleBilateral_vel = new Vec3(); // bilateral constraint between two dynamic objects

function resolveSingleBilateral(body1, pos1, body2, pos2, normal) {
  const normalLenSqr = normal.lengthSquared();

  if (normalLenSqr > 1.1) {
    return 0; // no impulse
  } // const rel_pos1 = new Vec3();
  // const rel_pos2 = new Vec3();
  // pos1.vsub(body1.position, rel_pos1);
  // pos2.vsub(body2.position, rel_pos2);


  const vel1 = resolveSingleBilateral_vel1;
  const vel2 = resolveSingleBilateral_vel2;
  const vel = resolveSingleBilateral_vel;
  body1.getVelocityAtWorldPoint(pos1, vel1);
  body2.getVelocityAtWorldPoint(pos2, vel2);
  vel1.vsub(vel2, vel);
  const rel_vel = normal.dot(vel);
  const contactDamping = 0.2;
  const massTerm = 1 / (body1.invMass + body2.invMass);
  const impulse = -contactDamping * rel_vel * massTerm;
  return impulse;
}

/**
 * Spherical shape
 * @example
 *     const radius = 1
 *     const sphereShape = new CANNON.Sphere(radius)
 *     const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape })
 *     world.addBody(sphereBody)
 */
class Sphere extends Shape {
  /**
   * The radius of the sphere.
   */

  /**
   *
   * @param radius The radius of the sphere, a non-negative number.
   */
  constructor(radius) {
    super({
      type: Shape.types.SPHERE
    });
    this.radius = radius !== undefined ? radius : 1.0;

    if (this.radius < 0) {
      throw new Error('The sphere radius cannot be negative.');
    }

    this.updateBoundingSphereRadius();
  }
  /** calculateLocalInertia */


  calculateLocalInertia(mass, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    const I = 2.0 * mass * this.radius * this.radius / 5.0;
    target.x = I;
    target.y = I;
    target.z = I;
    return target;
  }
  /** volume */


  volume() {
    return 4.0 * Math.PI * Math.pow(this.radius, 3) / 3.0;
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.radius;
  }

  calculateWorldAABB(pos, quat, min, max) {
    const r = this.radius;
    const axes = ['x', 'y', 'z'];

    for (let i = 0; i < axes.length; i++) {
      const ax = axes[i];
      min[ax] = pos[ax] - r;
      max[ax] = pos[ax] + r;
    }
  }

}

/**
 * Simple vehicle helper class with spherical rigid body wheels.
 */
class RigidVehicle {
  /**
   * The bodies of the wheels.
   */

  /**
   * The chassis body.
   */

  /**
   * The constraints.
   */

  /**
   * The wheel axes.
   */

  /**
   * The wheel forces.
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }

    this.wheelBodies = [];
    this.coordinateSystem = typeof options.coordinateSystem !== 'undefined' ? options.coordinateSystem.clone() : new Vec3(1, 2, 3);

    if (options.chassisBody) {
      this.chassisBody = options.chassisBody;
    } else {
      // No chassis body given. Create it!
      this.chassisBody = new Body({
        mass: 1,
        shape: new Box(new Vec3(5, 0.5, 2))
      });
    }

    this.constraints = [];
    this.wheelAxes = [];
    this.wheelForces = [];
  }
  /**
   * Add a wheel
   */


  addWheel(options) {
    if (options === void 0) {
      options = {};
    }

    let wheelBody;

    if (options.body) {
      wheelBody = options.body;
    } else {
      // No wheel body given. Create it!
      wheelBody = new Body({
        mass: 1,
        shape: new Sphere(1.2)
      });
    }

    this.wheelBodies.push(wheelBody);
    this.wheelForces.push(0); // Position constrain wheels

    const position = typeof options.position !== 'undefined' ? options.position.clone() : new Vec3(); // Set position locally to the chassis

    const worldPosition = new Vec3();
    this.chassisBody.pointToWorldFrame(position, worldPosition);
    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z); // Constrain wheel

    const axis = typeof options.axis !== 'undefined' ? options.axis.clone() : new Vec3(0, 0, 1);
    this.wheelAxes.push(axis);
    const hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
      pivotA: position,
      axisA: axis,
      pivotB: Vec3.ZERO,
      axisB: axis,
      collideConnected: false
    });
    this.constraints.push(hingeConstraint);
    return this.wheelBodies.length - 1;
  }
  /**
   * Set the steering value of a wheel.
   * @todo check coordinateSystem
   */


  setSteeringValue(value, wheelIndex) {
    // Set angle of the hinge axis
    const axis = this.wheelAxes[wheelIndex];
    const c = Math.cos(value);
    const s = Math.sin(value);
    const x = axis.x;
    const z = axis.z;
    this.constraints[wheelIndex].axisA.set(-c * x + s * z, 0, s * x + c * z);
  }
  /**
   * Set the target rotational speed of the hinge constraint.
   */


  setMotorSpeed(value, wheelIndex) {
    const hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.enableMotor();
    hingeConstraint.motorTargetVelocity = value;
  }
  /**
   * Set the target rotational speed of the hinge constraint.
   */


  disableMotor(wheelIndex) {
    const hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.disableMotor();
  }
  /**
   * Set the wheel force to apply on one of the wheels each time step
   */


  setWheelForce(value, wheelIndex) {
    this.wheelForces[wheelIndex] = value;
  }
  /**
   * Apply a torque on one of the wheels.
   */


  applyWheelForce(value, wheelIndex) {
    const axis = this.wheelAxes[wheelIndex];
    const wheelBody = this.wheelBodies[wheelIndex];
    const bodyTorque = wheelBody.torque;
    axis.scale(value, torque);
    wheelBody.vectorToWorldFrame(torque, torque);
    bodyTorque.vadd(torque, bodyTorque);
  }
  /**
   * Add the vehicle including its constraints to the world.
   */


  addToWorld(world) {
    const constraints = this.constraints;
    const bodies = this.wheelBodies.concat([this.chassisBody]);

    for (let i = 0; i < bodies.length; i++) {
      world.addBody(bodies[i]);
    }

    for (let i = 0; i < constraints.length; i++) {
      world.addConstraint(constraints[i]);
    }

    world.addEventListener('preStep', this._update.bind(this));
  }

  _update() {
    const wheelForces = this.wheelForces;

    for (let i = 0; i < wheelForces.length; i++) {
      this.applyWheelForce(wheelForces[i], i);
    }
  }
  /**
   * Remove the vehicle including its constraints from the world.
   */


  removeFromWorld(world) {
    const constraints = this.constraints;
    const bodies = this.wheelBodies.concat([this.chassisBody]);

    for (let i = 0; i < bodies.length; i++) {
      world.removeBody(bodies[i]);
    }

    for (let i = 0; i < constraints.length; i++) {
      world.removeConstraint(constraints[i]);
    }
  }
  /**
   * Get current rotational velocity of a wheel
   */


  getWheelSpeed(wheelIndex) {
    const axis = this.wheelAxes[wheelIndex];
    const wheelBody = this.wheelBodies[wheelIndex];
    const w = wheelBody.angularVelocity;
    this.chassisBody.vectorToWorldFrame(axis, worldAxis);
    return w.dot(worldAxis);
  }

}
const torque = new Vec3();
const worldAxis = new Vec3();

/**
 * Smoothed-particle hydrodynamics system
 * @todo Make parameters customizable in the constructor
 */
class SPHSystem {
  /**
   * The particles array.
   */

  /**
   * Density of the system (kg/m3).
   * @default 1
   */

  /**
   * Distance below which two particles are considered to be neighbors.
   * It should be adjusted so there are about 15-20 neighbor particles within this radius.
   * @default 1
   */

  /**
   * @default 1
   */

  /**
   * Viscosity of the system.
   * @default 0.01
   */

  /**
   * @default 0.000001
   */
  constructor() {
    this.particles = [];
    this.density = 1;
    this.smoothingRadius = 1;
    this.speedOfSound = 1;
    this.viscosity = 0.01;
    this.eps = 0.000001; // Stuff Computed per particle

    this.pressures = [];
    this.densities = [];
    this.neighbors = [];
  }
  /**
   * Add a particle to the system.
   */


  add(particle) {
    this.particles.push(particle);

    if (this.neighbors.length < this.particles.length) {
      this.neighbors.push([]);
    }
  }
  /**
   * Remove a particle from the system.
   */


  remove(particle) {
    const idx = this.particles.indexOf(particle);

    if (idx !== -1) {
      this.particles.splice(idx, 1);

      if (this.neighbors.length > this.particles.length) {
        this.neighbors.pop();
      }
    }
  }
  /**
   * Get neighbors within smoothing volume, save in the array neighbors
   */


  getNeighbors(particle, neighbors) {
    const N = this.particles.length;
    const id = particle.id;
    const R2 = this.smoothingRadius * this.smoothingRadius;
    const dist = SPHSystem_getNeighbors_dist;

    for (let i = 0; i !== N; i++) {
      const p = this.particles[i];
      p.position.vsub(particle.position, dist);

      if (id !== p.id && dist.lengthSquared() < R2) {
        neighbors.push(p);
      }
    }
  }

  update() {
    const N = this.particles.length;
    const dist = SPHSystem_update_dist;
    const cs = this.speedOfSound;
    const eps = this.eps;

    for (let i = 0; i !== N; i++) {
      const p = this.particles[i]; // Current particle

      const neighbors = this.neighbors[i]; // Get neighbors

      neighbors.length = 0;
      this.getNeighbors(p, neighbors);
      neighbors.push(this.particles[i]); // Add current too

      const numNeighbors = neighbors.length; // Accumulate density for the particle

      let sum = 0.0;

      for (let j = 0; j !== numNeighbors; j++) {
        //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
        p.position.vsub(neighbors[j].position, dist);
        const len = dist.length();
        const weight = this.w(len);
        sum += neighbors[j].mass * weight;
      } // Save


      this.densities[i] = sum;
      this.pressures[i] = cs * cs * (this.densities[i] - this.density);
    } // Add forces
    // Sum to these accelerations


    const a_pressure = SPHSystem_update_a_pressure;
    const a_visc = SPHSystem_update_a_visc;
    const gradW = SPHSystem_update_gradW;
    const r_vec = SPHSystem_update_r_vec;
    const u = SPHSystem_update_u;

    for (let i = 0; i !== N; i++) {
      const particle = this.particles[i];
      a_pressure.set(0, 0, 0);
      a_visc.set(0, 0, 0); // Init vars

      let Pij;
      let nabla;

      const neighbors = this.neighbors[i];
      const numNeighbors = neighbors.length; //printf("Neighbors: ");

      for (let j = 0; j !== numNeighbors; j++) {
        const neighbor = neighbors[j]; //printf("%d ",nj);
        // Get r once for all..

        particle.position.vsub(neighbor.position, r_vec);
        const r = r_vec.length(); // Pressure contribution

        Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps));
        this.gradw(r_vec, gradW); // Add to pressure acceleration

        gradW.scale(Pij, gradW);
        a_pressure.vadd(gradW, a_pressure); // Viscosity contribution

        neighbor.velocity.vsub(particle.velocity, u);
        u.scale(1.0 / (0.0001 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass, u);
        nabla = this.nablaw(r);
        u.scale(nabla, u); // Add to viscosity acceleration

        a_visc.vadd(u, a_visc);
      } // Calculate force


      a_visc.scale(particle.mass, a_visc);
      a_pressure.scale(particle.mass, a_pressure); // Add force to particles

      particle.force.vadd(a_visc, particle.force);
      particle.force.vadd(a_pressure, particle.force);
    }
  } // Calculate the weight using the W(r) weightfunction


  w(r) {
    // 315
    const h = this.smoothingRadius;
    return 315.0 / (64.0 * Math.PI * h ** 9) * (h * h - r * r) ** 3;
  } // calculate gradient of the weight function


  gradw(rVec, resultVec) {
    const r = rVec.length();
    const h = this.smoothingRadius;
    rVec.scale(945.0 / (32.0 * Math.PI * h ** 9) * (h * h - r * r) ** 2, resultVec);
  } // Calculate nabla(W)


  nablaw(r) {
    const h = this.smoothingRadius;
    const nabla = 945.0 / (32.0 * Math.PI * h ** 9) * (h * h - r * r) * (7 * r * r - 3 * h * h);
    return nabla;
  }

}
const SPHSystem_getNeighbors_dist = new Vec3(); // Temp vectors for calculation

const SPHSystem_update_dist = new Vec3(); // Relative velocity

const SPHSystem_update_a_pressure = new Vec3();
const SPHSystem_update_a_visc = new Vec3();
const SPHSystem_update_gradW = new Vec3();
const SPHSystem_update_r_vec = new Vec3();
const SPHSystem_update_u = new Vec3();

/**
 * Cylinder class.
 * @example
 *     const radiusTop = 0.5
 *     const radiusBottom = 0.5
 *     const height = 2
 *     const numSegments = 12
 *     const cylinderShape = new CANNON.Cylinder(radiusTop, radiusBottom, height, numSegments)
 *     const cylinderBody = new CANNON.Body({ mass: 1, shape: cylinderShape })
 *     world.addBody(cylinderBody)
 */

class Cylinder extends ConvexPolyhedron {
  /** The radius of the top of the Cylinder. */

  /** The radius of the bottom of the Cylinder. */

  /** The height of the Cylinder. */

  /** The number of segments to build the cylinder out of. */

  /**
   * @param radiusTop The radius of the top of the Cylinder.
   * @param radiusBottom The radius of the bottom of the Cylinder.
   * @param height The height of the Cylinder.
   * @param numSegments The number of segments to build the cylinder out of.
   */
  constructor(radiusTop, radiusBottom, height, numSegments) {
    if (radiusTop === void 0) {
      radiusTop = 1;
    }

    if (radiusBottom === void 0) {
      radiusBottom = 1;
    }

    if (height === void 0) {
      height = 1;
    }

    if (numSegments === void 0) {
      numSegments = 8;
    }

    if (radiusTop < 0) {
      throw new Error('The cylinder radiusTop cannot be negative.');
    }

    if (radiusBottom < 0) {
      throw new Error('The cylinder radiusBottom cannot be negative.');
    }

    const N = numSegments;
    const vertices = [];
    const axes = [];
    const faces = [];
    const bottomface = [];
    const topface = [];
    const cos = Math.cos;
    const sin = Math.sin; // First bottom point

    vertices.push(new Vec3(-radiusBottom * sin(0), -height * 0.5, radiusBottom * cos(0)));
    bottomface.push(0); // First top point

    vertices.push(new Vec3(-radiusTop * sin(0), height * 0.5, radiusTop * cos(0)));
    topface.push(1);

    for (let i = 0; i < N; i++) {
      const theta = 2 * Math.PI / N * (i + 1);
      const thetaN = 2 * Math.PI / N * (i + 0.5);

      if (i < N - 1) {
        // Bottom
        vertices.push(new Vec3(-radiusBottom * sin(theta), -height * 0.5, radiusBottom * cos(theta)));
        bottomface.push(2 * i + 2); // Top

        vertices.push(new Vec3(-radiusTop * sin(theta), height * 0.5, radiusTop * cos(theta)));
        topface.push(2 * i + 3); // Face

        faces.push([2 * i, 2 * i + 1, 2 * i + 3, 2 * i + 2]);
      } else {
        faces.push([2 * i, 2 * i + 1, 1, 0]); // Connect
      } // Axis: we can cut off half of them if we have even number of segments


      if (N % 2 === 1 || i < N / 2) {
        axes.push(new Vec3(-sin(thetaN), 0, cos(thetaN)));
      }
    }

    faces.push(bottomface);
    axes.push(new Vec3(0, 1, 0)); // Reorder top face

    const temp = [];

    for (let i = 0; i < topface.length; i++) {
      temp.push(topface[topface.length - i - 1]);
    }

    faces.push(temp);
    super({
      vertices,
      faces,
      axes
    });
    this.type = Shape.types.CYLINDER;
    this.radiusTop = radiusTop;
    this.radiusBottom = radiusBottom;
    this.height = height;
    this.numSegments = numSegments;
  }

}

/**
 * Particle shape.
 * @example
 *     const particleShape = new CANNON.Particle()
 *     const particleBody = new CANNON.Body({ mass: 1, shape: particleShape })
 *     world.addBody(particleBody)
 */
class Particle extends Shape {
  constructor() {
    super({
      type: Shape.types.PARTICLE
    });
  }
  /**
   * calculateLocalInertia
   */


  calculateLocalInertia(mass, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    target.set(0, 0, 0);
    return target;
  }

  volume() {
    return 0;
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = 0;
  }

  calculateWorldAABB(pos, quat, min, max) {
    // Get each axis max
    min.copy(pos);
    max.copy(pos);
  }

}

/**
 * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
 * @example
 *     const planeShape = new CANNON.Plane()
 *     const planeBody = new CANNON.Body({ mass: 0, shape:  planeShape })
 *     planeBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up
 *     world.addBody(planeBody)
 */
class Plane extends Shape {
  /** worldNormal */

  /** worldNormalNeedsUpdate */
  constructor() {
    super({
      type: Shape.types.PLANE
    }); // World oriented normal

    this.worldNormal = new Vec3();
    this.worldNormalNeedsUpdate = true;
    this.boundingSphereRadius = Number.MAX_VALUE;
  }
  /** computeWorldNormal */


  computeWorldNormal(quat) {
    const n = this.worldNormal;
    n.set(0, 0, 1);
    quat.vmult(n, n);
    this.worldNormalNeedsUpdate = false;
  }

  calculateLocalInertia(mass, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    return target;
  }

  volume() {
    return (// The plane is infinite...
      Number.MAX_VALUE
    );
  }

  calculateWorldAABB(pos, quat, min, max) {
    // The plane AABB is infinite, except if the normal is pointing along any axis
    tempNormal.set(0, 0, 1); // Default plane normal is z

    quat.vmult(tempNormal, tempNormal);
    const maxVal = Number.MAX_VALUE;
    min.set(-maxVal, -maxVal, -maxVal);
    max.set(maxVal, maxVal, maxVal);

    if (tempNormal.x === 1) {
      max.x = pos.x;
    } else if (tempNormal.x === -1) {
      min.x = pos.x;
    }

    if (tempNormal.y === 1) {
      max.y = pos.y;
    } else if (tempNormal.y === -1) {
      min.y = pos.y;
    }

    if (tempNormal.z === 1) {
      max.z = pos.z;
    } else if (tempNormal.z === -1) {
      min.z = pos.z;
    }
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = Number.MAX_VALUE;
  }

}
const tempNormal = new Vec3();

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
 * @todo Should be possible to use along all axes, not just y
 * @todo should be possible to scale along all axes
 * @todo Refactor elementSize to elementSizeX and elementSizeY
 *
 * @example
 *     // Generate some height data (y-values).
 *     const data = []
 *     for (let i = 0; i < 1000; i++) {
 *         const y = 0.5 * Math.cos(0.2 * i)
 *         data.push(y)
 *     }
 *
 *     // Create the heightfield shape
 *     const heightfieldShape = new CANNON.Heightfield(data, {
 *         elementSize: 1 // Distance between the data points in X and Y directions
 *     })
 *     const heightfieldBody = new CANNON.Body({ shape: heightfieldShape })
 *     world.addBody(heightfieldBody)
 */
class Heightfield extends Shape {
  /**
   * An array of numbers, or height values, that are spread out along the x axis.
   */

  /**
   * Max value of the data points in the data array.
   */

  /**
   * Minimum value of the data points in the data array.
   */

  /**
   * World spacing between the data points in X and Y direction.
   * @todo elementSizeX and Y
   * @default 1
   */

  /**
   * @default true
   */

  /**
   * @param data An array of numbers, or height values, that are spread out along the x axis.
   */
  constructor(data, options) {
    if (options === void 0) {
      options = {};
    }

    options = Utils.defaults(options, {
      maxValue: null,
      minValue: null,
      elementSize: 1
    });
    super({
      type: Shape.types.HEIGHTFIELD
    });
    this.data = data;
    this.maxValue = options.maxValue;
    this.minValue = options.minValue;
    this.elementSize = options.elementSize;

    if (options.minValue === null) {
      this.updateMinValue();
    }

    if (options.maxValue === null) {
      this.updateMaxValue();
    }

    this.cacheEnabled = true;
    this.pillarConvex = new ConvexPolyhedron();
    this.pillarOffset = new Vec3();
    this.updateBoundingSphereRadius(); // "i_j_isUpper" => { convex: ..., offset: ... }
    // for example:
    // _cachedPillars["0_2_1"]

    this._cachedPillars = {};
  }
  /**
   * Call whenever you change the data array.
   */


  update() {
    this._cachedPillars = {};
  }
  /**
   * Update the `minValue` property
   */


  updateMinValue() {
    const data = this.data;
    let minValue = data[0][0];

    for (let i = 0; i !== data.length; i++) {
      for (let j = 0; j !== data[i].length; j++) {
        const v = data[i][j];

        if (v < minValue) {
          minValue = v;
        }
      }
    }

    this.minValue = minValue;
  }
  /**
   * Update the `maxValue` property
   */


  updateMaxValue() {
    const data = this.data;
    let maxValue = data[0][0];

    for (let i = 0; i !== data.length; i++) {
      for (let j = 0; j !== data[i].length; j++) {
        const v = data[i][j];

        if (v > maxValue) {
          maxValue = v;
        }
      }
    }

    this.maxValue = maxValue;
  }
  /**
   * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
   */


  setHeightValueAtIndex(xi, yi, value) {
    const data = this.data;
    data[xi][yi] = value; // Invalidate cache

    this.clearCachedConvexTrianglePillar(xi, yi, false);

    if (xi > 0) {
      this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
      this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
    }

    if (yi > 0) {
      this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
      this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
    }

    if (yi > 0 && xi > 0) {
      this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
    }
  }
  /**
   * Get max/min in a rectangle in the matrix data
   * @param result An array to store the results in.
   * @return The result array, if it was passed in. Minimum will be at position 0 and max at 1.
   */


  getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, result) {
    if (result === void 0) {
      result = [];
    }

    // Get max and min of the data
    const data = this.data; // Set first value

    let max = this.minValue;

    for (let i = iMinX; i <= iMaxX; i++) {
      for (let j = iMinY; j <= iMaxY; j++) {
        const height = data[i][j];

        if (height > max) {
          max = height;
        }
      }
    }

    result[0] = this.minValue;
    result[1] = max;
  }
  /**
   * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
   * @param result Two-element array
   * @param clamp If the position should be clamped to the heightfield edge.
   */


  getIndexOfPosition(x, y, result, clamp) {
    // Get the index of the data points to test against
    const w = this.elementSize;
    const data = this.data;
    let xi = Math.floor(x / w);
    let yi = Math.floor(y / w);
    result[0] = xi;
    result[1] = yi;

    if (clamp) {
      // Clamp index to edges
      if (xi < 0) {
        xi = 0;
      }

      if (yi < 0) {
        yi = 0;
      }

      if (xi >= data.length - 1) {
        xi = data.length - 1;
      }

      if (yi >= data[0].length - 1) {
        yi = data[0].length - 1;
      }
    } // Bail out if we are out of the terrain


    if (xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1) {
      return false;
    }

    return true;
  }

  getTriangleAt(x, y, edgeClamp, a, b, c) {
    const idx = getHeightAt_idx;
    this.getIndexOfPosition(x, y, idx, edgeClamp);
    let xi = idx[0];
    let yi = idx[1];
    const data = this.data;

    if (edgeClamp) {
      xi = Math.min(data.length - 2, Math.max(0, xi));
      yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }

    const elementSize = this.elementSize;
    const lowerDist2 = (x / elementSize - xi) ** 2 + (y / elementSize - yi) ** 2;
    const upperDist2 = (x / elementSize - (xi + 1)) ** 2 + (y / elementSize - (yi + 1)) ** 2;
    const upper = lowerDist2 > upperDist2;
    this.getTriangle(xi, yi, upper, a, b, c);
    return upper;
  }

  getNormalAt(x, y, edgeClamp, result) {
    const a = getNormalAt_a;
    const b = getNormalAt_b;
    const c = getNormalAt_c;
    const e0 = getNormalAt_e0;
    const e1 = getNormalAt_e1;
    this.getTriangleAt(x, y, edgeClamp, a, b, c);
    b.vsub(a, e0);
    c.vsub(a, e1);
    e0.cross(e1, result);
    result.normalize();
  }
  /**
   * Get an AABB of a square in the heightfield
   * @param xi
   * @param yi
   * @param result
   */


  getAabbAtIndex(xi, yi, _ref) {
    let {
      lowerBound,
      upperBound
    } = _ref;
    const data = this.data;
    const elementSize = this.elementSize;
    lowerBound.set(xi * elementSize, yi * elementSize, data[xi][yi]);
    upperBound.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
  }
  /**
   * Get the height in the heightfield at a given position
   */


  getHeightAt(x, y, edgeClamp) {
    const data = this.data;
    const a = getHeightAt_a;
    const b = getHeightAt_b;
    const c = getHeightAt_c;
    const idx = getHeightAt_idx;
    this.getIndexOfPosition(x, y, idx, edgeClamp);
    let xi = idx[0];
    let yi = idx[1];

    if (edgeClamp) {
      xi = Math.min(data.length - 2, Math.max(0, xi));
      yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }

    const upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
    barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);
    const w = getHeightAt_weights;

    if (upper) {
      // Top triangle verts
      return data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z;
    } else {
      // Top triangle verts
      return data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;
    }
  }

  getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle) {
    return `${xi}_${yi}_${getUpperTriangle ? 1 : 0}`;
  }

  getCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {
    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
  }

  setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, convex, offset) {
    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
      convex,
      offset
    };
  }

  clearCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {
    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
  }
  /**
   * Get a triangle from the heightfield
   */


  getTriangle(xi, yi, upper, a, b, c) {
    const data = this.data;
    const elementSize = this.elementSize;

    if (upper) {
      // Top triangle verts
      a.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
      b.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
      c.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
    } else {
      // Top triangle verts
      a.set(xi * elementSize, yi * elementSize, data[xi][yi]);
      b.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
      c.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
    }
  }
  /**
   * Get a triangle in the terrain in the form of a triangular convex shape.
   */


  getConvexTrianglePillar(xi, yi, getUpperTriangle) {
    let result = this.pillarConvex;
    let offsetResult = this.pillarOffset;

    if (this.cacheEnabled) {
      const data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);

      if (data) {
        this.pillarConvex = data.convex;
        this.pillarOffset = data.offset;
        return;
      }

      result = new ConvexPolyhedron();
      offsetResult = new Vec3();
      this.pillarConvex = result;
      this.pillarOffset = offsetResult;
    }

    const data = this.data;
    const elementSize = this.elementSize;
    const faces = result.faces; // Reuse verts if possible

    result.vertices.length = 6;

    for (let i = 0; i < 6; i++) {
      if (!result.vertices[i]) {
        result.vertices[i] = new Vec3();
      }
    } // Reuse faces if possible


    faces.length = 5;

    for (let i = 0; i < 5; i++) {
      if (!faces[i]) {
        faces[i] = [];
      }
    }

    const verts = result.vertices;
    const h = (Math.min(data[xi][yi], data[xi + 1][yi], data[xi][yi + 1], data[xi + 1][yi + 1]) - this.minValue) / 2 + this.minValue;

    if (!getUpperTriangle) {
      // Center of the triangle pillar - all polygons are given relative to this one
      offsetResult.set((xi + 0.25) * elementSize, // sort of center of a triangle
      (yi + 0.25) * elementSize, h // vertical center
      ); // Top triangle verts

      verts[0].set(-0.25 * elementSize, -0.25 * elementSize, data[xi][yi] - h);
      verts[1].set(0.75 * elementSize, -0.25 * elementSize, data[xi + 1][yi] - h);
      verts[2].set(-0.25 * elementSize, 0.75 * elementSize, data[xi][yi + 1] - h); // bottom triangle verts

      verts[3].set(-0.25 * elementSize, -0.25 * elementSize, -Math.abs(h) - 1);
      verts[4].set(0.75 * elementSize, -0.25 * elementSize, -Math.abs(h) - 1);
      verts[5].set(-0.25 * elementSize, 0.75 * elementSize, -Math.abs(h) - 1); // top triangle

      faces[0][0] = 0;
      faces[0][1] = 1;
      faces[0][2] = 2; // bottom triangle

      faces[1][0] = 5;
      faces[1][1] = 4;
      faces[1][2] = 3; // -x facing quad

      faces[2][0] = 0;
      faces[2][1] = 2;
      faces[2][2] = 5;
      faces[2][3] = 3; // -y facing quad

      faces[3][0] = 1;
      faces[3][1] = 0;
      faces[3][2] = 3;
      faces[3][3] = 4; // +xy facing quad

      faces[4][0] = 4;
      faces[4][1] = 5;
      faces[4][2] = 2;
      faces[4][3] = 1;
    } else {
      // Center of the triangle pillar - all polygons are given relative to this one
      offsetResult.set((xi + 0.75) * elementSize, // sort of center of a triangle
      (yi + 0.75) * elementSize, h // vertical center
      ); // Top triangle verts

      verts[0].set(0.25 * elementSize, 0.25 * elementSize, data[xi + 1][yi + 1] - h);
      verts[1].set(-0.75 * elementSize, 0.25 * elementSize, data[xi][yi + 1] - h);
      verts[2].set(0.25 * elementSize, -0.75 * elementSize, data[xi + 1][yi] - h); // bottom triangle verts

      verts[3].set(0.25 * elementSize, 0.25 * elementSize, -Math.abs(h) - 1);
      verts[4].set(-0.75 * elementSize, 0.25 * elementSize, -Math.abs(h) - 1);
      verts[5].set(0.25 * elementSize, -0.75 * elementSize, -Math.abs(h) - 1); // Top triangle

      faces[0][0] = 0;
      faces[0][1] = 1;
      faces[0][2] = 2; // bottom triangle

      faces[1][0] = 5;
      faces[1][1] = 4;
      faces[1][2] = 3; // +x facing quad

      faces[2][0] = 2;
      faces[2][1] = 5;
      faces[2][2] = 3;
      faces[2][3] = 0; // +y facing quad

      faces[3][0] = 3;
      faces[3][1] = 4;
      faces[3][2] = 1;
      faces[3][3] = 0; // -xy facing quad

      faces[4][0] = 1;
      faces[4][1] = 4;
      faces[4][2] = 5;
      faces[4][3] = 2;
    }

    result.computeNormals();
    result.computeEdges();
    result.updateBoundingSphereRadius();
    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
  }

  calculateLocalInertia(mass, target) {
    if (target === void 0) {
      target = new Vec3();
    }

    target.set(0, 0, 0);
    return target;
  }

  volume() {
    return (// The terrain is infinite
      Number.MAX_VALUE
    );
  }

  calculateWorldAABB(pos, quat, min, max) {
    /** @TODO do it properly */
    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  }

  updateBoundingSphereRadius() {
    // Use the bounding box of the min/max values
    const data = this.data;
    const s = this.elementSize;
    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).length();
  }
  /**
   * Sets the height values from an image. Currently only supported in browser.
   */


  setHeightsFromImage(image, scale) {
    const {
      x,
      z,
      y
    } = scale;
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const context = canvas.getContext('2d');
    context.drawImage(image, 0, 0);
    const imageData = context.getImageData(0, 0, image.width, image.height);
    const matrix = this.data;
    matrix.length = 0;
    this.elementSize = Math.abs(x) / imageData.width;

    for (let i = 0; i < imageData.height; i++) {
      const row = [];

      for (let j = 0; j < imageData.width; j++) {
        const a = imageData.data[(i * imageData.height + j) * 4];
        const b = imageData.data[(i * imageData.height + j) * 4 + 1];
        const c = imageData.data[(i * imageData.height + j) * 4 + 2];
        const height = (a + b + c) / 4 / 255 * z;

        if (x < 0) {
          row.push(height);
        } else {
          row.unshift(height);
        }
      }

      if (y < 0) {
        matrix.unshift(row);
      } else {
        matrix.push(row);
      }
    }

    this.updateMaxValue();
    this.updateMinValue();
    this.update();
  }

}
const getHeightAt_idx = [];
const getHeightAt_weights = new Vec3();
const getHeightAt_a = new Vec3();
const getHeightAt_b = new Vec3();
const getHeightAt_c = new Vec3();
const getNormalAt_a = new Vec3();
const getNormalAt_b = new Vec3();
const getNormalAt_c = new Vec3();
const getNormalAt_e0 = new Vec3();
const getNormalAt_e1 = new Vec3(); // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system

function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result) {
  result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
  result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
  result.z = 1 - result.x - result.y;
}

/**
 * OctreeNode
 */
class OctreeNode {
  /** The root node */

  /** Boundary of this node */

  /** Contained data at the current node level */

  /** Children to this node */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }

    this.root = options.root || null;
    this.aabb = options.aabb ? options.aabb.clone() : new AABB();
    this.data = [];
    this.children = [];
  }
  /**
   * reset
   */


  reset() {
    this.children.length = this.data.length = 0;
  }
  /**
   * Insert data into this node
   * @return True if successful, otherwise false
   */


  insert(aabb, elementData, level) {
    if (level === void 0) {
      level = 0;
    }

    const nodeData = this.data; // Ignore objects that do not belong in this node

    if (!this.aabb.contains(aabb)) {
      return false; // object cannot be added
    }

    const children = this.children;
    const maxDepth = this.maxDepth || this.root.maxDepth;

    if (level < maxDepth) {
      // Subdivide if there are no children yet
      let subdivided = false;

      if (!children.length) {
        this.subdivide();
        subdivided = true;
      } // add to whichever node will accept it


      for (let i = 0; i !== 8; i++) {
        if (children[i].insert(aabb, elementData, level + 1)) {
          return true;
        }
      }

      if (subdivided) {
        // No children accepted! Might as well just remove em since they contain none
        children.length = 0;
      }
    } // Too deep, or children didnt want it. add it in current node


    nodeData.push(elementData);
    return true;
  }
  /**
   * Create 8 equally sized children nodes and put them in the `children` array.
   */


  subdivide() {
    const aabb = this.aabb;
    const l = aabb.lowerBound;
    const u = aabb.upperBound;
    const children = this.children;
    children.push(new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 0, 0)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 0, 0)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 1, 0)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 1, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 1, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 0, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 0, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 1, 0)
      })
    }));
    u.vsub(l, halfDiagonal);
    halfDiagonal.scale(0.5, halfDiagonal);
    const root = this.root || this;

    for (let i = 0; i !== 8; i++) {
      const child = children[i]; // Set current node as root

      child.root = root; // Compute bounds

      const lowerBound = child.aabb.lowerBound;
      lowerBound.x *= halfDiagonal.x;
      lowerBound.y *= halfDiagonal.y;
      lowerBound.z *= halfDiagonal.z;
      lowerBound.vadd(l, lowerBound); // Upper bound is always lower bound + halfDiagonal

      lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
    }
  }
  /**
   * Get all data, potentially within an AABB
   * @return The "result" object
   */


  aabbQuery(aabb, result) {
    this.data; // abort if the range does not intersect this node
    // if (!this.aabb.overlaps(aabb)){
    //     return result;
    // }
    // Add objects at this level
    // Array.prototype.push.apply(result, nodeData);
    // Add child data
    // @todo unwrap recursion into a queue / loop, that's faster in JS

    this.children; // for (let i = 0, N = this.children.length; i !== N; i++) {
    //     children[i].aabbQuery(aabb, result);
    // }

    const queue = [this];

    while (queue.length) {
      const node = queue.pop();

      if (node.aabb.overlaps(aabb)) {
        Array.prototype.push.apply(result, node.data);
      }

      Array.prototype.push.apply(queue, node.children);
    }

    return result;
  }
  /**
   * Get all data, potentially intersected by a ray.
   * @return The "result" object
   */


  rayQuery(ray, treeTransform, result) {
    // Use aabb query for now.

    /** @todo implement real ray query which needs less lookups */
    ray.getAABB(tmpAABB);
    tmpAABB.toLocalFrame(treeTransform, tmpAABB);
    this.aabbQuery(tmpAABB, result);
    return result;
  }
  /**
   * removeEmptyNodes
   */


  removeEmptyNodes() {
    for (let i = this.children.length - 1; i >= 0; i--) {
      this.children[i].removeEmptyNodes();

      if (!this.children[i].children.length && !this.children[i].data.length) {
        this.children.splice(i, 1);
      }
    }
  }

}
/**
 * Octree
 */


class Octree extends OctreeNode {
  /**
   * Maximum subdivision depth
   * @default 8
   */

  /**
   * @param aabb The total AABB of the tree
   */
  constructor(aabb, options) {
    if (options === void 0) {
      options = {};
    }

    super({
      root: null,
      aabb
    });
    this.maxDepth = typeof options.maxDepth !== 'undefined' ? options.maxDepth : 8;
  }

}
const halfDiagonal = new Vec3();
const tmpAABB = new AABB();

/**
 * Trimesh.
 * @example
 *     // How to make a mesh with a single triangle
 *     const vertices = [
 *         0, 0, 0, // vertex 0
 *         1, 0, 0, // vertex 1
 *         0, 1, 0  // vertex 2
 *     ]
 *     const indices = [
 *         0, 1, 2  // triangle 0
 *     ]
 *     const trimeshShape = new CANNON.Trimesh(vertices, indices)
 */
class Trimesh extends Shape {
  /**
   * vertices
   */

  /**
   * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
   */

  /**
   * The normals data.
   */

  /**
   * The local AABB of the mesh.
   */

  /**
   * References to vertex pairs, making up all unique edges in the trimesh.
   */

  /**
   * Local scaling of the mesh. Use .setScale() to set it.
   */

  /**
   * The indexed triangles. Use .updateTree() to update it.
   */
  constructor(vertices, indices) {
    super({
      type: Shape.types.TRIMESH
    });
    this.vertices = new Float32Array(vertices);
    this.indices = new Int16Array(indices);
    this.normals = new Float32Array(indices.length);
    this.aabb = new AABB();
    this.edges = null;
    this.scale = new Vec3(1, 1, 1);
    this.tree = new Octree();
    this.updateEdges();
    this.updateNormals();
    this.updateAABB();
    this.updateBoundingSphereRadius();
    this.updateTree();
  }
  /**
   * updateTree
   */


  updateTree() {
    const tree = this.tree;
    tree.reset();
    tree.aabb.copy(this.aabb);
    const scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled

    tree.aabb.lowerBound.x *= 1 / scale.x;
    tree.aabb.lowerBound.y *= 1 / scale.y;
    tree.aabb.lowerBound.z *= 1 / scale.z;
    tree.aabb.upperBound.x *= 1 / scale.x;
    tree.aabb.upperBound.y *= 1 / scale.y;
    tree.aabb.upperBound.z *= 1 / scale.z; // Insert all triangles

    const triangleAABB = new AABB();
    const a = new Vec3();
    const b = new Vec3();
    const c = new Vec3();
    const points = [a, b, c];

    for (let i = 0; i < this.indices.length / 3; i++) {
      //this.getTriangleVertices(i, a, b, c);
      // Get unscaled triangle verts
      const i3 = i * 3;

      this._getUnscaledVertex(this.indices[i3], a);

      this._getUnscaledVertex(this.indices[i3 + 1], b);

      this._getUnscaledVertex(this.indices[i3 + 2], c);

      triangleAABB.setFromPoints(points);
      tree.insert(triangleAABB, i);
    }

    tree.removeEmptyNodes();
  }
  /**
   * Get triangles in a local AABB from the trimesh.
   * @param result An array of integers, referencing the queried triangles.
   */


  getTrianglesInAABB(aabb, result) {
    unscaledAABB.copy(aabb); // Scale it to local

    const scale = this.scale;
    const isx = scale.x;
    const isy = scale.y;
    const isz = scale.z;
    const l = unscaledAABB.lowerBound;
    const u = unscaledAABB.upperBound;
    l.x /= isx;
    l.y /= isy;
    l.z /= isz;
    u.x /= isx;
    u.y /= isy;
    u.z /= isz;
    return this.tree.aabbQuery(unscaledAABB, result);
  }
  /**
   * setScale
   */


  setScale(scale) {
    const wasUniform = this.scale.x === this.scale.y && this.scale.y === this.scale.z;
    const isUniform = scale.x === scale.y && scale.y === scale.z;

    if (!(wasUniform && isUniform)) {
      // Non-uniform scaling. Need to update normals.
      this.updateNormals();
    }

    this.scale.copy(scale);
    this.updateAABB();
    this.updateBoundingSphereRadius();
  }
  /**
   * Compute the normals of the faces. Will save in the `.normals` array.
   */


  updateNormals() {
    const n = computeNormals_n; // Generate normals

    const normals = this.normals;

    for (let i = 0; i < this.indices.length / 3; i++) {
      const i3 = i * 3;
      const a = this.indices[i3];
      const b = this.indices[i3 + 1];
      const c = this.indices[i3 + 2];
      this.getVertex(a, va);
      this.getVertex(b, vb);
      this.getVertex(c, vc);
      Trimesh.computeNormal(vb, va, vc, n);
      normals[i3] = n.x;
      normals[i3 + 1] = n.y;
      normals[i3 + 2] = n.z;
    }
  }
  /**
   * Update the `.edges` property
   */


  updateEdges() {
    const edges = {};

    const add = (a, b) => {
      const key = a < b ? `${a}_${b}` : `${b}_${a}`;
      edges[key] = true;
    };

    for (let i = 0; i < this.indices.length / 3; i++) {
      const i3 = i * 3;
      const a = this.indices[i3];
      const b = this.indices[i3 + 1];
      const c = this.indices[i3 + 2];
      add(a, b);
      add(b, c);
      add(c, a);
    }

    const keys = Object.keys(edges);
    this.edges = new Int16Array(keys.length * 2);

    for (let i = 0; i < keys.length; i++) {
      const indices = keys[i].split('_');
      this.edges[2 * i] = parseInt(indices[0], 10);
      this.edges[2 * i + 1] = parseInt(indices[1], 10);
    }
  }
  /**
   * Get an edge vertex
   * @param firstOrSecond 0 or 1, depending on which one of the vertices you need.
   * @param vertexStore Where to store the result
   */


  getEdgeVertex(edgeIndex, firstOrSecond, vertexStore) {
    const vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
    this.getVertex(vertexIndex, vertexStore);
  }
  /**
   * Get a vector along an edge.
   */


  getEdgeVector(edgeIndex, vectorStore) {
    const va = getEdgeVector_va;
    const vb = getEdgeVector_vb;
    this.getEdgeVertex(edgeIndex, 0, va);
    this.getEdgeVertex(edgeIndex, 1, vb);
    vb.vsub(va, vectorStore);
  }
  /**
   * Get face normal given 3 vertices
   */


  static computeNormal(va, vb, vc, target) {
    vb.vsub(va, ab);
    vc.vsub(vb, cb);
    cb.cross(ab, target);

    if (!target.isZero()) {
      target.normalize();
    }
  }
  /**
   * Get vertex i.
   * @return The "out" vector object
   */


  getVertex(i, out) {
    const scale = this.scale;

    this._getUnscaledVertex(i, out);

    out.x *= scale.x;
    out.y *= scale.y;
    out.z *= scale.z;
    return out;
  }
  /**
   * Get raw vertex i
   * @return The "out" vector object
   */


  _getUnscaledVertex(i, out) {
    const i3 = i * 3;
    const vertices = this.vertices;
    return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
  }
  /**
   * Get a vertex from the trimesh,transformed by the given position and quaternion.
   * @return The "out" vector object
   */


  getWorldVertex(i, pos, quat, out) {
    this.getVertex(i, out);
    Transform.pointToWorldFrame(pos, quat, out, out);
    return out;
  }
  /**
   * Get the three vertices for triangle i.
   */


  getTriangleVertices(i, a, b, c) {
    const i3 = i * 3;
    this.getVertex(this.indices[i3], a);
    this.getVertex(this.indices[i3 + 1], b);
    this.getVertex(this.indices[i3 + 2], c);
  }
  /**
   * Compute the normal of triangle i.
   * @return The "target" vector object
   */


  getNormal(i, target) {
    const i3 = i * 3;
    return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);
  }
  /**
   * @return The "target" vector object
   */


  calculateLocalInertia(mass, target) {
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabb);
    const x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x;
    const y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y;
    const z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
    return target.set(1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x));
  }
  /**
   * Compute the local AABB for the trimesh
   */


  computeLocalAABB(aabb) {
    const l = aabb.lowerBound;
    const u = aabb.upperBound;
    const n = this.vertices.length;
    this.vertices;
    const v = computeLocalAABB_worldVert;
    this.getVertex(0, v);
    l.copy(v);
    u.copy(v);

    for (let i = 0; i !== n; i++) {
      this.getVertex(i, v);

      if (v.x < l.x) {
        l.x = v.x;
      } else if (v.x > u.x) {
        u.x = v.x;
      }

      if (v.y < l.y) {
        l.y = v.y;
      } else if (v.y > u.y) {
        u.y = v.y;
      }

      if (v.z < l.z) {
        l.z = v.z;
      } else if (v.z > u.z) {
        u.z = v.z;
      }
    }
  }
  /**
   * Update the `.aabb` property
   */


  updateAABB() {
    this.computeLocalAABB(this.aabb);
  }
  /**
   * Will update the `.boundingSphereRadius` property
   */


  updateBoundingSphereRadius() {
    // Assume points are distributed with local (0,0,0) as center
    let max2 = 0;
    const vertices = this.vertices;
    const v = new Vec3();

    for (let i = 0, N = vertices.length / 3; i !== N; i++) {
      this.getVertex(i, v);
      const norm2 = v.lengthSquared();

      if (norm2 > max2) {
        max2 = norm2;
      }
    }

    this.boundingSphereRadius = Math.sqrt(max2);
  }
  /**
   * calculateWorldAABB
   */


  calculateWorldAABB(pos, quat, min, max) {
    /*
        const n = this.vertices.length / 3,
            verts = this.vertices;
        const minx,miny,minz,maxx,maxy,maxz;
         const v = tempWorldVertex;
        for(let i=0; i<n; i++){
            this.getVertex(i, v);
            quat.vmult(v, v);
            pos.vadd(v, v);
            if (v.x < minx || minx===undefined){
                minx = v.x;
            } else if(v.x > maxx || maxx===undefined){
                maxx = v.x;
            }
             if (v.y < miny || miny===undefined){
                miny = v.y;
            } else if(v.y > maxy || maxy===undefined){
                maxy = v.y;
            }
             if (v.z < minz || minz===undefined){
                minz = v.z;
            } else if(v.z > maxz || maxz===undefined){
                maxz = v.z;
            }
        }
        min.set(minx,miny,minz);
        max.set(maxx,maxy,maxz);
        */
    // Faster approximation using local AABB
    const frame = calculateWorldAABB_frame;
    const result = calculateWorldAABB_aabb;
    frame.position = pos;
    frame.quaternion = quat;
    this.aabb.toWorldFrame(frame, result);
    min.copy(result.lowerBound);
    max.copy(result.upperBound);
  }
  /**
   * Get approximate volume
   */


  volume() {
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
  }
  /**
   * Create a Trimesh instance, shaped as a torus.
   */


  static createTorus(radius, tube, radialSegments, tubularSegments, arc) {
    if (radius === void 0) {
      radius = 1;
    }

    if (tube === void 0) {
      tube = 0.5;
    }

    if (radialSegments === void 0) {
      radialSegments = 8;
    }

    if (tubularSegments === void 0) {
      tubularSegments = 6;
    }

    if (arc === void 0) {
      arc = Math.PI * 2;
    }

    const vertices = [];
    const indices = [];

    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        const x = (radius + tube * Math.cos(v)) * Math.cos(u);
        const y = (radius + tube * Math.cos(v)) * Math.sin(u);
        const z = tube * Math.sin(v);
        vertices.push(x, y, z);
      }
    }

    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    return new Trimesh(vertices, indices);
  }

}
const computeNormals_n = new Vec3();
const unscaledAABB = new AABB();
const getEdgeVector_va = new Vec3();
const getEdgeVector_vb = new Vec3();
const cb = new Vec3();
const ab = new Vec3();
const va = new Vec3();
const vb = new Vec3();
const vc = new Vec3();
const cli_aabb = new AABB();
const computeLocalAABB_worldVert = new Vec3();
const calculateWorldAABB_frame = new Transform();
const calculateWorldAABB_aabb = new AABB();

/**
 * Constraint equation solver base class.
 */
class Solver {
  /**
   * All equations to be solved
   */

  /**
   * @todo remove useless constructor
   */
  constructor() {
    this.equations = [];
  }
  /**
   * Should be implemented in subclasses!
   * @todo use abstract
   * @return number of iterations performed
   */


  solve(dt, world) {
    return (// Should return the number of iterations done!
      0
    );
  }
  /**
   * Add an equation
   */


  addEquation(eq) {
    if (eq.enabled && !eq.bi.isTrigger && !eq.bj.isTrigger) {
      this.equations.push(eq);
    }
  }
  /**
   * Remove an equation
   */


  removeEquation(eq) {
    const eqs = this.equations;
    const i = eqs.indexOf(eq);

    if (i !== -1) {
      eqs.splice(i, 1);
    }
  }
  /**
   * Add all equations
   */


  removeAllEquations() {
    this.equations.length = 0;
  }

}

/**
 * Constraint equation Gauss-Seidel solver.
 * @todo The spook parameters should be specified for each constraint, not globally.
 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
 */
class GSSolver extends Solver {
  /**
   * The number of solver iterations determines quality of the constraints in the world.
   * The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
   */

  /**
   * When tolerance is reached, the system is assumed to be converged.
   */

  /**
   * @todo remove useless constructor
   */
  constructor() {
    super();
    this.iterations = 10;
    this.tolerance = 1e-7;
  }
  /**
   * Solve
   * @return number of iterations performed
   */


  solve(dt, world) {
    let iter = 0;
    const maxIter = this.iterations;
    const tolSquared = this.tolerance * this.tolerance;
    const equations = this.equations;
    const Neq = equations.length;
    const bodies = world.bodies;
    const Nbodies = bodies.length;
    const h = dt;
    let B;
    let invC;
    let deltalambda;
    let deltalambdaTot;
    let GWlambda;
    let lambdaj; // Update solve mass

    if (Neq !== 0) {
      for (let i = 0; i !== Nbodies; i++) {
        bodies[i].updateSolveMassProperties();
      }
    } // Things that do not change during iteration can be computed once


    const invCs = GSSolver_solve_invCs;
    const Bs = GSSolver_solve_Bs;
    const lambda = GSSolver_solve_lambda;
    invCs.length = Neq;
    Bs.length = Neq;
    lambda.length = Neq;

    for (let i = 0; i !== Neq; i++) {
      const c = equations[i];
      lambda[i] = 0.0;
      Bs[i] = c.computeB(h);
      invCs[i] = 1.0 / c.computeC();
    }

    if (Neq !== 0) {
      // Reset vlambda
      for (let i = 0; i !== Nbodies; i++) {
        const b = bodies[i];
        const vlambda = b.vlambda;
        const wlambda = b.wlambda;
        vlambda.set(0, 0, 0);
        wlambda.set(0, 0, 0);
      } // Iterate over equations


      for (iter = 0; iter !== maxIter; iter++) {
        // Accumulate the total error for each iteration.
        deltalambdaTot = 0.0;

        for (let j = 0; j !== Neq; j++) {
          const c = equations[j]; // Compute iteration

          B = Bs[j];
          invC = invCs[j];
          lambdaj = lambda[j];
          GWlambda = c.computeGWlambda();
          deltalambda = invC * (B - GWlambda - c.eps * lambdaj); // Clamp if we are not within the min/max interval

          if (lambdaj + deltalambda < c.minForce) {
            deltalambda = c.minForce - lambdaj;
          } else if (lambdaj + deltalambda > c.maxForce) {
            deltalambda = c.maxForce - lambdaj;
          }

          lambda[j] += deltalambda;
          deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

          c.addToWlambda(deltalambda);
        } // If the total error is small enough - stop iterate


        if (deltalambdaTot * deltalambdaTot < tolSquared) {
          break;
        }
      } // Add result to velocity


      for (let i = 0; i !== Nbodies; i++) {
        const b = bodies[i];
        const v = b.velocity;
        const w = b.angularVelocity;
        b.vlambda.vmul(b.linearFactor, b.vlambda);
        v.vadd(b.vlambda, v);
        b.wlambda.vmul(b.angularFactor, b.wlambda);
        w.vadd(b.wlambda, w);
      } // Set the `.multiplier` property of each equation


      let l = equations.length;
      const invDt = 1 / h;

      while (l--) {
        equations[l].multiplier = lambda[l] * invDt;
      }
    }

    return iter;
  }

} // Just temporary number holders that we want to reuse each iteration.

const GSSolver_solve_lambda = [];
const GSSolver_solve_invCs = [];
const GSSolver_solve_Bs = [];

/**
 * Splits the equations into islands and solves them independently. Can improve performance.
 */
class SplitSolver extends Solver {
  /**
   * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
   */

  /**
   * When tolerance is reached, the system is assumed to be converged.
   */

  /** subsolver */
  constructor(subsolver) {
    super();
    this.iterations = 10;
    this.tolerance = 1e-7;
    this.subsolver = subsolver;
    this.nodes = [];
    this.nodePool = []; // Create needed nodes, reuse if possible

    while (this.nodePool.length < 128) {
      this.nodePool.push(this.createNode());
    }
  }
  /**
   * createNode
   */


  createNode() {
    return {
      body: null,
      children: [],
      eqs: [],
      visited: false
    };
  }
  /**
   * Solve the subsystems
   * @return number of iterations performed
   */


  solve(dt, world) {
    const nodes = SplitSolver_solve_nodes;
    const nodePool = this.nodePool;
    const bodies = world.bodies;
    const equations = this.equations;
    const Neq = equations.length;
    const Nbodies = bodies.length;
    const subsolver = this.subsolver; // Create needed nodes, reuse if possible

    while (nodePool.length < Nbodies) {
      nodePool.push(this.createNode());
    }

    nodes.length = Nbodies;

    for (let i = 0; i < Nbodies; i++) {
      nodes[i] = nodePool[i];
    } // Reset node values


    for (let i = 0; i !== Nbodies; i++) {
      const node = nodes[i];
      node.body = bodies[i];
      node.children.length = 0;
      node.eqs.length = 0;
      node.visited = false;
    }

    for (let k = 0; k !== Neq; k++) {
      const eq = equations[k];
      const i = bodies.indexOf(eq.bi);
      const j = bodies.indexOf(eq.bj);
      const ni = nodes[i];
      const nj = nodes[j];
      ni.children.push(nj);
      ni.eqs.push(eq);
      nj.children.push(ni);
      nj.eqs.push(eq);
    }

    let child;
    let n = 0;
    let eqs = SplitSolver_solve_eqs;
    subsolver.tolerance = this.tolerance;
    subsolver.iterations = this.iterations;
    const dummyWorld = SplitSolver_solve_dummyWorld;

    while (child = getUnvisitedNode(nodes)) {
      eqs.length = 0;
      dummyWorld.bodies.length = 0;
      bfs(child, visitFunc, dummyWorld.bodies, eqs);
      const Neqs = eqs.length;
      eqs = eqs.sort(sortById);

      for (let i = 0; i !== Neqs; i++) {
        subsolver.addEquation(eqs[i]);
      }

      subsolver.solve(dt, dummyWorld);
      subsolver.removeAllEquations();
      n++;
    }

    return n;
  }

} // Returns the number of subsystems

const SplitSolver_solve_nodes = []; // All allocated node objects

const SplitSolver_solve_eqs = []; // Temp array

const SplitSolver_solve_dummyWorld = {
  bodies: []
}; // Temp object

const STATIC = Body.STATIC;

function getUnvisitedNode(nodes) {
  const Nnodes = nodes.length;

  for (let i = 0; i !== Nnodes; i++) {
    const node = nodes[i];

    if (!node.visited && !(node.body.type & STATIC)) {
      return node;
    }
  }

  return false;
}

const queue = [];

function bfs(root, visitFunc, bds, eqs) {
  queue.push(root);
  root.visited = true;
  visitFunc(root, bds, eqs);

  while (queue.length) {
    const node = queue.pop(); // Loop over unvisited child nodes

    let child;

    while (child = getUnvisitedNode(node.children)) {
      child.visited = true;
      visitFunc(child, bds, eqs);
      queue.push(child);
    }
  }
}

function visitFunc(node, bds, eqs) {
  bds.push(node.body);
  const Neqs = node.eqs.length;

  for (let i = 0; i !== Neqs; i++) {
    const eq = node.eqs[i];

    if (!eqs.includes(eq)) {
      eqs.push(eq);
    }
  }
}

function sortById(a, b) {
  return b.id - a.id;
}

/**
 * For pooling objects that can be reused.
 */
class Pool {
  constructor() {
    this.objects = [];
    this.type = Object;
  }

  /**
   * Release an object after use
   */
  release() {
    const Nargs = arguments.length;

    for (let i = 0; i !== Nargs; i++) {
      this.objects.push(i < 0 || arguments.length <= i ? undefined : arguments[i]);
    }

    return this;
  }
  /**
   * Get an object
   */


  get() {
    if (this.objects.length === 0) {
      return this.constructObject();
    } else {
      return this.objects.pop();
    }
  }
  /**
   * Construct an object. Should be implemented in each subclass.
   */


  constructObject() {
    throw new Error('constructObject() not implemented in this Pool subclass yet!');
  }
  /**
   * @return Self, for chaining
   */


  resize(size) {
    const objects = this.objects;

    while (objects.length > size) {
      objects.pop();
    }

    while (objects.length < size) {
      objects.push(this.constructObject());
    }

    return this;
  }

}

/**
 * Vec3Pool
 */

class Vec3Pool extends Pool {
  constructor() {
    super(...arguments);
    this.type = Vec3;
  }

  /**
   * Construct a vector
   */
  constructObject() {
    return new Vec3();
  }

}

// Naming rule: based of the order in SHAPE_TYPES,
// the first part of the method is formed by the
// shape type that comes before, in the second part
// there is the shape type that comes after in the SHAPE_TYPES list
const COLLISION_TYPES = {
  sphereSphere: Shape.types.SPHERE,
  spherePlane: Shape.types.SPHERE | Shape.types.PLANE,
  boxBox: Shape.types.BOX | Shape.types.BOX,
  sphereBox: Shape.types.SPHERE | Shape.types.BOX,
  planeBox: Shape.types.PLANE | Shape.types.BOX,
  convexConvex: Shape.types.CONVEXPOLYHEDRON,
  sphereConvex: Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON,
  planeConvex: Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON,
  boxConvex: Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON,
  sphereHeightfield: Shape.types.SPHERE | Shape.types.HEIGHTFIELD,
  boxHeightfield: Shape.types.BOX | Shape.types.HEIGHTFIELD,
  convexHeightfield: Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD,
  sphereParticle: Shape.types.PARTICLE | Shape.types.SPHERE,
  planeParticle: Shape.types.PLANE | Shape.types.PARTICLE,
  boxParticle: Shape.types.BOX | Shape.types.PARTICLE,
  convexParticle: Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON,
  cylinderCylinder: Shape.types.CYLINDER,
  sphereCylinder: Shape.types.SPHERE | Shape.types.CYLINDER,
  planeCylinder: Shape.types.PLANE | Shape.types.CYLINDER,
  boxCylinder: Shape.types.BOX | Shape.types.CYLINDER,
  convexCylinder: Shape.types.CONVEXPOLYHEDRON | Shape.types.CYLINDER,
  heightfieldCylinder: Shape.types.HEIGHTFIELD | Shape.types.CYLINDER,
  particleCylinder: Shape.types.PARTICLE | Shape.types.CYLINDER,
  sphereTrimesh: Shape.types.SPHERE | Shape.types.TRIMESH,
  planeTrimesh: Shape.types.PLANE | Shape.types.TRIMESH
};

/**
 * Helper class for the World. Generates ContactEquations.
 * @todo Sphere-ConvexPolyhedron contacts
 * @todo Contact reduction
 * @todo should move methods to prototype
 */
class Narrowphase {
  /**
   * Internal storage of pooled contact points.
   */

  /**
   * Pooled vectors.
   */
  get [COLLISION_TYPES.sphereSphere]() {
    return this.sphereSphere;
  }

  get [COLLISION_TYPES.spherePlane]() {
    return this.spherePlane;
  }

  get [COLLISION_TYPES.boxBox]() {
    return this.boxBox;
  }

  get [COLLISION_TYPES.sphereBox]() {
    return this.sphereBox;
  }

  get [COLLISION_TYPES.planeBox]() {
    return this.planeBox;
  }

  get [COLLISION_TYPES.convexConvex]() {
    return this.convexConvex;
  }

  get [COLLISION_TYPES.sphereConvex]() {
    return this.sphereConvex;
  }

  get [COLLISION_TYPES.planeConvex]() {
    return this.planeConvex;
  }

  get [COLLISION_TYPES.boxConvex]() {
    return this.boxConvex;
  }

  get [COLLISION_TYPES.sphereHeightfield]() {
    return this.sphereHeightfield;
  }

  get [COLLISION_TYPES.boxHeightfield]() {
    return this.boxHeightfield;
  }

  get [COLLISION_TYPES.convexHeightfield]() {
    return this.convexHeightfield;
  }

  get [COLLISION_TYPES.sphereParticle]() {
    return this.sphereParticle;
  }

  get [COLLISION_TYPES.planeParticle]() {
    return this.planeParticle;
  }

  get [COLLISION_TYPES.boxParticle]() {
    return this.boxParticle;
  }

  get [COLLISION_TYPES.convexParticle]() {
    return this.convexParticle;
  }

  get [COLLISION_TYPES.cylinderCylinder]() {
    return this.convexConvex;
  }

  get [COLLISION_TYPES.sphereCylinder]() {
    return this.sphereConvex;
  }

  get [COLLISION_TYPES.planeCylinder]() {
    return this.planeConvex;
  }

  get [COLLISION_TYPES.boxCylinder]() {
    return this.boxConvex;
  }

  get [COLLISION_TYPES.convexCylinder]() {
    return this.convexConvex;
  }

  get [COLLISION_TYPES.heightfieldCylinder]() {
    return this.heightfieldCylinder;
  }

  get [COLLISION_TYPES.particleCylinder]() {
    return this.particleCylinder;
  }

  get [COLLISION_TYPES.sphereTrimesh]() {
    return this.sphereTrimesh;
  }

  get [COLLISION_TYPES.planeTrimesh]() {
    return this.planeTrimesh;
  } // get [COLLISION_TYPES.convexTrimesh]() {
  //   return this.convexTrimesh
  // }


  constructor(world) {
    this.contactPointPool = [];
    this.frictionEquationPool = [];
    this.result = [];
    this.frictionResult = [];
    this.v3pool = new Vec3Pool();
    this.world = world;
    this.currentContactMaterial = world.defaultContactMaterial;
    this.enableFrictionReduction = false;
  }
  /**
   * Make a contact object, by using the internal pool or creating a new one.
   */


  createContactEquation(bi, bj, si, sj, overrideShapeA, overrideShapeB) {
    let c;

    if (this.contactPointPool.length) {
      c = this.contactPointPool.pop();
      c.bi = bi;
      c.bj = bj;
    } else {
      c = new ContactEquation(bi, bj);
    }

    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
    const cm = this.currentContactMaterial;
    c.restitution = cm.restitution;
    c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
    const matA = si.material || bi.material;
    const matB = sj.material || bj.material;

    if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {
      c.restitution = matA.restitution * matB.restitution;
    }

    c.si = overrideShapeA || si;
    c.sj = overrideShapeB || sj;
    return c;
  }

  createFrictionEquationsFromContact(contactEquation, outArray) {
    const bodyA = contactEquation.bi;
    const bodyB = contactEquation.bj;
    const shapeA = contactEquation.si;
    const shapeB = contactEquation.sj;
    const world = this.world;
    const cm = this.currentContactMaterial; // If friction or restitution were specified in the material, use them

    let friction = cm.friction;
    const matA = shapeA.material || bodyA.material;
    const matB = shapeB.material || bodyB.material;

    if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
      friction = matA.friction * matB.friction;
    }

    if (friction > 0) {
      // Create 2 tangent equations
      // Users may provide a force different from global gravity to use when computing contact friction.
      const mug = friction * (world.frictionGravity || world.gravity).length();
      let reducedMass = bodyA.invMass + bodyB.invMass;

      if (reducedMass > 0) {
        reducedMass = 1 / reducedMass;
      }

      const pool = this.frictionEquationPool;
      const c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
      const c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
      c1.bi = c2.bi = bodyA;
      c1.bj = c2.bj = bodyB;
      c1.minForce = c2.minForce = -mug * reducedMass;
      c1.maxForce = c2.maxForce = mug * reducedMass; // Copy over the relative vectors

      c1.ri.copy(contactEquation.ri);
      c1.rj.copy(contactEquation.rj);
      c2.ri.copy(contactEquation.ri);
      c2.rj.copy(contactEquation.rj); // Construct tangents

      contactEquation.ni.tangents(c1.t, c2.t); // Set spook params

      c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
      c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
      c1.enabled = c2.enabled = contactEquation.enabled;
      outArray.push(c1, c2);
      return true;
    }

    return false;
  }
  /**
   * Take the average N latest contact point on the plane.
   */


  createFrictionFromAverage(numContacts) {
    // The last contactEquation
    let c = this.result[this.result.length - 1]; // Create the result: two "average" friction equations

    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
      return;
    }

    const f1 = this.frictionResult[this.frictionResult.length - 2];
    const f2 = this.frictionResult[this.frictionResult.length - 1];
    averageNormal.setZero();
    averageContactPointA.setZero();
    averageContactPointB.setZero();
    const bodyA = c.bi;
    c.bj;

    for (let i = 0; i !== numContacts; i++) {
      c = this.result[this.result.length - 1 - i];

      if (c.bi !== bodyA) {
        averageNormal.vadd(c.ni, averageNormal);
        averageContactPointA.vadd(c.ri, averageContactPointA);
        averageContactPointB.vadd(c.rj, averageContactPointB);
      } else {
        averageNormal.vsub(c.ni, averageNormal);
        averageContactPointA.vadd(c.rj, averageContactPointA);
        averageContactPointB.vadd(c.ri, averageContactPointB);
      }
    }

    const invNumContacts = 1 / numContacts;
    averageContactPointA.scale(invNumContacts, f1.ri);
    averageContactPointB.scale(invNumContacts, f1.rj);
    f2.ri.copy(f1.ri); // Should be the same

    f2.rj.copy(f1.rj);
    averageNormal.normalize();
    averageNormal.tangents(f1.t, f2.t); // return eq;
  }
  /**
   * Generate all contacts between a list of body pairs
   * @param p1 Array of body indices
   * @param p2 Array of body indices
   * @param result Array to store generated contacts
   * @param oldcontacts Optional. Array of reusable contact objects
   */


  getContacts(p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
    // Save old contact objects
    this.contactPointPool = oldcontacts;
    this.frictionEquationPool = frictionPool;
    this.result = result;
    this.frictionResult = frictionResult;
    const qi = tmpQuat1;
    const qj = tmpQuat2;
    const xi = tmpVec1;
    const xj = tmpVec2;

    for (let k = 0, N = p1.length; k !== N; k++) {
      // Get current collision bodies
      const bi = p1[k];
      const bj = p2[k]; // Get contact material

      let bodyContactMaterial = null;

      if (bi.material && bj.material) {
        bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null;
      }

      const justTest = bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;

      for (let i = 0; i < bi.shapes.length; i++) {
        bi.quaternion.mult(bi.shapeOrientations[i], qi);
        bi.quaternion.vmult(bi.shapeOffsets[i], xi);
        xi.vadd(bi.position, xi);
        const si = bi.shapes[i];

        for (let j = 0; j < bj.shapes.length; j++) {
          // Compute world transform of shapes
          bj.quaternion.mult(bj.shapeOrientations[j], qj);
          bj.quaternion.vmult(bj.shapeOffsets[j], xj);
          xj.vadd(bj.position, xj);
          const sj = bj.shapes[j];

          if (!(si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup)) {
            continue;
          }

          if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
            continue;
          } // Get collision material


          let shapeContactMaterial = null;

          if (si.material && sj.material) {
            shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null;
          }

          this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial; // Get contacts

          const resolverIndex = si.type | sj.type;
          const resolver = this[resolverIndex];

          if (resolver) {
            let retval = false; // TO DO: investigate why sphereParticle and convexParticle
            // resolvers expect si and sj shapes to be in reverse order
            // (i.e. larger integer value type first instead of smaller first)

            if (si.type < sj.type) {
              retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
            } else {
              retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
            }

            if (retval && justTest) {
              // Register overlap
              world.shapeOverlapKeeper.set(si.id, sj.id);
              world.bodyOverlapKeeper.set(bi.id, bj.id);
            }
          }
        }
      }
    }
  }

  sphereSphere(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    if (justTest) {
      return xi.distanceSquared(xj) < (si.radius + sj.radius) ** 2;
    } // We will have only one contact in this case


    const contactEq = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

    xj.vsub(xi, contactEq.ni);
    contactEq.ni.normalize(); // Contact point locations

    contactEq.ri.copy(contactEq.ni);
    contactEq.rj.copy(contactEq.ni);
    contactEq.ri.scale(si.radius, contactEq.ri);
    contactEq.rj.scale(-sj.radius, contactEq.rj);
    contactEq.ri.vadd(xi, contactEq.ri);
    contactEq.ri.vsub(bi.position, contactEq.ri);
    contactEq.rj.vadd(xj, contactEq.rj);
    contactEq.rj.vsub(bj.position, contactEq.rj);
    this.result.push(contactEq);
    this.createFrictionEquationsFromContact(contactEq, this.frictionResult);
  }

  spherePlane(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    // We will have one contact in this case
    const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

    r.ni.set(0, 0, 1);
    qj.vmult(r.ni, r.ni);
    r.ni.negate(r.ni); // body i is the sphere, flip normal

    r.ni.normalize(); // Needed?
    // Vector from sphere center to contact point

    r.ni.scale(si.radius, r.ri); // Project down sphere on plane

    xi.vsub(xj, point_on_plane_to_sphere);
    r.ni.scale(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj); // The sphere position projected to plane

    if (-point_on_plane_to_sphere.dot(r.ni) <= si.radius) {
      if (justTest) {
        return true;
      } // Make it relative to the body


      const ri = r.ri;
      const rj = r.rj;
      ri.vadd(xi, ri);
      ri.vsub(bi.position, ri);
      rj.vadd(xj, rj);
      rj.vsub(bj.position, rj);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }

  boxBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    sj.convexPolyhedronRepresentation.material = sj.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  sphereBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    const v3pool = this.v3pool; // we refer to the box as body j

    const sides = sphereBox_sides;
    xi.vsub(xj, box_to_sphere);
    sj.getSideNormals(sides, qj);
    const R = si.radius;

    let found = false; // Store the resulting side penetration info

    const side_ns = sphereBox_side_ns;
    const side_ns1 = sphereBox_side_ns1;
    const side_ns2 = sphereBox_side_ns2;
    let side_h = null;
    let side_penetrations = 0;
    let side_dot1 = 0;
    let side_dot2 = 0;
    let side_distance = null;

    for (let idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {
      // Get the plane side normal (ns)
      const ns = sphereBox_ns;
      ns.copy(sides[idx]);
      const h = ns.length();
      ns.normalize(); // The normal/distance dot product tells which side of the plane we are

      const dot = box_to_sphere.dot(ns);

      if (dot < h + R && dot > 0) {
        // Intersects plane. Now check the other two dimensions
        const ns1 = sphereBox_ns1;
        const ns2 = sphereBox_ns2;
        ns1.copy(sides[(idx + 1) % 3]);
        ns2.copy(sides[(idx + 2) % 3]);
        const h1 = ns1.length();
        const h2 = ns2.length();
        ns1.normalize();
        ns2.normalize();
        const dot1 = box_to_sphere.dot(ns1);
        const dot2 = box_to_sphere.dot(ns2);

        if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
          const dist = Math.abs(dot - h - R);

          if (side_distance === null || dist < side_distance) {
            side_distance = dist;
            side_dot1 = dot1;
            side_dot2 = dot2;
            side_h = h;
            side_ns.copy(ns);
            side_ns1.copy(ns1);
            side_ns2.copy(ns2);
            side_penetrations++;

            if (justTest) {
              return true;
            }
          }
        }
      }
    }

    if (side_penetrations) {
      found = true;
      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      side_ns.scale(-R, r.ri); // Sphere r

      r.ni.copy(side_ns);
      r.ni.negate(r.ni); // Normal should be out of sphere

      side_ns.scale(side_h, side_ns);
      side_ns1.scale(side_dot1, side_ns1);
      side_ns.vadd(side_ns1, side_ns);
      side_ns2.scale(side_dot2, side_ns2);
      side_ns.vadd(side_ns2, r.rj); // Make relative to bodies

      r.ri.vadd(xi, r.ri);
      r.ri.vsub(bi.position, r.ri);
      r.rj.vadd(xj, r.rj);
      r.rj.vsub(bj.position, r.rj);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    } // Check corners


    let rj = v3pool.get();
    const sphere_to_corner = sphereBox_sphere_to_corner;

    for (let j = 0; j !== 2 && !found; j++) {
      for (let k = 0; k !== 2 && !found; k++) {
        for (let l = 0; l !== 2 && !found; l++) {
          rj.set(0, 0, 0);

          if (j) {
            rj.vadd(sides[0], rj);
          } else {
            rj.vsub(sides[0], rj);
          }

          if (k) {
            rj.vadd(sides[1], rj);
          } else {
            rj.vsub(sides[1], rj);
          }

          if (l) {
            rj.vadd(sides[2], rj);
          } else {
            rj.vsub(sides[2], rj);
          } // World position of corner


          xj.vadd(rj, sphere_to_corner);
          sphere_to_corner.vsub(xi, sphere_to_corner);

          if (sphere_to_corner.lengthSquared() < R * R) {
            if (justTest) {
              return true;
            }

            found = true;
            const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            r.ri.copy(sphere_to_corner);
            r.ri.normalize();
            r.ni.copy(r.ri);
            r.ri.scale(R, r.ri);
            r.rj.copy(rj); // Make relative to bodies

            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri);
            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      }
    }

    v3pool.release(rj);
    rj = null; // Check edges

    const edgeTangent = v3pool.get();
    const edgeCenter = v3pool.get();
    const r = v3pool.get(); // r = edge center to sphere center

    const orthogonal = v3pool.get();
    const dist = v3pool.get();
    const Nsides = sides.length;

    for (let j = 0; j !== Nsides && !found; j++) {
      for (let k = 0; k !== Nsides && !found; k++) {
        if (j % 3 !== k % 3) {
          // Get edge tangent
          sides[k].cross(sides[j], edgeTangent);
          edgeTangent.normalize();
          sides[j].vadd(sides[k], edgeCenter);
          r.copy(xi);
          r.vsub(edgeCenter, r);
          r.vsub(xj, r);
          const orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction

          edgeTangent.scale(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction
          // Find the third side orthogonal to this one

          let l = 0;

          while (l === j % 3 || l === k % 3) {
            l++;
          } // vec from edge center to sphere projected to the plane orthogonal to the edge tangent


          dist.copy(xi);
          dist.vsub(orthogonal, dist);
          dist.vsub(edgeCenter, dist);
          dist.vsub(xj, dist); // Distances in tangent direction and distance in the plane orthogonal to it

          const tdist = Math.abs(orthonorm);
          const ndist = dist.length();

          if (tdist < sides[l].length() && ndist < R) {
            if (justTest) {
              return true;
            }

            found = true;
            const res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            edgeCenter.vadd(orthogonal, res.rj); // box rj

            res.rj.copy(res.rj);
            dist.negate(res.ni);
            res.ni.normalize();
            res.ri.copy(res.rj);
            res.ri.vadd(xj, res.ri);
            res.ri.vsub(xi, res.ri);
            res.ri.normalize();
            res.ri.scale(R, res.ri); // Make relative to bodies

            res.ri.vadd(xi, res.ri);
            res.ri.vsub(bi.position, res.ri);
            res.rj.vadd(xj, res.rj);
            res.rj.vsub(bj.position, res.rj);
            this.result.push(res);
            this.createFrictionEquationsFromContact(res, this.frictionResult);
          }
        }
      }
    }

    v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
  }

  planeBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    sj.convexPolyhedronRepresentation.material = sj.material;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    sj.convexPolyhedronRepresentation.id = sj.id;
    return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  convexConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {
    const sepAxis = convexConvex_sepAxis;

    if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
      return;
    }

    if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
      const res = [];
      const q = convexConvex_q;
      si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
      let numContacts = 0;

      for (let j = 0; j !== res.length; j++) {
        if (justTest) {
          return true;
        }

        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        const ri = r.ri;
        const rj = r.rj;
        sepAxis.negate(r.ni);
        res[j].normal.negate(q);
        q.scale(res[j].depth, q);
        res[j].point.vadd(q, ri);
        rj.copy(res[j].point); // Contact points are in world coordinates. Transform back to relative

        ri.vsub(xi, ri);
        rj.vsub(xj, rj); // Make relative to bodies

        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);
        this.result.push(r);
        numContacts++;

        if (!this.enableFrictionReduction) {
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }

      if (this.enableFrictionReduction && numContacts) {
        this.createFrictionFromAverage(numContacts);
      }
    }
  }

  sphereConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    const v3pool = this.v3pool;
    xi.vsub(xj, convex_to_sphere);
    const normals = sj.faceNormals;
    const faces = sj.faces;
    const verts = sj.vertices;
    const R = si.radius;
    //     return;
    // }

    let found = false; // Check corners

    for (let i = 0; i !== verts.length; i++) {
      const v = verts[i]; // World position of corner

      const worldCorner = sphereConvex_worldCorner;
      qj.vmult(v, worldCorner);
      xj.vadd(worldCorner, worldCorner);
      const sphere_to_corner = sphereConvex_sphereToCorner;
      worldCorner.vsub(xi, sphere_to_corner);

      if (sphere_to_corner.lengthSquared() < R * R) {
        if (justTest) {
          return true;
        }

        found = true;
        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        r.ri.copy(sphere_to_corner);
        r.ri.normalize();
        r.ni.copy(r.ri);
        r.ri.scale(R, r.ri);
        worldCorner.vsub(xj, r.rj); // Should be relative to the body.

        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri); // Should be relative to the body.

        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
        return;
      }
    } // Check side (plane) intersections


    for (let i = 0, nfaces = faces.length; i !== nfaces && found === false; i++) {
      const normal = normals[i];
      const face = faces[i]; // Get world-transformed normal of the face

      const worldNormal = sphereConvex_worldNormal;
      qj.vmult(normal, worldNormal); // Get a world vertex from the face

      const worldPoint = sphereConvex_worldPoint;
      qj.vmult(verts[face[0]], worldPoint);
      worldPoint.vadd(xj, worldPoint); // Get a point on the sphere, closest to the face normal

      const worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
      worldNormal.scale(-R, worldSpherePointClosestToPlane);
      xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane); // Vector from a face point to the closest point on the sphere

      const penetrationVec = sphereConvex_penetrationVec;
      worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec); // The penetration. Negative value means overlap.

      const penetration = penetrationVec.dot(worldNormal);
      const worldPointToSphere = sphereConvex_sphereToWorldPoint;
      xi.vsub(worldPoint, worldPointToSphere);

      if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
        // Intersects plane. Now check if the sphere is inside the face polygon
        const faceVerts = []; // Face vertices, in world coords

        for (let j = 0, Nverts = face.length; j !== Nverts; j++) {
          const worldVertex = v3pool.get();
          qj.vmult(verts[face[j]], worldVertex);
          xj.vadd(worldVertex, worldVertex);
          faceVerts.push(worldVertex);
        }

        if (pointInPolygon(faceVerts, worldNormal, xi)) {
          // Is the sphere center in the face polygon?
          if (justTest) {
            return true;
          }

          found = true;
          const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          worldNormal.scale(-R, r.ri); // Contact offset, from sphere center to contact

          worldNormal.negate(r.ni); // Normal pointing out of sphere

          const penetrationVec2 = v3pool.get();
          worldNormal.scale(-penetration, penetrationVec2);
          const penetrationSpherePoint = v3pool.get();
          worldNormal.scale(-R, penetrationSpherePoint); //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);

          xi.vsub(xj, r.rj);
          r.rj.vadd(penetrationSpherePoint, r.rj);
          r.rj.vadd(penetrationVec2, r.rj); // Should be relative to the body.

          r.rj.vadd(xj, r.rj);
          r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

          r.ri.vadd(xi, r.ri);
          r.ri.vsub(bi.position, r.ri);
          v3pool.release(penetrationVec2);
          v3pool.release(penetrationSpherePoint);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

          for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
            v3pool.release(faceVerts[j]);
          }

          return; // We only expect *one* face contact
        } else {
          // Edge?
          for (let j = 0; j !== face.length; j++) {
            // Get two world transformed vertices
            const v1 = v3pool.get();
            const v2 = v3pool.get();
            qj.vmult(verts[face[(j + 1) % face.length]], v1);
            qj.vmult(verts[face[(j + 2) % face.length]], v2);
            xj.vadd(v1, v1);
            xj.vadd(v2, v2); // Construct edge vector

            const edge = sphereConvex_edge;
            v2.vsub(v1, edge); // Construct the same vector, but normalized

            const edgeUnit = sphereConvex_edgeUnit;
            edge.unit(edgeUnit); // p is xi projected onto the edge

            const p = v3pool.get();
            const v1_to_xi = v3pool.get();
            xi.vsub(v1, v1_to_xi);
            const dot = v1_to_xi.dot(edgeUnit);
            edgeUnit.scale(dot, p);
            p.vadd(v1, p); // Compute a vector from p to the center of the sphere

            const xi_to_p = v3pool.get();
            p.vsub(xi, xi_to_p); // Collision if the edge-sphere distance is less than the radius
            // AND if p is in between v1 and v2

            if (dot > 0 && dot * dot < edge.lengthSquared() && xi_to_p.lengthSquared() < R * R) {
              // Collision if the edge-sphere distance is less than the radius
              // Edge contact!
              if (justTest) {
                return true;
              }

              const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              p.vsub(xj, r.rj);
              p.vsub(xi, r.ni);
              r.ni.normalize();
              r.ni.scale(R, r.ri); // Should be relative to the body.

              r.rj.vadd(xj, r.rj);
              r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

              r.ri.vadd(xi, r.ri);
              r.ri.vsub(bi.position, r.ri);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

              for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                v3pool.release(faceVerts[j]);
              }

              v3pool.release(v1);
              v3pool.release(v2);
              v3pool.release(p);
              v3pool.release(xi_to_p);
              v3pool.release(v1_to_xi);
              return;
            }

            v3pool.release(v1);
            v3pool.release(v2);
            v3pool.release(p);
            v3pool.release(xi_to_p);
            v3pool.release(v1_to_xi);
          }
        } // Release world vertices


        for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
          v3pool.release(faceVerts[j]);
        }
      }
    }
  }

  planeConvex(planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {
    // Simply return the points behind the plane.
    const worldVertex = planeConvex_v;
    const worldNormal = planeConvex_normal;
    worldNormal.set(0, 0, 1);
    planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation

    let numContacts = 0;
    const relpos = planeConvex_relpos;

    for (let i = 0; i !== convexShape.vertices.length; i++) {
      // Get world convex vertex
      worldVertex.copy(convexShape.vertices[i]);
      convexQuat.vmult(worldVertex, worldVertex);
      convexPosition.vadd(worldVertex, worldVertex);
      worldVertex.vsub(planePosition, relpos);
      const dot = worldNormal.dot(relpos);

      if (dot <= 0.0) {
        if (justTest) {
          return true;
        }

        const r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj); // Get vertex position projected on plane

        const projected = planeConvex_projected;
        worldNormal.scale(worldNormal.dot(relpos), projected);
        worldVertex.vsub(projected, projected);
        projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

        r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane
        // rj is now just the vector from the convex center to the vertex

        worldVertex.vsub(convexPosition, r.rj); // Make it relative to the body

        r.ri.vadd(planePosition, r.ri);
        r.ri.vsub(planeBody.position, r.ri);
        r.rj.vadd(convexPosition, r.rj);
        r.rj.vsub(convexBody.position, r.rj);
        this.result.push(r);
        numContacts++;

        if (!this.enableFrictionReduction) {
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
    }

    if (this.enableFrictionReduction && numContacts) {
      this.createFrictionFromAverage(numContacts);
    }
  }

  boxConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  sphereHeightfield(sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {
    const data = hfShape.data;
    const radius = sphereShape.radius;
    const w = hfShape.elementSize;
    const worldPillarOffset = sphereHeightfield_tmp2; // Get sphere position to heightfield local!

    const localSpherePos = sphereHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos); // Get the index of the data points to test against

    let iMinX = Math.floor((localSpherePos.x - radius) / w) - 1;
    let iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1;
    let iMinY = Math.floor((localSpherePos.y - radius) / w) - 1;
    let iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1; // Bail out if we are out of the terrain

    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
      return;
    } // Clamp index to edges


    if (iMinX < 0) {
      iMinX = 0;
    }

    if (iMaxX < 0) {
      iMaxX = 0;
    }

    if (iMinY < 0) {
      iMinY = 0;
    }

    if (iMaxY < 0) {
      iMaxY = 0;
    }

    if (iMinX >= data.length) {
      iMinX = data.length - 1;
    }

    if (iMaxX >= data.length) {
      iMaxX = data.length - 1;
    }

    if (iMaxY >= data[0].length) {
      iMaxY = data[0].length - 1;
    }

    if (iMinY >= data[0].length) {
      iMinY = data[0].length - 1;
    }

    const minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    const min = minMax[0];
    const max = minMax[1]; // Bail out if we can't touch the bounding height box

    if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) {
      return;
    }

    const result = this.result;

    for (let i = iMinX; i < iMaxX; i++) {
      for (let j = iMinY; j < iMaxY; j++) {
        const numContactsBefore = result.length;
        let intersecting = false; // Lower triangle

        hfShape.getConvexTrianglePillar(i, j, false);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
        }

        if (justTest && intersecting) {
          return true;
        } // Upper triangle


        hfShape.getConvexTrianglePillar(i, j, true);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
        }

        if (justTest && intersecting) {
          return true;
        }

        const numContacts = result.length - numContactsBefore;

        if (numContacts > 2) {
          return;
        }
        /*
          // Skip all but 1
          for (let k = 0; k < numContacts - 1; k++) {
              result.pop();
          }
        */

      }
    }
  }

  boxHeightfield(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  convexHeightfield(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {
    const data = hfShape.data;
    const w = hfShape.elementSize;
    const radius = convexShape.boundingSphereRadius;
    const worldPillarOffset = convexHeightfield_tmp2;
    const faceList = convexHeightfield_faceList; // Get sphere position to heightfield local!

    const localConvexPos = convexHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos); // Get the index of the data points to test against

    let iMinX = Math.floor((localConvexPos.x - radius) / w) - 1;
    let iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1;
    let iMinY = Math.floor((localConvexPos.y - radius) / w) - 1;
    let iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1; // Bail out if we are out of the terrain

    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
      return;
    } // Clamp index to edges


    if (iMinX < 0) {
      iMinX = 0;
    }

    if (iMaxX < 0) {
      iMaxX = 0;
    }

    if (iMinY < 0) {
      iMinY = 0;
    }

    if (iMaxY < 0) {
      iMaxY = 0;
    }

    if (iMinX >= data.length) {
      iMinX = data.length - 1;
    }

    if (iMaxX >= data.length) {
      iMaxX = data.length - 1;
    }

    if (iMaxY >= data[0].length) {
      iMaxY = data[0].length - 1;
    }

    if (iMinY >= data[0].length) {
      iMinY = data[0].length - 1;
    }

    const minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    const min = minMax[0];
    const max = minMax[1]; // Bail out if we're cant touch the bounding height box

    if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) {
      return;
    }

    for (let i = iMinX; i < iMaxX; i++) {
      for (let j = iMinY; j < iMaxY; j++) {
        let intersecting = false; // Lower triangle

        hfShape.getConvexTrianglePillar(i, j, false);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
        }

        if (justTest && intersecting) {
          return true;
        } // Upper triangle


        hfShape.getConvexTrianglePillar(i, j, true);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
        }

        if (justTest && intersecting) {
          return true;
        }
      }
    }
  }

  sphereParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    // The normal is the unit vector from sphere center to particle center
    const normal = particleSphere_normal;
    normal.set(0, 0, 1);
    xi.vsub(xj, normal);
    const lengthSquared = normal.lengthSquared();

    if (lengthSquared <= sj.radius * sj.radius) {
      if (justTest) {
        return true;
      }

      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      normal.normalize();
      r.rj.copy(normal);
      r.rj.scale(sj.radius, r.rj);
      r.ni.copy(normal); // Contact normal

      r.ni.negate(r.ni);
      r.ri.set(0, 0, 0); // Center of particle

      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }

  planeParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    const normal = particlePlane_normal;
    normal.set(0, 0, 1);
    bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation

    const relpos = particlePlane_relpos;
    xi.vsub(bj.position, relpos);
    const dot = normal.dot(relpos);

    if (dot <= 0.0) {
      if (justTest) {
        return true;
      }

      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      r.ni.copy(normal); // Contact normal is the plane normal

      r.ni.negate(r.ni);
      r.ri.set(0, 0, 0); // Center of particle
      // Get particle position projected on plane

      const projected = particlePlane_projected;
      normal.scale(normal.dot(xi), projected);
      xi.vsub(projected, projected); //projected.vadd(bj.position,projected);
      // rj is now the projected world position minus plane position

      r.rj.copy(projected);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }

  boxParticle(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  convexParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    let penetratedFaceIndex = -1;
    const penetratedFaceNormal = convexParticle_penetratedFaceNormal;
    const worldPenetrationVec = convexParticle_worldPenetrationVec;
    let minPenetration = null;

    const local = convexParticle_local;
    local.copy(xi);
    local.vsub(xj, local); // Convert position to relative the convex origin

    qj.conjugate(cqj);
    cqj.vmult(local, local);

    if (sj.pointIsInside(local)) {
      if (sj.worldVerticesNeedsUpdate) {
        sj.computeWorldVertices(xj, qj);
      }

      if (sj.worldFaceNormalsNeedsUpdate) {
        sj.computeWorldFaceNormals(qj);
      } // For each world polygon in the polyhedra


      for (let i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
        // Construct world face vertices
        const verts = [sj.worldVertices[sj.faces[i][0]]];
        const normal = sj.worldFaceNormals[i]; // Check how much the particle penetrates the polygon plane.

        xi.vsub(verts[0], convexParticle_vertexToParticle);
        const penetration = -normal.dot(convexParticle_vertexToParticle);

        if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {
          if (justTest) {
            return true;
          }

          minPenetration = penetration;
          penetratedFaceIndex = i;
          penetratedFaceNormal.copy(normal);
        }
      }

      if (penetratedFaceIndex !== -1) {
        // Setup contact
        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        penetratedFaceNormal.scale(minPenetration, worldPenetrationVec); // rj is the particle position projected to the face

        worldPenetrationVec.vadd(xi, worldPenetrationVec);
        worldPenetrationVec.vsub(xj, worldPenetrationVec);
        r.rj.copy(worldPenetrationVec); //const projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
        //projectedToFace.copy(r.rj);
        //qj.vmult(r.rj,r.rj);

        penetratedFaceNormal.negate(r.ni); // Contact normal

        r.ri.set(0, 0, 0); // Center of particle

        const ri = r.ri;
        const rj = r.rj; // Make relative to bodies

        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      } else {
        console.warn('Point found inside convex, but did not find penetrating face!');
      }
    }
  }

  heightfieldCylinder(hfShape, convexShape, hfPos, convexPos, hfQuat, convexQuat, hfBody, convexBody, rsi, rsj, justTest) {
    return this.convexHeightfield(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest);
  }

  particleCylinder(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    return this.convexParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest);
  }

  sphereTrimesh(sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {
    const edgeVertexA = sphereTrimesh_edgeVertexA;
    const edgeVertexB = sphereTrimesh_edgeVertexB;
    const edgeVector = sphereTrimesh_edgeVector;
    const edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
    const localSpherePos = sphereTrimesh_localSpherePos;
    const tmp = sphereTrimesh_tmp;
    const localSphereAABB = sphereTrimesh_localSphereAABB;
    const v2 = sphereTrimesh_v2;
    const relpos = sphereTrimesh_relpos;
    const triangles = sphereTrimesh_triangles; // Convert sphere position to local in the trimesh

    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos); // Get the aabb of the sphere locally in the trimesh

    const sphereRadius = sphereShape.radius;
    localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);
    localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);
    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles); //for (let i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All
    // Vertices

    const v = sphereTrimesh_v;
    const radiusSquared = sphereShape.radius * sphereShape.radius;

    for (let i = 0; i < triangles.length; i++) {
      for (let j = 0; j < 3; j++) {
        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v); // Check vertex overlap in sphere

        v.vsub(localSpherePos, relpos);

        if (relpos.lengthSquared() <= radiusSquared) {
          // Safe up
          v2.copy(v);
          Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
          v.vsub(spherePos, relpos);

          if (justTest) {
            return true;
          }

          let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
          r.ni.copy(relpos);
          r.ni.normalize(); // ri is the vector from sphere center to the sphere surface

          r.ri.copy(r.ni);
          r.ri.scale(sphereShape.radius, r.ri);
          r.ri.vadd(spherePos, r.ri);
          r.ri.vsub(sphereBody.position, r.ri);
          r.rj.copy(v);
          r.rj.vsub(trimeshBody.position, r.rj); // Store result

          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
    } // Check all edges


    for (let i = 0; i < triangles.length; i++) {
      for (let j = 0; j < 3; j++) {
        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + (j + 1) % 3], edgeVertexB);
        edgeVertexB.vsub(edgeVertexA, edgeVector); // Project sphere position to the edge

        localSpherePos.vsub(edgeVertexB, tmp);
        const positionAlongEdgeB = tmp.dot(edgeVector);
        localSpherePos.vsub(edgeVertexA, tmp);
        let positionAlongEdgeA = tmp.dot(edgeVector);

        if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
          // Now check the orthogonal distance from edge to sphere center
          localSpherePos.vsub(edgeVertexA, tmp);
          edgeVectorUnit.copy(edgeVector);
          edgeVectorUnit.normalize();
          positionAlongEdgeA = tmp.dot(edgeVectorUnit);
          edgeVectorUnit.scale(positionAlongEdgeA, tmp);
          tmp.vadd(edgeVertexA, tmp); // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame

          const dist = tmp.distanceTo(localSpherePos);

          if (dist < sphereShape.radius) {
            if (justTest) {
              return true;
            }

            const r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
            tmp.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);
            r.ri.vadd(spherePos, r.ri);
            r.ri.vsub(sphereBody.position, r.ri);
            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
            tmp.vsub(trimeshBody.position, r.rj);
            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      }
    } // Triangle faces


    const va = sphereTrimesh_va;
    const vb = sphereTrimesh_vb;
    const vc = sphereTrimesh_vc;
    const normal = sphereTrimesh_normal;

    for (let i = 0, N = triangles.length; i !== N; i++) {
      trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
      trimeshShape.getNormal(triangles[i], normal);
      localSpherePos.vsub(va, tmp);
      let dist = tmp.dot(normal);
      normal.scale(dist, tmp);
      localSpherePos.vsub(tmp, tmp); // tmp is now the sphere position projected to the triangle plane

      dist = tmp.distanceTo(localSpherePos);

      if (Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
        if (justTest) {
          return true;
        }

        let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
        tmp.vsub(localSpherePos, r.ni);
        r.ni.normalize();
        r.ni.scale(sphereShape.radius, r.ri);
        r.ri.vadd(spherePos, r.ri);
        r.ri.vsub(sphereBody.position, r.ri);
        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
        tmp.vsub(trimeshBody.position, r.rj);
        Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
        Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      }
    }

    triangles.length = 0;
  }

  planeTrimesh(planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {
    // Make contacts!
    const v = new Vec3();
    const normal = planeTrimesh_normal;
    normal.set(0, 0, 1);
    planeQuat.vmult(normal, normal); // Turn normal according to plane

    for (let i = 0; i < trimeshShape.vertices.length / 3; i++) {
      // Get world vertex from trimesh
      trimeshShape.getVertex(i, v); // Safe up

      const v2 = new Vec3();
      v2.copy(v);
      Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v); // Check plane side

      const relpos = planeTrimesh_relpos;
      v.vsub(planePos, relpos);
      const dot = normal.dot(relpos);

      if (dot <= 0.0) {
        if (justTest) {
          return true;
        }

        const r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);
        r.ni.copy(normal); // Contact normal is the plane normal
        // Get vertex position projected on plane

        const projected = planeTrimesh_projected;
        normal.scale(relpos.dot(normal), projected);
        v.vsub(projected, projected); // ri is the projected world position minus plane position

        r.ri.copy(projected);
        r.ri.vsub(planeBody.position, r.ri);
        r.rj.copy(v);
        r.rj.vsub(trimeshBody.position, r.rj); // Store result

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      }
    }
  } // convexTrimesh(
  //   si: ConvexPolyhedron, sj: Trimesh, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion,
  //   bi: Body, bj: Body, rsi?: Shape | null, rsj?: Shape | null,
  //   faceListA?: number[] | null, faceListB?: number[] | null,
  // ) {
  //   const sepAxis = convexConvex_sepAxis;
  //   if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
  //       return;
  //   }
  //   // Construct a temp hull for each triangle
  //   const hullB = new ConvexPolyhedron();
  //   hullB.faces = [[0,1,2]];
  //   const va = new Vec3();
  //   const vb = new Vec3();
  //   const vc = new Vec3();
  //   hullB.vertices = [
  //       va,
  //       vb,
  //       vc
  //   ];
  //   for (let i = 0; i < sj.indices.length / 3; i++) {
  //       const triangleNormal = new Vec3();
  //       sj.getNormal(i, triangleNormal);
  //       hullB.faceNormals = [triangleNormal];
  //       sj.getTriangleVertices(i, va, vb, vc);
  //       let d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
  //       if(!d){
  //           triangleNormal.scale(-1, triangleNormal);
  //           d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
  //           if(!d){
  //               continue;
  //           }
  //       }
  //       const res: ConvexPolyhedronContactPoint[] = [];
  //       const q = convexConvex_q;
  //       si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
  //       for(let j = 0; j !== res.length; j++){
  //           const r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
  //               ri = r.ri,
  //               rj = r.rj;
  //           r.ni.copy(triangleNormal);
  //           r.ni.negate(r.ni);
  //           res[j].normal.negate(q);
  //           q.mult(res[j].depth, q);
  //           res[j].point.vadd(q, ri);
  //           rj.copy(res[j].point);
  //           // Contact points are in world coordinates. Transform back to relative
  //           ri.vsub(xi,ri);
  //           rj.vsub(xj,rj);
  //           // Make relative to bodies
  //           ri.vadd(xi, ri);
  //           ri.vsub(bi.position, ri);
  //           rj.vadd(xj, rj);
  //           rj.vsub(bj.position, rj);
  //           result.push(r);
  //       }
  //   }
  // }


}
const averageNormal = new Vec3();
const averageContactPointA = new Vec3();
const averageContactPointB = new Vec3();
const tmpVec1 = new Vec3();
const tmpVec2 = new Vec3();
const tmpQuat1 = new Quaternion();
const tmpQuat2 = new Quaternion();

const planeTrimesh_normal = new Vec3();
const planeTrimesh_relpos = new Vec3();
const planeTrimesh_projected = new Vec3();
const sphereTrimesh_normal = new Vec3();
const sphereTrimesh_relpos = new Vec3();
new Vec3();
const sphereTrimesh_v = new Vec3();
const sphereTrimesh_v2 = new Vec3();
const sphereTrimesh_edgeVertexA = new Vec3();
const sphereTrimesh_edgeVertexB = new Vec3();
const sphereTrimesh_edgeVector = new Vec3();
const sphereTrimesh_edgeVectorUnit = new Vec3();
const sphereTrimesh_localSpherePos = new Vec3();
const sphereTrimesh_tmp = new Vec3();
const sphereTrimesh_va = new Vec3();
const sphereTrimesh_vb = new Vec3();
const sphereTrimesh_vc = new Vec3();
const sphereTrimesh_localSphereAABB = new AABB();
const sphereTrimesh_triangles = [];
const point_on_plane_to_sphere = new Vec3();
const plane_to_sphere_ortho = new Vec3(); // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html

const pointInPolygon_edge = new Vec3();
const pointInPolygon_edge_x_normal = new Vec3();
const pointInPolygon_vtp = new Vec3();

function pointInPolygon(verts, normal, p) {
  let positiveResult = null;
  const N = verts.length;

  for (let i = 0; i !== N; i++) {
    const v = verts[i]; // Get edge to the next vertex

    const edge = pointInPolygon_edge;
    verts[(i + 1) % N].vsub(v, edge); // Get cross product between polygon normal and the edge

    const edge_x_normal = pointInPolygon_edge_x_normal; //const edge_x_normal = new Vec3();

    edge.cross(normal, edge_x_normal); // Get vector between point and current vertex

    const vertex_to_p = pointInPolygon_vtp;
    p.vsub(v, vertex_to_p); // This dot product determines which side of the edge the point is

    const r = edge_x_normal.dot(vertex_to_p); // If all such dot products have same sign, we are inside the polygon.

    if (positiveResult === null || r > 0 && positiveResult === true || r <= 0 && positiveResult === false) {
      if (positiveResult === null) {
        positiveResult = r > 0;
      }

      continue;
    } else {
      return false; // Encountered some other sign. Exit.
    }
  } // If we got here, all dot products were of the same sign.


  return true;
}

const box_to_sphere = new Vec3();
const sphereBox_ns = new Vec3();
const sphereBox_ns1 = new Vec3();
const sphereBox_ns2 = new Vec3();
const sphereBox_sides = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
const sphereBox_sphere_to_corner = new Vec3();
const sphereBox_side_ns = new Vec3();
const sphereBox_side_ns1 = new Vec3();
const sphereBox_side_ns2 = new Vec3();
const convex_to_sphere = new Vec3();
const sphereConvex_edge = new Vec3();
const sphereConvex_edgeUnit = new Vec3();
const sphereConvex_sphereToCorner = new Vec3();
const sphereConvex_worldCorner = new Vec3();
const sphereConvex_worldNormal = new Vec3();
const sphereConvex_worldPoint = new Vec3();
const sphereConvex_worldSpherePointClosestToPlane = new Vec3();
const sphereConvex_penetrationVec = new Vec3();
const sphereConvex_sphereToWorldPoint = new Vec3();
new Vec3();
new Vec3();
const planeConvex_v = new Vec3();
const planeConvex_normal = new Vec3();
const planeConvex_relpos = new Vec3();
const planeConvex_projected = new Vec3();
const convexConvex_sepAxis = new Vec3();
const convexConvex_q = new Vec3();
const particlePlane_normal = new Vec3();
const particlePlane_relpos = new Vec3();
const particlePlane_projected = new Vec3();
const particleSphere_normal = new Vec3(); // WIP

const cqj = new Quaternion();
const convexParticle_local = new Vec3();
new Vec3();
const convexParticle_penetratedFaceNormal = new Vec3();
const convexParticle_vertexToParticle = new Vec3();
const convexParticle_worldPenetrationVec = new Vec3();
const convexHeightfield_tmp1 = new Vec3();
const convexHeightfield_tmp2 = new Vec3();
const convexHeightfield_faceList = [0];
const sphereHeightfield_tmp1 = new Vec3();
const sphereHeightfield_tmp2 = new Vec3();

class OverlapKeeper {
  /**
   * @todo Remove useless constructor
   */
  constructor() {
    this.current = [];
    this.previous = [];
  }
  /**
   * getKey
   */


  getKey(i, j) {
    if (j < i) {
      const temp = j;
      j = i;
      i = temp;
    }

    return i << 16 | j;
  }
  /**
   * set
   */


  set(i, j) {
    // Insertion sort. This way the diff will have linear complexity.
    const key = this.getKey(i, j);
    const current = this.current;
    let index = 0;

    while (key > current[index]) {
      index++;
    }

    if (key === current[index]) {
      return; // Pair was already added
    }

    for (let j = current.length - 1; j >= index; j--) {
      current[j + 1] = current[j];
    }

    current[index] = key;
  }
  /**
   * tick
   */


  tick() {
    const tmp = this.current;
    this.current = this.previous;
    this.previous = tmp;
    this.current.length = 0;
  }
  /**
   * getDiff
   */


  getDiff(additions, removals) {
    const a = this.current;
    const b = this.previous;
    const al = a.length;
    const bl = b.length;
    let j = 0;

    for (let i = 0; i < al; i++) {
      let found = false;
      const keyA = a[i];

      while (keyA > b[j]) {
        j++;
      }

      found = keyA === b[j];

      if (!found) {
        unpackAndPush(additions, keyA);
      }
    }

    j = 0;

    for (let i = 0; i < bl; i++) {
      let found = false;
      const keyB = b[i];

      while (keyB > a[j]) {
        j++;
      }

      found = a[j] === keyB;

      if (!found) {
        unpackAndPush(removals, keyB);
      }
    }
  }

}

function unpackAndPush(array, key) {
  array.push((key & 0xffff0000) >> 16, key & 0x0000ffff);
}

const getKey = (i, j) => i < j ? `${i}-${j}` : `${j}-${i}`;
/**
 * TupleDictionary
 */


class TupleDictionary {
  constructor() {
    this.data = {
      keys: []
    };
  }

  /** get */
  get(i, j) {
    const key = getKey(i, j);
    return this.data[key];
  }
  /** set */


  set(i, j, value) {
    const key = getKey(i, j); // Check if key already exists

    if (!this.get(i, j)) {
      this.data.keys.push(key);
    }

    this.data[key] = value;
  }
  /** delete */


  delete(i, j) {
    const key = getKey(i, j);
    const index = this.data.keys.indexOf(key);

    if (index !== -1) {
      this.data.keys.splice(index, 1);
    }

    delete this.data[key];
  }
  /** reset */


  reset() {
    const data = this.data;
    const keys = data.keys;

    while (keys.length > 0) {
      const key = keys.pop();
      delete data[key];
    }
  }

}

/**
 * The physics world
 */
class World extends EventTarget {
  /**
   * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
   */

  /**
   * Makes bodies go to sleep when they've been inactive.
   * @default false
   */

  /**
   * All the current contacts (instances of ContactEquation) in the world.
   */

  /**
   * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
   * @default 0
   */

  /**
   * Set to true to use fast quaternion normalization. It is often enough accurate to use.
   * If bodies tend to explode, set to false.
   * @default false
   */

  /**
   * The wall-clock time since simulation start.
   */

  /**
   * Number of timesteps taken since start.
   */

  /**
   * Default and last timestep sizes.
   */

  /**
   * The gravity of the world.
   */

  /**
   * Gravity to use when approximating the friction max force (mu*mass*gravity).
   * If undefined, global gravity will be used.
   * Use to enable friction in a World with a null gravity vector (no gravity).
   */

  /**
   * The broadphase algorithm to use.
   * @default NaiveBroadphase
   */

  /**
   * All bodies in this world
   */

  /**
   * True if any bodies are not sleeping, false if every body is sleeping.
   */

  /**
   * The solver algorithm to use.
   * @default GSSolver
   */

  /**
   * collisionMatrix
   */

  /**
   * CollisionMatrix from the previous step.
   */

  /**
   * All added contactmaterials.
   */

  /**
   * Used to look up a ContactMaterial given two instances of Material.
   */

  /**
   * The default material of the bodies.
   */

  /**
   * This contact material is used if no suitable contactmaterial is found for a contact.
   */

  /**
   * Time accumulator for interpolation.
   * @see https://gafferongames.com/game-physics/fix-your-timestep/
   */

  /**
   * Dispatched after a body has been added to the world.
   */

  /**
   * Dispatched after a body has been removed from the world.
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }

    super();
    this.dt = -1;
    this.allowSleep = !!options.allowSleep;
    this.contacts = [];
    this.frictionEquations = [];
    this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;
    this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;
    this.time = 0.0;
    this.stepnumber = 0;
    this.default_dt = 1 / 60;
    this.nextId = 0;
    this.gravity = new Vec3();

    if (options.gravity) {
      this.gravity.copy(options.gravity);
    }

    if (options.frictionGravity) {
      this.frictionGravity = new Vec3();
      this.frictionGravity.copy(options.frictionGravity);
    }

    this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();
    this.bodies = [];
    this.hasActiveBodies = false;
    this.solver = options.solver !== undefined ? options.solver : new GSSolver();
    this.constraints = [];
    this.narrowphase = new Narrowphase(this);
    this.collisionMatrix = new ArrayCollisionMatrix();
    this.collisionMatrixPrevious = new ArrayCollisionMatrix();
    this.bodyOverlapKeeper = new OverlapKeeper();
    this.shapeOverlapKeeper = new OverlapKeeper();
    this.contactmaterials = [];
    this.contactMaterialTable = new TupleDictionary();
    this.defaultMaterial = new Material('default');
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {
      friction: 0.3,
      restitution: 0.0
    });
    this.doProfiling = false;
    this.profile = {
      solve: 0,
      makeContactConstraints: 0,
      broadphase: 0,
      integrate: 0,
      narrowphase: 0
    };
    this.accumulator = 0;
    this.subsystems = [];
    this.addBodyEvent = {
      type: 'addBody',
      body: null
    };
    this.removeBodyEvent = {
      type: 'removeBody',
      body: null
    };
    this.idToBodyMap = {};
    this.broadphase.setWorld(this);
  }
  /**
   * Get the contact material between materials m1 and m2
   * @return The contact material if it was found.
   */


  getContactMaterial(m1, m2) {
    return this.contactMaterialTable.get(m1.id, m2.id);
  }
  /**
   * Store old collision state info
   */


  collisionMatrixTick() {
    const temp = this.collisionMatrixPrevious;
    this.collisionMatrixPrevious = this.collisionMatrix;
    this.collisionMatrix = temp;
    this.collisionMatrix.reset();
    this.bodyOverlapKeeper.tick();
    this.shapeOverlapKeeper.tick();
  }
  /**
   * Add a constraint to the simulation.
   */


  addConstraint(c) {
    this.constraints.push(c);
  }
  /**
   * Removes a constraint
   */


  removeConstraint(c) {
    const idx = this.constraints.indexOf(c);

    if (idx !== -1) {
      this.constraints.splice(idx, 1);
    }
  }
  /**
   * Raycast test
   * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
   */


  rayTest(from, to, result) {
    if (result instanceof RaycastResult) {
      // Do raycastClosest
      this.raycastClosest(from, to, {
        skipBackfaces: true
      }, result);
    } else {
      // Do raycastAll
      this.raycastAll(from, to, {
        skipBackfaces: true
      }, result);
    }
  }
  /**
   * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
   * @return True if any body was hit.
   */


  raycastAll(from, to, options, callback) {
    if (options === void 0) {
      options = {};
    }

    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
  }
  /**
   * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
   * @return True if any body was hit.
   */


  raycastAny(from, to, options, result) {
    if (options === void 0) {
      options = {};
    }

    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
  }
  /**
   * Ray cast, and return information of the closest hit.
   * @return True if any body was hit.
   */


  raycastClosest(from, to, options, result) {
    if (options === void 0) {
      options = {};
    }

    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
  }
  /**
   * Add a rigid body to the simulation.
   * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
   * @todo Adding an array of bodies should be possible. This would save some loops too
   */


  addBody(body) {
    if (this.bodies.includes(body)) {
      return;
    }

    body.index = this.bodies.length;
    this.bodies.push(body);
    body.world = this;
    body.initPosition.copy(body.position);
    body.initVelocity.copy(body.velocity);
    body.timeLastSleepy = this.time;

    if (body instanceof Body) {
      body.initAngularVelocity.copy(body.angularVelocity);
      body.initQuaternion.copy(body.quaternion);
    }

    this.collisionMatrix.setNumObjects(this.bodies.length);
    this.addBodyEvent.body = body;
    this.idToBodyMap[body.id] = body;
    this.dispatchEvent(this.addBodyEvent);
  }
  /**
   * Remove a rigid body from the simulation.
   */


  removeBody(body) {
    body.world = null;
    const n = this.bodies.length - 1;
    const bodies = this.bodies;
    const idx = bodies.indexOf(body);

    if (idx !== -1) {
      bodies.splice(idx, 1); // Todo: should use a garbage free method
      // Recompute index

      for (let i = 0; i !== bodies.length; i++) {
        bodies[i].index = i;
      }

      this.collisionMatrix.setNumObjects(n);
      this.removeBodyEvent.body = body;
      delete this.idToBodyMap[body.id];
      this.dispatchEvent(this.removeBodyEvent);
    }
  }

  getBodyById(id) {
    return this.idToBodyMap[id];
  }
  /**
   * @todo Make a faster map
   */


  getShapeById(id) {
    const bodies = this.bodies;

    for (let i = 0; i < bodies.length; i++) {
      const shapes = bodies[i].shapes;

      for (let j = 0; j < shapes.length; j++) {
        const shape = shapes[j];

        if (shape.id === id) {
          return shape;
        }
      }
    }

    return null;
  }
  /**
   * Adds a contact material to the World
   */


  addContactMaterial(cmat) {
    // Add contact material
    this.contactmaterials.push(cmat); // Add current contact material to the material table

    this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
  }
  /**
   * Removes a contact material from the World.
   */


  removeContactMaterial(cmat) {
    const idx = this.contactmaterials.indexOf(cmat);

    if (idx === -1) {
      return;
    }

    this.contactmaterials.splice(idx, 1);
    this.contactMaterialTable.delete(cmat.materials[0].id, cmat.materials[1].id);
  }
  /**
   * Step the simulation forward keeping track of last called time
   * to be able to step the world at a fixed rate, independently of framerate.
   *
   * @param dt The fixed time step size to use (default: 1 / 60).
   * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
   * @see https://gafferongames.com/post/fix_your_timestep/
   * @example
   *     // Run the simulation independently of framerate every 1 / 60 ms
   *     world.fixedStep()
   */


  fixedStep(dt, maxSubSteps) {
    if (dt === void 0) {
      dt = 1 / 60;
    }

    if (maxSubSteps === void 0) {
      maxSubSteps = 10;
    }

    const time = performance.now() / 1000; // seconds

    if (!this.lastCallTime) {
      this.step(dt, undefined, maxSubSteps);
    } else {
      const timeSinceLastCalled = time - this.lastCallTime;
      this.step(dt, timeSinceLastCalled, maxSubSteps);
    }

    this.lastCallTime = time;
  }
  /**
   * Step the physics world forward in time.
   *
   * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
   *
   * @param dt The fixed time step size to use.
   * @param timeSinceLastCalled The time elapsed since the function was last called.
   * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
   * @see https://web.archive.org/web/20180426154531/http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World#What_do_the_parameters_to_btDynamicsWorld::stepSimulation_mean.3F
   * @example
   *     // fixed timestepping without interpolation
   *     world.step(1 / 60)
   */


  step(dt, timeSinceLastCalled, maxSubSteps) {
    if (maxSubSteps === void 0) {
      maxSubSteps = 10;
    }

    if (timeSinceLastCalled === undefined) {
      // Fixed, simple stepping
      this.internalStep(dt); // Increment time

      this.time += dt;
    } else {
      this.accumulator += timeSinceLastCalled;
      const t0 = performance.now();
      let substeps = 0;

      while (this.accumulator >= dt && substeps < maxSubSteps) {
        // Do fixed steps to catch up
        this.internalStep(dt);
        this.accumulator -= dt;
        substeps++;

        if (performance.now() - t0 > dt * 1000) {
          // The framerate is not interactive anymore.
          // We are below the target framerate.
          // Better bail out.
          break;
        }
      } // Remove the excess accumulator, since we may not
      // have had enough substeps available to catch up


      this.accumulator = this.accumulator % dt;
      const t = this.accumulator / dt;

      for (let j = 0; j !== this.bodies.length; j++) {
        const b = this.bodies[j];
        b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
        b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
        b.previousQuaternion.normalize();
      }

      this.time += timeSinceLastCalled;
    }
  }

  internalStep(dt) {
    this.dt = dt;
    const contacts = this.contacts;
    const p1 = World_step_p1;
    const p2 = World_step_p2;
    const N = this.bodies.length;
    const bodies = this.bodies;
    const solver = this.solver;
    const gravity = this.gravity;
    const doProfiling = this.doProfiling;
    const profile = this.profile;
    const DYNAMIC = Body.DYNAMIC;
    let profilingStart = -Infinity;
    const constraints = this.constraints;
    const frictionEquationPool = World_step_frictionEquationPool;
    gravity.length();
    const gx = gravity.x;
    const gy = gravity.y;
    const gz = gravity.z;
    let i = 0;

    if (doProfiling) {
      profilingStart = performance.now();
    } // Add gravity to all objects


    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.type === DYNAMIC) {
        // Only for dynamic bodies
        const f = bi.force;
        const m = bi.mass;
        f.x += m * gx;
        f.y += m * gy;
        f.z += m * gz;
      }
    } // Update subsystems


    for (let i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) {
      this.subsystems[i].update();
    } // Collision detection


    if (doProfiling) {
      profilingStart = performance.now();
    }

    p1.length = 0; // Clean up pair arrays from last step

    p2.length = 0;
    this.broadphase.collisionPairs(this, p1, p2);

    if (doProfiling) {
      profile.broadphase = performance.now() - profilingStart;
    } // Remove constrained pairs with collideConnected == false


    let Nconstraints = constraints.length;

    for (i = 0; i !== Nconstraints; i++) {
      const c = constraints[i];

      if (!c.collideConnected) {
        for (let j = p1.length - 1; j >= 0; j -= 1) {
          if (c.bodyA === p1[j] && c.bodyB === p2[j] || c.bodyB === p1[j] && c.bodyA === p2[j]) {
            p1.splice(j, 1);
            p2.splice(j, 1);
          }
        }
      }
    }

    this.collisionMatrixTick(); // Generate contacts

    if (doProfiling) {
      profilingStart = performance.now();
    }

    const oldcontacts = World_step_oldContacts;
    const NoldContacts = contacts.length;

    for (i = 0; i !== NoldContacts; i++) {
      oldcontacts.push(contacts[i]);
    }

    contacts.length = 0; // Transfer FrictionEquation from current list to the pool for reuse

    const NoldFrictionEquations = this.frictionEquations.length;

    for (i = 0; i !== NoldFrictionEquations; i++) {
      frictionEquationPool.push(this.frictionEquations[i]);
    }

    this.frictionEquations.length = 0;
    this.narrowphase.getContacts(p1, p2, this, contacts, oldcontacts, // To be reused
    this.frictionEquations, frictionEquationPool);

    if (doProfiling) {
      profile.narrowphase = performance.now() - profilingStart;
    } // Loop over all collisions


    if (doProfiling) {
      profilingStart = performance.now();
    } // Add all friction eqs


    for (i = 0; i < this.frictionEquations.length; i++) {
      solver.addEquation(this.frictionEquations[i]);
    }

    const ncontacts = contacts.length;

    for (let k = 0; k !== ncontacts; k++) {
      // Current contact
      const c = contacts[k]; // Get current collision indeces

      const bi = c.bi;
      const bj = c.bj;
      const si = c.si;
      const sj = c.sj; // Get collision properties

      let cm;

      if (bi.material && bj.material) {
        cm = this.getContactMaterial(bi.material, bj.material) || this.defaultContactMaterial;
      } else {
        cm = this.defaultContactMaterial;
      } // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;


      cm.friction; // c.restitution = cm.restitution;
      // If friction or restitution were specified in the material, use them

      if (bi.material && bj.material) {
        if (bi.material.friction >= 0 && bj.material.friction >= 0) {
          bi.material.friction * bj.material.friction;
        }

        if (bi.material.restitution >= 0 && bj.material.restitution >= 0) {
          c.restitution = bi.material.restitution * bj.material.restitution;
        }
      } // c.setSpookParams(
      //           cm.contactEquationStiffness,
      //           cm.contactEquationRelaxation,
      //           dt
      //       );


      solver.addEquation(c); // // Add friction constraint equation
      // if(mu > 0){
      // 	// Create 2 tangent equations
      // 	const mug = mu * gnorm;
      // 	const reducedMass = (bi.invMass + bj.invMass);
      // 	if(reducedMass > 0){
      // 		reducedMass = 1/reducedMass;
      // 	}
      // 	const pool = frictionEquationPool;
      // 	const c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
      // 	const c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
      // 	this.frictionEquations.push(c1, c2);
      // 	c1.bi = c2.bi = bi;
      // 	c1.bj = c2.bj = bj;
      // 	c1.minForce = c2.minForce = -mug*reducedMass;
      // 	c1.maxForce = c2.maxForce = mug*reducedMass;
      // 	// Copy over the relative vectors
      // 	c1.ri.copy(c.ri);
      // 	c1.rj.copy(c.rj);
      // 	c2.ri.copy(c.ri);
      // 	c2.rj.copy(c.rj);
      // 	// Construct tangents
      // 	c.ni.tangents(c1.t, c2.t);
      //           // Set spook params
      //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
      //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
      //           c1.enabled = c2.enabled = c.enabled;
      // 	// Add equations to solver
      // 	solver.addEquation(c1);
      // 	solver.addEquation(c2);
      // }

      if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
        const speedSquaredB = bj.velocity.lengthSquared() + bj.angularVelocity.lengthSquared();
        const speedLimitSquaredB = bj.sleepSpeedLimit ** 2;

        if (speedSquaredB >= speedLimitSquaredB * 2) {
          bi.wakeUpAfterNarrowphase = true;
        }
      }

      if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
        const speedSquaredA = bi.velocity.lengthSquared() + bi.angularVelocity.lengthSquared();
        const speedLimitSquaredA = bi.sleepSpeedLimit ** 2;

        if (speedSquaredA >= speedLimitSquaredA * 2) {
          bj.wakeUpAfterNarrowphase = true;
        }
      } // Now we know that i and j are in contact. Set collision matrix state


      this.collisionMatrix.set(bi, bj, true);

      if (!this.collisionMatrixPrevious.get(bi, bj)) {
        // First contact!
        // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
        World_step_collideEvent.body = bj;
        World_step_collideEvent.contact = c;
        bi.dispatchEvent(World_step_collideEvent);
        World_step_collideEvent.body = bi;
        bj.dispatchEvent(World_step_collideEvent);
      }

      this.bodyOverlapKeeper.set(bi.id, bj.id);
      this.shapeOverlapKeeper.set(si.id, sj.id);
    }

    this.emitContactEvents();

    if (doProfiling) {
      profile.makeContactConstraints = performance.now() - profilingStart;
      profilingStart = performance.now();
    } // Wake up bodies


    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.wakeUpAfterNarrowphase) {
        bi.wakeUp();
        bi.wakeUpAfterNarrowphase = false;
      }
    } // Add user-added constraints


    Nconstraints = constraints.length;

    for (i = 0; i !== Nconstraints; i++) {
      const c = constraints[i];
      c.update();

      for (let j = 0, Neq = c.equations.length; j !== Neq; j++) {
        const eq = c.equations[j];
        solver.addEquation(eq);
      }
    } // Solve the constrained system


    solver.solve(dt, this);

    if (doProfiling) {
      profile.solve = performance.now() - profilingStart;
    } // Remove all contacts from solver


    solver.removeAllEquations(); // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details

    const pow = Math.pow;

    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.type & DYNAMIC) {
        // Only for dynamic bodies
        const ld = pow(1.0 - bi.linearDamping, dt);
        const v = bi.velocity;
        v.scale(ld, v);
        const av = bi.angularVelocity;

        if (av) {
          const ad = pow(1.0 - bi.angularDamping, dt);
          av.scale(ad, av);
        }
      }
    }

    this.dispatchEvent(World_step_preStepEvent); // Leap frog
    // vnew = v + h*f/m
    // xnew = x + h*vnew

    if (doProfiling) {
      profilingStart = performance.now();
    }

    const stepnumber = this.stepnumber;
    const quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
    const quatNormalizeFast = this.quatNormalizeFast;

    for (i = 0; i !== N; i++) {
      bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
    }

    this.clearForces();
    this.broadphase.dirty = true;

    if (doProfiling) {
      profile.integrate = performance.now() - profilingStart;
    } // Update step number


    this.stepnumber += 1;
    this.dispatchEvent(World_step_postStepEvent); // Sleeping update

    let hasActiveBodies = true;

    if (this.allowSleep) {
      hasActiveBodies = false;

      for (i = 0; i !== N; i++) {
        const bi = bodies[i];
        bi.sleepTick(this.time);

        if (bi.sleepState !== Body.SLEEPING) {
          hasActiveBodies = true;
        }
      }
    }

    this.hasActiveBodies = hasActiveBodies;
  }

  emitContactEvents() {
    const hasBeginContact = this.hasAnyEventListener('beginContact');
    const hasEndContact = this.hasAnyEventListener('endContact');

    if (hasBeginContact || hasEndContact) {
      this.bodyOverlapKeeper.getDiff(additions, removals);
    }

    if (hasBeginContact) {
      for (let i = 0, l = additions.length; i < l; i += 2) {
        beginContactEvent.bodyA = this.getBodyById(additions[i]);
        beginContactEvent.bodyB = this.getBodyById(additions[i + 1]);
        this.dispatchEvent(beginContactEvent);
      }

      beginContactEvent.bodyA = beginContactEvent.bodyB = null;
    }

    if (hasEndContact) {
      for (let i = 0, l = removals.length; i < l; i += 2) {
        endContactEvent.bodyA = this.getBodyById(removals[i]);
        endContactEvent.bodyB = this.getBodyById(removals[i + 1]);
        this.dispatchEvent(endContactEvent);
      }

      endContactEvent.bodyA = endContactEvent.bodyB = null;
    }

    additions.length = removals.length = 0;
    const hasBeginShapeContact = this.hasAnyEventListener('beginShapeContact');
    const hasEndShapeContact = this.hasAnyEventListener('endShapeContact');

    if (hasBeginShapeContact || hasEndShapeContact) {
      this.shapeOverlapKeeper.getDiff(additions, removals);
    }

    if (hasBeginShapeContact) {
      for (let i = 0, l = additions.length; i < l; i += 2) {
        const shapeA = this.getShapeById(additions[i]);
        const shapeB = this.getShapeById(additions[i + 1]);
        beginShapeContactEvent.shapeA = shapeA;
        beginShapeContactEvent.shapeB = shapeB;
        if (shapeA) beginShapeContactEvent.bodyA = shapeA.body;
        if (shapeB) beginShapeContactEvent.bodyB = shapeB.body;
        this.dispatchEvent(beginShapeContactEvent);
      }

      beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
    }

    if (hasEndShapeContact) {
      for (let i = 0, l = removals.length; i < l; i += 2) {
        const shapeA = this.getShapeById(removals[i]);
        const shapeB = this.getShapeById(removals[i + 1]);
        endShapeContactEvent.shapeA = shapeA;
        endShapeContactEvent.shapeB = shapeB;
        if (shapeA) endShapeContactEvent.bodyA = shapeA.body;
        if (shapeB) endShapeContactEvent.bodyB = shapeB.body;
        this.dispatchEvent(endShapeContactEvent);
      }

      endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
    }
  }
  /**
   * Sets all body forces in the world to zero.
   */


  clearForces() {
    const bodies = this.bodies;
    const N = bodies.length;

    for (let i = 0; i !== N; i++) {
      const b = bodies[i];
      b.force;
      b.torque;
      b.force.set(0, 0, 0);
      b.torque.set(0, 0, 0);
    }
  }

} // Temp stuff

new AABB();
const tmpRay = new Ray(); // performance.now() fallback on Date.now()

const performance = globalThis.performance || {};

if (!performance.now) {
  let nowOffset = Date.now();

  if (performance.timing && performance.timing.navigationStart) {
    nowOffset = performance.timing.navigationStart;
  }

  performance.now = () => Date.now() - nowOffset;
}

new Vec3(); // Dispatched after the world has stepped forward in time.
// Reusable event objects to save memory.

const World_step_postStepEvent = {
  type: 'postStep'
}; // Dispatched before the world steps forward in time.

const World_step_preStepEvent = {
  type: 'preStep'
};
const World_step_collideEvent = {
  type: Body.COLLIDE_EVENT_NAME,
  body: null,
  contact: null
}; // Pools for unused objects

const World_step_oldContacts = [];
const World_step_frictionEquationPool = []; // Reusable arrays for collision pairs

const World_step_p1 = [];
const World_step_p2 = []; // Stuff for emitContactEvents

const additions = [];
const removals = [];
const beginContactEvent = {
  type: 'beginContact',
  bodyA: null,
  bodyB: null
};
const endContactEvent = {
  type: 'endContact',
  bodyA: null,
  bodyB: null
};
const beginShapeContactEvent = {
  type: 'beginShapeContact',
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
};
const endShapeContactEvent = {
  type: 'endShapeContact',
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
};




/***/ }),

/***/ "./node_modules/core-js/internals/a-callable.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-callable.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-instance.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw $TypeError('Incorrect invocation');
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-non-extensible.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-non-extensible.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = fails(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
  }
});


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-iteration.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-slice-simple.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/array-slice-simple.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-unique-by.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-unique-by.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var MapHelpers = __webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

var Map = MapHelpers.Map;
var mapHas = MapHelpers.has;
var mapSet = MapHelpers.set;
var push = uncurryThis([].push);

// `Array.prototype.uniqueBy` method
// https://github.com/tc39/proposal-array-unique
module.exports = function uniqueBy(resolver) {
  var that = toObject(this);
  var length = lengthOfArrayLike(that);
  var result = [];
  var map = new Map();
  var resolverFunction = !isNullOrUndefined(resolver) ? aCallable(resolver) : function (value) {
    return value;
  };
  var index, item, key;
  for (index = 0; index < length; index++) {
    item = that[index];
    key = resolverFunction(item);
    if (!mapHas(map, key)) mapSet(map, key, item);
  }
  iterate(map, function (value) {
    push(result, value);
  });
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-strong.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/collection-strong.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fastKey = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").fastKey);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    defineBuiltIns(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineBuiltInAccessor(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return createIterResultObject(undefined, true);
      }
      // return step by kind
      if (kind == 'keys') return createIterResultObject(entry.key, false);
      if (kind == 'values') return createIterResultObject(entry.value, false);
      return createIterResultObject([entry.key, entry.value], false);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-weak.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/collection-weak.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var getWeakData = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").getWeakData);
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var ArrayIterationModule = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis([].splice);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) splice(this.entries, index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);
      else data[state.id] = value;
      return that;
    };

    defineBuiltIns(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && hasOwn(data, state.id) && delete data[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && hasOwn(data, state.id);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });

    return Constructor;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/collection.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
    defineBuiltIn(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced(
    CONSTRUCTOR_NAME,
    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, constructor: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js/internals/create-iter-result-object.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iter-result-object.js ***!
  \*********************************************************************/
/***/ ((module) => {

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in-accessor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in-accessor.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-ins.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-ins.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-global-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/define-global-property.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/document-all.js ***!
  \********************************************************/
/***/ ((module) => {

var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = {
  all: documentAll,
  IS_HTMLDDA: IS_HTMLDDA
};


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ ((module) => {

module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/freezing.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/freezing.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js/internals/function-uncurry-this-clause.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-native.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-native.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-call.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-call.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-name.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-name.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-accessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-accessor.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-clause.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-clause.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-method.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/get-method.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has-own-property.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/has-own-property.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-metadata.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/internal-metadata.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternalModule = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var isExtensible = __webpack_require__(/*! ../internals/object-is-extensible */ "./node_modules/core-js/internals/object-is-extensible.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");

var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + id++, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () { /* empty */ };
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      } return result;
    };

    $({ target: 'Object', stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = module.exports = {
  enable: enable,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-callable.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js/internals/document-all.js");

var documentAll = $documentAll.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-constructor.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/is-constructor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-null-or-undefined.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/is-null-or-undefined.js ***!
  \****************************************************************/
/***/ ((module) => {

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js/internals/document-all.js");

var documentAll = $documentAll.all;

module.exports = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-symbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterate-simple.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterate-simple.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");

module.exports = function (iterator, fn, $next) {
  var next = $next || iterator.next;
  var step, result;
  while (!(step = call(next, iterator)).done) {
    result = fn(step.value);
    if (result !== undefined) return result;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterate.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-close.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-close.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-create-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-create-constructor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype);
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-define.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-define.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var FunctionName = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js/internals/iterator-create-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/length-of-array-like.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/length-of-array-like.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/make-built-in.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/make-built-in.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").CONFIGURABLE);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ "./node_modules/core-js/internals/map-helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/map-helpers.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

// eslint-disable-next-line es/no-map -- safe
var MapPrototype = Map.prototype;

module.exports = {
  // eslint-disable-next-line es/no-map -- safe
  Map: Map,
  set: uncurryThis(MapPrototype.set),
  get: uncurryThis(MapPrototype.get),
  has: uncurryThis(MapPrototype.has),
  remove: uncurryThis(MapPrototype['delete']),
  proto: MapPrototype
};


/***/ }),

/***/ "./node_modules/core-js/internals/map-iterate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/map-iterate.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var iterateSimple = __webpack_require__(/*! ../internals/iterate-simple */ "./node_modules/core-js/internals/iterate-simple.js");
var MapHelpers = __webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js");

var Map = MapHelpers.Map;
var MapPrototype = MapHelpers.proto;
var forEach = uncurryThis(MapPrototype.forEach);
var entries = uncurryThis(MapPrototype.entries);
var next = entries(new Map()).next;

module.exports = function (map, fn, interruptible) {
  return interruptible ? iterateSimple(entries(map), function (entry) {
    return fn(entry[1], entry[0]);
  }, next) : forEach(map, fn);
};


/***/ }),

/***/ "./node_modules/core-js/internals/math-trunc.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-trunc.js ***!
  \******************************************************/
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var $getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f);
var arraySlice = __webpack_require__(/*! ../internals/array-slice-simple */ "./node_modules/core-js/internals/array-slice-simple.js");

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-extensible.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-extensible.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__(/*! ../internals/array-buffer-non-extensible */ "./node_modules/core-js/internals/array-buffer-non-extensible.js");

// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
module.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
  if (!isObject(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-prototype-of.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-prototype-of.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(/*! ../internals/function-uncurry-this-accessor */ "./node_modules/core-js/internals/function-uncurry-this-accessor.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/reflect-metadata.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/reflect-metadata.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(/*! ../modules/es.map */ "./node_modules/core-js/modules/es.map.js");
__webpack_require__(/*! ../modules/es.weak-map */ "./node_modules/core-js/modules/es.weak-map.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");

var Map = getBuiltIn('Map');
var WeakMap = getBuiltIn('WeakMap');
var push = uncurryThis([].push);

var metadata = shared('metadata');
var store = metadata.store || (metadata.store = new WeakMap());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};

var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};

var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};

var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};

var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { push(keys, key); });
  return keys;
};

var toMetadataKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};

module.exports = {
  store: store,
  getMap: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  toKey: toMetadataKey
};


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-species.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineBuiltInAccessor(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.29.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.29.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-constructor-detection.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-constructor-detection.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer-or-infinity.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer-or-infinity.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js/internals/math-trunc.js");

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-property-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "./node_modules/core-js/internals/try-to-string.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/try-to-string.js ***!
  \*********************************************************/
/***/ ((module) => {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js/internals/v8-prototype-define-bug.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/v8-prototype-define-bug.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ "./node_modules/core-js/internals/weak-map-basic-detection.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/weak-map-basic-detection.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.map.constructor.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.map.constructor.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");

// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "./node_modules/core-js/modules/es.map.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/es.map.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(/*! ../modules/es.map.constructor */ "./node_modules/core-js/modules/es.map.constructor.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-map.constructor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-map.constructor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");
var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js/internals/collection-weak.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var enforceInternalState = (__webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js").enforce);
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");

var $Object = Object;
// eslint-disable-next-line es/no-array-isarray -- safe
var isArray = Array.isArray;
// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible = $Object.isExtensible;
// eslint-disable-next-line es/no-object-isfrozen -- safe
var isFrozen = $Object.isFrozen;
// eslint-disable-next-line es/no-object-issealed -- safe
var isSealed = $Object.isSealed;
// eslint-disable-next-line es/no-object-freeze -- safe
var freeze = $Object.freeze;
// eslint-disable-next-line es/no-object-seal -- safe
var seal = $Object.seal;

var FROZEN = {};
var SEALED = {};
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var InternalWeakMap;

var wrapper = function (init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
};

// `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor
var $WeakMap = collection('WeakMap', wrapper, collectionWeak);
var WeakMapPrototype = $WeakMap.prototype;
var nativeSet = uncurryThis(WeakMapPrototype.set);

// Chakra Edge bug: adding frozen arrays to WeakMap unfreeze them
var hasMSEdgeFreezingBug = function () {
  return FREEZING && fails(function () {
    var frozenArray = freeze([]);
    nativeSet(new $WeakMap(), frozenArray, 1);
    return !isFrozen(frozenArray);
  });
};

// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP) if (IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.enable();
  var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
  var nativeHas = uncurryThis(WeakMapPrototype.has);
  var nativeGet = uncurryThis(WeakMapPrototype.get);
  defineBuiltIns(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen['delete'](key);
      } return nativeDelete(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      } return nativeHas(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      } return nativeGet(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else nativeSet(this, key, value);
      return this;
    }
  });
// Chakra Edge frozen keys fix
} else if (hasMSEdgeFreezingBug()) {
  defineBuiltIns(WeakMapPrototype, {
    set: function set(key, value) {
      var arrayIntegrityLevel;
      if (isArray(key)) {
        if (isFrozen(key)) arrayIntegrityLevel = FROZEN;
        else if (isSealed(key)) arrayIntegrityLevel = SEALED;
      }
      nativeSet(this, key, value);
      if (arrayIntegrityLevel == FROZEN) freeze(key);
      if (arrayIntegrityLevel == SEALED) seal(key);
      return this;
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-map.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-map.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(/*! ../modules/es.weak-map.constructor */ "./node_modules/core-js/modules/es.weak-map.constructor.js");


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.define-metadata.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.define-metadata.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;

// `Reflect.defineMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target /* , targetKey */) {
    var targetKey = arguments.length < 4 ? undefined : toMetadataKey(arguments[3]);
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.delete-metadata.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.delete-metadata.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toMetadataKey = ReflectMetadataModule.toKey;
var getOrCreateMetadataMap = ReflectMetadataModule.getMap;
var store = ReflectMetadataModule.store;

// `Reflect.deleteMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var $arrayUniqueBy = __webpack_require__(/*! ../internals/array-unique-by */ "./node_modules/core-js/internals/array-unique-by.js");

var arrayUniqueBy = uncurryThis($arrayUniqueBy);
var concat = uncurryThis([].concat);
var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
var toMetadataKey = ReflectMetadataModule.toKey;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? arrayUniqueBy(concat(oKeys, pKeys)) : pKeys : oKeys;
};

// `Reflect.getMetadataKeys` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
    var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
    return ordinaryMetadataKeys(anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.get-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.get-metadata.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");

var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
var toMetadataKey = ReflectMetadataModule.toKey;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

// `Reflect.getMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryGetMetadata(metadataKey, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
var toMetadataKey = ReflectMetadataModule.toKey;

// `Reflect.getOwnMetadataKeys` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
    var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
    return ordinaryOwnMetadataKeys(anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
var toMetadataKey = ReflectMetadataModule.toKey;

// `Reflect.getOwnMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.has-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.has-metadata.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");

var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var toMetadataKey = ReflectMetadataModule.toKey;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

// `Reflect.hasMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryHasMetadata(metadataKey, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var toMetadataKey = ReflectMetadataModule.toKey;

// `Reflect.hasOwnMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.metadata.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.metadata.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;

// `Reflect.metadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, key) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetadataKey(key));
    };
  }
});


/***/ }),

/***/ "./node_modules/core-js/proposals/reflect-metadata.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/proposals/reflect-metadata.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/rbuckton/reflect-metadata
__webpack_require__(/*! ../modules/esnext.reflect.define-metadata */ "./node_modules/core-js/modules/esnext.reflect.define-metadata.js");
__webpack_require__(/*! ../modules/esnext.reflect.delete-metadata */ "./node_modules/core-js/modules/esnext.reflect.delete-metadata.js");
__webpack_require__(/*! ../modules/esnext.reflect.get-metadata */ "./node_modules/core-js/modules/esnext.reflect.get-metadata.js");
__webpack_require__(/*! ../modules/esnext.reflect.get-metadata-keys */ "./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js");
__webpack_require__(/*! ../modules/esnext.reflect.get-own-metadata */ "./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js");
__webpack_require__(/*! ../modules/esnext.reflect.get-own-metadata-keys */ "./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js");
__webpack_require__(/*! ../modules/esnext.reflect.has-metadata */ "./node_modules/core-js/modules/esnext.reflect.has-metadata.js");
__webpack_require__(/*! ../modules/esnext.reflect.has-own-metadata */ "./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js");
__webpack_require__(/*! ../modules/esnext.reflect.metadata */ "./node_modules/core-js/modules/esnext.reflect.metadata.js");


/***/ }),

/***/ "./src/styles/discord.css":
/*!********************************!*\
  !*** ./src/styles/discord.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/styles/index.css":
/*!******************************!*\
  !*** ./src/styles/index.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/styles/pre-loader.css":
/*!***********************************!*\
  !*** ./src/styles/pre-loader.css ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/nipplejs/dist/nipplejs.js":
/*!************************************************!*\
  !*** ./node_modules/nipplejs/dist/nipplejs.js ***!
  \************************************************/
/***/ ((module) => {

!function(t,i){ true?module.exports=i():0}(window,function(){return function(t){var i={};function e(o){if(i[o])return i[o].exports;var n=i[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,e),n.l=!0,n.exports}return e.m=t,e.c=i,e.d=function(t,i,o){e.o(t,i)||Object.defineProperty(t,i,{enumerable:!0,get:o})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,i){if(1&i&&(t=e(t)),8&i)return t;if(4&i&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(e.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&i&&"string"!=typeof t)for(var n in t)e.d(o,n,function(i){return t[i]}.bind(null,n));return o},e.n=function(t){var i=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(i,"a",i),i},e.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},e.p="",e(e.s=0)}([function(t,i,e){"use strict";e.r(i);var o,n=function(t,i){var e=i.x-t.x,o=i.y-t.y;return Math.sqrt(e*e+o*o)},s=function(t){return t*(Math.PI/180)},r=function(t){return t*(180/Math.PI)},d=new Map,a=function(t){d.has(t)&&clearTimeout(d.get(t)),d.set(t,setTimeout(t,100))},p=function(t,i,e){for(var o,n=i.split(/[ ,]+/g),s=0;s<n.length;s+=1)o=n[s],t.addEventListener?t.addEventListener(o,e,!1):t.attachEvent&&t.attachEvent(o,e)},c=function(t,i,e){for(var o,n=i.split(/[ ,]+/g),s=0;s<n.length;s+=1)o=n[s],t.removeEventListener?t.removeEventListener(o,e):t.detachEvent&&t.detachEvent(o,e)},l=function(t){return t.preventDefault(),t.type.match(/^touch/)?t.changedTouches:t},h=function(){return{x:void 0!==window.pageXOffset?window.pageXOffset:(document.documentElement||document.body.parentNode||document.body).scrollLeft,y:void 0!==window.pageYOffset?window.pageYOffset:(document.documentElement||document.body.parentNode||document.body).scrollTop}},u=function(t,i){i.top||i.right||i.bottom||i.left?(t.style.top=i.top,t.style.right=i.right,t.style.bottom=i.bottom,t.style.left=i.left):(t.style.left=i.x+"px",t.style.top=i.y+"px")},f=function(t,i,e){var o=y(t);for(var n in o)if(o.hasOwnProperty(n))if("string"==typeof i)o[n]=i+" "+e;else{for(var s="",r=0,d=i.length;r<d;r+=1)s+=i[r]+" "+e+", ";o[n]=s.slice(0,-2)}return o},y=function(t){var i={};i[t]="";return["webkit","Moz","o"].forEach(function(e){i[e+t.charAt(0).toUpperCase()+t.slice(1)]=""}),i},m=function(t,i){for(var e in i)i.hasOwnProperty(e)&&(t[e]=i[e]);return t},v=function(t,i){if(t.length)for(var e=0,o=t.length;e<o;e+=1)i(t[e]);else i(t)},g=!!("ontouchstart"in window),b=!!window.PointerEvent,x=!!window.MSPointerEvent,O={start:"mousedown",move:"mousemove",end:"mouseup"},w={};function _(){}b?o={start:"pointerdown",move:"pointermove",end:"pointerup, pointercancel"}:x?o={start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}:g?(o={start:"touchstart",move:"touchmove",end:"touchend, touchcancel"},w=O):o=O,_.prototype.on=function(t,i){var e,o=t.split(/[ ,]+/g);this._handlers_=this._handlers_||{};for(var n=0;n<o.length;n+=1)e=o[n],this._handlers_[e]=this._handlers_[e]||[],this._handlers_[e].push(i);return this},_.prototype.off=function(t,i){return this._handlers_=this._handlers_||{},void 0===t?this._handlers_={}:void 0===i?this._handlers_[t]=null:this._handlers_[t]&&this._handlers_[t].indexOf(i)>=0&&this._handlers_[t].splice(this._handlers_[t].indexOf(i),1),this},_.prototype.trigger=function(t,i){var e,o=this,n=t.split(/[ ,]+/g);o._handlers_=o._handlers_||{};for(var s=0;s<n.length;s+=1)e=n[s],o._handlers_[e]&&o._handlers_[e].length&&o._handlers_[e].forEach(function(t){t.call(o,{type:e,target:o},i)})},_.prototype.config=function(t){this.options=this.defaults||{},t&&(this.options=function(t,i){var e={};for(var o in t)t.hasOwnProperty(o)&&i.hasOwnProperty(o)?e[o]=i[o]:t.hasOwnProperty(o)&&(e[o]=t[o]);return e}(this.options,t))},_.prototype.bindEvt=function(t,i){var e=this;return e._domHandlers_=e._domHandlers_||{},e._domHandlers_[i]=function(){"function"==typeof e["on"+i]?e["on"+i].apply(e,arguments):console.warn('[WARNING] : Missing "on'+i+'" handler.')},p(t,o[i],e._domHandlers_[i]),w[i]&&p(t,w[i],e._domHandlers_[i]),e},_.prototype.unbindEvt=function(t,i){return this._domHandlers_=this._domHandlers_||{},c(t,o[i],this._domHandlers_[i]),w[i]&&c(t,w[i],this._domHandlers_[i]),delete this._domHandlers_[i],this};var T=_;function k(t,i){return this.identifier=i.identifier,this.position=i.position,this.frontPosition=i.frontPosition,this.collection=t,this.defaults={size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:.5,mode:"dynamic",zone:document.body,lockX:!1,lockY:!1,shape:"circle"},this.config(i),"dynamic"===this.options.mode&&(this.options.restOpacity=0),this.id=k.id,k.id+=1,this.buildEl().stylize(),this.instance={el:this.ui.el,on:this.on.bind(this),off:this.off.bind(this),show:this.show.bind(this),hide:this.hide.bind(this),add:this.addToDom.bind(this),remove:this.removeFromDom.bind(this),destroy:this.destroy.bind(this),setPosition:this.setPosition.bind(this),resetDirection:this.resetDirection.bind(this),computeDirection:this.computeDirection.bind(this),trigger:this.trigger.bind(this),position:this.position,frontPosition:this.frontPosition,ui:this.ui,identifier:this.identifier,id:this.id,options:this.options},this.instance}k.prototype=new T,k.constructor=k,k.id=0,k.prototype.buildEl=function(t){return this.ui={},this.options.dataOnly?this:(this.ui.el=document.createElement("div"),this.ui.back=document.createElement("div"),this.ui.front=document.createElement("div"),this.ui.el.className="nipple collection_"+this.collection.id,this.ui.back.className="back",this.ui.front.className="front",this.ui.el.setAttribute("id","nipple_"+this.collection.id+"_"+this.id),this.ui.el.appendChild(this.ui.back),this.ui.el.appendChild(this.ui.front),this)},k.prototype.stylize=function(){if(this.options.dataOnly)return this;var t=this.options.fadeTime+"ms",i=function(t,i){var e=y(t);for(var o in e)e.hasOwnProperty(o)&&(e[o]=i);return e}("borderRadius","50%"),e=f("transition","opacity",t),o={};return o.el={position:"absolute",opacity:this.options.restOpacity,display:"block",zIndex:999},o.back={position:"absolute",display:"block",width:this.options.size+"px",height:this.options.size+"px",marginLeft:-this.options.size/2+"px",marginTop:-this.options.size/2+"px",background:this.options.color,opacity:".5"},o.front={width:this.options.size/2+"px",height:this.options.size/2+"px",position:"absolute",display:"block",marginLeft:-this.options.size/4+"px",marginTop:-this.options.size/4+"px",background:this.options.color,opacity:".5",transform:"translate(0px, 0px)"},m(o.el,e),"circle"===this.options.shape&&m(o.back,i),m(o.front,i),this.applyStyles(o),this},k.prototype.applyStyles=function(t){for(var i in this.ui)if(this.ui.hasOwnProperty(i))for(var e in t[i])this.ui[i].style[e]=t[i][e];return this},k.prototype.addToDom=function(){return this.options.dataOnly||document.body.contains(this.ui.el)?this:(this.options.zone.appendChild(this.ui.el),this)},k.prototype.removeFromDom=function(){return this.options.dataOnly||!document.body.contains(this.ui.el)?this:(this.options.zone.removeChild(this.ui.el),this)},k.prototype.destroy=function(){clearTimeout(this.removeTimeout),clearTimeout(this.showTimeout),clearTimeout(this.restTimeout),this.trigger("destroyed",this.instance),this.removeFromDom(),this.off()},k.prototype.show=function(t){var i=this;return i.options.dataOnly?i:(clearTimeout(i.removeTimeout),clearTimeout(i.showTimeout),clearTimeout(i.restTimeout),i.addToDom(),i.restCallback(),setTimeout(function(){i.ui.el.style.opacity=1},0),i.showTimeout=setTimeout(function(){i.trigger("shown",i.instance),"function"==typeof t&&t.call(this)},i.options.fadeTime),i)},k.prototype.hide=function(t){var i=this;if(i.options.dataOnly)return i;if(i.ui.el.style.opacity=i.options.restOpacity,clearTimeout(i.removeTimeout),clearTimeout(i.showTimeout),clearTimeout(i.restTimeout),i.removeTimeout=setTimeout(function(){var e="dynamic"===i.options.mode?"none":"block";i.ui.el.style.display=e,"function"==typeof t&&t.call(i),i.trigger("hidden",i.instance)},i.options.fadeTime),i.options.restJoystick){var e=i.options.restJoystick,o={};o.x=!0===e||!1!==e.x?0:i.instance.frontPosition.x,o.y=!0===e||!1!==e.y?0:i.instance.frontPosition.y,i.setPosition(t,o)}return i},k.prototype.setPosition=function(t,i){var e=this;e.frontPosition={x:i.x,y:i.y};var o=e.options.fadeTime+"ms",n={};n.front=f("transition",["transform"],o);var s={front:{}};s.front={transform:"translate("+e.frontPosition.x+"px,"+e.frontPosition.y+"px)"},e.applyStyles(n),e.applyStyles(s),e.restTimeout=setTimeout(function(){"function"==typeof t&&t.call(e),e.restCallback()},e.options.fadeTime)},k.prototype.restCallback=function(){var t={};t.front=f("transition","none",""),this.applyStyles(t),this.trigger("rested",this.instance)},k.prototype.resetDirection=function(){this.direction={x:!1,y:!1,angle:!1}},k.prototype.computeDirection=function(t){var i,e,o,n=t.angle.radian,s=Math.PI/4,r=Math.PI/2;if(n>s&&n<3*s&&!t.lockX?i="up":n>-s&&n<=s&&!t.lockY?i="left":n>3*-s&&n<=-s&&!t.lockX?i="down":t.lockY||(i="right"),t.lockY||(e=n>-r&&n<r?"left":"right"),t.lockX||(o=n>0?"up":"down"),t.force>this.options.threshold){var d,a={};for(d in this.direction)this.direction.hasOwnProperty(d)&&(a[d]=this.direction[d]);var p={};for(d in this.direction={x:e,y:o,angle:i},t.direction=this.direction,a)a[d]===this.direction[d]&&(p[d]=!0);if(p.x&&p.y&&p.angle)return t;p.x&&p.y||this.trigger("plain",t),p.x||this.trigger("plain:"+e,t),p.y||this.trigger("plain:"+o,t),p.angle||this.trigger("dir dir:"+i,t)}else this.resetDirection();return t};var P=k;function E(t,i){this.nipples=[],this.idles=[],this.actives=[],this.ids=[],this.pressureIntervals={},this.manager=t,this.id=E.id,E.id+=1,this.defaults={zone:document.body,multitouch:!1,maxNumberOfNipples:10,mode:"dynamic",position:{top:0,left:0},catchDistance:200,size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:.5,lockX:!1,lockY:!1,shape:"circle",dynamicPage:!1,follow:!1},this.config(i),"static"!==this.options.mode&&"semi"!==this.options.mode||(this.options.multitouch=!1),this.options.multitouch||(this.options.maxNumberOfNipples=1);var e=getComputedStyle(this.options.zone.parentElement);return e&&"flex"===e.display&&(this.parentIsFlex=!0),this.updateBox(),this.prepareNipples(),this.bindings(),this.begin(),this.nipples}E.prototype=new T,E.constructor=E,E.id=0,E.prototype.prepareNipples=function(){var t=this.nipples;t.on=this.on.bind(this),t.off=this.off.bind(this),t.options=this.options,t.destroy=this.destroy.bind(this),t.ids=this.ids,t.id=this.id,t.processOnMove=this.processOnMove.bind(this),t.processOnEnd=this.processOnEnd.bind(this),t.get=function(i){if(void 0===i)return t[0];for(var e=0,o=t.length;e<o;e+=1)if(t[e].identifier===i)return t[e];return!1}},E.prototype.bindings=function(){this.bindEvt(this.options.zone,"start"),this.options.zone.style.touchAction="none",this.options.zone.style.msTouchAction="none"},E.prototype.begin=function(){var t=this.options;if("static"===t.mode){var i=this.createNipple(t.position,this.manager.getIdentifier());i.add(),this.idles.push(i)}},E.prototype.createNipple=function(t,i){var e=this.manager.scroll,o={},n=this.options,s=this.parentIsFlex?e.x:e.x+this.box.left,r=this.parentIsFlex?e.y:e.y+this.box.top;if(t.x&&t.y)o={x:t.x-s,y:t.y-r};else if(t.top||t.right||t.bottom||t.left){var d=document.createElement("DIV");d.style.display="hidden",d.style.top=t.top,d.style.right=t.right,d.style.bottom=t.bottom,d.style.left=t.left,d.style.position="absolute",n.zone.appendChild(d);var a=d.getBoundingClientRect();n.zone.removeChild(d),o=t,t={x:a.left+e.x,y:a.top+e.y}}var p=new P(this,{color:n.color,size:n.size,threshold:n.threshold,fadeTime:n.fadeTime,dataOnly:n.dataOnly,restJoystick:n.restJoystick,restOpacity:n.restOpacity,mode:n.mode,identifier:i,position:t,zone:n.zone,frontPosition:{x:0,y:0},shape:n.shape});return n.dataOnly||(u(p.ui.el,o),u(p.ui.front,p.frontPosition)),this.nipples.push(p),this.trigger("added "+p.identifier+":added",p),this.manager.trigger("added "+p.identifier+":added",p),this.bindNipple(p),p},E.prototype.updateBox=function(){this.box=this.options.zone.getBoundingClientRect()},E.prototype.bindNipple=function(t){var i,e=this,o=function(t,o){i=t.type+" "+o.id+":"+t.type,e.trigger(i,o)};t.on("destroyed",e.onDestroyed.bind(e)),t.on("shown hidden rested dir plain",o),t.on("dir:up dir:right dir:down dir:left",o),t.on("plain:up plain:right plain:down plain:left",o)},E.prototype.pressureFn=function(t,i,e){var o=this,n=0;clearInterval(o.pressureIntervals[e]),o.pressureIntervals[e]=setInterval(function(){var e=t.force||t.pressure||t.webkitForce||0;e!==n&&(i.trigger("pressure",e),o.trigger("pressure "+i.identifier+":pressure",e),n=e)}.bind(o),100)},E.prototype.onstart=function(t){var i=this,e=i.options,o=t;t=l(t),i.updateBox();return v(t,function(n){i.actives.length<e.maxNumberOfNipples?i.processOnStart(n):o.type.match(/^touch/)&&(Object.keys(i.manager.ids).forEach(function(e){if(Object.values(o.touches).findIndex(function(t){return t.identifier===e})<0){var n=[t[0]];n.identifier=e,i.processOnEnd(n)}}),i.actives.length<e.maxNumberOfNipples&&i.processOnStart(n))}),i.manager.bindDocument(),!1},E.prototype.processOnStart=function(t){var i,e=this,o=e.options,s=e.manager.getIdentifier(t),r=t.force||t.pressure||t.webkitForce||0,d={x:t.pageX,y:t.pageY},a=e.getOrCreate(s,d);a.identifier!==s&&e.manager.removeIdentifier(a.identifier),a.identifier=s;var p=function(i){i.trigger("start",i),e.trigger("start "+i.id+":start",i),i.show(),r>0&&e.pressureFn(t,i,i.identifier),e.processOnMove(t)};if((i=e.idles.indexOf(a))>=0&&e.idles.splice(i,1),e.actives.push(a),e.ids.push(a.identifier),"semi"!==o.mode)p(a);else{if(!(n(d,a.position)<=o.catchDistance))return a.destroy(),void e.processOnStart(t);p(a)}return a},E.prototype.getOrCreate=function(t,i){var e,o=this.options;return/(semi|static)/.test(o.mode)?(e=this.idles[0])?(this.idles.splice(0,1),e):"semi"===o.mode?this.createNipple(i,t):(console.warn("Coudln't find the needed nipple."),!1):e=this.createNipple(i,t)},E.prototype.processOnMove=function(t){var i=this.options,e=this.manager.getIdentifier(t),o=this.nipples.get(e),d=this.manager.scroll;if(function(t){return isNaN(t.buttons)?0!==t.pressure:0!==t.buttons}(t)){if(!o)return console.error("Found zombie joystick with ID "+e),void this.manager.removeIdentifier(e);if(i.dynamicPage){var a=o.el.getBoundingClientRect();o.position={x:d.x+a.left,y:d.y+a.top}}o.identifier=e;var p=o.options.size/2,c={x:t.pageX,y:t.pageY};i.lockX&&(c.y=o.position.y),i.lockY&&(c.x=o.position.x);var l,h,u,f,y,m,v,g,b,x,O=n(c,o.position),w=(l=c,h=o.position,u=h.x-l.x,f=h.y-l.y,r(Math.atan2(f,u))),_=s(w),T=O/p,k={distance:O,position:c};if("circle"===o.options.shape?(y=Math.min(O,p),v=o.position,g=y,x={x:0,y:0},b=s(b=w),x.x=v.x-g*Math.cos(b),x.y=v.y-g*Math.sin(b),m=x):(m=function(t,i,e){return{x:Math.min(Math.max(t.x,i.x-e),i.x+e),y:Math.min(Math.max(t.y,i.y-e),i.y+e)}}(c,o.position,p),y=n(m,o.position)),i.follow){if(O>p){var P=c.x-m.x,E=c.y-m.y;o.position.x+=P,o.position.y+=E,o.el.style.top=o.position.y-(this.box.top+d.y)+"px",o.el.style.left=o.position.x-(this.box.left+d.x)+"px",O=n(c,o.position)}}else c=m,O=y;var I=c.x-o.position.x,z=c.y-o.position.y;o.frontPosition={x:I,y:z},i.dataOnly||(o.ui.front.style.transform="translate("+I+"px,"+z+"px)");var D={identifier:o.identifier,position:c,force:T,pressure:t.force||t.pressure||t.webkitForce||0,distance:O,angle:{radian:_,degree:w},vector:{x:I/p,y:-z/p},raw:k,instance:o,lockX:i.lockX,lockY:i.lockY};(D=o.computeDirection(D)).angle={radian:s(180-w),degree:180-w},o.trigger("move",D),this.trigger("move "+o.id+":move",D)}else this.processOnEnd(t)},E.prototype.processOnEnd=function(t){var i=this,e=i.options,o=i.manager.getIdentifier(t),n=i.nipples.get(o),s=i.manager.removeIdentifier(n.identifier);n&&(e.dataOnly||n.hide(function(){"dynamic"===e.mode&&(n.trigger("removed",n),i.trigger("removed "+n.id+":removed",n),i.manager.trigger("removed "+n.id+":removed",n),n.destroy())}),clearInterval(i.pressureIntervals[n.identifier]),n.resetDirection(),n.trigger("end",n),i.trigger("end "+n.id+":end",n),i.ids.indexOf(n.identifier)>=0&&i.ids.splice(i.ids.indexOf(n.identifier),1),i.actives.indexOf(n)>=0&&i.actives.splice(i.actives.indexOf(n),1),/(semi|static)/.test(e.mode)?i.idles.push(n):i.nipples.indexOf(n)>=0&&i.nipples.splice(i.nipples.indexOf(n),1),i.manager.unbindDocument(),/(semi|static)/.test(e.mode)&&(i.manager.ids[s.id]=s.identifier))},E.prototype.onDestroyed=function(t,i){this.nipples.indexOf(i)>=0&&this.nipples.splice(this.nipples.indexOf(i),1),this.actives.indexOf(i)>=0&&this.actives.splice(this.actives.indexOf(i),1),this.idles.indexOf(i)>=0&&this.idles.splice(this.idles.indexOf(i),1),this.ids.indexOf(i.identifier)>=0&&this.ids.splice(this.ids.indexOf(i.identifier),1),this.manager.removeIdentifier(i.identifier),this.manager.unbindDocument()},E.prototype.destroy=function(){for(var t in this.unbindEvt(this.options.zone,"start"),this.nipples.forEach(function(t){t.destroy()}),this.pressureIntervals)this.pressureIntervals.hasOwnProperty(t)&&clearInterval(this.pressureIntervals[t]);this.trigger("destroyed",this.nipples),this.manager.unbindDocument(),this.off()};var I=E;function z(t){var i=this;i.ids={},i.index=0,i.collections=[],i.scroll=h(),i.config(t),i.prepareCollections();var e=function(){var t;i.collections.forEach(function(e){e.forEach(function(e){t=e.el.getBoundingClientRect(),e.position={x:i.scroll.x+t.left,y:i.scroll.y+t.top}})})};p(window,"resize",function(){a(e)});var o=function(){i.scroll=h()};return p(window,"scroll",function(){a(o)}),i.collections}z.prototype=new T,z.constructor=z,z.prototype.prepareCollections=function(){var t=this;t.collections.create=t.create.bind(t),t.collections.on=t.on.bind(t),t.collections.off=t.off.bind(t),t.collections.destroy=t.destroy.bind(t),t.collections.get=function(i){var e;return t.collections.every(function(t){return!(e=t.get(i))}),e}},z.prototype.create=function(t){return this.createCollection(t)},z.prototype.createCollection=function(t){var i=new I(this,t);return this.bindCollection(i),this.collections.push(i),i},z.prototype.bindCollection=function(t){var i,e=this,o=function(t,o){i=t.type+" "+o.id+":"+t.type,e.trigger(i,o)};t.on("destroyed",e.onDestroyed.bind(e)),t.on("shown hidden rested dir plain",o),t.on("dir:up dir:right dir:down dir:left",o),t.on("plain:up plain:right plain:down plain:left",o)},z.prototype.bindDocument=function(){this.binded||(this.bindEvt(document,"move").bindEvt(document,"end"),this.binded=!0)},z.prototype.unbindDocument=function(t){Object.keys(this.ids).length&&!0!==t||(this.unbindEvt(document,"move").unbindEvt(document,"end"),this.binded=!1)},z.prototype.getIdentifier=function(t){var i;return t?void 0===(i=void 0===t.identifier?t.pointerId:t.identifier)&&(i=this.latest||0):i=this.index,void 0===this.ids[i]&&(this.ids[i]=this.index,this.index+=1),this.latest=i,this.ids[i]},z.prototype.removeIdentifier=function(t){var i={};for(var e in this.ids)if(this.ids[e]===t){i.id=e,i.identifier=this.ids[e],delete this.ids[e];break}return i},z.prototype.onmove=function(t){return this.onAny("move",t),!1},z.prototype.onend=function(t){return this.onAny("end",t),!1},z.prototype.oncancel=function(t){return this.onAny("end",t),!1},z.prototype.onAny=function(t,i){var e,o=this,n="processOn"+t.charAt(0).toUpperCase()+t.slice(1);i=l(i);return v(i,function(t){e=o.getIdentifier(t),v(o.collections,function(t,i,e){e.ids.indexOf(i)>=0&&(e[n](t),t._found_=!0)}.bind(null,t,e)),t._found_||o.removeIdentifier(e)}),!1},z.prototype.destroy=function(){this.unbindDocument(!0),this.ids={},this.index=0,this.collections.forEach(function(t){t.destroy()}),this.off()},z.prototype.onDestroyed=function(t,i){if(this.collections.indexOf(i)<0)return!1;this.collections.splice(this.collections.indexOf(i),1)};var D=new z;i.default={create:function(t){return D.create(t)},factory:D}}]).default});

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) });

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
  defineProperty(
    GeneratorFunctionPrototype,
    "constructor",
    { value: GeneratorFunction, configurable: true }
  );
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    defineProperty(this, "_invoke", { value: enqueue });
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method;
    var method = delegate.iterator[methodName];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method, or a missing .next mehtod, always terminate the
      // yield* loop.
      context.delegate = null;

      // Note: ["return"] must be used for ES3 parsing compatibility.
      if (methodName === "throw" && delegate.iterator["return"]) {
        // If the delegate iterator has a return method, give it a
        // chance to clean up.
        context.method = "return";
        context.arg = undefined;
        maybeInvokeDelegate(delegate, context);

        if (context.method === "throw") {
          // If maybeInvokeDelegate(context) changed context.method from
          // "return" to "throw", let that override the TypeError below.
          return ContinueSentinel;
        }
      }
      if (methodName !== "return") {
        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a '" + methodName + "' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(val) {
    var object = Object(val);
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  randomUUID
});

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "unsafeStringify": () => (/* binding */ unsafeStringify)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/esm-browser/native.js");
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");




function v4(options, buf, offset) {
  if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
    return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./src/assets/background/blue_skybox.png":
/*!***********************************************!*\
  !*** ./src/assets/background/blue_skybox.png ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "fd496265ecb3907db6e3.png";

/***/ }),

/***/ "./src/assets/models/animations/diamond_rush/Jump.gltf":
/*!*************************************************************!*\
  !*** ./src/assets/models/animations/diamond_rush/Jump.gltf ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "bfe03328b8cf3cad445b.gltf";

/***/ }),

/***/ "./src/assets/models/animations/diamond_rush/Running4.gltf":
/*!*****************************************************************!*\
  !*** ./src/assets/models/animations/diamond_rush/Running4.gltf ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "7b2a3298c7fd9c05a788.gltf";

/***/ }),

/***/ "./src/assets/models/animations/diamond_rush/Walking.gltf":
/*!****************************************************************!*\
  !*** ./src/assets/models/animations/diamond_rush/Walking.gltf ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "6315e597042ede64a144.gltf";

/***/ }),

/***/ "./src/assets/models/animations/diamond_rush/attack.gltf":
/*!***************************************************************!*\
  !*** ./src/assets/models/animations/diamond_rush/attack.gltf ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "756ff2222111e578d4dd.gltf";

/***/ }),

/***/ "./src/assets/models/animations/diamond_rush/idle.gltf":
/*!*************************************************************!*\
  !*** ./src/assets/models/animations/diamond_rush/idle.gltf ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "abd5a09c0d82d6535267.gltf";

/***/ }),

/***/ "./src/assets/models/base/cube.gltf":
/*!******************************************!*\
  !*** ./src/assets/models/base/cube.gltf ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "6a8f5f3222df06270f1b.gltf";

/***/ }),

/***/ "./src/assets/models/diamond_rush/Career.gltf":
/*!****************************************************!*\
  !*** ./src/assets/models/diamond_rush/Career.gltf ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "e8202af301f28cd39559.gltf";

/***/ }),

/***/ "./src/assets/models/diamond_rush/Kirka.gltf":
/*!***************************************************!*\
  !*** ./src/assets/models/diamond_rush/Kirka.gltf ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "21ef2d59ab4f46ec904c.gltf";

/***/ }),

/***/ "./src/assets/models/diamond_rush/TronMalen.gltf":
/*!*******************************************************!*\
  !*** ./src/assets/models/diamond_rush/TronMalen.gltf ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "1c50d999574fbd833bef.gltf";

/***/ }),

/***/ "./src/assets/models/diamond_rush/blocks.gltf":
/*!****************************************************!*\
  !*** ./src/assets/models/diamond_rush/blocks.gltf ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "26c59b3efcc567596377.gltf";

/***/ }),

/***/ "./src/assets/textures/base/error.png":
/*!********************************************!*\
  !*** ./src/assets/textures/base/error.png ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "c62f96e4ef7ebcbc3782.png";

/***/ }),

/***/ "./src/assets/textures/cloud.png":
/*!***************************************!*\
  !*** ./src/assets/textures/cloud.png ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "8a9ef15290563f508489.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/character_texture/emmisive.png":
/*!*************************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/character_texture/emmisive.png ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "061c5344d4fbf9d2be30.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/character_texture/normal_map.png":
/*!***************************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/character_texture/normal_map.png ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "81231f3fee39326cafdc.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/character_texture/roughnes_map.png":
/*!*****************************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/character_texture/roughnes_map.png ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "633e8b0caf4bfe27949a.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/grass/blade_alpha.jpg":
/*!****************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/grass/blade_alpha.jpg ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "fd72bbc9635d5a296576.jpg";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/grass/blade_diffuse.jpg":
/*!******************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/grass/blade_diffuse.jpg ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "afc6a995c517c5c0bb32.jpg";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/grass/perlinFbm.jpg":
/*!**************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/grass/perlinFbm.jpg ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "30d712d47c87b08e7536.jpg";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/popup/bitcoin.png":
/*!************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/popup/bitcoin.png ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "c45c16b6d2dbcfb1d4ad.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/popup/crystal.png":
/*!************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/popup/crystal.png ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "99ab9e4a1984f0e2114a.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/popup/gold.png":
/*!*********************************************************!*\
  !*** ./src/assets/textures/diamond_rush/popup/gold.png ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "2b061820c109f9c787df.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/popup/ore.png":
/*!********************************************************!*\
  !*** ./src/assets/textures/diamond_rush/popup/ore.png ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "bdca55d16c880ebc3938.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/popup/purple.png":
/*!***********************************************************!*\
  !*** ./src/assets/textures/diamond_rush/popup/purple.png ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "cfbcb2f42a7282806395.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/popup/sand.png":
/*!*********************************************************!*\
  !*** ./src/assets/textures/diamond_rush/popup/sand.png ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "0f13999c2066784462a7.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/popup/white.png":
/*!**********************************************************!*\
  !*** ./src/assets/textures/diamond_rush/popup/white.png ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "2f7bb8082fed8c4043c3.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/terrain/grass_terrain.png":
/*!********************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/terrain/grass_terrain.png ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "64b6d9ec17b861b8d93e.png";

/***/ }),

/***/ "./src/assets/textures/diamond_rush/terrain/ground_01.png":
/*!****************************************************************!*\
  !*** ./src/assets/textures/diamond_rush/terrain/ground_01.png ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "f2c49fd517d4f5b42623.png";

/***/ }),

/***/ "./src/assets/textures/pointer.png":
/*!*****************************************!*\
  !*** ./src/assets/textures/pointer.png ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "52c1a9dc64882f4109e7.png";

/***/ }),

/***/ "./src/assets/textures/white.png":
/*!***************************************!*\
  !*** ./src/assets/textures/white.png ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "80b12e56ea92f59ec28d.png";

/***/ }),

/***/ "./src/game/fx/shaders/grass/fragment.glsl":
/*!*************************************************!*\
  !*** ./src/game/fx/shaders/grass/fragment.glsl ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = "precision mediump float;\r\n\r\nuniform vec3 cameraPosition;\r\n\r\n//Light uniforms\r\nuniform float ambientStrength;\r\nuniform float diffuseStrength;\r\nuniform float specularStrength;\r\nuniform float translucencyStrength;\r\nuniform float shininess;\r\nuniform vec3 lightColour;\r\nuniform vec3 sunDirection;\r\n\r\n\r\n//Surface uniforms\r\nuniform sampler2D map;\r\nuniform sampler2D alphaMap;\r\nuniform vec3 specularColour;\r\n\r\nvarying float frc;\r\nvarying float idx;\r\nvarying vec2 vUv;\r\nvarying vec3 vNormal;\r\nvarying vec3 vPosition;\r\n\r\nvec3 ACESFilm(vec3 x){\r\n    float a = 2.51;\r\n    float b = 0.03;\r\n    float c = 2.43;\r\n    float d = 0.59;\r\n    float e = 0.14;\r\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n\r\n    //If transparent, don't draw\r\n    if (texture2D(alphaMap, vUv).r < 0.15){\r\n        discard;\r\n    }\r\n\r\n    vec3 normal;\r\n\r\n    //Flip normals when viewing reverse of the blade\r\n    if (gl_FrontFacing){\r\n        normal = normalize(vNormal);\r\n    } else {\r\n        normal = normalize(-vNormal);\r\n    }\r\n\r\n    //Get colour data from texture\r\n    vec3 textureColour = pow(texture2D(map, vUv).rgb, vec3(2.2));\r\n\r\n    //Add different green tones towards root\r\n    vec3 mixColour = idx > 0.75 ? vec3(0.2, 0.8, 0.06) : vec3(0.5, 0.8, 0.08);\r\n    textureColour = mix(0.1 * mixColour, textureColour, 0.75);\r\n\r\n    vec3 lightTimesTexture = lightColour * textureColour;\r\n    vec3 ambient = textureColour;\r\n    vec3 lightDir = normalize(sunDirection);\r\n\r\n    //How much a fragment faces the light\r\n    float dotNormalLight = dot(normal, lightDir);\r\n    float diff = max(dotNormalLight, 0.0);\r\n\r\n    //Colour when lit by light\r\n    vec3 diffuse = diff * lightTimesTexture;\r\n\r\n    float sky = max(dot(normal, vec3(0, 1, 0)), 0.0);\r\n    vec3 skyLight = sky * vec3(0.12, 0.29, 0.55);\r\n\r\n    vec3 viewDirection = normalize(cameraPosition - vPosition);\r\n    vec3 halfwayDir = normalize(lightDir + viewDirection);\r\n    //How much a fragment directly reflects the light to the camera\r\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\r\n\r\n    //Colour of light sharply reflected into the camera\r\n    vec3 specular = spec * specularColour * lightColour;\r\n\r\n    //https://en.wikibooks.org/wiki/GLSL_Programming/Unity/Translucent_Surfaces\r\n    vec3 diffuseTranslucency = vec3(0);\r\n    vec3 forwardTranslucency = vec3(0);\r\n    float dotViewLight = dot(-lightDir, viewDirection);\r\n    if (dotNormalLight <= 0.0){\r\n        diffuseTranslucency = lightTimesTexture * translucencyStrength * -dotNormalLight;\r\n        if (dotViewLight > 0.0){\r\n            forwardTranslucency = lightTimesTexture * translucencyStrength * pow(dotViewLight, 16.0);\r\n        }\r\n    }\r\n\r\n    vec3 col = 0.3 * skyLight * textureColour + ambientStrength * ambient + diffuseStrength * diffuse + specularStrength * specular + diffuseTranslucency + forwardTranslucency;\r\n\r\n    //Add a shadow towards root\r\n    col = mix(0.35*vec3(0.1, 0.25, 0.02), col, frc);\r\n\r\n    //Tonemapping\r\n    col = ACESFilm(col);\r\n\r\n    //Gamma correction 1.0/2.2 = 0.4545...\r\n    col = pow(col, vec3(0.4545));\r\n\r\n    gl_FragColor = vec4(col, 1.0);\r\n}";

/***/ }),

/***/ "./src/game/fx/shaders/grass/shaderPrefix.glsl":
/*!*****************************************************!*\
  !*** ./src/game/fx/shaders/grass/shaderPrefix.glsl ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
module.exports = "precision mediump float;\r\n\r\nuniform sampler2D noiseTexture;\r\nfloat getYPosition(vec2 p) {\r\n    return 8.0*(2.0*texture2D(noiseTexture, p/800.0).r - 1.0);\r\n}\r\n";

/***/ }),

/***/ "./src/game/fx/shaders/grass/vertex.glsl":
/*!***********************************************!*\
  !*** ./src/game/fx/shaders/grass/vertex.glsl ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
module.exports = "attribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec3 offset;\r\nattribute vec2 uv;\r\nattribute vec2 halfRootAngle;\r\nattribute float scale;\r\nattribute float index;\r\nuniform float time;\r\n\r\nuniform float delta;\r\nuniform float posX;\r\nuniform float posZ;\r\nuniform float radius;\r\nuniform float width;\r\nuniform float bladeHeight;\r\n\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vNormal;\r\nvarying vec3 vPosition;\r\nvarying float frc;\r\nvarying float idx;\r\n\r\nconst float PI = 3.1415;\r\nconst float TWO_PI = 2.0 * PI;\r\n\r\n\r\n//https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\r\nvec3 rotateVectorByQuaternion(vec3 v, vec4 q){\r\n    return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\r\n}\r\n\r\nfloat placeOnSphere(vec3 v){\r\n    float theta = acos(v.z/radius);\r\n    float phi = acos(v.x/(radius * sin(theta)));\r\n    float sV = radius * sin(theta) * sin(phi);\r\n    //If undefined, set to default value\r\n    if (sV != sV){\r\n        sV = v.y;\r\n    }\r\n    return sV;\r\n}\r\n\r\nvoid main() {\r\n\r\n    //Vertex height in blade geometry\r\n    frc = position.y / float(bladeHeight);\r\n\r\n    vec3 vPosition = position;\r\n    vPosition.y *= scale;\r\n\r\n    //Invert scaling for normals\r\n    vNormal = normal;\r\n    vNormal.y /= scale;\r\n\r\n    //Rotate blade around Y axis\r\n    vec4 direction = vec4(0.0, halfRootAngle.x, 0.0, halfRootAngle.y);\r\n    vPosition = rotateVectorByQuaternion(vPosition, direction);\r\n    vNormal = rotateVectorByQuaternion(vNormal, direction);\r\n\r\n    //UV for texture\r\n    vUv = uv;\r\n\r\n    vec3 pos;\r\n    vec3 globalPos;\r\n    vec3 tile;\r\n\r\n    globalPos.x = offset.x-posX*delta;\r\n    globalPos.z = offset.z-posZ*delta;\r\n    globalPos.y = offset.y;\r\n\r\n    tile.x = floor((globalPos.x + 0.5 * width) / width);\r\n    tile.z = floor((globalPos.z + 0.5 * width) / width);\r\n\r\n    pos.x = globalPos.x - tile.x * width;\r\n    pos.z = globalPos.z - tile.z * width;\r\n    pos.y = globalPos.y - tile.y;\r\n\r\n    // pos.y = max(0.0, placeOnSphere(pos)) - radius;\r\n    // pos.y += getYPosition(vec2(pos.x+delta*posX, pos.z+delta*posZ));\r\n\r\n    //Position of the blade in the visible patch [0->1]\r\n    vec2 fractionalPos = 0.5 + offset.xz / width;\r\n    //To make it seamless, make it a multiple of 2*PI\r\n    fractionalPos *= TWO_PI;\r\n\r\n    //Wind is sine waves in time.\r\n    float noise = 0.5 + 0.5 * sin(fractionalPos.x + time);\r\n    float halfAngle = -noise * 0.1;\r\n    noise = 0.5 + 0.5 * cos(fractionalPos.y + time);\r\n    halfAngle -= noise * 0.05;\r\n\r\n    direction = normalize(vec4(sin(halfAngle), 0.0, -sin(halfAngle), cos(halfAngle)));\r\n\r\n    //Rotate blade and normals according to the wind\r\n    vPosition = rotateVectorByQuaternion(vPosition, direction);\r\n    vNormal = rotateVectorByQuaternion(vNormal, direction);\r\n\r\n    //Move vertex to global location\r\n    vPosition += pos;\r\n\r\n    //Index of instance for varying colour in fragment shader\r\n    idx = index;\r\n\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);\r\n\r\n}";

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _applyDecoratedDescriptor)
/* harmony export */ });
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _initializerDefineProperty)
/* harmony export */ });
function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _initializerWarningHelper)
/* harmony export */ });
function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
}

/***/ }),

/***/ "./node_modules/@lastolivegames/becsy/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lastolivegames/becsy/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanceledError": () => (/* binding */ CanceledError),
/* harmony export */   "Query": () => (/* binding */ Query),
/* harmony export */   "System": () => (/* binding */ System),
/* harmony export */   "Type": () => (/* binding */ Type),
/* harmony export */   "World": () => (/* binding */ World),
/* harmony export */   "co": () => (/* binding */ co),
/* harmony export */   "component": () => (/* binding */ component),
/* harmony export */   "field": () => (/* binding */ field),
/* harmony export */   "system": () => (/* binding */ system)
/* harmony export */ });
const ENTITY_ID_BITS = 22;
const COMPONENT_ID_BITS = 9;
const FIELD_SEQ_BITS = 7;
const MAX_NUM_ENTITIES = 2 ** ENTITY_ID_BITS;
const ENTITY_ID_MASK = MAX_NUM_ENTITIES - 1;
const MAX_NUM_COMPONENTS = 2 ** COMPONENT_ID_BITS;
const COMPONENT_ID_MASK = MAX_NUM_COMPONENTS - 1;
const MAX_NUM_FIELDS = 2 ** FIELD_SEQ_BITS;
const FIELD_SEQ_MASK = MAX_NUM_FIELDS - 1;
// TODO: enforce max length of ref structs/arrays

class InternalError extends Error {
    constructor(message) {
        super(`Internal error: ${message}. Please report a bug!`);
    }
}
class CheckError extends Error {
}

const encoder = new TextEncoder();
const decoder = new TextDecoder();
function throwNotWritable(binding) {
    throw new CheckError(`Component is not writable; ` +
        `use entity.write(${binding.type.name}) to acquire a writable version`);
}
function checkInvalid(component, binding) {
    if (component.__invalid) {
        throw new CheckError(`Component instance for ${binding.type.name} is no longer valid, as you already bound it ` +
            `to another entity`);
    }
}
class Type {
    defaultValue;
    shared;
    constructor(defaultValue, shared = true) {
        this.defaultValue = defaultValue;
        this.shared = shared;
    }
    get internallyIndexed() { return false; }
    /* eslint-disable lines-between-class-members */
    static boolean;
    static uint8;
    static int8;
    static uint16;
    static int16;
    static uint32;
    static int32;
    static float32;
    static float64;
    static vector;
    static staticString;
    static dynamicString;
    static object;
    static weakObject;
    // TODO: add autoremove/autodelete when nulled out
    static ref;
    static backrefs;
}
class BooleanType extends Type {
    constructor() { super(false); }
    defineElastic(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        let data;
        field.updateBuffer = () => {
            binding.dispatcher.buffers.register(bufferKey, binding.capacity, Uint8Array, (newData) => { data = newData; });
        };
        field.updateBuffer();
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return Boolean(data[binding.writableIndex]);
            },
            set(value) {
                checkInvalid(this, binding);
                data[binding.writableIndex] = value ? 1 : 0;
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return Boolean(data[binding.readonlyIndex]);
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
    defineFixed(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, Uint8Array);
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return Boolean(data[binding.writableIndex]);
            },
            set(value) {
                checkInvalid(this, binding);
                data[binding.writableIndex] = value ? 1 : 0;
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return Boolean(data[binding.readonlyIndex]);
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
}
class NumberType extends Type {
    NumberArray;
    constructor(NumberArray) {
        super(0);
        this.NumberArray = NumberArray;
    }
    defineElastic(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        let data;
        field.updateBuffer = () => {
            binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.NumberArray, (newData) => { data = newData; });
        };
        field.updateBuffer();
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return data[binding.writableIndex];
            },
            set(value) {
                checkInvalid(this, binding);
                data[binding.writableIndex] = value;
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return data[binding.readonlyIndex];
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
    defineFixed(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.NumberArray);
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return data[binding.writableIndex];
            },
            set(value) {
                checkInvalid(this, binding);
                data[binding.writableIndex] = value;
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return data[binding.readonlyIndex];
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
}
class VectorType extends Type {
    type;
    Class;
    stride;
    elementNames;
    constructor(type, elements, Class) {
        super(new Array(typeof elements === 'number' ? elements : elements.length).fill(0));
        this.type = type;
        this.Class = Class;
        if (typeof elements === 'number') {
            this.stride = elements;
        }
        else {
            this.stride = elements.length;
            this.elementNames = elements;
        }
    }
    get internallyIndexed() { return true; }
    defineElastic(binding, field) {
        const stride = this.stride;
        const elementNames = this.elementNames;
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        let data;
        field.updateBuffer = () => {
            binding.dispatcher.buffers.register(bufferKey, binding.capacity * stride, this.type.NumberArray, (newData) => { data = newData; });
        };
        field.updateBuffer();
        const masterWritableAccessor = this.Class ? new this.Class() : {};
        const masterReadonlyAccessor = this.Class ? new this.Class() : {};
        Object.defineProperty(masterWritableAccessor, 'length', { value: stride });
        Object.defineProperty(masterReadonlyAccessor, 'length', { value: stride });
        {
            Object.defineProperty(masterWritableAccessor, '__becsyComponent', { value: undefined, writable: true });
            Object.defineProperty(masterReadonlyAccessor, '__becsyComponent', { value: undefined, writable: true });
        }
        let writableAccessor = Object.create(masterWritableAccessor);
        Object.seal(writableAccessor);
        let readonlyAccessor = Object.create(masterReadonlyAccessor);
        Object.seal(readonlyAccessor);
        /* eslint-disable no-loop-func */
        for (let i = 0; i < this.stride; i++) {
            Object.defineProperty(masterWritableAccessor, `${i}`, {
                enumerable: true,
                get() {
                    checkInvalid(this.__becsyComponent, binding);
                    return data[binding.writableIndex * stride + i];
                },
                set(value) {
                    checkInvalid(this.__becsyComponent, binding);
                    data[binding.writableIndex * stride + i] = value;
                }
            });
            Object.defineProperty(masterReadonlyAccessor, `${i}`, {
                enumerable: true,
                get() {
                    checkInvalid(this.__becsyComponent, binding);
                    return data[binding.readonlyIndex * stride + i];
                },
                set(value) {
                    throwNotWritable(binding);
                }
            });
            if (this.elementNames?.[i]) {
                Object.defineProperty(masterWritableAccessor, this.elementNames[i], {
                    enumerable: true,
                    get() {
                        checkInvalid(this.__becsyComponent, binding);
                        return data[binding.writableIndex * stride + i];
                    },
                    set(value) {
                        checkInvalid(this.__becsyComponent, binding);
                        data[binding.writableIndex * stride + i] = value;
                    }
                });
                Object.defineProperty(masterReadonlyAccessor, this.elementNames[i], {
                    enumerable: true,
                    get() {
                        checkInvalid(this.__becsyComponent, binding);
                        return data[binding.readonlyIndex * stride + i];
                    },
                    set(value) {
                        throwNotWritable(binding);
                    }
                });
            }
        }
        /* eslint-enable no-loop-func */
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                {
                    checkInvalid(this, binding);
                    writableAccessor = Object.create(masterWritableAccessor);
                    writableAccessor.__becsyComponent = this;
                    Object.seal(writableAccessor);
                }
                return writableAccessor;
            },
            set(value) {
                checkInvalid(this, binding);
                if (value.length) {
                    if (value.length !== stride) {
                        throw new CheckError(`Value of length ${value.length} doesn't match vector of length ${stride}`);
                    }
                    for (let i = 0; i < stride; i++)
                        data[binding.writableIndex * stride + i] = value[i];
                }
                else {
                    if (!elementNames) {
                        throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} must be an array`);
                    }
                    for (let i = 0; i < stride; i++) {
                        if (typeof value[elementNames[i]] !== 'number') {
                            throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} is missing element ` +
                                `"${elementNames[i]}`);
                        }
                        data[binding.writableIndex * stride + i] = value[elementNames[i]];
                    }
                }
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                {
                    checkInvalid(this, binding);
                    readonlyAccessor = Object.create(masterReadonlyAccessor);
                    readonlyAccessor.__becsyComponent = this;
                    Object.seal(readonlyAccessor);
                }
                return readonlyAccessor;
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
    defineFixed(binding, field) {
        const stride = this.stride;
        const elementNames = this.elementNames;
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity * stride, this.type.NumberArray);
        const masterWritableAccessor = this.Class ? new this.Class() : {};
        const masterReadonlyAccessor = this.Class ? new this.Class() : {};
        Object.defineProperty(masterWritableAccessor, 'length', { value: stride });
        Object.defineProperty(masterReadonlyAccessor, 'length', { value: stride });
        {
            Object.defineProperty(masterWritableAccessor, '__becsyComponent', { value: undefined, writable: true });
            Object.defineProperty(masterReadonlyAccessor, '__becsyComponent', { value: undefined, writable: true });
        }
        let writableAccessor = Object.create(masterWritableAccessor);
        Object.seal(writableAccessor);
        let readonlyAccessor = Object.create(masterReadonlyAccessor);
        Object.seal(readonlyAccessor);
        for (let i = 0; i < this.stride; i++) {
            Object.defineProperty(masterWritableAccessor, `${i}`, {
                enumerable: true,
                get() {
                    checkInvalid(this.__becsyComponent, binding);
                    return data[binding.writableIndex * stride + i];
                },
                set(value) {
                    checkInvalid(this.__becsyComponent, binding);
                    data[binding.writableIndex * stride + i] = value;
                }
            });
            Object.defineProperty(masterReadonlyAccessor, `${i}`, {
                enumerable: true,
                get() {
                    checkInvalid(this.__becsyComponent, binding);
                    return data[binding.readonlyIndex * stride + i];
                },
                set(value) {
                    throwNotWritable(binding);
                }
            });
            if (this.elementNames?.[i]) {
                Object.defineProperty(masterWritableAccessor, this.elementNames[i], {
                    enumerable: true,
                    get() {
                        checkInvalid(this.__becsyComponent, binding);
                        return data[binding.writableIndex * stride + i];
                    },
                    set(value) {
                        checkInvalid(this.__becsyComponent, binding);
                        data[binding.writableIndex * stride + i] = value;
                    }
                });
                Object.defineProperty(masterReadonlyAccessor, this.elementNames[i], {
                    enumerable: true,
                    get() {
                        checkInvalid(this.__becsyComponent, binding);
                        return data[binding.readonlyIndex * stride + i];
                    },
                    set(value) {
                        throwNotWritable(binding);
                    }
                });
            }
        }
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                {
                    checkInvalid(this, binding);
                    writableAccessor = Object.create(masterWritableAccessor);
                    writableAccessor.__becsyComponent = this;
                    Object.seal(writableAccessor);
                }
                return writableAccessor;
            },
            set(value) {
                checkInvalid(this, binding);
                if (value.length) {
                    if (value.length !== stride) {
                        throw new CheckError(`Value of length ${value.length} doesn't match vector of length ${stride}`);
                    }
                    for (let i = 0; i < stride; i++)
                        data[binding.writableIndex * stride + i] = value[i];
                }
                else {
                    if (!elementNames) {
                        throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} must be an array`);
                    }
                    for (let i = 0; i < stride; i++) {
                        if (typeof value[elementNames[i]] !== 'number') {
                            throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} is missing element ` +
                                `"${elementNames[i]}`);
                        }
                        data[binding.writableIndex * stride + i] = value[elementNames[i]];
                    }
                }
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                {
                    checkInvalid(this, binding);
                    readonlyAccessor = Object.create(masterReadonlyAccessor);
                    readonlyAccessor.__becsyComponent = this;
                    Object.seal(readonlyAccessor);
                }
                return readonlyAccessor;
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
}
class StaticStringType extends Type {
    choices;
    choicesIndex = new Map();
    TypedArray;
    constructor(choices) {
        super(choices[0]);
        this.choices = choices;
        {
            if (!choices?.length)
                throw new CheckError('No choices specified for Type.staticString');
        }
        if (choices.length < 1 << 8)
            this.TypedArray = Uint8Array;
        else if (choices.length < 1 << 16)
            this.TypedArray = Uint16Array;
        else
            this.TypedArray = Uint32Array;
        for (let i = 0; i < choices.length; i++)
            this.choicesIndex.set(choices[i], i);
    }
    defineElastic(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        let data;
        const choices = this.choices, choicesIndex = this.choicesIndex;
        field.updateBuffer = () => {
            binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.TypedArray, (newData) => { data = newData; });
        };
        field.updateBuffer();
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const index = data[binding.writableIndex];
                const result = choices[index];
                {
                    if (result === undefined)
                        throw new CheckError(`Invalid static string index: ${index}`);
                }
                return result;
            },
            set(value) {
                checkInvalid(this, binding);
                const index = choicesIndex.get(value);
                {
                    if (index === undefined)
                        throw new CheckError(`Static string not in set: "${value}"`);
                }
                data[binding.writableIndex] = index;
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const index = data[binding.readonlyIndex];
                const result = choices[index];
                {
                    if (result === undefined)
                        throw new CheckError(`Invalid static string index: ${index}`);
                }
                return result;
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
    defineFixed(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        const choices = this.choices, choicesIndex = this.choicesIndex;
        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.TypedArray);
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const index = data[binding.writableIndex];
                const result = choices[index];
                {
                    if (result === undefined)
                        throw new CheckError(`Invalid static string index: ${index}`);
                }
                return result;
            },
            set(value) {
                checkInvalid(this, binding);
                const index = choicesIndex.get(value);
                {
                    if (index === undefined)
                        throw new CheckError(`Static string not in set: "${value}"`);
                }
                data[binding.writableIndex] = index;
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const index = data[binding.readonlyIndex];
                const result = choices[index];
                {
                    if (result === undefined)
                        throw new CheckError(`Invalid static string index: ${index}`);
                }
                return result;
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
}
class DynamicStringType extends Type {
    maxUtf8Length;
    lengthsStride;
    bytesStride;
    constructor(maxUtf8Length) {
        super('');
        this.maxUtf8Length = maxUtf8Length + (maxUtf8Length % 2);
        this.bytesStride = this.maxUtf8Length + 2; // account for length field
        this.lengthsStride = this.bytesStride / 2;
    }
    defineElastic(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        let lengths;
        let bytes;
        const maxUtf8Length = this.maxUtf8Length;
        const lengthsStride = this.lengthsStride, bytesStride = this.bytesStride;
        field.updateBuffer = () => {
            const size = binding.capacity * (this.maxUtf8Length + Uint16Array.BYTES_PER_ELEMENT);
            binding.dispatcher.buffers.register(bufferKey, size, Uint8Array, (newData) => {
                bytes = newData;
                lengths = new Uint16Array(bytes.buffer);
            });
        };
        field.updateBuffer();
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const length = lengths[binding.writableIndex * lengthsStride];
                return decoder.decode(new Uint8Array(bytes.buffer, binding.writableIndex * bytesStride + 2, length));
            },
            set(value) {
                checkInvalid(this, binding);
                const encodedString = encoder.encode(value);
                {
                    if (encodedString.byteLength > maxUtf8Length) {
                        throw new CheckError(`Dynamic string length > ${maxUtf8Length} after encoding: ${value}`);
                    }
                }
                lengths[binding.writableIndex * lengthsStride] = encodedString.byteLength;
                bytes.set(encodedString, binding.writableIndex * bytesStride + 2);
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const length = lengths[binding.readonlyIndex * lengthsStride];
                return decoder.decode(new Uint8Array(bytes.buffer, binding.readonlyIndex * bytesStride + 2, length));
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
    defineFixed(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        const maxUtf8Length = this.maxUtf8Length;
        const lengthsStride = this.lengthsStride, bytesStride = this.bytesStride;
        const size = binding.capacity * (this.maxUtf8Length + Uint16Array.BYTES_PER_ELEMENT);
        const bytes = binding.dispatcher.buffers.register(bufferKey, size, Uint8Array);
        const lengths = new Uint16Array(bytes.buffer);
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const length = lengths[binding.writableIndex * lengthsStride];
                return decoder.decode(new Uint8Array(bytes.buffer, binding.writableIndex * bytesStride + 2, length));
            },
            set(value) {
                checkInvalid(this, binding);
                const encodedString = encoder.encode(value);
                {
                    if (encodedString.byteLength > maxUtf8Length) {
                        throw new CheckError(`Dynamic string length > ${maxUtf8Length} after encoding: ${value}`);
                    }
                }
                lengths[binding.writableIndex * lengthsStride] = encodedString.byteLength;
                bytes.set(encodedString, binding.writableIndex * bytesStride + 2);
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const length = lengths[binding.readonlyIndex * lengthsStride];
                return decoder.decode(new Uint8Array(bytes.buffer, binding.readonlyIndex * bytesStride + 2, length));
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
}
const STALE_REF_BIT = 2 ** 31;
class RefType extends Type {
    constructor() {
        super(undefined);
    }
    defineElastic(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        let data;
        const indexer = binding.dispatcher.indexer;
        const registry = binding.dispatcher.registry;
        const pool = registry.pool;
        indexer.registerSelector();
        field.updateBuffer = () => {
            binding.dispatcher.buffers.register(bufferKey, binding.capacity, Int32Array, (newData) => { data = newData; }, -1);
        };
        field.updateBuffer();
        field.clearRef = (final, targetId, internalIndex) => {
            if (internalIndex)
                throw new InternalError('Ref fields have no internal index');
            if (data[binding.writableIndex] === -1)
                return;
            const stale = (data[binding.writableIndex] & STALE_REF_BIT) !== 0;
            if (stale && !final)
                return;
            if (!stale && final)
                throw new InternalError('Wrong ref stale state');
            const id = (data[binding.writableIndex] & ENTITY_ID_MASK);
            const targetIdGiven = targetId !== undefined;
            if (targetIdGiven && id !== targetId)
                return;
            if (final) {
                data[binding.writableIndex] = -1;
            }
            else {
                data[binding.writableIndex] |= STALE_REF_BIT;
            }
            indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, id, -1, !final, final);
        };
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const id = data[binding.writableIndex];
                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)
                    return;
                return pool.borrowTemporarily((id & ENTITY_ID_MASK));
            },
            set(value) {
                checkInvalid(this, binding);
                if (value && !registry.hasShape(value.__id, registry.Alive, false)) {
                    throw new CheckError('Referencing a deleted entity is not allowed');
                }
                let oldId = data[binding.writableIndex];
                if (oldId !== -1)
                    oldId = (oldId & ENTITY_ID_MASK);
                const stale = oldId !== -1 && !!(data[binding.writableIndex] & STALE_REF_BIT);
                const newId = (value?.__id ?? -1);
                if (oldId === newId && !stale)
                    return;
                data[binding.writableIndex] = newId;
                indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, oldId, newId, !stale, true);
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const id = data[binding.readonlyIndex];
                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)
                    return;
                return pool.borrowTemporarily((id & ENTITY_ID_MASK));
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
    defineFixed(binding, field) {
        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;
        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, Int32Array, undefined, -1);
        const indexer = binding.dispatcher.indexer;
        const registry = binding.dispatcher.registry;
        const pool = registry.pool;
        indexer.registerSelector();
        field.clearRef = (final, targetId, internalIndex) => {
            if (internalIndex)
                throw new InternalError('Ref fields have no internal index');
            if (data[binding.writableIndex] === -1)
                return;
            const stale = (data[binding.writableIndex] & STALE_REF_BIT) !== 0;
            if (stale && !final)
                return;
            if (!stale && final)
                throw new InternalError('Wrong ref stale state');
            const id = (data[binding.writableIndex] & ENTITY_ID_MASK);
            const targetIdGiven = targetId !== undefined;
            if (targetIdGiven && id !== targetId)
                return;
            if (final) {
                data[binding.writableIndex] = -1;
            }
            else {
                data[binding.writableIndex] |= STALE_REF_BIT;
            }
            indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, id, -1, !final, final);
        };
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const id = data[binding.writableIndex];
                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)
                    return;
                return pool.borrowTemporarily((id & ENTITY_ID_MASK));
            },
            set(value) {
                checkInvalid(this, binding);
                if (value && !registry.hasShape(value.__id, registry.Alive, false)) {
                    throw new CheckError('Referencing a deleted entity is not allowed');
                }
                let oldId = data[binding.writableIndex];
                if (oldId !== -1)
                    oldId = (oldId & ENTITY_ID_MASK);
                const stale = oldId !== -1 && !!(data[binding.writableIndex] & STALE_REF_BIT);
                const newId = (value?.__id ?? -1);
                if (oldId === newId && !stale)
                    return;
                data[binding.writableIndex] = newId;
                indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, oldId, newId, !stale, true);
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const id = data[binding.readonlyIndex];
                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)
                    return;
                return pool.borrowTemporarily((id & ENTITY_ID_MASK));
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
}
const EMPTY_ARRAY = [];
class BackrefsType extends Type {
    type;
    fieldName;
    trackDeletedBackrefs;
    constructor(type, fieldName, trackDeletedBackrefs) {
        super(EMPTY_ARRAY);
        this.type = type;
        this.fieldName = fieldName;
        this.trackDeletedBackrefs = trackDeletedBackrefs;
    }
    // TODO: build benchmarks for backrefs and see if storing pointers to the trackers' entities
    // arrays for direct access performs significantly better than looking them up in the indexer's
    // Map each time.
    defineElastic(binding, field) {
        field.updateBuffer = () => { };
        const refField = this.fieldName ?
            this.type?.__binding.fields.find(aField => aField.name === this.fieldName) : undefined;
        {
            if (this.fieldName && !refField) {
                throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} refers to ` +
                    `an unknown field ${this.type.name}.${this.fieldName}`);
            }
            if (refField && refField.type !== Type.ref) {
                throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} refers to ` +
                    `a field ${this.type.name}.${this.fieldName} that is not a ref`);
            }
            if (this.fieldName && !this.type) {
                throw new CheckError(`Backrefs selector has field but no component in ${binding.type.name}.${field.name}`);
            }
            if (this.type && !this.fieldName && !this.type.__binding.refFields.length) {
                throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} refers to ` +
                    `component ${this.type.name} that has no ref fields`);
            }
        }
        const trackDeletedBackrefs = this.trackDeletedBackrefs;
        const indexer = binding.dispatcher.indexer;
        indexer.registerSelector(); // make sure global selector always registered first
        const selectorId = indexer.registerSelector(binding.type, this.type, refField?.seq, this.trackDeletedBackrefs);
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                if (!trackDeletedBackrefs && binding.dispatcher.registry.includeRecentlyDeleted) {
                    throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} not configured to track recently ` +
                        `deleted refs`);
                }
                return indexer.getBackrefs(binding.writableEntityId, selectorId);
            },
            set(value) {
                checkInvalid(this, binding);
                if (value !== EMPTY_ARRAY) {
                    throw new CheckError('Backrefs properties are computed automatically, you cannot set them');
                }
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                if (!trackDeletedBackrefs && binding.dispatcher.registry.includeRecentlyDeleted) {
                    throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} not configured to track recently ` +
                        `deleted refs`);
                }
                return indexer.getBackrefs(binding.readonlyEntityId, selectorId);
            },
            set(value) {
                checkInvalid(this, binding);
                if (value !== EMPTY_ARRAY) {
                    throw new CheckError('Backrefs properties are computed automatically, you cannot set them');
                }
            }
        });
    }
    defineFixed(binding, field) {
        this.defineElastic(binding, field);
    }
}
class ObjectType extends Type {
    constructor() { super(undefined, false); }
    defineElastic(binding, field) {
        const data = [];
        field.updateBuffer = () => { };
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return data[binding.writableIndex];
            },
            set(value) {
                checkInvalid(this, binding);
                data[binding.writableIndex] = value;
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return data[binding.readonlyIndex];
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
    defineFixed(binding, field) {
        const data = new Array(binding.capacity);
        field.updateBuffer = () => { };
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return data[binding.writableIndex];
            },
            set(value) {
                checkInvalid(this, binding);
                data[binding.writableIndex] = value;
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                return data[binding.readonlyIndex];
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
}
class WeakObjectType extends Type {
    finalizers;
    constructor() { super(undefined, false); }
    defineElastic(binding, field) {
        const data = [];
        field.updateBuffer = () => { };
        const finalizers = this.initFinalizers(binding);
        Object.defineProperty(binding.writableMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const value = data[binding.writableIndex];
                if (value === null || value === undefined)
                    return value;
                return value.deref();
            },
            set(value) {
                checkInvalid(this, binding);
                if (value !== null && value !== undefined) {
                    const weakRef = new WeakRef(value);
                    finalizers?.register(value, {
                        type: binding.type, data, weakRef, id: binding.writableEntityId,
                        index: binding.writableIndex
                    });
                    value = weakRef;
                }
                data[binding.writableIndex] = value;
            }
        });
        Object.defineProperty(binding.readonlyMaster, field.name, {
            enumerable: true, configurable: true,
            get() {
                checkInvalid(this, binding);
                const value = data[binding.readonlyIndex];
                if (value === null || value === undefined)
                    return value;
                return value.deref();
            },
            set(value) {
                throwNotWritable(binding);
            }
        });
    }
    defineFixed(binding, field) {
        this.defineElastic(binding, field);
    }
    initFinalizers(binding) {
        if (!binding.trackedWrites)
            return;
        if (this.finalizers)
            return this.finalizers;
        const dispatcher = binding.dispatcher;
        if (!dispatcher.writeLog || typeof FinalizationRegistry === 'undefined')
            return;
        this.finalizers = new FinalizationRegistry(({ type, data, weakRef, id, index }) => {
            if (data[index] === weakRef)
                dispatcher.registry.trackWrite(id, type);
        });
        return this.finalizers;
    }
}
// The fields below are replicated in the @field decorator, keep them in sync.
Type.boolean = new BooleanType();
Type.uint8 = new NumberType(Uint8Array);
Type.int8 = new NumberType(Int8Array);
Type.uint16 = new NumberType(Uint16Array);
Type.int16 = new NumberType(Int16Array);
Type.uint32 = new NumberType(Uint32Array);
Type.int32 = new NumberType(Int32Array);
Type.float32 = new NumberType(Float32Array);
Type.float64 = new NumberType(Float64Array);
Type.vector = (type, elements, Class) => new VectorType(type, elements, Class);
Type.staticString = (choices) => new StaticStringType(choices);
Type.dynamicString = (maxUtf8Length) => new DynamicStringType(maxUtf8Length);
Type.ref = new RefType();
Type.backrefs = (type, fieldName, trackDeletedBackrefs = false) => new BackrefsType(type, fieldName, trackDeletedBackrefs);
Type.object = new ObjectType();
Type.weakObject = new WeakObjectType();

class Binding {
    type;
    fields;
    dispatcher;
    capacity;
    storage;
    elastic;
    constructor(type, fields, shapeSpec, dispatcher, capacity, storage, elastic) {
        this.type = type;
        this.fields = fields;
        this.dispatcher = dispatcher;
        this.capacity = capacity;
        this.storage = storage;
        this.elastic = elastic;
        this.readonlyMaster = this.readonlyInstance = new type(); // eslint-disable-line new-cap
        this.writableMaster = this.writableInstance = new type(); // eslint-disable-line new-cap
        {
            this.readonlyInstance = Object.create(this.readonlyMaster);
            this.readonlyInstance.__invalid = !this.elastic && this.capacity > 1;
            this.writableInstance = Object.create(this.writableMaster);
            this.writableInstance.__invalid = !this.elastic && this.capacity > 1;
        }
        this.shapeOffset = shapeSpec.offset;
        this.shapeMask = shapeSpec.mask;
        this.shapeValue = shapeSpec.value;
        this.refFields = fields.filter(field => field.type === Type.ref);
        this.trackedWrites = false;
        this.writableEntityId = 0;
        this.writableIndex = 0;
        this.readonlyEntityId = 0;
        this.readonlyIndex = 0;
        // eslint-disable-next-line no-new-func
        this.initDefault = new Function('component', fields
            .filter(field => field.default !== EMPTY_ARRAY)
            .map(field => `component.${field.name} = ${JSON.stringify(field.default)};`)
            .join('\n'));
        let backrefFieldInits = [];
        {
            backrefFieldInits = fields
                .filter(field => field.default === EMPTY_ARRAY)
                .map(field => `
          if (${JSON.stringify(field.name)} in values) {
            component.${field.name} = values.${field.name};
          }
        `);
        }
        // eslint-disable-next-line no-new-func
        this.init = new Function('component', 'values', fields
            .filter(field => field.default !== EMPTY_ARRAY)
            .map(field => `
          component.${field.name} = values.${field.name} === undefined ?
            ${JSON.stringify(field.default)} : values.${field.name};
        `)
            .concat(backrefFieldInits)
            .join('\n'));
    }
    resetWritableInstance(entityId, index) {
        if (index === -1) {
            throw new InternalError(`Attempt to bind unacquired entity ${entityId} to ${this.type.name}`);
        }
        this.writableEntityId = entityId;
        this.writableIndex = index;
        if (this.elastic || this.capacity > 1) {
            this.writableInstance.__invalid = true;
            this.writableInstance = Object.create(this.writableMaster);
        }
        return this.writableInstance;
    }
    resetReadonlyInstance(entityId, index) {
        if (index === -1) {
            throw new InternalError(`Attempt to bind unacquired entity ${entityId} to ${this.type.name}`);
        }
        this.readonlyEntityId = entityId;
        this.readonlyIndex = index;
        if (this.elastic || this.capacity > 1) {
            this.readonlyInstance.__invalid = true;
            this.readonlyInstance = Object.create(this.readonlyMaster);
        }
        return this.readonlyInstance;
    }
}
function checkTypeDefined(type) {
    if (!type.__binding) {
        throw new CheckError(`Component ${type.name} not defined; add to world defs`);
    }
}
class PackedStorage {
    maxEntities;
    binding;
    fields;
    constructor(maxEntities, binding, fields) {
        this.maxEntities = maxEntities;
        this.binding = binding;
        this.fields = fields;
        this.growSpares();
        this.growCapacity();
    }
    acquireIndex(id) {
        let index = this.index[id];
        if (index === -1) {
            if (this.spares[3] > 0) {
                index = this.spares[--this.spares[3] + 4];
            }
            else {
                if (this.spares[1] === this.spares[2]) {
                    if (!this.binding.elastic) {
                        throw new CheckError(`Storage exhausted for component ${this.binding.type.name}; ` +
                            `raise its capacity above ${this.binding.capacity}`);
                    }
                    if (this.binding.capacity === this.maxEntities) {
                        throw new InternalError(`Trying to grow storage index for component ${this.binding.type.name} beyond ` +
                            `maxEntities`);
                    }
                    this.binding.capacity = Math.min(this.maxEntities, this.binding.capacity * 2);
                    this.growCapacity();
                }
                index = this.spares[1]++;
            }
            this.index[id] = index;
        }
        return index;
    }
    releaseIndex(id) {
        if (this.index[id] === -1) {
            throw new InternalError(`Index for entity ${id} in component ${this.binding.type.name} not allocated`);
        }
        if (this.spares[3] === this.spares.length - 4)
            this.growSpares();
        this.spares[this.spares[3]++ + 4] = this.index[id];
        this.index[id] = -1;
    }
    growCapacity() {
        const capacity = this.binding.capacity;
        this.binding.dispatcher.stats.forComponent(this.binding.type).capacity = capacity;
        const ArrayType = this.ArrayType;
        const elementSizeChanged = ArrayType.BYTES_PER_ELEMENT !== this.spares?.[0];
        if (!this.index || elementSizeChanged) {
            this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.index`, this.maxEntities, ArrayType, (index) => { this.index = index; }, -1);
        }
        if (elementSizeChanged) {
            this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.spares`, this.spares.length, ArrayType, this.updateSpares.bind(this));
        }
        else {
            this.spares[2] = capacity;
        }
        if (this.binding.elastic)
            for (const field of this.fields)
                field.updateBuffer();
    }
    growSpares() {
        const maxSpares = this.spares ? Math.min(this.maxEntities, (this.spares.length - 4) * 2) : 8;
        this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.spares`, 4 + maxSpares, this.ArrayType, this.updateSpares.bind(this));
    }
    updateSpares(spares) {
        spares[2] = this.binding.capacity = Math.max(this.binding.capacity, spares[2]);
        spares[0] = this.ArrayType.BYTES_PER_ELEMENT;
        this.spares = spares;
    }
    get ArrayType() {
        const capacity = Math.max(this.spares?.[2] ?? 0, this.binding.capacity);
        return capacity < (1 << 7) ? Int8Array : capacity < (1 << 15) ? Int16Array : Int32Array;
    }
}
class CompactStorage {
    maxEntities;
    binding;
    fields;
    constructor(maxEntities, binding, fields) {
        this.maxEntities = maxEntities;
        this.binding = binding;
        this.fields = fields;
        this.growCapacity();
    }
    findIndex(id) {
        for (let i = 0; i < this.index.length; i++) {
            if (this.index[i] === id)
                return i;
        }
        return -1;
    }
    acquireIndex(id) {
        let firstEmpty;
        for (let i = 0; i < this.index.length; i++) {
            if (this.index[i] === id)
                return i;
            if (firstEmpty === undefined && this.index[i] === -1)
                firstEmpty = i;
        }
        if (firstEmpty === undefined) {
            if (!this.binding.elastic) {
                throw new CheckError(`Storage exhausted for component ${this.binding.type.name}; ` +
                    `raise its capacity above ${this.binding.capacity}`);
            }
            if (this.binding.capacity === this.maxEntities) {
                throw new InternalError(`Trying to grow storage index for component ${this.binding.type.name} beyond ` +
                    `maxEntities`);
            }
            firstEmpty = this.index.length;
            this.binding.capacity = Math.min(this.maxEntities, this.binding.capacity * 2);
            this.growCapacity();
        }
        this.index[firstEmpty] = id;
        return firstEmpty;
    }
    releaseIndex(id) {
        for (let i = 0; i < this.index.length; i++) {
            if (this.index[i] === id) {
                this.index[i] = -1;
                return;
            }
        }
        throw new InternalError(`Index for entity ${id} in component ${this.binding.type.name} not allocated`);
    }
    growCapacity() {
        const capacity = this.binding.capacity;
        this.binding.dispatcher.stats.forComponent(this.binding.type).capacity = capacity;
        this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.index`, capacity, Int32Array, this.updateIndex.bind(this), -1);
        if (this.binding.elastic)
            for (const field of this.fields)
                field.updateBuffer();
    }
    updateIndex(index) {
        this.index = index;
        this.binding.capacity = this.index.length;
    }
}
function initComponent(type, id, values) {
    {
        checkTypeDefined(type);
        if (values !== undefined) {
            for (const key in values) {
                if (!type.schema?.[key]) {
                    throw new CheckError(`Property ${key} not defined for component ${type.name}`);
                }
            }
        }
    }
    const component = type.__allocate(id);
    if (values) {
        type.__binding.init(component, values);
    }
    else {
        type.__binding.initDefault(component);
    }
}
function gatherFields(type) {
    const schema = type.schema;
    const fields = [];
    if (schema) {
        let seq = 0;
        for (const name in schema) {
            let entry = schema[name];
            if (entry instanceof Type || typeof entry === 'function')
                entry = { type: entry };
            if (typeof entry.type === 'function')
                entry.type = entry.type();
            if (!('default' in entry))
                entry.default = entry.type.defaultValue;
            fields.push({ name, seq: seq++, type: entry.type, default: entry.default });
        }
        if (seq > MAX_NUM_FIELDS) {
            throw new CheckError(`Component ${type.name} declares too many fields`);
        }
    }
    return fields;
}
function assimilateComponentType(typeId, type, shapeSpec, dispatcher) {
    const fields = gatherFields(type);
    // For tag components, force sparse storage since we don't actually need to allocate anything.
    const storage = fields.length ? (type.options?.storage ?? dispatcher.defaultComponentStorage) : 'sparse';
    const capacity = storage === 'sparse' ?
        dispatcher.maxEntities : Math.min(dispatcher.maxEntities, type.options?.capacity ?? 0);
    const initialCapacity = type.options?.initialCapacity ?? 8;
    {
        if (typeof type.options?.capacity !== 'undefined') {
            if (storage === 'sparse') {
                throw new CheckError(`Component type ${type.name} cannot combine custom capacity with sparse storage`);
            }
            if (type.options.capacity <= 0) {
                throw new CheckError(`Component type ${type.name} capacity option must be great than zero: got ${capacity}`);
            }
            if (typeof type.options.initialCapacity !== 'undefined') {
                throw new CheckError(`Component type ${type.name} cannot have both capacity and initialCapacity options`);
            }
        }
        if (type.options?.restrictedToMainThread && fields.every(field => field.type.shared)) {
            throw new CheckError(`Component type ${type.name} is restrictedToMainThread but has no thread-exclusive fields`);
        }
        if ((typeof process === 'undefined' || "development" !== 'test') && type.__bind) {
            throw new CheckError(`Component type ${type.name} is already in use in another world`);
        }
    }
    type.id = typeId;
    const binding = new Binding(type, fields, shapeSpec, dispatcher, capacity || initialCapacity, storage, !capacity);
    type.__binding = binding;
}
function defineAndAllocateComponentType(type) {
    const binding = type.__binding;
    for (const field of binding.fields) {
        if (binding.elastic) {
            field.type.defineElastic(binding, field);
        }
        else {
            field.type.defineFixed(binding, field);
        }
    }
    switch (binding.storage) {
        case 'sparse':
            // Inline the trivial storage manager for performance.
            binding.dispatcher.stats.forComponent(type).capacity = binding.capacity; // fixed
            type.__bind = (id, writable) => {
                return writable ?
                    binding.resetWritableInstance(id, id) :
                    binding.resetReadonlyInstance(id, id);
            };
            type.__allocate = (id) => {
                return binding.resetWritableInstance(id, id);
            };
            break;
        case 'packed': {
            const storageManager = new PackedStorage(binding.dispatcher.maxEntities, binding, binding.fields);
            type.__bind = (id, writable) => {
                return writable ?
                    binding.resetWritableInstance(id, storageManager.index[id]) :
                    binding.resetReadonlyInstance(id, storageManager.index[id]);
            };
            type.__allocate = (id) => {
                return binding.resetWritableInstance(id, storageManager.acquireIndex(id));
            };
            type.__free = (id) => {
                storageManager.releaseIndex(id);
            };
            break;
        }
        case 'compact': {
            const storageManager = new CompactStorage(binding.dispatcher.maxEntities, binding, binding.fields);
            type.__bind = (id, writable) => {
                return writable ?
                    binding.resetWritableInstance(id, storageManager.findIndex(id)) :
                    binding.resetReadonlyInstance(id, storageManager.findIndex(id));
            };
            type.__allocate = (id) => {
                return binding.resetWritableInstance(id, storageManager.acquireIndex(id));
            };
            type.__free = (id) => {
                storageManager.releaseIndex(id);
            };
            break;
        }
        default:
            throw new CheckError(`Invalid storage type "${binding.storage}`);
    }
}
function dissimilateComponentType(type) {
    delete type.id;
    delete type.__binding;
    delete type.__bind;
    delete type.__allocate;
    delete type.__free;
}
function declareSingleton(type) {
    if (!type.options)
        type.options = {};
    {
        if (type.options.storage && type.options.storage !== 'compact') {
            throw new CheckError(`Component ${type.name} ${type.options.storage} storage is incompatible with singletons`);
        }
        if (type.options.capacity && type.options.capacity !== 1) {
            throw new CheckError(`Component ${type.name} capacity of ${type.options.capacity} ` +
                `is incompatible with singletons`);
        }
        if (type.options.initialCapacity) {
            throw new CheckError(`Component ${type.name} initial capacity of ${type.options.initialCapacity} ` +
                `is incompatible with singletons`);
        }
    }
    type.options.storage = 'compact';
    type.options.capacity = 1;
}

/**
 * An entity represents a collection of distinct components with a unique identity.
 *
 * You can obtain entities from queries in your system.  You must not keep references to entities
 * thus obtained, as they may be pointed to another entity at any time between system executions.
 * Instead, call {@link Entity.hold} to obtain a long-lived version of the object.
 */
class EntityImpl {
    __registry;
    constructor(__registry) {
        this.__registry = __registry;
        this.__id = undefined;
        this.__sortKey = undefined;
        {
            this.__valid = true;
        }
    }
    /**
     * Returns whether the entity is alive, i.e. has not been deleted.  Turning on
     * `accessRecentlyDeletedData` doesn't affect the return value.
     */
    get alive() {
        this.__checkValid();
        return this.__registry.hasShape(this.__id, this.__registry.Alive, false);
    }
    /**
     * Returns the entity's ordinal number, as determined by the order of entity creation.  Entities
     * created in systems running concurrently may have overlapping ordinals.
     */
    get ordinal() {
        return this.__registry.entityOrdinals[this.__id];
    }
    /**
     * Adds a component to the entity.  If the entity already possesses a component of this type the
     * call will fail.
     * @param type The type of component to add.
     * @param values An optional object with field values to initialize the new component.
     */
    add(type, values) {
        {
            this.__checkValid();
            this.__checkMask(type, 'write');
            if (!this.__registry.hasShape(this.__id, this.__registry.Alive, false)) {
                throw new CheckError('Entity has been deleted');
            }
            if (this.__registry.hasShape(this.__id, type, false)) {
                throw new CheckError(`Entity already has a ${type.name} component`);
            }
        }
        this.__registry.setShape(this.__id, type);
        this.__registry.dispatcher.stats.forComponent(type).numEntities += 1;
        initComponent(type, this.__id, values);
    }
    /**
     * Adds a list of components to the entity.  If entity already possesses a component of any of
     * the given types, the call will fail.
     * @param args A list of component types to add, optionally interleaved wth objects that specify
     *  fields values for initializing the immediately preceding component.
     */
    addAll(...args) {
        this.__checkValid();
        {
            const enums = new Set();
            for (const arg of args) {
                if (typeof arg === 'function' && arg.enum) {
                    if (enums.has(arg.enum)) {
                        throw new CheckError(`Can't add multiple components from the same enum`);
                    }
                    enums.add(arg.enum);
                }
            }
        }
        for (let i = 0; i < args.length; i++) {
            const type = args[i];
            {
                if (typeof type !== 'function') {
                    throw new CheckError(`Bad arguments to addAll: expected component type, got: ${type}`);
                }
            }
            let value = args[i + 1];
            if (typeof value === 'function')
                value = undefined;
            else
                i++;
            this.add(type, value);
        }
    }
    /**
     * Remove a component from the entity.  If the entity doesn't possess a component of this type
     * the call will fail.
     * @param type The type of component to remove.
     */
    remove(type) {
        {
            this.__checkValid();
            this.__checkMask(type, 'write');
            if (typeof type === 'function')
                this.__checkHas(type, false);
        }
        if (typeof type !== 'function') {
            const currentType = this.__registry.getEnumShape(this.__id, type, false);
            if (!currentType) {
                throw new CheckError(`Entity doesn't have any components from ${type.name} enumeration`);
            }
            type = currentType;
        }
        this.__registry.clearShape(this.__id, type);
    }
    /**
     * Remove a list of components from the entity.  If the entity doesn't possess a component of any
     * of the given types, the call will fail.
     * @param types A list of component types to remove.
     */
    removeAll(...types) {
        for (const type of types)
            this.remove(type);
    }
    /**
     * Returns whether the entity currently contains a component of the given type.  If a system is
     * running in `accessRecentlyDeletedData` mode, this will also return true for recently removed
     * components.
     *
     * @param type The type of component to check for.
     * @returns Whether the entity has a component of the given type.
     */
    has(type) {
        {
            this.__checkValid();
            this.__checkMask(type, 'check');
        }
        if (typeof type === 'function')
            return this.__registry.hasShape(this.__id, type, true);
        return !!this.__registry.getEnumShape(this.__id, type, true);
    }
    // TODO: see if precomputing the masks and using Registry.match gets better performance on the
    // following has* methods.
    /**
     * Returns whether the entity currently contains a component of any of the given types.  If a
     * system is running in `accessRecentlyDeletedData` mode, this will also consider recently removed
     * components.
     * @param types A list of component types to check for.
     * @returns Whether the entity has a component of at least one of the given types.
     */
    hasSomeOf(...types) {
        this.__checkValid();
        for (const type of types)
            if (this.has(type))
                return true;
        return false;
    }
    /**
     * Returns whether the entity currently contains a component of every one of the given types.  If
     * a system is running in `accessRecentlyDeletedData` mode, this will also consider recently
     * removed components.
     * @param types A list of component types to check for.
     * @returns Whether the entity has a component of every one of the given types.
     */
    hasAllOf(...types) {
        this.__checkValid();
        for (const type of types)
            if (!this.has(type))
                return false;
        return true;
    }
    /**
     * Returns whether the entity currently contains a component of any type other than the given
     * ones.  If a system is running in `accessRecentlyDeletedData` mode, this will also consider
     * recently removed components.
     * @param types A list of component types to exclude from the check.
     * @returns Whether the entity has a component of a type not given.
     */
    hasAnyOtherThan(...types) {
        this.__checkValid();
        const typeSet = new Set(types);
        for (const type of this.__registry.types) {
            this.__checkMask(type, 'check');
            if (!(typeSet.has(type) || type.enum && typeSet.has(type.enum)) &&
                this.__registry.hasShape(this.__id, type, true))
                return true;
        }
        return false;
    }
    /**
     * Counts the number of components of the given types the entity currently contains. If a system
     * is running in `accessRecentlyDeletedData` mode, this will also consider recently removed
     * components.
     * @param types A list of component types to count.
     * @returns The number of components present from among the given types.
     */
    countHas(...types) {
        this.__checkValid();
        let count = 0;
        for (const type of types)
            if (this.has(type))
                count += 1;
        return count;
    }
    /**
     * Returns the type from the given enumeration currently contained by the entity, if any.  If a
     * system is running in `accessRecentlyDeletedData` mode, this will also consider recently removed
     * components.
     * @param enumeration The enumeration of the desired types.
     * @returns A type from the enumeration if contained by the entity, or `undefined` if none.
     */
    hasWhich(enumeration) {
        this.__checkValid();
        this.__checkMask(enumeration, 'check');
        return this.__registry.getEnumShape(this.__id, enumeration, true);
    }
    /**
     * Obtains a component of the entity that will not allow writing to its fields.  If a component of
     * the given type is not part of this entity this method will fail, unless a system is running in
     * `accessRecentlyDeletedData` mode and the component was only recently removed.
     *
     * The component returned must be used immediately; you must not retain a reference to it beyond
     * the local scope.  Any subsequent request to read the same component type on any entity will
     * invalidate the object.
     * @param type The type of component to obtain.
     * @returns The component of the given type that is part of the entity, ready for reading.
     */
    read(type) {
        {
            this.__checkValid();
            this.__checkMask(type, 'read');
            this.__checkHas(type, true);
        }
        return type.__bind(this.__id, false);
    }
    /**
     * Obtains a component of the entity that will allow writing to its fields, and mark the component
     * as having been written to (for `changed` queries).  If a component of the given type is not
     * part of this entity this method will fail, unless a system is running in
     * `accessRecentlyDeletedData` mode and the component was only recently removed.
     *
     * The component returned must be used immediately; you must not retain a reference to it beyond
     * the local scope.  Any subsequent request to write the same component type on any entity will
     * invalidate the object.
     * @param type The type of component to obtain.
     * @returns The component of the given type that is part of the entity, ready for reading and
     *  writing.
     */
    write(type) {
        {
            this.__checkValid();
            this.__checkMask(type, 'write');
            this.__checkHas(type, true);
        }
        if (type.__binding.trackedWrites)
            this.__registry.trackWrite(this.__id, type);
        return type.__bind(this.__id, true);
    }
    /**
     * Deletes this entity and removes all its components.
     */
    delete() {
        this.__checkValid();
        const Alive = this.__registry.Alive;
        if (!this.__registry.hasShape(this.__id, Alive, false)) {
            throw new CheckError('Entity already deleted');
        }
        for (const type of this.__registry.types) {
            if (this.__registry.hasShape(this.__id, type, false)) {
                if (type !== Alive)
                    this.__checkMask(type, 'write');
                this.__registry.clearShape(this.__id, type);
            }
        }
        this.__registry.dispatcher.indexer.clearAllRefs(this.__id, false);
    }
    /**
     * Creates a long-lived version of this entity object, that you can safely keep for as long as the
     * entity exists.  Once the entity is deleted (and swept up after the end of the next frame) all
     * further calls on the object will fail.
     * @returns A long-lived version of this entity object.
     */
    hold() {
        this.__checkValid();
        return this.__registry.holdEntity(this.__id);
    }
    /**
     * Returns whether this entity and another one are in fact the same entity.  This can be useful
     * for comparing held entities to transient query ones.
     * @param other The other entity to match against.
     * @returns Whether this entity and the other one are the same.
     */
    isSame(other) {
        this.__checkValid();
        return this.__id === other.__id;
    }
    __checkMask(type, kind) {
        checkMask(type, this.__registry.executingSystem, kind);
    }
    __checkHas(type, allowRecentlyDeleted) {
        if (!this.__registry.hasShape(this.__id, type, allowRecentlyDeleted)) {
            throw new CheckError(`Entity doesn't have a ${type.name} component`);
        }
    }
    __checkValid() {
        if (!this.__valid)
            throw new CheckError('Entity handle no longer valid');
    }
}
function checkMask(type, system, kind) {
    checkTypeDefined(type);
    const mask = system?.accessMasks[kind];
    if (!mask)
        return;
    // Inline isMaskFlagSet for performance.
    const binding = type.__binding;
    if (((mask[binding.shapeOffset] ?? 0) & binding.shapeMask) === 0) {
        throw new CheckError(`System ${system.name} didn't mark component ${type.name} as ${kind}able`);
    }
}
function isMaskFlagSet(mask, type) {
    const binding = type.__binding;
    return ((mask[binding.shapeOffset] ?? 0) & binding.shapeMask) !== 0;
}
function extendMaskAndSetFlag(mask, type, useValues = false) {
    checkTypeDefined(type);
    const flagOffset = type.__binding.shapeOffset;
    if (flagOffset >= mask.length) {
        const oldLength = mask.length;
        mask.length = flagOffset + 1;
        mask.fill(0, oldLength, flagOffset);
    }
    mask[flagOffset] |=
        useValues ? type.__binding.shapeValue : type.__binding.shapeMask;
}

const HEADER_LENGTH$1 = 2;
const EMPTY_TUPLE = [];
/**
 * A circular log of u32 numbers with smart pointers into it.  When the log wraps around it
 * increments a generation counter so you can tell if your pointer got lapped and is now invalid.
 */
class Log {
    maxEntries;
    configParamName;
    options;
    /* layout: [index, generation, ...entries] */
    data;
    /* layout: [length, generation, ...entries] */
    corral;
    /* layout: [length, unused, ...entries] */
    staging;
    typeCounters;
    constructor(maxEntries, configParamName, buffers, options = {
        localProcessingAllowed: false, sortedByComponentType: false, numComponentTypes: 0
    }) {
        this.maxEntries = maxEntries;
        this.configParamName = configParamName;
        this.options = options;
        buffers.register(`log.${configParamName}.buffer`, maxEntries + HEADER_LENGTH$1, Uint32Array, (data) => { this.data = data; });
        buffers.register(`log.${configParamName}.corral`, maxEntries + HEADER_LENGTH$1, Uint32Array, (corral) => { this.corral = corral; });
        if (options.sortedByComponentType) {
            if (options.numComponentTypes === undefined) {
                throw new InternalError(`numComponentTypes required when ${this.configParamName} is sortedByComponentType`);
            }
            buffers.register(`log.${configParamName}.staging`, maxEntries + HEADER_LENGTH$1, Uint32Array, (staging) => { this.staging = staging; });
            this.typeCounters = new Uint32Array(this.options.numComponentTypes);
        }
    }
    push(value, type) {
        const corralLength = this.corral[0];
        if (corralLength >= this.maxEntries)
            this.throwCapacityExceeded();
        if (corralLength && this.corral[corralLength] === value)
            return;
        this.corral[corralLength + HEADER_LENGTH$1] = value;
        this.corral[0] += 1;
        if (!!type !== !!this.options.sortedByComponentType) {
            throw new InternalError(`Pushing value ${type ? 'with' : 'without'} type to log ${this.configParamName} ` +
                `${this.options.sortedByComponentType ? '' : 'not '}sorted by component type`);
        }
        if (type)
            this.typeCounters[type.id] += 1;
    }
    commit(pointer) {
        if (!pointer && this.options.localProcessingAllowed) {
            throw new InternalError('Cannot use blind commit when log local processing is allowed');
        }
        if (!this.corral[0])
            return true;
        if (pointer && !(pointer.generation === this.data[1] && pointer.index === this.data[0] &&
            pointer.corralGeneration === this.corral[1] && pointer.corralIndex === this.corral[0]))
            return false;
        this.copyToData(this.staging ? this.sortCorral() : this.corral);
        this.corral[0] = 0;
        this.corral[1] += 1;
        if (pointer) {
            pointer.index = this.data[0];
            pointer.generation = this.data[1];
        }
        return true;
    }
    sortCorral() {
        let offset = HEADER_LENGTH$1, soleTypeId = -1, soleTypeCount = 0, numNonZeroTypes = 0;
        for (let typeId = 0; typeId < this.typeCounters.length; typeId++) {
            const count = this.typeCounters[typeId];
            if (!count)
                continue;
            numNonZeroTypes += 1;
            if (soleTypeId === -1) {
                soleTypeId = typeId;
                soleTypeCount = count;
            }
            else if (soleTypeId >= 0) {
                soleTypeId = -2;
            }
            if (count === 1) {
                this.typeCounters[typeId] = offset;
                offset += 1;
            }
            else {
                this.typeCounters[typeId] = offset + 1;
                this.staging[offset] = count | (typeId << ENTITY_ID_BITS) | 2 ** 31;
                offset += count + 1;
            }
        }
        if (soleTypeId >= 0) {
            if (soleTypeCount > 1) {
                if (this.corral[0] === this.maxEntries)
                    this.throwCapacityExceeded();
                this.corral[this.corral[0] + HEADER_LENGTH$1] = this.corral[HEADER_LENGTH$1];
                this.corral[HEADER_LENGTH$1] = this.corral[0] | (soleTypeId << ENTITY_ID_BITS) | 2 ** 31;
                this.corral[0] += 1;
            }
            this.typeCounters.fill(0);
            return this.corral;
        }
        if (this.corral[0] + numNonZeroTypes > this.maxEntries)
            this.throwCapacityExceeded();
        const corralAndHeaderLength = this.corral[0] + HEADER_LENGTH$1;
        for (let i = HEADER_LENGTH$1; i < corralAndHeaderLength; i++) {
            const value = this.corral[i];
            const typeId = value >>> ENTITY_ID_BITS;
            this.staging[this.typeCounters[typeId]++] = value;
        }
        this.staging[0] = offset - HEADER_LENGTH$1;
        this.typeCounters.fill(0);
        return this.staging;
    }
    copyToData(source) {
        let index = this.data[0];
        const length = source[0];
        const firstSegmentLength = Math.min(length, this.maxEntries - index);
        this.data.set(source.subarray(HEADER_LENGTH$1, firstSegmentLength + HEADER_LENGTH$1), index + HEADER_LENGTH$1);
        if (firstSegmentLength < length) {
            this.data.set(source.subarray(firstSegmentLength + HEADER_LENGTH$1, length + HEADER_LENGTH$1), HEADER_LENGTH$1);
        }
        index += length;
        while (index >= this.maxEntries) {
            index -= this.maxEntries;
            this.data[1] += 1;
        }
        this.data[0] = index;
    }
    createPointer(pointer) {
        if (!pointer) {
            return {
                index: this.data[0], generation: this.data[1],
                corralIndex: this.corral[0], corralGeneration: this.corral[1]
            };
        }
        pointer.index = this.data[0];
        pointer.generation = this.data[1];
        pointer.corralIndex = this.corral[0];
        pointer.corralGeneration = this.corral[1];
        return pointer;
    }
    copyPointer(pointer) {
        return {
            index: pointer.index, generation: pointer.generation,
            corralIndex: pointer.corralIndex, corralGeneration: pointer.corralGeneration
        };
    }
    hasUpdatesSince(pointer) {
        this.checkPointer(pointer);
        return !(pointer.index === this.data[0] && pointer.generation === this.data[1] &&
            (pointer.corralGeneration === this.corral[1] ?
                pointer.corralIndex === this.corral[0] : this.corral[0] === 0));
    }
    processSince(startPointer, endPointer) {
        this.checkPointers(startPointer, endPointer);
        let result = EMPTY_TUPLE;
        const endIndex = endPointer?.index ?? this.data[0];
        const endGeneration = endPointer?.generation ?? this.data[1];
        if (startPointer.generation === endGeneration) {
            if (startPointer.index < endIndex) {
                result = [
                    this.data, startPointer.index + HEADER_LENGTH$1, endIndex + HEADER_LENGTH$1, false
                ];
                startPointer.index = endIndex;
            }
            else {
                const corralLength = this.corral[0];
                const corralGeneration = this.corral[1];
                const corralHasNewEntries = startPointer.corralGeneration === corralGeneration ?
                    startPointer.corralIndex < corralLength : corralLength;
                if (corralHasNewEntries) {
                    result = [
                        this.corral, startPointer.corralIndex + HEADER_LENGTH$1,
                        corralLength + HEADER_LENGTH$1, true
                    ];
                    startPointer.corralIndex = corralLength;
                    startPointer.corralGeneration = corralGeneration;
                }
            }
        }
        else {
            result = [this.data, startPointer.index + HEADER_LENGTH$1, this.data.length, false];
            startPointer.index = 0;
            startPointer.generation = endGeneration;
        }
        return result;
    }
    processAndCommitSince(startPointer) {
        const result = this.processSince(startPointer);
        if (result[0])
            return result;
        if (this.commit(startPointer))
            return EMPTY_TUPLE;
        return this.processSince(startPointer);
    }
    countSince(startPointer, endPointer) {
        this.checkPointers(startPointer, endPointer);
        if (this.corral[0]) {
            throw new InternalError(`Should commit log before counting`);
        }
        const startIndex = startPointer.index;
        const startGeneration = startPointer.generation;
        const endIndex = endPointer?.index ?? this.data[0];
        const endGeneration = endPointer?.generation ?? this.data[1];
        startPointer.index = endIndex;
        startPointer.generation = endGeneration;
        if (startIndex === endIndex && startGeneration === endGeneration)
            return 0;
        if (startIndex < endIndex)
            return endIndex - startIndex;
        return this.maxEntries - (startIndex - endIndex);
    }
    checkPointers(startPointer, endPointer) {
        this.checkPointer(startPointer);
        if (endPointer) {
            this.checkPointer(endPointer);
            {
                if (startPointer.index > endPointer.index &&
                    startPointer.generation >= endPointer.generation) {
                    throw new InternalError(`Start pointer exceeds end pointer`);
                }
            }
        }
    }
    checkPointer(pointer) {
        const index = this.data[0];
        let generation = pointer.generation;
        if (pointer.index === index) {
            if (generation + 1 < this.data[1])
                this.throwCapacityExceeded();
        }
        else {
            if (pointer.index > index)
                generation += 1;
            if (generation !== this.data[1])
                this.throwCapacityExceeded();
        }
        {
            if (pointer.corralGeneration > this.corral[1]) {
                throw new InternalError('Pointer corral generation older than corral');
            }
            if (pointer.corralGeneration === this.corral[1] && pointer.corralIndex > this.corral[0]) {
                throw new InternalError('Pointer past end of log corral area');
            }
        }
    }
    throwCapacityExceeded() {
        throw new CheckError(`Log capacity exceeded, please raise ${this.configParamName} above ${this.maxEntries}`);
    }
}

/**
 * A fixed but arbitrary size bitset.
 */
class Bitset {
    size;
    bytes;
    constructor(size) {
        this.size = size;
        this.bytes = new Uint32Array(Math.ceil(size / 32));
    }
    get(index) {
        {
            if (index < 0 || index >= this.size) {
                throw new InternalError(`Bit index out of bounds: ${index}`);
            }
        }
        return (this.bytes[index >>> 5] & (1 << (index & 31))) !== 0;
    }
    set(index) {
        {
            if (index < 0 || index >= this.size) {
                throw new InternalError(`Bit index out of bounds: ${index}`);
            }
        }
        this.bytes[index >>> 5] |= (1 << (index & 31));
    }
    unset(index) {
        {
            if (index < 0 || index >= this.size) {
                throw new InternalError(`Bit index out of bounds: ${index}`);
            }
        }
        this.bytes[index >>> 5] &= ~(1 << (index & 31));
    }
    clear() {
        this.bytes.fill(0);
    }
}

class ArrayEntityList {
    pool;
    orderBy;
    entities = [];
    maxOrderKey = -Infinity;
    sorted = true;
    constructor(pool, orderBy) {
        this.pool = pool;
        this.orderBy = orderBy;
    }
    add(id) {
        const entity = this.pool.borrowTemporarily(id);
        if (this.orderBy) {
            const orderKey = this.orderBy(entity);
            if (orderKey >= this.maxOrderKey) {
                this.maxOrderKey = orderKey;
            }
            else {
                this.sorted = false;
            }
        }
        this.entities.push(entity);
    }
    clear() {
        if (this.entities.length)
            this.entities.length = 0;
        this.maxOrderKey = -Infinity;
        this.sorted = true;
    }
    sort() {
        if (this.sorted)
            return;
        const orderBy = this.orderBy;
        for (const entity of this.entities)
            entity.__sortKey = orderBy(entity);
        this.entities.sort((a, b) => {
            return a.__sortKey < b.__sortKey ? -1 : a.__sortKey > b.__sortKey ? +1 : 0;
        });
        this.sorted = true;
    }
}
class PackedArrayEntityList {
    pool;
    orderBy;
    entities = [];
    lookupTable;
    maxOrderKey = -Infinity;
    sorted = true;
    constructor(pool, orderBy, maxEntities) {
        this.pool = pool;
        this.orderBy = orderBy;
        this.lookupTable = new Int32Array(maxEntities);
        this.lookupTable.fill(-1);
    }
    add(id) {
        const entity = this.pool.borrow(id);
        if (this.orderBy) {
            const orderKey = this.orderBy(entity);
            if (orderKey >= this.maxOrderKey) {
                this.maxOrderKey = orderKey;
            }
            else {
                this.sorted = false;
            }
        }
        const index = this.entities.push(entity) - 1;
        this.lookupTable[id] = index;
    }
    remove(id) {
        const index = this.lookupTable[id];
        if (index < 0)
            throw new InternalError('Entity not in list');
        this.pool.return(id);
        this.lookupTable[id] = -1;
        const entity = this.entities.pop();
        if (index < this.entities.length) {
            this.entities[index] = entity;
            this.lookupTable[entity.__id] = index;
            if (this.orderBy)
                this.sorted = false;
        }
    }
    has(id) {
        return this.lookupTable[id] >= 0;
    }
    clear() {
        for (const entity of this.entities)
            this.pool.return(entity.__id);
        this.entities = [];
        this.lookupTable.fill(-1);
        this.maxOrderKey = -Infinity;
        this.sorted = true;
    }
    sort() {
        if (this.sorted)
            return;
        const orderBy = this.orderBy;
        for (const entity of this.entities)
            entity.__sortKey = orderBy(entity);
        this.entities.sort((a, b) => {
            return a.__sortKey < b.__sortKey ? -1 : a.__sortKey > b.__sortKey ? +1 : 0;
        });
        for (let i = 0; i < this.entities.length; i++) {
            this.lookupTable[this.entities[i].__id] = i;
        }
        this.sorted = true;
    }
}

var QueryFlavor;
(function (QueryFlavor) {
    QueryFlavor[QueryFlavor["current"] = 1] = "current";
    QueryFlavor[QueryFlavor["added"] = 2] = "added";
    QueryFlavor[QueryFlavor["removed"] = 4] = "removed";
    QueryFlavor[QueryFlavor["changed"] = 8] = "changed";
    QueryFlavor[QueryFlavor["addedOrChanged"] = 16] = "addedOrChanged";
    QueryFlavor[QueryFlavor["changedOrRemoved"] = 32] = "changedOrRemoved";
    QueryFlavor[QueryFlavor["addedChangedOrRemoved"] = 64] = "addedChangedOrRemoved";
})(QueryFlavor || (QueryFlavor = {}));
const transientFlavorsMask = QueryFlavor.added | QueryFlavor.removed | QueryFlavor.changed | QueryFlavor.addedOrChanged |
    QueryFlavor.changedOrRemoved | QueryFlavor.addedChangedOrRemoved;
const changedFlavorsMask = QueryFlavor.changed | QueryFlavor.addedOrChanged | QueryFlavor.changedOrRemoved |
    QueryFlavor.addedChangedOrRemoved;
const shapeFlavorsMask = QueryFlavor.added | QueryFlavor.removed | QueryFlavor.addedOrChanged |
    QueryFlavor.changedOrRemoved | QueryFlavor.addedChangedOrRemoved;
class QueryBox {
    system;
    results = {};
    flavors = 0;
    withMask;
    withValues;
    withAnyRecords;
    withoutMask;
    withoutEnumTypes;
    trackWritesMask;
    orderBy;
    hasTransientResults;
    hasChangedResults;
    hasShapeResults;
    hasMatchTracking;
    currentEntities;
    processedEntities;
    changedEntities;
    constructor(query, system) {
        this.system = system;
        query.__results = this.results;
        query.__systemName = system.name;
    }
    complete() {
        const dispatcher = this.system.dispatcher;
        this.hasTransientResults = Boolean(this.flavors & transientFlavorsMask);
        this.hasChangedResults = Boolean(this.flavors & changedFlavorsMask);
        this.hasShapeResults = Boolean(this.flavors & shapeFlavorsMask);
        this.hasMatchTracking = Boolean(this.withAnyRecords?.some(record => record.lastMatches));
        {
            if (this.withMask && this.withoutMask) {
                const minLength = Math.min(this.withMask.length, this.withoutMask.length);
                for (let i = 0; i < minLength; i++) {
                    if ((this.withMask[i] & this.withoutMask[i]) !== 0) {
                        throw new CheckError('Query must not list a component type in both `with` and `without` clauses');
                    }
                }
            }
            if (this.withAnyRecords && this.withoutMask) {
                for (const { mask } of this.withAnyRecords) {
                    const minLength = Math.min(mask.length, this.withoutMask.length);
                    for (let i = 0; i < minLength; i++) {
                        if ((mask[i] & this.withoutMask[i]) !== 0) {
                            throw new CheckError('Query must not list a component type in both `withAny` and `without` clauses');
                        }
                    }
                }
            }
            const hasTrackers = !!this.trackWritesMask || this.withAnyRecords?.some(item => item.lastMatches);
            if (this.hasChangedResults && !hasTrackers) {
                throw new CheckError(`Query for changed entities must track at least one component`);
            }
            if (!this.hasChangedResults && hasTrackers) {
                throw new CheckError('You can only track components if you have a query for changed entities');
            }
        }
        if (this.flavors & QueryFlavor.current) {
            this.results.current =
                new PackedArrayEntityList(dispatcher.registry.pool, this.orderBy, dispatcher.maxEntities);
        }
        else {
            this.currentEntities = new Bitset(dispatcher.maxEntities);
        }
        this.processedEntities = new Bitset(dispatcher.maxEntities);
        if (this.hasTransientResults)
            this.allocateTransientResultLists();
        if (this.flavors)
            this.system.shapeQueries.push(this);
        if (this.hasChangedResults) {
            this.changedEntities = new Bitset(dispatcher.maxEntities);
            this.system.writeQueries.push(this);
        }
    }
    allocateTransientResultLists() {
        if (this.flavors & QueryFlavor.added)
            this.allocateResult('added');
        if (this.flavors & QueryFlavor.removed)
            this.allocateResult('removed');
        if (this.flavors & QueryFlavor.changed)
            this.allocateResult('changed');
        if (this.flavors & QueryFlavor.addedOrChanged)
            this.allocateResult('addedOrChanged');
        if (this.flavors & QueryFlavor.changedOrRemoved)
            this.allocateResult('changedOrRemoved');
        if (this.flavors & QueryFlavor.addedChangedOrRemoved) {
            this.allocateResult('addedChangedOrRemoved');
        }
    }
    allocateResult(name) {
        const dispatcher = this.system.dispatcher;
        this.results[name] = new ArrayEntityList(dispatcher.registry.pool, this.orderBy);
    }
    clearTransientResults() {
        if (!this.hasTransientResults)
            return;
        this.results.added?.clear();
        this.results.removed?.clear();
        this.results.changed?.clear();
        this.results.addedOrChanged?.clear();
        this.results.changedOrRemoved?.clear();
        this.results.addedChangedOrRemoved?.clear();
        this.changedEntities?.clear();
    }
    clearAllResults() {
        this.clearTransientResults();
        this.results.current?.clear();
    }
    clearProcessedEntities() {
        this.processedEntities.clear();
    }
    handleShapeUpdate(id) {
        if (this.processedEntities.get(id))
            return;
        this.processedEntities.set(id);
        const registry = this.system.dispatcher.registry;
        const oldMatch = this.results.current?.has(id) ?? this.currentEntities.get(id);
        const newMatch = registry.matchShape(id, this.withMask, this.withValues, this.withAnyRecords, this.withoutMask, this.withoutEnumTypes);
        if (newMatch && !oldMatch) {
            this.currentEntities?.set(id);
            this.changedEntities?.set(id);
            this.results.current?.add(id);
            this.results.added?.add(id);
            this.results.addedOrChanged?.add(id);
            this.results.addedChangedOrRemoved?.add(id);
        }
        else if (!newMatch && oldMatch) {
            this.currentEntities?.unset(id);
            this.changedEntities?.set(id);
            this.results.current?.remove(id);
            this.results.removed?.add(id);
            this.results.changedOrRemoved?.add(id);
            this.results.addedChangedOrRemoved?.add(id);
        }
        else if (newMatch && oldMatch && this.hasMatchTracking) {
            for (const record of this.withAnyRecords) {
                if (record.changed) {
                    this.changedEntities.set(id);
                    this.results.changed?.add(id);
                    this.results.addedOrChanged?.add(id);
                    this.results.changedOrRemoved?.add(id);
                    this.results.addedChangedOrRemoved?.add(id);
                    break;
                }
            }
        }
    }
    handleWrite(id, componentFlagOffset, componentFlagMask) {
        if (!this.changedEntities.get(id) &&
            (this.hasShapeResults ?
                (this.results.current?.has(id) ?? this.currentEntities.get(id)) :
                this.system.dispatcher.registry.matchShape(id, this.withMask, this.withValues, this.withAnyRecords, this.withoutMask, this.withoutEnumTypes)) &&
            (this.trackWritesMask[componentFlagOffset] ?? 0) & componentFlagMask) {
            this.changedEntities.set(id);
            this.results.changed?.add(id);
            this.results.addedOrChanged?.add(id);
            this.results.changedOrRemoved?.add(id);
            this.results.addedChangedOrRemoved?.add(id);
        }
    }
    sort() {
        this.results.current?.sort();
        this.results.added?.sort();
        this.results.removed?.sort();
        this.results.changed?.sort();
        this.results.addedOrChanged?.sort();
        this.results.changedOrRemoved?.sort();
        this.results.addedChangedOrRemoved?.sort();
    }
}
/**
 * A fluent DSL for specifying a family of queries over the world's entities.
 *
 * Each query has a number of aspects:
 * 1. What components an entity must (`with`) and must not (`without`) have to be selected.
 * 2. Whether to return all `current` entities that satisfy the query, only various deltas from the
 *    last frame (`added`, `removed`, `changed`, etc.).  It's permitted and encouraged to declare
 *    multiple such variants on a single query if needed.  For the delta queries, each entity will
 *    be compared against the query's value in the previous frame, so an entity that changes state
 *    and changes back again between system executions will not be selected.
 * 3. Which component types the query will read and write.  This doesn't affect the results of the
 *    query but is used to order and deconflict systems.
 */
class QueryBuilder {
    __callback;
    __userQuery;
    __query;
    __system;
    __lastTypes;
    __lastWasWithAny;
    constructor(__callback, __userQuery) {
        this.__callback = __callback;
        this.__userQuery = __userQuery;
    }
    __build(system) {
        try {
            this.__system = system;
            this.__query = new QueryBox(this.__userQuery, system);
            this.__callback(this);
            if (!this.__query.withMask && this.__query.flavors) {
                this.set('withMask', [this.__system.dispatcher.registry.Alive]);
            }
            this.__query.complete();
        }
        catch (e) {
            e.message = `Failed to build query in system ${system.name}: ${e.message}`;
            throw e;
        }
    }
    // TODO: support partitioned queries in stateless systems
    /**
     * A noop connector to make a query definition read better.
     */
    get and() {
        return this;
    }
    /**
     * A noop connector to make a query definition read better.
     */
    get but() {
        return this;
    }
    /**
     * A noop connector to make a query definition read better.
     */
    get also() {
        return this;
    }
    /**
     * Requests the maintenance of a list of all entities that currently satisfy the query.  This is
     * the most common use of queries.
     */
    get current() {
        this.__query.flavors |= QueryFlavor.current;
        return this;
    }
    /**
     * Requests that a list of all entities that newly satisfy the query be made available each frame.
     */
    get added() {
        this.__query.flavors |= QueryFlavor.added;
        return this;
    }
    /**
     * Requests that a list of all entities that no longer satisfy the query be made available each
     * frame.
     */
    get removed() {
        this.__query.flavors |= QueryFlavor.removed;
        return this;
    }
    /**
     * Requests that a list of all entities that were recently written to and satisfy the query be
     * made available each frame.  You must additionally specify which components the write detection
     * should be sensitive to using `trackWrites`.
     */
    get changed() {
        this.__query.flavors |= QueryFlavor.changed;
        return this;
    }
    /**
     * A combination of the `added` and `changed` query types, with the advantage that an entity that
     * satisfies both will only appear once.
     */
    get addedOrChanged() {
        this.__query.flavors |= QueryFlavor.addedOrChanged;
        return this;
    }
    /**
     * A combination of the `changed` and `removed` query types, with the advantage that an entity
     * that satisfies both will only appear once.
     */
    get changedOrRemoved() {
        this.__query.flavors |= QueryFlavor.changedOrRemoved;
        return this;
    }
    /**
     * A combination of the `added`, `changed`, and `removed` query types, with the advantage that an
     * entity that satisfies multiple ones will only appear once.
     */
    get addedChangedOrRemoved() {
        this.__query.flavors |= QueryFlavor.addedChangedOrRemoved;
        return this;
    }
    /**
     * Order query results in ascending order of the given function's output for each entity.
     * @example
     *   q.added.orderBy(entity => entity.ordinal)
     * @param transformer A function that transforms an entity to a number for sorting.
     */
    orderBy(transformer) {
        this.__query.orderBy = transformer;
        return this;
    }
    /**
     * Constrains the query to entities that possess components of all the given types.  All given
     * types are also marked as `read`.
     *
     * All `with` clauses are combined into a single `O(1)` check.
     *
     * You cannot pass in enums since by definition it's impossible for an entity to possess more than
     * one component from an enum.  See {@link QueryBuilder.withAny} instead.
     * @param types The types of components required to match the query.
     */
    with(...types) {
        this.set(this.__system.accessMasks.read, types);
        this.set('withMask');
        return this;
    }
    /**
     * Constrains the query to entities that possess a component of at least one of the given types.
     * All given types are also marked as `read`.
     *
     * Unlike `with`, `withAny` clauses are not combined; each is evaluated as a separate check, which
     * may affect performance.
     *
     * You cannot pass in enum component types, only whole enums.
     * @param types
     */
    withAny(...types) {
        for (const type of types) {
            if (typeof type === 'function' && type.enum) {
                throw new CheckError(`Cannot use enum types in a withAny clause: ${type.name}`);
            }
        }
        this.set(this.__system.accessMasks.read, types);
        if (!this.__query.withAnyRecords)
            this.__query.withAnyRecords = [];
        const mask = [];
        this.__query.withAnyRecords.push({ mask, lastMatches: undefined, changed: false });
        this.set(mask);
        return this;
    }
    /**
     * Constrains the query to entities that don't possess components of any of the given types.  All
     * given types are also marked as `read`.
     *
     * While you can pass in enum component types, evaluating such queries is inefficient (`O(n)` in
     * the number of enum types passed).  Passing in whole enums is fine, though (the query stays
     * `O(1)`).
     * @param types The types of components that must not be present to match the query.
     */
    without(...types) {
        this.set(this.__system.accessMasks.read, types);
        this.set('withoutMask');
        return this;
    }
    /**
     * Mentions some component types for follow-up modifiers.
     * @param types The types of components for follow-up modifiers, but that don't constrain the
     * query.
     */
    using(...types) {
        this.__lastTypes = types;
        return this;
    }
    /**
     * Makes all component types in the world available for follow-up modifiers.  This can be modified
     * with a `.write` as usual, and may be useful in "sweeper" systems that want to be able to, e.g.,
     * delete any entity without having to worry what it might hold refs to or what components might
     * have backrefs pointing to it.
     */
    get usingAll() {
        // All types except Alive, which is always at index 0.
        this.__lastTypes = this.__system.dispatcher.registry.types.slice(1);
        return this;
    }
    /**
     * Marks writes to the most recently mentioned component types as trackable for `changed` query
     * flavors.  An entity will be considered changed if any system called `write` on one of those
     * components since the last frame.
     */
    get trackWrites() {
        this.set('trackWritesMask');
        for (const type of this.__lastTypes) {
            if (typeof type === 'function') {
                type.__binding.trackedWrites = true;
            }
            else {
                for (const enumType of type.__types)
                    enumType.__binding.trackedWrites = true;
            }
        }
        return this;
    }
    /**
     * Marks changes in the matching set of the immediately preceding `withAny` component types as
     * trackable for `changed` query flavors.  An entity will be considered changed if it matched the
     * query in the last frame and still matches it in the current frame, but satisfied the `withAny`
     * constraint with a different set of components.
     *
     * This tracking is particularly useful for detecting changing enum states, but can be applied to
     * any set of components.
     */
    get trackMatches() {
        if (!this.__lastWasWithAny) {
            throw new Error('You can only apply trackMatches to a withAny clause');
        }
        this.__query.withAnyRecords[this.__query.withAnyRecords.length - 1].lastMatches = [];
        return this;
    }
    /**
     * Marks the most recently mentioned component types as read by the system.  This declaration
     * is enforced: you will only be able to read components of types thus declared.
     */
    get read() {
        this.set(this.__system.accessMasks.read);
        return this;
    }
    /**
     * Marks the most recently mentioned component types as created (and only created!) by the system.
     * This means that the component types will only be used in `createEntity` calls; they cannot be
     * otherwise read, checked for (`has` methods), or written.  It can run concurrently with other
     * `create` entitlements but counts as a `write` for purposes of system ordering.
     */
    get create() {
        this.set(this.__system.accessMasks.create);
        return this;
    }
    /**
     * Marks the most recently mentioned component types as indirectly updated by the system.  This
     * covers automatic change propagation to non-writable fields such as updates of `backrefs`
     * properties; however, it doesn't cover automatic clearing of refs to a deleted entity.  It can
     * run concurrently with other `read` and `update` entitlements but counts as a `write` for
     * purposes of system ordering.
     */
    get update() {
        this.set(this.__system.accessMasks.update);
        return this;
    }
    /**
     * Marks the most recently mentioned component types as read, written, created and/or updated by
     * the system.  This declaration is enforced: you will only be able to read and write to component
     * of types thus declared. You should try to declare the minimum writable set that your system
     * will need to improve ordering and concurrency.
     */
    get write() {
        this.set(this.__system.accessMasks.write);
        this.set(this.__system.accessMasks.read);
        this.set(this.__system.accessMasks.create);
        this.set(this.__system.accessMasks.update);
        return this;
    }
    set(mask, types) {
        if (!mask)
            return;
        if (types) {
            for (const type of types)
                checkTypeDefined(type);
        }
        if (!types)
            types = this.__lastTypes;
        if (!types)
            throw new InternalError('No component type to apply query modifier to');
        this.__lastTypes = types;
        if (typeof mask === 'string') {
            if (!this.__query[mask])
                this.__query[mask] = [];
            mask = this.__query[mask];
        }
        this.__lastWasWithAny = this.__query.withAnyRecords?.some(item => item.mask === mask) ?? false;
        const readMask = mask === this.__system.accessMasks.read;
        const updateMask = mask === this.__system.accessMasks.update;
        const createMask = mask === this.__system.accessMasks.create;
        const writeMask = mask === this.__system.accessMasks.write;
        const withMask = mask === this.__query.withMask;
        const withoutMask = mask === this.__query.withoutMask;
        const shapeMask = mask === this.__query.withMask || mask === this.__query.withoutMask || this.__lastWasWithAny;
        const trackMask = mask === this.__query.trackWritesMask;
        const map = readMask ? this.__system.dispatcher.planner.readers :
            writeMask || createMask || updateMask ? this.__system.dispatcher.planner.writers :
                undefined;
        for (const type of types) {
            {
                if (!isMaskFlagSet(this.__system.accessMasks.write, type) && (readMask && isMaskFlagSet(this.__system.accessMasks.create, type) ||
                    createMask && isMaskFlagSet(this.__system.accessMasks.read, type))) {
                    throw new CheckError(`Cannot combine create and read entitlements for component type ${type.name}; ` +
                        `just use a write entitlement instead`);
                }
            }
            if (withoutMask && typeof type === 'function' && type.enum) {
                this.__query.withoutEnumTypes = this.__query.withoutEnumTypes ?? [];
                this.__query.withoutEnumTypes.push(type);
            }
            else {
                extendMaskAndSetFlag(mask, type);
                if (withMask) {
                    if (!this.__query.withValues)
                        this.__query.withValues = [];
                    extendMaskAndSetFlag(this.__query.withValues, type, true);
                }
            }
            if (readMask)
                extendMaskAndSetFlag(this.__system.accessMasks.check, type);
            if (typeof type === 'function') {
                if (map)
                    map.get(type).add(this.__system);
                if (shapeMask)
                    this.categorize(this.__system.shapeQueriesByComponent, type);
                if (trackMask)
                    this.categorize(this.__system.writeQueriesByComponent, type);
            }
            else {
                for (const enumType of type.__types) {
                    if (map)
                        map.get(enumType).add(this.__system);
                    if (shapeMask)
                        this.categorize(this.__system.shapeQueriesByComponent, enumType);
                    if (trackMask)
                        this.categorize(this.__system.writeQueriesByComponent, enumType);
                }
            }
        }
    }
    categorize(index, type) {
        const id = type.id;
        if (!index[id])
            index[id] = [];
        if (!index[id].includes(this.__query))
            index[id].push(this.__query);
    }
}
class Query {
    __results;
    __systemName;
    // TODO: add an API for freezing/thawing a query
    /**
     * A list of all entities that match this query as of the beginning of the system's current (or
     * last) execution.
     *
     * You must not keep a reference to these entities beyond the local scope of a system's execution.
     * To obtain an object for long-term use please see {@link Entity.hold}.
     */
    get current() {
        this.__checkList('current');
        return this.__results.current.entities;
    }
    /**
     * A list of all entities that newly started matching this query between the system's current (or
     * last) and previous executions.
     *
     * You must not keep a reference to these entities beyond the local scope of a system's execution.
     * To obtain an object for long-term use please see {@link Entity.hold}.
     */
    get added() {
        this.__checkList('added');
        return this.__results.added.entities;
    }
    /**
     * A list of all entities that newly stopped matching this query between the system's current (or
     * last) and previous executions.
     *
     * You must not keep a reference to these entities beyond the local scope of a system's execution.
     * To obtain an object for long-term use please see {@link Entity.hold}.
     */
    get removed() {
        this.__checkList('removed');
        return this.__results.removed.entities;
    }
    /**
     * A list of all entities that match this query as of the beginning of of the system's current (or
     * last) execution, and that had tracked components written to between the system's current (or
     * last) and previous executions.
     *
     * You must not keep a reference to these entities beyond the local scope of a system's execution.
     * To obtain an object for long-term use please see {@link Entity.hold}.
     */
    get changed() {
        this.__checkList('changed');
        return this.__results.changed.entities;
    }
    /**
     * A list that combines `added` and `changed`, but without duplicate entities.
     *
     * You must not keep a reference to these entities beyond the local scope of a system's execution.
     * To obtain an object for long-term use please see {@link Entity.hold}.
     */
    get addedOrChanged() {
        this.__checkList('addedOrChanged');
        return this.__results.addedOrChanged.entities;
    }
    /**
     * A list that combines `changed` and `removed`, but without duplicate entities.
     *
     * You must not keep a reference to these entities beyond the local scope of a system's execution.
     * To obtain an object for long-term use please see {@link Entity.hold}.
     */
    get changedOrRemoved() {
        this.__checkList('changedOrRemoved');
        return this.__results.changedOrRemoved.entities;
    }
    /**
     * A list that combines `added`, `changed`, and `removed`, but without duplicate entities.
     *
     * You must not keep a reference to these entities beyond the local scope of a system's execution.
     * To obtain an object for long-term use please see {@link Entity.hold}.
     */
    get addedChangedOrRemoved() {
        this.__checkList('addedChangedOrRemoved');
        return this.__results.addedChangedOrRemoved.entities;
    }
    __checkList(flavor) {
        const list = this.__results[flavor];
        if (!list) {
            throw new CheckError(`Query '${flavor}' not configured, please add .${flavor} to your query definition in ` +
                `system ${this.__systemName}`);
        }
    }
}

const now = typeof window !== 'undefined' && typeof window.performance !== 'undefined' ?
    performance.now.bind(performance) : Date.now.bind(Date);
// TODO: support replicated systems
// TODO: support continuously executed systems
/**
 * A fluent DSL for specifying a system's scheduling constraints.
 *
 * Any given pair of systems will be ordered by the first of the following rules that matches:
 * 1. A system was explicitly placed `before` or `after` another.
 * 2. A system was explicitly left unordered with respect to another using `inAnyOrderWith`.
 * 3. A system was implicitly placed before or after another system based on the components the
 *    other system reads or writes, using `beforeReadersOf`, `afterReadersOf`, `beforeWritersOf` or
 *    `afterWritersOf`.
 * 4. A system was explicitly left unordered with respect to another using `inAnyOrderWithReadersOf`
 *    or `inAnyOrderWithWritersOf`.
 * 5. A system was implicitly placed after another because it reads a component that the other
 *    system writes.
 *
 * If there are multiple constraints at the same priority level they will conflict and create a
 * cycle.  If there are any cycles in the order graph (whether due to explicit conflicts or implicit
 * circular dependencies), world creation will fail with an informative error and you'll need to
 * break the cycles by adding scheduling constraints to the systems involved.
 */
class ScheduleBuilder {
    __callback;
    __schedule;
    __systems;
    __dispatcher;
    constructor(__callback, __schedule) {
        this.__callback = __callback;
        this.__schedule = __schedule;
    }
    __build(systems, name) {
        try {
            this.__systems = systems;
            this.__dispatcher = systems[0].dispatcher;
            this.__callback(this);
        }
        catch (e) {
            e.message = `Failed to build schedule in ${name}: ${e.message}`;
            throw e;
        }
    }
    /**
     * Returns a group that includes all the world's systems.
     */
    get allSystems() {
        return this.__dispatcher.defaultGroup;
    }
    /**
     * Forces this system to only execute on the main thread.  This is needed for systems that
     * interact with APIs only available in the main thread such as the DOM.
     * @returns The builder for chaining calls.
     */
    get onMainThread() {
        this.__checkNoLaneAssigned();
        this.__dispatcher.planner.mainLane?.add(...this.__systems);
        return this;
    }
    /**
     * Executes this system consistently on a single thread.  This is the default behavior to
     * accommodate systems with internal state.
     * @returns The builder for chaining calls.
     */
    get onOneThread() {
        this.__checkNoLaneAssigned();
        this.__dispatcher.planner.createLane().add(...this.__systems);
        return this;
    }
    /**
     * Replicates this system among multiple threads and execute it on any one of them, possibly a
     * different one each time.  This allows Becsy to better utilize available CPUs but requires the
     * system to be stateless (except for queries and attached systems).  Note that `prepare` and
     * `initialize` will be called on each replicated instance of the system!
     * @returns The builder for chaining calls.
     */
    get onManyThreads() {
        this.__checkNoLaneAssigned();
        this.__dispatcher.planner.replicatedLane?.add(...this.__systems);
        for (const system of this.__systems)
            system.stateless = true;
        return this;
    }
    __checkNoLaneAssigned() {
        if (this.__systems.some(system => system.lane)) {
            throw new CheckError(`Threading semantics already specified`);
        }
    }
    /**
     * Schedules this system before all the given ones (highest priority).  Any systems present in
     * both the receiver and the target are skipped.
     * @param systemTypes The systems or groups that this one should precede.
     * @returns The builder for chaining calls.
     */
    before(...systemTypes) {
        const thisSet = new Set(this.__systems);
        for (const type of systemTypes) {
            for (const other of this.__dispatcher.getSystems(type)) {
                if (thisSet.has(other))
                    continue;
                for (const system of this.__systems) {
                    this.__dispatcher.planner.graph.addEdge(system, other, 5);
                }
            }
        }
        return this;
    }
    /**
     * Schedules this system after all the given ones (highest priority).  Any systems present in
     * both the receiver and the target are skipped.
     * @param systemTypes The systems or groups that this one should follow.
     * @returns The builder for chaining calls.
     */
    after(...systemTypes) {
        const thisSet = new Set(this.__systems);
        for (const type of systemTypes) {
            for (const other of this.__dispatcher.getSystems(type)) {
                if (thisSet.has(other))
                    continue;
                for (const system of this.__systems) {
                    this.__dispatcher.planner.graph.addEdge(other, system, 5);
                }
            }
        }
        return this;
    }
    /**
     * Schedules this system in any order relative to the given ones (high priority).
     * @param systemTypes The systems or groups whose order doesn't matter relative to this one.
     * @returns The builder for chaining calls.
     */
    inAnyOrderWith(...systemTypes) {
        for (const type of systemTypes) {
            for (const other of this.__dispatcher.getSystems(type)) {
                for (const system of this.__systems) {
                    this.__dispatcher.planner.graph.denyEdge(system, other, 4);
                }
            }
        }
        return this;
    }
    /**
     * Schedules this system before all other systems that declared a read dependency on the given
     * component types (medium priority).
     * @param componentTypes The component types whose readers this system should precede.
     * @returns The builder for chaining calls.
     */
    beforeReadersOf(...componentTypes) {
        for (const componentType of componentTypes) {
            for (const other of this.__dispatcher.planner.readers.get(componentType)) {
                for (const system of this.__systems) {
                    this.__dispatcher.planner.graph.addEdge(system, other, 3);
                }
            }
        }
        return this;
    }
    /**
     * Schedules this system after all other systems that declared a read dependency on the given
     * component types (medium priority).
     * @param componentTypes The component types whose readers this system should follow.
     * @returns The builder for chaining calls.
     */
    afterReadersOf(...componentTypes) {
        for (const componentType of componentTypes) {
            for (const other of this.__dispatcher.planner.readers.get(componentType)) {
                for (const system of this.__systems) {
                    this.__dispatcher.planner.graph.addEdge(other, system, 3);
                }
            }
        }
        return this;
    }
    /**
     * Schedules this system before all other systems that declared a write dependency on the given
     * component types (medium priority).
     * @param componentTypes The component types whose writers this system should precede.
     * @returns The builder for chaining calls.
     */
    beforeWritersOf(...componentTypes) {
        for (const componentType of componentTypes) {
            for (const other of this.__dispatcher.planner.writers.get(componentType)) {
                for (const system of this.__systems) {
                    this.__dispatcher.planner.graph.addEdge(system, other, 3);
                }
            }
        }
        return this;
    }
    /**
     * Schedules this system after all other systems that declared a write dependency on the given
     * component types (medium priority).
     * @param componentTypes The component types whose writers this system should follow.
     * @returns The builder for chaining calls.
     */
    afterWritersOf(...componentTypes) {
        for (const componentType of componentTypes) {
            for (const other of this.__dispatcher.planner.writers.get(componentType)) {
                for (const system of this.__systems) {
                    this.__dispatcher.planner.graph.addEdge(other, system, 3);
                }
            }
        }
        return this;
    }
    /**
     * Schedules this system in any order relative to systems that declared a read dependency on the
     * given component types (low priority).
     * @param componentTypes The component types whose readers' order doesn't matter relative to this
     *  one.
     * @returns The builder for chaining calls.
     */
    inAnyOrderWithReadersOf(...componentTypes) {
        for (const componentType of componentTypes) {
            for (const other of this.__dispatcher.planner.readers.get(componentType)) {
                for (const system of this.__systems) {
                    this.__dispatcher.planner.graph.denyEdge(other, system, 2);
                }
            }
        }
        return this;
    }
    /**
     * Schedules this system in any order relative to systems that declared a write dependency on the
     * given component types (low priority).
     * @param componentTypes The component types whose writers' order doesn't matter relative to this
     *  one.
     * @returns The builder for chaining calls.
     */
    inAnyOrderWithWritersOf(...componentTypes) {
        for (const componentType of componentTypes) {
            for (const other of this.__dispatcher.planner.writers.get(componentType)) {
                for (const system of this.__systems) {
                    this.__dispatcher.planner.graph.denyEdge(other, system, 2);
                }
            }
        }
        return this;
    }
}
/**
 * A placeholder object returned from {@link System.schedule} with no public API.
 */
class Schedule {
}
class SystemGroupImpl {
    __contents;
    __plan;
    __executed = false;
    __systems;
    __scheduleBuilder;
    constructor(__contents) {
        this.__contents = __contents;
    }
    __collectSystems(dispatcher) {
        if (!this.__systems) {
            this.__systems = [];
            for (const item of this.__contents) {
                if (item instanceof Function && item.__system) {
                    this.__systems.push(dispatcher.systemsByClass.get(item));
                }
                else if (item instanceof SystemGroupImpl) {
                    this.__systems.push(...item.__collectSystems(dispatcher));
                }
            }
        }
        return this.__systems;
    }
    __buildSchedule() {
        this.__scheduleBuilder?.__build(this.__systems, `a group`);
        this.__scheduleBuilder = null;
    }
    /**
     * Creates scheduling constraints for all systems in the group; this works exactly as if the
     * call was made individually to every {@link System.schedule}.  Can be called at most once.
     * @param buildCallback A function that constrains the schedule using a small DSL.  See
     * {@link ScheduleBuilder} for the API.
     * @returns This group for chaining calls.
     */
    schedule(buildCallback) {
        if (this.__scheduleBuilder === null) {
            throw new CheckError(`Attempt to define group schedule after world initialized`);
        }
        if (this.__scheduleBuilder) {
            throw new CheckError(`Attempt to define multiple schedules in a group`);
        }
        this.__scheduleBuilder = new ScheduleBuilder(buildCallback, new Schedule());
        return this;
    }
}
class FrameImpl {
    dispatcher;
    groups;
    executing;
    time = now() / 1000;
    delta;
    constructor(dispatcher, groups) {
        this.dispatcher = dispatcher;
        this.groups = groups;
        if (groups.length === 0) {
            throw new CheckError('At least one system group needed');
        }
        for (const group of groups) {
            if (!dispatcher.systemGroups.includes(group)) {
                throw new CheckError('Some groups in the frame are not parts of the world defs');
            }
        }
    }
    /**
     * Indicates that execution of a frame has begun and locks in the default `time` and `delta`.
     * Must be called once at the beginning of each frame, prior to any calls to `execute`.  Must be
     * bookended by a call to `end`.
     *
     * You cannot call `begin` while any other executors are running.
     */
    async begin() {
        if (this.executing)
            throw new CheckError('Frame already executing');
        this.executing = true;
        const lastTime = this.dispatcher.lastTime ?? this.time;
        this.time = now() / 1000;
        this.delta = this.time - lastTime;
        this.dispatcher.startFrame(this.time);
    }
    /**
     * Indicates that execution of a frame has completed.  Must be called once at the end of each
     * frame, after any calls to `execute`.
     */
    async end() {
        if (!this.executing)
            throw new CheckError('Frame not executing');
        this.executing = false;
        allExecuted: {
            for (const group of this.groups)
                if (!group.__executed)
                    break allExecuted;
            for (const group of this.groups)
                group.__executed = false;
            this.dispatcher.completeCycle();
        }
        await this.dispatcher.completeFrame();
    }
    /**
     * Executes a group of systems.  If your world is single-threaded then execution is synchronous
     * and you can ignore the returned promise.
     *
     * You cannot execute individual systems, unless you create a singleton group to hold them.
     *
     * @param group The group of systems to execute.  Must be a member of the group list passed in
     * when this executor was created.
     *
     * @param time The time of this frame's execution.  This will be set on every system's `time`
     * property and defaults to the time when `begin` was called.  It's not used internally so you can
     * pass in any numeric value that's expected by your systems.
     *
     * @param delta The duration since the last frame's execution.  This will be set on every system's
     * `delta` property and default to the duration since any previous frame's `begin` was called.
     * It's not used internally so you can pass in any numeric value that's expected by your systems.
     */
    execute(group, time, delta) {
        if (!this.groups.includes(group)) {
            throw new CheckError('Group not included in this frame');
        }
        if (!this.executing)
            throw new CheckError('Frame not executing');
        return group.__plan.execute(time ?? this.time, delta ?? this.delta);
    }
}

/**
 * An exception thrown by coroutines when they've been canceled. You should normally rethrow it
 * from any catch blocks, and it will be caught and ignored at the top coroutine nesting level.
 */
class CanceledError extends Error {
    canceled = true;
    constructor() {
        super('Canceled');
    }
}
let currentCoroutine;
class CoroutineImpl {
    __generator;
    __fn;
    __supervisor;
    __cancellers = [];
    __blocker;
    __scope;
    __done = false;
    __awaited = false;
    __error;
    __value;
    __firstRun = true;
    constructor(__generator, __fn, __supervisor) {
        this.__generator = __generator;
        this.__fn = __fn;
        this.__supervisor = __supervisor;
    }
    __checkCancelation() {
        if (this.__firstRun) {
            this.__firstRun = false;
            this.__supervisor.cancelMatching(this, this.__scope, this.__fn);
        }
        if (!this.__done) {
            for (const canceller of this.__cancellers) {
                if (canceller()) {
                    this.cancel();
                    break;
                }
            }
        }
    }
    __step() {
        currentCoroutine = this;
        try {
            if (!this.__done && (this.__blocker?.isReady() ?? true)) {
                try {
                    let next;
                    if (this.__blocker?.error) {
                        next = this.__generator.throw(this.__blocker.error);
                    }
                    else {
                        next = this.__generator.next(this.__blocker?.value);
                    }
                    if (next.done) {
                        this.__done = true;
                        this.__value = next.value;
                        this.__blocker = undefined;
                    }
                    else {
                        this.__blocker = next.value;
                        this.__blocker?.markAwaited?.();
                    }
                }
                catch (e) {
                    this.__done = true;
                    if (!this.__error)
                        this.__error = e;
                    this.__blocker = undefined;
                }
            }
            if (this.__error && !(this.__awaited || this.__error instanceof CanceledError)) {
                throw this.__error;
            }
        }
        finally {
            currentCoroutine = undefined;
        }
    }
    // Waitable methods
    isReady() {
        return this.__done;
    }
    get value() {
        return this.__value;
    }
    get error() {
        return this.__error;
    }
    markAwaited() {
        this.__awaited = true;
    }
    // CurrentCoroutine methods
    waitForFrames(frames) {
        if (frames <= 0)
            throw new CheckError('Number of frames to wait for must be >0');
        return {
            isReady() { return --frames <= 0; }
        };
    }
    waitForSeconds(seconds) {
        const system = this.__supervisor.system;
        const targetTime = system.time + seconds;
        return {
            isReady() { return system.time >= targetTime; }
        };
    }
    waitUntil(condition) {
        return { isReady: condition };
    }
    // Coroutine methods
    cancel() {
        if (this.__blocker?.cancel) {
            this.__blocker.cancel();
        }
        else {
            this.__error = new CanceledError();
            this.__done = true;
        }
        return this;
    }
    cancelIf(condition) {
        this.__cancellers.push(condition);
        return this;
    }
    scope(entity) {
        if (this.__scope)
            throw new CheckError('Scope already set for this coroutine');
        if (this.__cancellers.length) {
            throw new CheckError('Scope must be set before any cancelation conditions');
        }
        this.__scope = entity;
        this.cancelIf(() => !entity.alive);
        return this;
    }
    cancelIfComponentMissing(type) {
        if (!this.__scope)
            throw new CheckError('Required scope not set for this coroutine');
        this.cancelIf(() => !this.__scope?.has(type));
        return this;
    }
    cancelIfCoroutineStarted(coroutineFn) {
        this.__supervisor.registerCancelIfStarted(this, this.__scope, coroutineFn === coDecorator.self ? this.__fn : coroutineFn);
        return this;
    }
    // We need to stub out all the Generator methods because we're overloading the type.  They must
    // not be called by the user, however.
    return(value) {
        throw new CheckError('Generator methods not available for coroutines');
    }
    throw(e) {
        throw new CheckError('Generator methods not available for coroutines');
    }
    next(...args) {
        throw new CheckError('Generator methods not available for coroutines');
    }
    [Symbol.iterator]() {
        throw new CheckError('Generator methods not available for coroutines');
    }
}
function coDecorator(target, name, descriptor) {
    const coroutine = descriptor.value;
    return {
        value(...args) {
            return this.start(coroutine, ...args);
        },
    };
}
coDecorator.waitForFrames = function (frames) {
    checkCurrentCoroutine();
    return currentCoroutine.waitForFrames(frames);
};
coDecorator.waitForSeconds = function (seconds) {
    checkCurrentCoroutine();
    return currentCoroutine.waitForSeconds(seconds);
};
coDecorator.waitUntil = function (condition) {
    checkCurrentCoroutine();
    return currentCoroutine.waitUntil(condition);
};
coDecorator.cancel = function () {
    checkCurrentCoroutine();
    currentCoroutine.cancel();
};
coDecorator.cancelIf = function (condition) {
    checkCurrentCoroutine();
    return currentCoroutine.cancelIf(condition);
};
coDecorator.scope = function (entity) {
    checkCurrentCoroutine();
    return currentCoroutine.scope(entity);
};
coDecorator.cancelIfComponentMissing = function (type) {
    checkCurrentCoroutine();
    return currentCoroutine.cancelIfComponentMissing(type);
};
coDecorator.cancelIfCoroutineStarted = function (coroutineFn) {
    checkCurrentCoroutine();
    return currentCoroutine.cancelIfCoroutineStarted(coroutineFn);
};
coDecorator.self = function* () { yield; };
function checkCurrentCoroutine() {
    if (!currentCoroutine)
        throw new CheckError('Cannot call co methods outside coroutine context');
}
/**
 * This object can be used in two ways:
 * 1. As a decorator, to wrap coroutine methods in a call to {@link System.start} so you can invoke
 * them directly.
 * 2. As a handle to the currently executing coroutine, so you can invoke coroutine control methods
 * from within the coroutine's code.
 */
const co = coDecorator;
class Supervisor {
    system;
    coroutines = [];
    mutuallyExclusiveCoroutines = new Map();
    constructor(system) {
        this.system = system;
    }
    start(coroutineFn, ...args) {
        const coroutine = new CoroutineImpl(coroutineFn.apply(this.system, args), coroutineFn, this);
        this.coroutines.push(coroutine);
        return coroutine;
    }
    execute() {
        // Execute in reverse order, so that the most recently started coroutines execute first.  That
        // way, if coroutine A started coroutine B and is waiting for it to complete, it will resume in
        // the same frame as B finishes rather than having to wait for another go-around. At the same
        // time, if new coroutines are started while we're processing, keep iterating to execute the
        // extra ones within the same frame.
        let processedLength = 0;
        while (processedLength < this.coroutines.length) {
            const endIndex = processedLength;
            processedLength = this.coroutines.length;
            for (let i = processedLength - 1; i >= endIndex; i--) {
                this.system.accessRecentlyDeletedData(false);
                this.coroutines[i].__checkCancelation();
            }
            for (let i = processedLength - 1; i >= endIndex; i--) {
                this.system.accessRecentlyDeletedData(false);
                const coroutine = this.coroutines[i];
                coroutine.__step();
                if (coroutine.isReady()) {
                    this.coroutines.splice(i, 1);
                    processedLength -= 1;
                }
            }
        }
    }
    registerCancelIfStarted(targetCoroutine, scope, coroutineFn) {
        const key = (scope?.__id ?? '') + (coroutineFn?.name ?? '');
        if (!this.mutuallyExclusiveCoroutines.has(key))
            this.mutuallyExclusiveCoroutines.set(key, []);
        this.mutuallyExclusiveCoroutines.get(key)?.push(targetCoroutine);
    }
    cancelMatching(startingCoroutine, scope, coroutineFn) {
        this.cancelMatchingKey(startingCoroutine, '');
        this.cancelMatchingKey(startingCoroutine, coroutineFn.name);
        if (scope) {
            this.cancelMatchingKey(startingCoroutine, '' + scope.__id);
            this.cancelMatchingKey(startingCoroutine, '' + scope.__id + coroutineFn.name);
        }
    }
    cancelMatchingKey(requestingCoroutine, key) {
        const coroutines = this.mutuallyExclusiveCoroutines.get(key);
        if (coroutines) {
            let hasRequesting = false;
            for (const coroutine of coroutines) {
                if (coroutine === requestingCoroutine) {
                    hasRequesting = true;
                }
                else {
                    coroutine.cancel();
                }
            }
            coroutines.length = 0;
            if (hasRequesting)
                coroutines.push(requestingCoroutine);
        }
    }
}

var RunState;
(function (RunState) {
    RunState[RunState["RUNNING"] = 0] = "RUNNING";
    RunState[RunState["STOPPED"] = 1] = "STOPPED";
})(RunState || (RunState = {}));
class SingletonPlaceholder {
    access;
    type;
    initialValues;
    constructor(access, type, initialValues) {
        this.access = access;
        this.type = type;
        this.initialValues = initialValues;
    }
}
class AttachPlaceholder {
    type;
    constructor(type) {
        this.type = type;
    }
}
// TODO: support HMR for systems
/**
 * An encapsulated piece of functionality for your app that executes every frame, typically by
 * iterating over some components returned by a query.
 *
 * You should subclass and implement {@link System.execute} at a minimum, but take a look at the
 * other methods as well.
 */
class System {
    static __system = true;
    /**
     * Create a group of systems that can be scheduled collectively, or used in
     * {@link World.createCustomExecutor} to execute a subset of all the system in a frame. The group
     * needs to be included in the world's defs, which will also automatically include all its member
     * systems.
     * @param systemTypes System classes to include in the group, each optionally followed by an
     *  object to initialize the system's properties.  A system can be a member of more than one
     *  group.
     * @returns A group of the given systems.
     */
    static group(...systemTypes) {
        return new SystemGroupImpl(systemTypes);
    }
    __queryBuilders = [];
    __scheduleBuilder;
    __attachPlaceholders = [];
    __singletonPlaceholders = [];
    __supervisor = new Supervisor(this);
    __dispatcher;
    /**
     * A numeric ID, unique for systems within a world, that you can use for your own purposes.  Don't
     * change it!
     */
    id;
    /**
     * The time that execution of the current frame was started. See {@link World.execute} for
     * details.
     * @typedef {}
     */
    time;
    /**
     * The duration between the execution times of the current and previous frames.  See
     * {@link World.execute} for details.
     */
    delta;
    /**
     * This system's name, as used in error messages and stats reports.
     */
    get name() { return this.constructor.name; }
    // TODO: add an API for making immediate queries
    /**
     * Creates a persistent query for this system.  Can only be called from the constructor, typically
     * by initializing an instance property.
     *
     * Each query is automatically updated each frame immediately before the system executes.
     * @example
     * entities = this.query(q => q.all.with(ComponentFoo).write);
     * execute() {
     *   for (const entity of this.entities) {
     *     entity.write(ComponentFoo).bar += 1;
     *   }
     * }
     * @param buildCallback A function that builds the actual query using a small DSL.  See
     * {@link QueryBuilder} for the API.
     * @returns A live query that you can reference from the `execute` method.  It's also OK to read
     * a query from other attached systems, but note that it will only be updated prior to its host
     * system's execution.
     */
    query(buildCallback) {
        const query = new Query();
        const builder = new QueryBuilder(buildCallback, query);
        if (!this.__queryBuilders) {
            throw new CheckError(`Attempt to create a new query after world initialized in system ${this.name}`);
        }
        this.__queryBuilders.push(builder);
        return query;
    }
    /**
     * Creates scheduling constraints for this system that will help determine its assignment to a
     * thread and the order of execution.  Can be called at most once, and only from the constructor,
     * typically by initializing an instance property.
     * @example
     * sked = this.schedule(s => s.beforeWritesTo(ComponentFoo).after(SystemBar));
     * @param buildCallback A function that constrains the schedule using a small DSL.  See
     * {@link ScheduleBuilder} for the API.
     * @returns A schedule placeholder object with no public API.
     */
    schedule(buildCallback) {
        if (this.__scheduleBuilder === null) {
            throw new CheckError(`Attempt to define schedule after world initialized in system ${this.name}`);
        }
        if (this.__scheduleBuilder) {
            throw new CheckError(`Attempt to define multiple schedules in system ${this.name}`);
        }
        const schedule = new Schedule();
        this.__scheduleBuilder = new ScheduleBuilder(buildCallback, schedule);
        return schedule;
    }
    /**
     * Creates a reference to another system in the world, that you can then use in your `initialize`
     * or `execute` methods.  Be careful not to abuse this feature as it will force all systems that
     * reference each other to be located in the same thread when using multithreading, possibly
     * limiting performance.  Can only be called from the constructor, typically by initializing an
     * instance property.
     * @example
     * foo = this.attach(SystemFoo);
     * @param systemType The type of the system to reference.
     * @returns The unique instance of the system of the given type that exists in the world.
     */
    attach(systemType) {
        if (!this.__attachPlaceholders) {
            throw new CheckError(`Attempt to attach a system after world initialized in system ${this.name}`);
        }
        const placeholder = new AttachPlaceholder(systemType);
        this.__attachPlaceholders.push(placeholder);
        return placeholder;
    }
    /**
     * Creates a new entity.  It works just like {@link World.createEntity} but returns the newly
     * created entity.  You *must not* retain a direct reference to the entity past the end of the
     * `execute` method.
     * @param initialComponents The types of the components to add to the new entity, optionally
     * interleaved with their initial properties.
     * @returns The newly created entity.
     */
    createEntity(...initialComponents) {
        return this.__dispatcher.createEntity(initialComponents);
    }
    /**
     * Enables or disables access to recently deleted data.  When turned on, you'll be able to read
     * components that were removed since the system's last execution, as well as references and
     * back references to entities deleted in the same time frame.
     * @param toggle Whether to turn access to recently deleted data on or off.
     */
    accessRecentlyDeletedData(toggle = true) {
        this.__dispatcher.registry.includeRecentlyDeleted = toggle;
    }
    /**
     * Starts running a coroutine.  The coroutine will execute after each time this system does and
     * run until its next `yield` expression.  You can start coroutines anytime: from within
     * `initialize` or `execute`, from within a coroutine, or even from an event handler between
     * frames.  Coroutines started from within `execute` will begin running in the same frame.  The
     * execution order of coroutines within a system is unspecified and you should not depend on it.
     *
     * If you're using the {@link co} decorator you don't need call this method manually, it'll be
     * handled for you.
     *
     * Inside the coroutine, you can call methods on {@link co} to control the execution of the
     * coroutine.  You can `yield` on the result of the various `co.wait` methods, and also `yield`
     * directly on the result of starting another coroutine to wait for its returned value.
     *
     * @param generator The generator returned by a coroutine method.
     * @param coroutineFn The coroutine being started, to be used with
     *    {@link Coroutine.cancelIfCoroutineStarted}.
     * @returns A coroutine handle that you can use to control it.
     */
    start(coroutineFn, ...args) {
        // TODO: disable coroutines if system is stateless
        return this.__supervisor.start(coroutineFn, ...args);
    }
    /**
     * Prepares any data or other structures needed by the system; to be implemented in a subclass and
     * invoked automatically precisely once when the world is created.  This method is not allowed to
     * create entities or access components.  Instead, it should set any needed data on the system's
     * properties to be used in `initialize`, which will be called afterwards.
     */
    async prepare() { } // eslint-disable-line @typescript-eslint/no-empty-function
    /**
     * Initializes the system; to be implemented in a subclass and invoked automatically precisely
     * once when the world is created and after the system has been prepared.  This method is allowed
     * to access the components as declared in the system's queries.
     */
    initialize() { } // eslint-disable-line @typescript-eslint/no-empty-function
    /**
     * Executes the system's function; to be implemented in a subclass and invoked automatically at
     * regular intervals.
     */
    execute() { } // eslint-disable-line @typescript-eslint/no-empty-function
    /**
     * Finalizes the system; to be implemented in a subclass and invoked automatically precisely
     * once when the world is terminated.  This method is allowed to access the components as declared
     * in the system's queries.
     */
    finalize() { } // eslint-disable-line @typescript-eslint/no-empty-function
}
Object.defineProperty(System.prototype, 'singleton', {
    get() {
        const self = this; // eslint-disable-line @typescript-eslint/no-this-alias
        const singleton = {
            read(type) {
                if (!self.__singletonPlaceholders) {
                    throw new CheckError(`Attempt to declare a singleton after world initialized in system ${self.name}`);
                }
                declareSingleton(type);
                self.query(q => q.using(type).read);
                const placeholder = new SingletonPlaceholder('read', type);
                self.__singletonPlaceholders.push(placeholder);
                return placeholder;
            },
            write(type, initialValues) {
                if (!self.__singletonPlaceholders) {
                    throw new CheckError(`Attempt to declare a singleton after world initialized in system ${self.name}`);
                }
                declareSingleton(type);
                self.query(q => q.using(type).write);
                const placeholder = new SingletonPlaceholder('write', type, initialValues);
                self.__singletonPlaceholders.push(placeholder);
                return placeholder;
            }
        };
        Object.defineProperty(this, 'singleton', { value: singleton, configurable: true });
        return singleton;
    }
});
class SystemBox {
    system;
    dispatcher;
    get id() { return this.system.id; }
    get name() { return this.system.name; }
    toString() { return this.name; }
    constructor(system, dispatcher) {
        this.system = system;
        this.dispatcher = dispatcher;
        system.__dispatcher = dispatcher;
        this.accessMasks = { read: [], update: [], create: [], write: [], check: [] };
        this.shapeQueries = [];
        this.shapeQueriesByComponent = [];
        this.writeQueries = [];
        this.writeQueriesByComponent = [];
        this.state = RunState.RUNNING;
        this.propsAssigned = false;
        this.stateless = false;
        this.weight = 1;
        this.shapeLogPointer = dispatcher.shapeLog.createPointer();
        this.stats = dispatcher.stats.forSystem(system.constructor);
        this.attachedSystems = this.system.__attachPlaceholders.map(placeholder => this.dispatcher.systemsByClass.get(placeholder.type));
        this.singletonComponentDefs = this.system.__singletonPlaceholders.flatMap(placeholder => {
            return placeholder.initialValues ?
                [placeholder.type, placeholder.initialValues] : [placeholder.type];
        });
        this.singletonStandingWrites = this.system.__singletonPlaceholders
            .filter(placeholder => placeholder.access === 'write')
            .map(placeholder => placeholder.type);
    }
    assignProps(props) {
        if (this.propsAssigned) {
            throw new CheckError(`System ${this.name} has multiple props assigned in world defs`);
        }
        Object.assign(this.system, props);
        this.propsAssigned = true;
    }
    buildQueries() {
        for (const builder of this.system.__queryBuilders)
            builder.__build(this);
        this.system.__queryBuilders = null;
        this.hasNegativeQueries = !!this.shapeQueriesByComponent[this.dispatcher.registry.Alive.id];
        this.hasWriteQueries = !!this.writeQueries.length;
        this.hasTransientQueries = this.shapeQueries.some(query => query.hasTransientResults);
    }
    buildSchedule() {
        const staticScheduler = this.system.constructor.__staticScheduler;
        if (staticScheduler)
            this.system.schedule(staticScheduler);
        this.system.__scheduleBuilder?.__build([this], `system ${this.name}`);
        this.system.__scheduleBuilder = null;
    }
    finishConstructing() {
        this.writeLogPointer = this.dispatcher.writeLog?.createPointer();
        this.singletonStandingWrites =
            this.singletonStandingWrites.filter(type => type.__binding.trackedWrites);
    }
    replacePlaceholders() {
        const openSystem = this.system;
        for (const prop in this.system) {
            const value = openSystem[prop];
            if (value instanceof AttachPlaceholder) {
                const targetSystemType = value.type;
                const targetSystem = this.dispatcher.systemsByClass.get(targetSystemType);
                if (!targetSystem) {
                    throw new CheckError(`Attached system ${targetSystemType.name} not defined in this world`);
                }
                openSystem[prop] = targetSystem.system;
            }
            else if (value instanceof SingletonPlaceholder) {
                openSystem[prop] = this.dispatcher.singleton[value.access](value.type);
            }
        }
        this.system.__attachPlaceholders = null;
        this.system.__singletonPlaceholders = null;
        if (this.dispatcher.singleton) {
            Object.defineProperty(this.system, 'singleton', { value: this.dispatcher.singleton });
        }
    }
    prepare() {
        return this.system.prepare();
    }
    initialize() {
        this.dispatcher.registry.executingSystem = this;
        this.system.initialize();
        this.trackStandingWrites();
    }
    finalize() {
        this.dispatcher.registry.executingSystem = this;
        this.system.finalize();
        this.trackStandingWrites();
    }
    execute(time, delta) {
        if (this.state !== RunState.RUNNING)
            return;
        this.dispatcher.registry.executingSystem = this;
        this.system.time = time;
        this.system.delta = delta;
        let time1, time2, time3, time4;
        time1 = now();
        this.runQueries();
        time2 = now();
        this.system.execute();
        time3 = now();
        this.system.__supervisor.execute();
        this.trackStandingWrites();
        time4 = now();
        {
            this.stats.lastQueryUpdateDuration = time2 - time1;
            this.stats.lastExecutionDuration = time3 - time2;
            this.stats.lastCoroutinesDuration = time4 - time3;
        }
    }
    trackStandingWrites() {
        const singleton = this.dispatcher.singleton;
        for (const type of this.singletonStandingWrites) {
            this.dispatcher.registry.trackWrite(singleton.__id, type);
        }
    }
    runQueries() {
        const ranQueriesLastFrame = this.ranQueriesLastFrame;
        this.ranQueriesLastFrame = false;
        const shapesChanged = this.dispatcher.shapeLog.hasUpdatesSince(this.shapeLogPointer);
        const writesMade = this.hasWriteQueries &&
            this.dispatcher.writeLog.hasUpdatesSince(this.writeLogPointer);
        if (shapesChanged || writesMade || this.hasTransientQueries && ranQueriesLastFrame) {
            if (this.hasTransientQueries) {
                // Every write query is a shape query too.
                for (const query of this.shapeQueries)
                    query.clearTransientResults();
            }
            if (shapesChanged || writesMade) {
                this.ranQueriesLastFrame = true;
                if (shapesChanged)
                    this.__updateShapeQueries();
                if (writesMade)
                    this.__updateWriteQueries();
                for (const query of this.shapeQueries)
                    query.sort();
            }
        }
    }
    __updateShapeQueries() {
        const shapeLog = this.dispatcher.shapeLog;
        if (!this.shapeQueries.length) {
            shapeLog.createPointer(this.shapeLogPointer);
            return;
        }
        for (const query of this.shapeQueries)
            query.clearProcessedEntities();
        let queries, runLength = 0;
        let log, startIndex, endIndex;
        while (true) {
            [log, startIndex, endIndex] = shapeLog.processSince(this.shapeLogPointer);
            if (!log)
                break;
            if (runLength && !queries) {
                startIndex += runLength;
                runLength = 0;
            }
            for (let i = startIndex; i < endIndex; i++) {
                const entry = log[i];
                const entityId = (entry & ENTITY_ID_MASK);
                if (!queries) {
                    const typeId = (entry >>> ENTITY_ID_BITS) & COMPONENT_ID_MASK;
                    const runHeader = entry & 2 ** 31;
                    queries = this.shapeQueriesByComponent[typeId];
                    if (runHeader) {
                        runLength = entityId;
                        if (!queries) {
                            const skip = Math.min(runLength, endIndex - i);
                            i += skip;
                            runLength -= skip;
                        }
                        continue;
                    }
                    if (!queries)
                        continue;
                    runLength = 1;
                }
                if (entry & 2 ** 31) {
                    throw new InternalError('Trying to process run header as entry in shape log');
                }
                for (let j = 0; j < queries.length; j++)
                    queries[j].handleShapeUpdate(entityId);
                if (--runLength === 0)
                    queries = undefined;
            }
        }
    }
    __updateWriteQueries() {
        const writeLog = this.dispatcher.writeLog;
        if (!this.writeQueries.length) {
            writeLog.createPointer(this.writeLogPointer);
            return;
        }
        let queries, runLength = 0;
        let componentFlagOffset, componentFlagMask;
        let log, startIndex, endIndex;
        while (true) {
            [log, startIndex, endIndex] = writeLog.processSince(this.writeLogPointer);
            if (!log)
                break;
            if (runLength && !queries) {
                startIndex += runLength;
                runLength = 0;
            }
            for (let i = startIndex; i < endIndex; i++) {
                const entry = log[i];
                const entityId = (entry & ENTITY_ID_MASK);
                if (!queries) {
                    const typeId = (entry >>> ENTITY_ID_BITS) & COMPONENT_ID_MASK;
                    const runHeader = entry & 2 ** 31;
                    // Manually recompute flag offset and mask instead of looking up component type.
                    componentFlagOffset = typeId >> 5;
                    componentFlagMask = 1 << (typeId & 31);
                    queries = this.writeQueriesByComponent[typeId];
                    if (runHeader) {
                        runLength = entityId;
                        if (!queries) {
                            const skip = Math.min(runLength, endIndex - i);
                            i += skip;
                            runLength -= skip;
                        }
                        continue;
                    }
                    if (!queries)
                        continue;
                    runLength = 1;
                }
                if (entry & 2 ** 31) {
                    throw new InternalError('Trying to process run header as entry in write log');
                }
                for (let j = 0; j < queries.length; j++) {
                    queries[j].handleWrite(entityId, componentFlagOffset, componentFlagMask);
                }
                if (--runLength === 0)
                    queries = undefined;
            }
        }
    }
    stop() {
        if (this.state === RunState.STOPPED)
            return;
        this.state = RunState.STOPPED;
        for (const query of this.shapeQueries)
            query.clearAllResults();
    }
    restart() {
        if (this.state === RunState.STOPPED) {
            const registry = this.dispatcher.registry;
            const Alive = registry.Alive;
            for (const query of this.shapeQueries)
                query.clearProcessedEntities();
            for (let id = 0; id < this.dispatcher.maxEntities; id++) {
                if (registry.hasShape(id, Alive, false)) {
                    for (const query of this.shapeQueries)
                        query.handleShapeUpdate(id);
                }
            }
            for (const query of this.shapeQueries) {
                query.clearTransientResults();
                query.sort();
            }
            this.dispatcher.shapeLog.createPointer(this.shapeLogPointer);
            this.dispatcher.writeLog?.createPointer(this.writeLogPointer);
        }
        this.state = RunState.RUNNING;
    }
}

class ComponentEnum {
    name;
    __types;
    __binding;
    constructor(name, types) {
        this.name = name;
        this.__types = Array.from(new Set(types));
    }
}

const HEADER_LENGTH = 2;
class UnsharedPool {
    maxItems;
    configParamName;
    // layout: length, mark, ...uints
    data;
    constructor(maxItems, configParamName) {
        this.maxItems = maxItems;
        this.configParamName = configParamName;
        this.data = new Uint32Array(new ArrayBuffer((maxItems + HEADER_LENGTH) * Uint32Array.BYTES_PER_ELEMENT));
    }
    get length() {
        return this.data[0];
    }
    take() {
        const length = --this.data[0];
        if (length < 0) {
            throw new RangeError(`Pool capacity exceeded, please raise ${this.configParamName} above ${this.maxItems}`);
        }
        return this.data[length + HEADER_LENGTH];
    }
    return(id) {
        if (this.length >= this.maxItems) {
            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');
        }
        this.data[this.length + HEADER_LENGTH] = id;
        this.data[0] += 1;
    }
    mark() {
        this.data[1] = this.data[0];
    }
    peekSinceMark(index) {
        const i = this.data[1] + index;
        if (i < this.data[0])
            return this.data[i + HEADER_LENGTH];
    }
    refill(source) {
        if (!source.length)
            return;
        const length = this.length;
        const newLength = length + source.length;
        if (newLength > this.maxItems) {
            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');
        }
        this.data.set(source, length + HEADER_LENGTH);
        this.data[0] = newLength;
    }
    fillWithDescendingIntegers(first) {
        const lowerBound = this.length + HEADER_LENGTH;
        for (let i = this.data.length - 1; i >= lowerBound; i--) {
            this.data[i] = first++;
        }
        this.data[0] = this.data.length - HEADER_LENGTH;
    }
}
/**
 * A shared pool of u32's that uses atomic operations to deconflict concurrent callers of `take`.
 * The `return` method is not threadsafe.
 */
class SharedAtomicPool {
    maxItems;
    configParamName;
    // layout: length, mark, ...uints
    data;
    constructor(maxItems, configParamName, buffers) {
        this.maxItems = maxItems;
        this.configParamName = configParamName;
        buffers.register(`pool.${configParamName}`, maxItems + HEADER_LENGTH, Uint32Array, (data) => { this.data = data; });
    }
    get length() {
        return this.data[0];
    }
    take() {
        const length = Atomics.sub(this.data, 0, 1);
        if (length < 0) {
            throw new RangeError(`Pool capacity exceeded, please raise ${this.configParamName} above ${this.maxItems}`);
        }
        return this.data[length + HEADER_LENGTH];
    }
    return(id) {
        if (this.length >= this.maxItems) {
            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');
        }
        this.data[this.length + HEADER_LENGTH] = id;
        this.data[0] += 1;
    }
    mark() {
        this.data[1] = this.data[0];
    }
    peekSinceMark(index) {
        const i = this.data[1] + index;
        if (i < this.data[0])
            return this.data[i + HEADER_LENGTH];
    }
    refill(source) {
        if (!source.length)
            return;
        const length = this.length;
        const newLength = length + source.length;
        if (newLength > this.maxItems) {
            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');
        }
        this.data.set(source, length + HEADER_LENGTH);
        this.data[0] = newLength;
    }
    fillWithDescendingIntegers(first) {
        const lowerBound = this.length + HEADER_LENGTH;
        for (let i = this.data.length - 1; i >= lowerBound; i--) {
            this.data[i] = first++;
        }
        this.data[0] = this.data.length - HEADER_LENGTH;
    }
}

class UnsharedShapeArray {
    stride;
    array;
    constructor(bufferKey, numBits, maxEntities, buffers) {
        this.stride = Math.ceil(numBits / 32);
        buffers.register(bufferKey, maxEntities * this.stride, Uint32Array, shapes => { this.array = shapes; });
    }
    syncThreads() {
        // no-op
    }
    set(entityId, type) {
        const binding = type.__binding;
        const index = entityId * this.stride + binding.shapeOffset;
        const mask = binding.shapeMask;
        const value = binding.shapeValue;
        this.array[index] &= ~mask;
        this.array[index] |= value;
    }
    unset(entityId, type) {
        const binding = type.__binding;
        const index = entityId * this.stride + binding.shapeOffset;
        const mask = binding.shapeMask;
        this.array[index] &= ~mask;
    }
    isSet(entityId, type) {
        const binding = type.__binding;
        const index = entityId * this.stride + binding.shapeOffset;
        const mask = binding.shapeMask;
        const value = binding.shapeValue;
        return (this.array[index] & mask) === value;
    }
    get(entityId, enumeration) {
        const binding = enumeration.__binding;
        const index = entityId * this.stride + binding.shapeOffset;
        const mask = binding.shapeMask;
        return (this.array[index] & mask) >>> binding.shapeShift;
    }
    clear() {
        this.array.fill(0);
    }
    match(entityId, positiveMask, positiveValues) {
        if (positiveMask.length !== positiveValues.length) {
            throw new InternalError(`Mismatched mask and value lengths: ${positiveMask.length} vs ${positiveValues.length}`);
        }
        const array = this.array;
        const index = entityId * this.stride;
        for (let i = 0; i < positiveMask.length; i++) {
            if ((array[index + i] & positiveMask[i]) !== positiveValues[i])
                return false;
        }
        return true;
    }
    matchNot(entityId, negativeMask) {
        const array = this.array;
        const index = entityId * this.stride;
        for (let i = 0; i < negativeMask.length; i++) {
            if ((array[index + i] & negativeMask[i]) !== 0)
                return false;
        }
        return true;
    }
    matchAny(entityId, trackingMask) {
        trackingMask.changed = false;
        const mask = trackingMask.mask;
        const lastMatch = trackingMask.lastMatches[entityId] = trackingMask.lastMatches[entityId] || [];
        const array = this.array;
        const index = entityId * this.stride;
        let ok = false;
        for (let i = 0; i < mask.length; i++) {
            const masked = array[index + i] & mask[i];
            if (masked !== 0)
                ok = true;
            if (masked !== lastMatch[i])
                trackingMask.changed = true;
            lastMatch[i] = masked;
        }
        if (!ok)
            delete trackingMask.lastMatches[entityId];
        return ok;
    }
}
class AtomicSharedShapeArray {
    stride;
    array;
    constructor(bufferKey, numBits, maxEntities, buffers) {
        this.stride = Math.ceil(numBits / 32);
        buffers.register(bufferKey, maxEntities * this.stride, Uint32Array, shapes => { this.array = shapes; });
    }
    syncThreads() {
        // We assume that any atomic operation will force a write barrier on the whole array.
        Atomics.load(this.array, 0);
    }
    set(entityId, type) {
        const binding = type.__binding;
        const index = entityId * this.stride + binding.shapeOffset;
        const mask = binding.shapeMask;
        const value = binding.shapeValue;
        if (mask !== value)
            Atomics.and(this.array, index, ~mask);
        Atomics.or(this.array, index, value);
    }
    unset(entityId, type) {
        const binding = type.__binding;
        const index = entityId * this.stride + binding.shapeOffset;
        const mask = binding.shapeMask;
        Atomics.and(this.array, index, ~mask);
    }
    isSet(entityId, type) {
        const binding = type.__binding;
        const index = entityId * this.stride + binding.shapeOffset;
        const mask = binding.shapeMask;
        const value = binding.shapeValue;
        // Entity liveness flag can be written at any time from any thread, so do atomic check.
        if (type.id === 0)
            return (Atomics.load(this.array, index) & mask) === value;
        return (this.array[index] & mask) === value;
    }
    get(entityId, enumeration) {
        const binding = enumeration.__binding;
        const index = entityId * this.stride + binding.shapeOffset;
        const mask = binding.shapeMask;
        return (this.array[index] & mask) >>> binding.shapeShift;
    }
    clear() {
        this.array.fill(0);
    }
    match(entityId, positiveMask, positiveValues) {
        if (positiveMask.length !== positiveValues.length) {
            throw new InternalError(`Mismatched mask and value lengths: ${positiveMask.length} vs ${positiveValues.length}`);
        }
        const array = this.array;
        const index = entityId * this.stride;
        for (let i = 0; i < positiveMask.length; i++) {
            if ((array[index + i] & positiveMask[i]) !== positiveValues[i])
                return false;
        }
        return true;
    }
    matchNot(entityId, negativeMask) {
        const array = this.array;
        const index = entityId * this.stride;
        for (let i = 0; i < negativeMask.length; i++) {
            if ((array[index + i] & negativeMask[i]) !== 0)
                return false;
        }
        return true;
    }
    matchAny(entityId, trackingMask) {
        trackingMask.changed = false;
        const mask = trackingMask.mask;
        const lastMatch = trackingMask.lastMatches[entityId] = trackingMask.lastMatches[entityId] || [];
        const array = this.array;
        const index = entityId * this.stride;
        for (let i = 0; i < mask.length; i++) {
            const masked = array[index + i] & mask[i];
            if (masked === 0) {
                delete trackingMask.lastMatches[entityId];
                return false;
            }
            if (masked !== lastMatch[i])
                trackingMask.changed = true;
            lastMatch[i] = masked;
        }
        return true;
    }
}

const SYSTEM_ERROR_TYPES = [
    EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError,
    CheckError, InternalError
];
class EntityPool {
    registry;
    borrowed; // indexed by id
    borrowCounts; // indexed by id
    spares = [];
    temporarilyBorrowedIds = [];
    constructor(registry, maxEntities) {
        this.registry = registry;
        this.borrowed = Array.from({ length: maxEntities });
        this.borrowCounts = new Int32Array(maxEntities);
    }
    borrow(id) {
        this.borrowCounts[id] += 1;
        let entity = this.borrowed[id];
        if (!entity) {
            entity = this.borrowed[id] = this.spares.pop() ?? new EntityImpl(this.registry);
            entity.__id = id;
        }
        return entity;
    }
    borrowTemporarily(id) {
        const entity = this.borrow(id);
        this.temporarilyBorrowedIds.push(id);
        return entity;
    }
    returnTemporaryBorrows() {
        for (const id of this.temporarilyBorrowedIds)
            this.return(id);
        this.temporarilyBorrowedIds.length = 0;
    }
    return(id) {
        {
            if (!this.borrowCounts[id]) {
                throw new InternalError('Returning entity with no borrows');
            }
        }
        if (--this.borrowCounts[id] <= 0) {
            const entity = this.borrowed[id];
            this.borrowed[id] = undefined;
            {
                entity.__valid = false;
                return;
            }
        }
    }
}
class Registry {
    types;
    enums;
    dispatcher;
    allocationItems;
    numShapeBits = 0;
    shapes;
    staleShapes;
    removedShapes;
    entityIdPool;
    pool;
    heldEntities;
    validators;
    reshapedEntityIds = [];
    validateSystem;
    executingSystem;
    includeRecentlyDeleted = false;
    hasNegativeQueries = false;
    nextEntityOrdinal = 0;
    entityOrdinals;
    removalLog;
    prevRemovalPointer;
    oldRemovalPointer;
    Alive = class Alive {
    };
    constructor(maxEntities, maxLimboComponents, types, enums, dispatcher) {
        this.types = types;
        this.enums = enums;
        this.dispatcher = dispatcher;
        this.allocationItems = this.prepareComponentTypesAndEnums();
        for (const item of this.allocationItems)
            this.numShapeBits += item.size;
        const ShapeArrayClass = dispatcher.threaded ? AtomicSharedShapeArray : UnsharedShapeArray;
        this.shapes = new ShapeArrayClass('registry.shapes', this.numShapeBits, maxEntities, dispatcher.buffers);
        this.staleShapes = new ShapeArrayClass('registry.staleShapes', this.numShapeBits, maxEntities, dispatcher.buffers);
        this.removedShapes = new ShapeArrayClass('registry.removedShapes', this.numShapeBits, maxEntities, dispatcher.buffers);
        this.entityIdPool = dispatcher.threaded ?
            new SharedAtomicPool(maxEntities, 'maxEntities', dispatcher.buffers) :
            new UnsharedPool(maxEntities, 'maxEntities');
        this.entityOrdinals = dispatcher.buffers.register('registry.entityOrdinals', maxEntities, Uint32Array, array => { this.entityOrdinals = array; });
        this.entityIdPool.fillWithDescendingIntegers(0);
        this.pool = new EntityPool(this, maxEntities);
        this.heldEntities = [];
        this.validators = [];
        this.removalLog = new Log(maxLimboComponents, 'maxLimboComponents', dispatcher.buffers);
        this.prevRemovalPointer = this.removalLog.createPointer();
        this.oldRemovalPointer = this.removalLog.createPointer();
    }
    initializeComponentTypes() {
        // Two-phase init, so components can have dependencies on each other's fields.
        let bitIndex = 0, typeId = 0;
        while (this.allocationItems.length) {
            const shift = bitIndex % 32;
            const item = this.removeBiggestNoLargerThan(32 - shift);
            if (!item) {
                bitIndex += 32 - shift;
                continue;
            }
            const shapeSpec = {
                offset: bitIndex >>> 5, mask: ((1 << item.size) - 1) << shift, value: 1 << shift
            };
            bitIndex += item.size;
            if (item.typeOrEnum instanceof ComponentEnum) {
                const enumeration = item.typeOrEnum;
                enumeration.__binding = {
                    shapeOffset: shapeSpec.offset, shapeMask: shapeSpec.mask, shapeShift: shift
                };
                for (const type of enumeration.__types) {
                    assimilateComponentType(typeId++, type, shapeSpec, this.dispatcher);
                    if (type.validate)
                        this.validators.push(type);
                    shapeSpec.value += 1 << shift;
                }
            }
            else {
                const type = item.typeOrEnum;
                assimilateComponentType(typeId++, type, shapeSpec, this.dispatcher);
                if (type.validate)
                    this.validators.push(type);
            }
        }
        for (const type of this.types)
            defineAndAllocateComponentType(type);
        {
            const aliveBinding = this.Alive.__binding;
            if (!(aliveBinding.shapeOffset === 0 && aliveBinding.shapeMask === 1 &&
                aliveBinding.shapeValue === 1)) {
                throw new InternalError('Alive component was not assigned first available shape mask');
            }
        }
    }
    prepareComponentTypesAndEnums() {
        const pool = [];
        const enumTypes = new Set();
        for (const type of this.types) {
            if (type.enum) {
                if (!this.enums.includes(type.enum)) {
                    throw new CheckError(`Component type ${type.name} references an enum that's not in the world's defs`);
                }
                if (!type.enum.__types.includes(type))
                    type.enum.__types.push(type);
            }
        }
        for (const enumeration of this.enums) {
            if (enumeration.__types.length > 2 ** 31) {
                throw new CheckError(`Too many types in enum: ${enumeration.__types.length}`);
            }
            pool.push({
                // +1 for the implicit null value of every enum
                typeOrEnum: enumeration, size: Math.ceil(Math.log2(enumeration.__types.length + 1))
            });
            for (const type of enumeration.__types) {
                if (enumTypes.has(type)) {
                    throw new CheckError(`Component type ${type.name} is a member of more than one enum`);
                }
                type.enum = enumeration;
                enumTypes.add(type);
            }
        }
        for (const type of this.types) {
            if (!enumTypes.has(type))
                pool.push({ typeOrEnum: type, size: 1 });
        }
        pool.sort((a, b) => b.size - a.size);
        // Ensure that Alive will always be the first type allocated.
        this.types.unshift(this.Alive);
        pool.unshift({ typeOrEnum: this.Alive, size: 1 });
        return pool;
    }
    removeBiggestNoLargerThan(maxSize) {
        const k = this.allocationItems.findIndex(item => item.size <= maxSize);
        if (k === -1)
            return;
        return this.allocationItems.splice(k, 1)[0];
    }
    releaseComponentTypes() {
        for (const type of this.types)
            dissimilateComponentType(type);
        for (const enumeration of this.enums)
            delete enumeration.__binding;
    }
    createEntity(initialComponents) {
        const id = this.entityIdPool.take();
        this.entityOrdinals[id] = this.nextEntityOrdinal++;
        this.setShape(id, this.Alive);
        const entity = this.pool.borrowTemporarily(id);
        this.createComponents(id, initialComponents);
        this.dispatcher.stats.numEntities += 1;
        return entity;
    }
    // Everything is copied over from Entity and inlined here to keep performance from cratering.
    // Just calling checkMask with 'create' kills it...
    createComponents(id, initialComponents) {
        for (let i = 0; i < initialComponents.length; i++) {
            const type = initialComponents[i];
            {
                if (typeof type !== 'function') {
                    throw new CheckError(`Bad arguments to createEntity: expected component type, got: ${type}`);
                }
                checkTypeDefined(type);
                const mask = this.executingSystem?.accessMasks.create;
                if (mask) {
                    const binding = type.__binding;
                    if (((mask[binding.shapeOffset] ?? 0) & binding.shapeMask) === 0) {
                        throw new CheckError(`System ${this.executingSystem?.name} didn't mark component ${type.name} ` +
                            `as createable`);
                    }
                }
                if (type.enum) {
                    if (this.getEnumShape(id, type.enum, false)) {
                        throw new CheckError(`Can't add multiple components from the same enum when creating entity: ` +
                            type.name);
                    }
                }
                else if (this.hasShape(id, type, false)) {
                    throw new CheckError(`Duplicate ${type.name} component when creating entity`);
                }
            }
            let value = initialComponents[i + 1];
            if (typeof value === 'function')
                value = undefined;
            else
                i++;
            this.setShape(id, type);
            this.dispatcher.stats.forComponent(type).numEntities += 1;
            initComponent(type, id, value);
        }
    }
    flush() {
        const lastExecutingSystem = this.executingSystem;
        this.includeRecentlyDeleted = false;
        this.validateShapes(lastExecutingSystem);
        this.executingSystem = undefined;
        this.pool.returnTemporaryBorrows();
        this.removalLog.commit();
    }
    completeCycle() {
        this.processRemovalLog();
        this.invalidateDeletedHeldEntities();
    }
    validateShapes(system) {
        this.executingSystem = this.validateSystem;
        for (const entityId of this.reshapedEntityIds) {
            for (const componentType of this.validators) {
                try {
                    componentType.validate(this.pool.borrowTemporarily(entityId));
                }
                catch (e) {
                    if (!SYSTEM_ERROR_TYPES.includes(e.constructor)) {
                        const systemSuffix = system ? ` after system ${system.name} executed` : '';
                        const componentNames = this.types
                            .filter(type => type !== this.Alive && this.hasShape(entityId, type, false))
                            .map(type => type.name)
                            .join(', ') || 'none';
                        e.message =
                            `An entity failed to satisfy ${componentType.name}.validate${systemSuffix}: ` +
                                `${e.message} (components: ${componentNames})`;
                    }
                    throw e;
                }
            }
        }
        this.reshapedEntityIds.length = 0;
    }
    processRemovalLog() {
        const indexer = this.dispatcher.indexer;
        this.removalLog.commit();
        this.entityIdPool.mark();
        let numDeletedEntities = 0;
        let log, startIndex, endIndex;
        {
            this.dispatcher.stats.maxLimboComponents =
                this.removalLog.countSince(this.removalLog.copyPointer(this.oldRemovalPointer));
        }
        while (true) {
            [log, startIndex, endIndex] =
                this.removalLog.processSince(this.oldRemovalPointer, this.prevRemovalPointer);
            if (!log)
                break;
            for (let i = startIndex; i < endIndex; i++) {
                const entry = log[i];
                const entityId = (entry & ENTITY_ID_MASK);
                const componentId = (entry >>> ENTITY_ID_BITS) & COMPONENT_ID_MASK;
                const type = this.types[componentId];
                if (!this.shapes.isSet(entityId, type) && !this.removedShapes.isSet(entityId, type)) {
                    this.staleShapes.unset(entityId, type);
                    if (type === this.Alive) {
                        indexer.clearAllRefs(entityId, true);
                        this.entityIdPool.return(entityId);
                        numDeletedEntities += 1;
                    }
                    else {
                        this.clearRefs(entityId, type, true);
                    }
                    type.__free?.(entityId);
                    this.removedShapes.set(entityId, type);
                }
            }
        }
        this.dispatcher.stats.numEntities -= numDeletedEntities;
        this.removedShapes.clear();
        this.removalLog.createPointer(this.prevRemovalPointer);
    }
    invalidateDeletedHeldEntities() {
        let index = 0;
        let entityId;
        while ((entityId = this.entityIdPool.peekSinceMark(index++)) !== undefined) {
            const entity = this.heldEntities[entityId];
            if (entity) {
                entity.__valid = false;
                delete this.heldEntities[entityId];
            }
        }
    }
    holdEntity(id) {
        let entity;
        entity = this.heldEntities[id];
        if (!entity) {
            entity = new EntityImpl(this);
            entity.__id = id;
            this.heldEntities[id] = entity;
        }
        return entity;
    }
    hasShape(id, type, allowRecentlyDeleted) {
        if (this.shapes.isSet(id, type))
            return true;
        if (allowRecentlyDeleted && this.includeRecentlyDeleted &&
            this.staleShapes.isSet(id, type))
            return true;
        return false;
    }
    getEnumShape(id, enumeration, allowRecentlyDeleted) {
        let index = this.shapes.get(id, enumeration);
        if (index === 0 && allowRecentlyDeleted && this.includeRecentlyDeleted) {
            index = this.staleShapes.get(id, enumeration);
        }
        if (index > 0)
            return enumeration.__types[index - 1];
    }
    setShape(id, type) {
        if (type.enum) {
            const oldType = this.getEnumShape(id, type.enum, false);
            if (oldType)
                this.clearShape(id, oldType);
        }
        this.shapes.set(id, type);
        this.staleShapes.set(id, type);
        this.reshapedEntityIds.push(id);
        if (type !== this.Alive || this.hasNegativeQueries) {
            this.dispatcher.shapeLog.push(id | (type.id << ENTITY_ID_BITS), type);
        }
    }
    clearShape(id, type) {
        this.clearRefs(id, type, false);
        this.shapes.unset(id, type);
        this.removedShapes.set(id, type);
        this.reshapedEntityIds.push(id);
        const logEntry = id | (type.id << ENTITY_ID_BITS);
        this.removalLog.push(logEntry);
        if (type !== this.Alive || this.hasNegativeQueries) {
            this.dispatcher.shapeLog.push(logEntry, type);
        }
        this.dispatcher.stats.forComponent(type).numEntities -= 1;
    }
    trackWrite(id, type) {
        this.dispatcher.writeLog.push(id | (type.id << ENTITY_ID_BITS), type);
    }
    clearRefs(id, type, final) {
        const hasRefs = !!type.__binding.refFields.length;
        if (hasRefs) {
            type.__bind(id, true);
            for (const field of type.__binding.refFields)
                field.clearRef(final);
        }
    }
    matchShape(id, positiveMask, positiveValues, trackingMasks, negativeMask, negativeTypes) {
        if (positiveMask && positiveValues && !this.shapes.match(id, positiveMask, positiveValues)) {
            return false;
        }
        if (negativeMask && !this.shapes.matchNot(id, negativeMask))
            return false;
        if (negativeTypes) {
            for (const type of negativeTypes)
                if (this.shapes.isSet(id, type))
                    return false;
        }
        if (trackingMasks) {
            for (const trackingMask of trackingMasks) {
                if (trackingMask.lastMatches) {
                    if (!this.shapes.matchAny(id, trackingMask))
                        return false;
                }
                else if (this.shapes.matchNot(id, trackingMask.mask)) {
                    return false;
                }
            }
        }
        return true;
    }
}

const ALPHA = 0.05;
function computeMovingAverage(average, value) {
    return value * ALPHA + average * (1 - ALPHA);
}
class ComponentStats {
    _numEntities = 0;
    maxEntities = 0;
    capacity = 0;
    get numEntities() {
        return this._numEntities;
    }
    set numEntities(value) {
        this._numEntities = value;
        if (value > this.maxEntities)
            this.maxEntities = value;
    }
    toString() {
        /* eslint-disable max-len */
        return `${this.numEntities.toLocaleString()} of ${this.maxEntities.toLocaleString()} peak (capacity ${this.capacity.toLocaleString()})`;
        /* eslint-enable max-len */
    }
}
class SystemStats {
    worker; // -1 means replicated to all workers
    _lastQueryUpdateDuration = 0;
    averageQueryUpdateDuration = 0;
    _lastExecutionDuration = 0;
    averageExecutionDuration = 0;
    _lastCoroutinesDuration = 0;
    averageCoroutinesDuration = 0;
    get lastQueryUpdateDuration() {
        return this._lastQueryUpdateDuration;
    }
    set lastQueryUpdateDuration(value) {
        this._lastQueryUpdateDuration = value;
        this.averageQueryUpdateDuration = computeMovingAverage(this.averageQueryUpdateDuration, value);
    }
    get lastExecutionDuration() {
        return this._lastExecutionDuration;
    }
    set lastExecutionDuration(value) {
        this._lastExecutionDuration = value;
        this.averageExecutionDuration = computeMovingAverage(this.averageExecutionDuration, value);
    }
    get lastCoroutinesDuration() {
        return this._lastCoroutinesDuration;
    }
    set lastCoroutinesDuration(value) {
        this._lastCoroutinesDuration = value;
        this.averageCoroutinesDuration = computeMovingAverage(this.averageCoroutinesDuration, value);
    }
}
const internalComponentStats = new ComponentStats();
const internalSystemStats = new SystemStats();
class Stats {
    frames = 0;
    _numEntities = 0;
    _maxEntities = 0;
    _maxLimboComponents = 0;
    _maxRefChangesPerFrame = 0;
    _maxShapeChangesPerFrame = 0;
    _maxWritesPerFrame = 0;
    components = Object.create(null);
    systems = Object.create(null);
    get maxEntities() {
        return this._maxEntities;
    }
    get numEntities() {
        return this._numEntities;
    }
    set numEntities(value) {
        this._numEntities = value;
        if (value > this._maxEntities)
            this._maxEntities = value;
    }
    get maxLimboComponents() {
        return this._maxLimboComponents;
    }
    set maxLimboComponents(value) {
        if (value > this._maxLimboComponents)
            this._maxLimboComponents = value;
    }
    get maxRefChangesPerFrame() {
        return this._maxRefChangesPerFrame;
    }
    set maxRefChangesPerFrame(value) {
        if (value > this._maxRefChangesPerFrame)
            this._maxRefChangesPerFrame = value;
    }
    get maxShapeChangesPerFrame() {
        return this._maxShapeChangesPerFrame;
    }
    set maxShapeChangesPerFrame(value) {
        if (value > this._maxShapeChangesPerFrame)
            this._maxShapeChangesPerFrame = value;
    }
    get maxWritesPerFrame() {
        return this._maxWritesPerFrame;
    }
    set maxWritesPerFrame(value) {
        if (value > this._maxWritesPerFrame)
            this._maxWritesPerFrame = value;
    }
    forComponent(type) {
        if (type.id === 0)
            return internalComponentStats;
        return this.components[type.name] = this.components[type.name] ?? new ComponentStats();
    }
    forSystem(type) {
        if (type.name === 'CallbackSystem')
            return internalSystemStats;
        return this.systems[type.name] = this.systems[type.name] ?? new SystemStats();
    }
    toString() {
        /* eslint-disable max-len */
        return `World stats:
  frames: ${this.frames.toLocaleString()}
  entities: ${this.numEntities.toLocaleString()} of ${this.maxEntities.toLocaleString()} max
  refs: ${this.maxRefChangesPerFrame.toLocaleString()} ref changes/frame max
  logs: ${this.maxShapeChangesPerFrame.toLocaleString()} shape changes/frame max, ${this.maxWritesPerFrame.toLocaleString()} writes/frame max
  components: (${this.maxLimboComponents.toLocaleString()} limbo max)\n` +
            Object.keys(this.components).map(name => {
                const compStats = this.components[name];
                return `    ${name}: ${compStats.numEntities} (max ${compStats.maxEntities})`;
            }).join('\n');
        /* eslint-enable max-len */
    }
}

var Action;
(function (Action) {
    Action[Action["REFERENCE"] = 0] = "REFERENCE";
    Action[Action["UNREFERENCE"] = 1073741824] = "UNREFERENCE";
    Action[Action["RELEASE"] = 2147483648] = "RELEASE";
    Action[Action["UNREFERENCE_AND_RELEASE"] = -1073741824] = "UNREFERENCE_AND_RELEASE";
})(Action || (Action = {}));
const ACTION_MASK = Action.UNREFERENCE_AND_RELEASE;
class Tracker {
    targetEntityId;
    selector;
    trackStale;
    dispatcher;
    entities = [];
    tags;
    entityIndex;
    clearing = false;
    registry;
    constructor(targetEntityId, selector, trackStale, dispatcher) {
        this.targetEntityId = targetEntityId;
        this.selector = selector;
        this.trackStale = trackStale;
        this.dispatcher = dispatcher;
        const binding = selector.sourceType?.__binding;
        const precise = selector.matchType && (selector.matchSeq && !binding.fields[selector.sourceSeq].type.internallyIndexed ||
            binding.refFields.length === 1 && !binding.refFields[0].type.internallyIndexed);
        if (!precise)
            this.tags = [];
        this.registry = dispatcher.registry;
    }
    clearAllRefs(final) {
        if (!this.tags)
            throw new InternalError('Unreferencing an untagged tracker');
        this.clearing = true;
        for (let i = 0; i < this.entities.length; i++) {
            const entityId = this.entities[i].__id;
            const set = this.tags[i];
            if (typeof set === 'number') {
                this.clearRef(entityId, set, final);
            }
            else {
                for (const tag of set)
                    this.clearRef(entityId, tag, final);
            }
        }
        this.entities = [];
        if (this.tags)
            this.tags = [];
        this.entityIndex = undefined;
        this.clearing = false;
    }
    clearRef(sourceId, tag, final) {
        const sourceTypeId = tag & COMPONENT_ID_MASK;
        const sourceSeq = (tag >>> COMPONENT_ID_BITS) & FIELD_SEQ_MASK;
        const internalIndex = tag >>> (COMPONENT_ID_BITS + FIELD_SEQ_BITS);
        const sourceType = this.registry.types[sourceTypeId];
        checkMask(sourceType, this.registry.executingSystem, 'write');
        sourceType.__bind(sourceId, true);
        sourceType.__binding.fields[sourceSeq].clearRef(final, this.targetEntityId, internalIndex);
    }
    trackReference(entityId, typeId, fieldSeq, internalIndex, trackChanges) {
        if (this.clearing) {
            throw new InternalError('Cannot track a new reference while clearing tracker');
        }
        if (trackChanges)
            this.checkUpdateMask();
        let index = this.getEntityIndex(entityId);
        if (index === undefined)
            index = this.addEntity(entityId, trackChanges);
        this.addTag(index, this.makeTag(typeId, fieldSeq, internalIndex));
    }
    trackUnreference(entityId, typeId, fieldSeq, internalIndex, trackChanges) {
        if (this.clearing)
            return;
        if (trackChanges)
            this.checkUpdateMask();
        const index = this.getEntityIndex(entityId);
        if (index === undefined)
            throw new InternalError('Entity backref not tracked');
        const empty = this.removeTag(index, this.makeTag(typeId, fieldSeq, internalIndex));
        if (empty)
            this.removeEntity(index, entityId, trackChanges);
    }
    getEntityIndex(entityId) {
        if (this.entityIndex)
            return this.entityIndex[entityId];
        const k = this.entities.findIndex(entity => entity.__id === entityId);
        if (k >= 0)
            return k;
    }
    indexEntities() {
        if (this.entityIndex)
            throw new InternalError('Entities already indexed');
        this.entityIndex = new Array(this.dispatcher.maxEntities);
        for (let i = 0; i < this.entities.length; i++) {
            this.entityIndex[this.entities[i].__id] = i;
        }
    }
    addTag(index, tag) {
        if (!this.tags)
            return;
        const set = this.tags[index];
        if (set === undefined) {
            this.tags[index] = tag;
        }
        else if (typeof set === 'number') {
            if (set === tag)
                throw new InternalError(`Ref ${tag} already tracked (single)`);
            this.tags[index] = [set, tag];
        }
        else if (Array.isArray(set)) {
            if (set.includes(tag))
                throw new InternalError(`Ref ${tag} already tracked (array)`);
            if (set.length >= 1000) {
                const actualSet = this.tags[index] = new Set(set);
                actualSet.add(tag);
            }
            else {
                set.push(tag);
            }
        }
        else {
            if (set.has(tag))
                throw new InternalError(`Ref ${tag} already tracked (set)`);
            set.add(tag);
        }
    }
    removeTag(index, tag) {
        if (!this.tags)
            return true; // precise mode
        const set = this.tags[index];
        if (set === undefined)
            throw new InternalError(`Ref ${tag} not tracked (none)`);
        if (typeof set === 'number') {
            if (set !== tag)
                throw new InternalError(`Ref ${tag} not tracked (single ${set})`);
            delete this.tags[index];
            return true;
        }
        if (Array.isArray(set)) {
            const k = set.indexOf(tag);
            if (k === -1)
                throw new InternalError(`Ref ${tag} not tracked (array ${set})`);
            set.splice(k, 1);
            return !this.tags.length;
        }
        if (!set.has(tag)) {
            throw new InternalError(`Ref ${tag} not tracked (set ${new Array(...set)})`);
        }
        set.delete(tag);
        return !set.size;
    }
    makeTag(typeId, fieldSeq, internalIndex) {
        return typeId | (fieldSeq << COMPONENT_ID_BITS) |
            (internalIndex === undefined ? 0 : (internalIndex << (COMPONENT_ID_BITS + FIELD_SEQ_BITS)));
    }
    addEntity(entityId, trackChanges) {
        const index = this.entities.length;
        this.entities.push(this.registry.pool.borrow(entityId));
        if (this.entityIndex) {
            this.entityIndex[entityId] = index;
        }
        else if (index > 100) {
            this.indexEntities();
        }
        if (trackChanges)
            this.trackBackrefsChange();
        return index;
    }
    removeEntity(index, entityId, trackChanges) {
        this.registry.pool.return(entityId);
        const lastEntity = this.entities.pop();
        if (this.entityIndex)
            delete this.entityIndex[entityId];
        if (this.entities.length > index) {
            this.entities[index] = lastEntity;
            if (this.entityIndex)
                this.entityIndex[lastEntity.__id] = index;
        }
        if (this.tags) {
            const lastTag = this.tags.pop();
            if (this.tags.length > index)
                this.tags[index] = lastTag;
        }
        if (trackChanges)
            this.trackBackrefsChange();
    }
    trackBackrefsChange() {
        for (const targetType of this.selector.targetTypes) {
            if (targetType.__binding.trackedWrites) {
                this.registry.trackWrite(this.targetEntityId, targetType);
            }
        }
    }
    checkUpdateMask() {
        const system = this.registry.executingSystem;
        for (const targetType of this.selector.targetTypes) {
            if (this.registry.hasShape(this.targetEntityId, targetType, this.trackStale)) {
                checkMask(targetType, system, 'update');
            }
        }
    }
}
class RefIndexer {
    dispatcher;
    maxRefChangesPerFrame;
    refLog;
    refLogPointer;
    refLogStatsPointer;
    selectorIdsBySourceKey = new Map();
    selectors = [];
    trackers = new Map();
    registry;
    constructor(dispatcher, maxRefChangesPerFrame) {
        this.dispatcher = dispatcher;
        this.maxRefChangesPerFrame = maxRefChangesPerFrame;
        this.registry = dispatcher.registry;
    }
    completeCycle() {
        this.flush(); // to handle ref changes coming from registry.processEndOfFrame()
        this.dispatcher.stats.maxRefChangesPerFrame =
            this.refLog?.countSince(this.refLogStatsPointer) ?? 0;
    }
    registerSelector(targetType, sourceType, sourceFieldSeq, trackStale = false) {
        if (targetType)
            checkTypeDefined(targetType);
        if (sourceType)
            checkTypeDefined(sourceType);
        if (!this.refLog) {
            this.refLog = new Log(this.maxRefChangesPerFrame, 'maxRefChangesPerFrame', this.dispatcher.buffers, { localProcessingAllowed: true });
            this.refLogPointer = this.refLog.createPointer();
            this.refLogStatsPointer = this.refLog.createPointer();
        }
        const selectorSourceKey = sourceType ?
            (sourceFieldSeq === undefined ?
                -2 - sourceType.id : sourceType.id | (sourceFieldSeq << COMPONENT_ID_BITS)) : -1;
        let selectorId = this.selectorIdsBySourceKey.get(selectorSourceKey);
        if (selectorId === undefined) {
            // Always track stale refs on the global selector.
            if (!this.selectors.length)
                trackStale = true;
            const selector = {
                id: this.selectors.length, targetTypes: targetType ? [targetType] : [], sourceType,
                matchType: !!sourceType, matchSeq: sourceFieldSeq !== undefined,
                sourceTypeId: sourceType?.id, sourceSeq: sourceFieldSeq, trackStale
            };
            this.selectors.push(selector);
            selectorId = selector.id;
            this.selectorIdsBySourceKey.set(selectorSourceKey, selectorId);
            if (selectorId > MAX_NUM_COMPONENTS) {
                throw new CheckError(`Too many distinct backrefs selectors`);
            }
        }
        else {
            const selector = this.selectors[selectorId];
            selector.trackStale = selector.trackStale || trackStale;
            if (targetType)
                selector.targetTypes.push(targetType);
        }
        return selectorId;
    }
    getBackrefs(entityId, selectorId = 0) {
        const selector = this.selectors[selectorId];
        return this.getOrCreateTracker(selector, entityId, this.registry.includeRecentlyDeleted).entities;
    }
    trackRefChange(sourceId, sourceType, sourceSeq, sourceInternalIndex, oldTargetId, newTargetId, unreference, release) {
        if (!this.refLog)
            throw new InternalError(`Trying to trackRefChange without a refLog`);
        if (oldTargetId === newTargetId && unreference) {
            throw new InternalError('No-op call to trackRefChange');
        }
        if (oldTargetId !== -1) {
            const action = (unreference ? Action.UNREFERENCE : 0) | (release ? Action.RELEASE : 0);
            if (!action) {
                throw new InternalError('Called trackRefChange with neither unreference nor release');
            }
            this.pushRefLogEntry(sourceId, sourceType, sourceSeq, sourceInternalIndex, oldTargetId, action);
        }
        if (newTargetId !== -1) {
            this.pushRefLogEntry(sourceId, sourceType, sourceSeq, sourceInternalIndex, newTargetId, Action.REFERENCE);
        }
    }
    clearAllRefs(targetId, final) {
        if (!this.selectors.length)
            return;
        this.getTracker(this.selectors[0], targetId, final)?.clearAllRefs(final);
    }
    pushRefLogEntry(sourceId, sourceType, sourceSeq, sourceInternalIndex, targetId, action) {
        const internallyIndexed = typeof sourceInternalIndex !== 'undefined';
        {
            if (internallyIndexed && !sourceType.__binding.fields[sourceSeq].type.internallyIndexed) {
                throw new InternalError('Inconsistent internally indexed flag');
            }
        }
        this.refLog.push(sourceId | (sourceType.id << ENTITY_ID_BITS));
        this.refLog.push(targetId | (sourceSeq << ENTITY_ID_BITS) | action | (internallyIndexed ? 2 ** 29 : 0));
        if (internallyIndexed)
            this.refLog.push(sourceInternalIndex);
        this.processEntry(sourceId, sourceType.id, sourceSeq, sourceInternalIndex, targetId, action, true);
    }
    getOrCreateTracker(selector, targetId, stale) {
        let tracker = this.getTracker(selector, targetId, stale);
        if (tracker)
            return tracker;
        if (stale && !selector.trackStale) {
            throw new InternalError('Selector not configured for stale tracking');
        }
        let staleTracker;
        tracker = new Tracker(targetId, selector, false, this.dispatcher);
        this.trackers.set(targetId | (selector.id << ENTITY_ID_BITS), tracker);
        if (selector.trackStale) {
            staleTracker = new Tracker(targetId, selector, true, this.dispatcher);
            this.trackers.set(targetId | (selector.id << ENTITY_ID_BITS) | 2 ** 31, staleTracker);
        }
        return stale ? staleTracker : tracker;
    }
    getTracker(selector, targetId, stale) {
        return this.trackers.get(targetId | (selector.id << ENTITY_ID_BITS) | (stale ? 2 ** 31 : 0));
    }
    flush() {
        if (!this.refLog)
            return;
        while (true) {
            const [log, startIndex, endIndex, local] = this.refLog.processAndCommitSince(this.refLogPointer);
            if (!log)
                break;
            if (local)
                continue;
            for (let i = startIndex; i < endIndex; i += 2) {
                const entryPart1 = log[i], entryPart2 = log[i + 1];
                const sourceId = (entryPart1 & ENTITY_ID_MASK);
                const sourceTypeId = entryPart1 >>> ENTITY_ID_BITS;
                const targetId = (entryPart2 & ENTITY_ID_MASK);
                const sourceSeq = (entryPart2 >>> ENTITY_ID_BITS) & (MAX_NUM_FIELDS - 1);
                const action = entryPart2 & ACTION_MASK;
                const internallyIndexed = (entryPart2 & 2 ** 29) !== 0;
                const internalIndex = internallyIndexed ? log[i + 2] : undefined;
                if (internallyIndexed)
                    i += 1;
                this.processEntry(sourceId, sourceTypeId, sourceSeq, internalIndex, targetId, action, false);
            }
        }
    }
    processEntry(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, targetId, action, local) {
        for (let j = 0; j < this.selectors.length; j++) {
            const selector = this.selectors[j];
            if ((!selector.matchType || selector.sourceTypeId === sourceTypeId) &&
                (!selector.matchSeq || selector.sourceSeq === sourceSeq)) {
                if (action === Action.REFERENCE || action & Action.UNREFERENCE) {
                    const tracker = this.getOrCreateTracker(selector, targetId, false);
                    if (action === Action.REFERENCE) {
                        tracker.trackReference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);
                    }
                    else {
                        tracker.trackUnreference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);
                    }
                }
                if (selector.trackStale && (action === Action.REFERENCE || action & Action.RELEASE)) {
                    const tracker = this.getOrCreateTracker(selector, targetId, true);
                    if (action === Action.REFERENCE) {
                        tracker.trackReference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);
                    }
                    else {
                        tracker.trackUnreference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);
                    }
                }
            }
        }
    }
}

class Item {
    buffer;
    array;
    update;
}
const arrayTypeToKind = new Map([
    [Uint8Array, 'u8'], [Int8Array, 'i8'], [Uint16Array, 'u16'], [Int16Array, 'i16'],
    [Uint32Array, 'u32'], [Int32Array, 'i32'], [Float32Array, 'f32'], [Float64Array, 'f64']
]);
const arrayKindToType = new Map([
    ['u8', Uint8Array], ['i8', Int8Array], ['u16', Uint16Array], ['i16', Int16Array],
    ['u32', Uint32Array], ['i32', Int32Array], ['f32', Float32Array], ['f64', Float64Array]
]);
class Buffers {
    threaded;
    items = new Map();
    changes;
    constructor(threaded) {
        this.threaded = threaded;
    }
    register(key, length, ArrayType, update, filler) {
        const size = length * ArrayType.BYTES_PER_ELEMENT;
        let item = this.items.get(key);
        const needBiggerBuffer = !item || item.buffer.byteLength < size;
        const needNewArray = needBiggerBuffer || item.array.constructor !== ArrayType;
        if (!item || needBiggerBuffer || needNewArray) {
            const newItem = new Item();
            newItem.buffer = needBiggerBuffer ?
                (this.threaded ? new SharedArrayBuffer(size) : new ArrayBuffer(size)) : item.buffer;
            newItem.array = new ArrayType(newItem.buffer);
            if (item) {
                newItem.array.set(item.array);
                if (filler !== undefined && newItem.array.length > item.array.length) {
                    newItem.array.fill(filler, item.array.length);
                }
            }
            else if (filler !== undefined) {
                newItem.array.fill(filler);
            }
            item = newItem;
            this.items.set(key, item);
            if (this.threaded) {
                if (!this.changes)
                    this.changes = new Map();
                this.changes.set(key, {
                    buffer: item.buffer, arrayKind: arrayTypeToKind.get(ArrayType)
                });
            }
            update?.(item.array);
        }
        item.update = update;
        return item.array;
    }
    makePatch() {
        if (!this.changes)
            return;
        const patch = this.changes;
        this.changes = undefined;
        return patch;
    }
    applyPatch(patch) {
        for (const [key, patchItem] of patch.entries()) {
            const item = new Item();
            item.update = this.items.get(key)?.update;
            item.buffer = patchItem.buffer;
            const ArrayType = arrayKindToType.get(patchItem.arrayKind);
            item.array = new ArrayType(item.buffer);
            this.items.set(key, item);
            item.update?.(item.array);
        }
    }
}

function addFieldSchema(options, target, name) {
    if (!target.constructor.schema)
        target.constructor.schema = {};
    target.constructor.schema[name] = options;
}
function field(practicalOptions) {
    return function (target, name) {
        const options = 'type' in practicalOptions ? practicalOptions : { type: practicalOptions };
        addFieldSchema(options, target, name);
    };
}
function makeVectorDecorator(type) {
    const fn = addFieldSchema.bind(null, { type });
    fn.vector =
        (elements, Class) => (target, name) => {
            addFieldSchema({ type: Type.vector(type, elements, Class) }, target, name);
        };
    return fn;
}
function backrefs(...args) {
    if (typeof args[0] === 'function' || args[0] === undefined) {
        return addFieldSchema.bind(null, { type: Type.backrefs(...args) });
    }
    addFieldSchema({ type: Type.backrefs }, args[0], args[1]);
}
field.boolean = addFieldSchema.bind(null, { type: Type.boolean });
field.uint8 = makeVectorDecorator(Type.uint8);
field.int8 = makeVectorDecorator(Type.int8);
field.uint16 = makeVectorDecorator(Type.uint16);
field.int16 = makeVectorDecorator(Type.int16);
field.uint32 = makeVectorDecorator(Type.uint32);
field.int32 = makeVectorDecorator(Type.int32);
field.float32 = makeVectorDecorator(Type.float32);
field.float64 = makeVectorDecorator(Type.float64);
field.staticString = function (choices) {
    return addFieldSchema.bind(null, { type: Type.staticString(choices) });
};
field.dynamicString = function (maxUtf8Length) {
    return addFieldSchema.bind(null, { type: Type.dynamicString(maxUtf8Length) });
};
field.ref = addFieldSchema.bind(null, { type: Type.ref });
field.backrefs = backrefs;
field.object = addFieldSchema.bind(null, { type: Type.object });
field.weakObject = addFieldSchema.bind(null, { type: Type.weakObject });
const componentTypes = [];
function component(arg, options) {
    if (typeof arg === 'function') {
        componentTypes.push(arg);
    }
    else if (arg instanceof ComponentEnum) {
        return (componentClass) => {
            if (!arg.__types.includes(componentClass))
                arg.__types.push(componentClass);
            componentTypes.push(arg); // duplicates will be removed by Dispatcher
            if (options)
                componentClass.options = options;
        };
    }
    else {
        return (componentClass) => {
            componentClass.options = arg;
            componentTypes.push(componentClass);
        };
    }
}
const systemTypes = [];
function system(arg, scheduler) {
    if (typeof arg === 'function' && !arg.__system) {
        scheduler = arg;
        arg = undefined;
    }
    if (typeof arg === 'function') {
        systemTypes.push(arg);
    }
    else {
        if (arg && !systemTypes.includes(arg))
            systemTypes.push(arg);
        return (systemClass) => {
            if (arg)
                arg.__contents.push(systemClass);
            if (scheduler)
                systemClass.__staticScheduler = scheduler;
            systemTypes.push(systemClass);
        };
    }
}

/**
 * A directed graph with weighted edges and a few extra constraints:
 * 1. Loop edges on a single vertex are not allowed, nor are multiple edges from A to B.
 * 2. An edge from A to B with a higher weight will override an edge from B to A.
 * 3. A "denial" edge from A to B will similarly override lower-weight edges, but not count as an
 *    edge itself.  We store these with negative weights.
 */
class Graph {
    vertices;
    numVertices;
    edges;
    paths;
    vertexIndexMap = new Map();
    sealed = false;
    sortedVertices;
    dependencyCounts;
    traversalCounts;
    numTraversedVertices;
    constructor(vertices) {
        this.vertices = vertices;
        this.numVertices = vertices.length;
        for (let i = 0; i < vertices.length; i++) {
            this.vertexIndexMap.set(vertices[i], i);
        }
        this.edges = new Array(this.numVertices ** 2).fill(0);
        this.dependencyCounts = new Array(this.numVertices);
        this.traversalCounts = new Array(this.numVertices);
    }
    get topologicallySortedVertices() {
        if (!this.sealed)
            throw new InternalError('Graph not yet sealed');
        if (!this.sortedVertices)
            this.sortedVertices = this.sortTopologically();
        return this.sortedVertices;
    }
    getEdgeIndex(source, target) {
        const sourceId = this.vertexIndexMap.get(source);
        const targetId = this.vertexIndexMap.get(target);
        if (sourceId === undefined)
            throw new InternalError(`Unknown vertex: ${source}`);
        if (targetId === undefined)
            throw new InternalError(`Unknown vertex: ${target}`);
        return sourceId * this.numVertices + targetId;
    }
    setEdge(source, target, weight) {
        if (this.sealed)
            throw new InternalError('Graph already sealed');
        if (source === target)
            return;
        const sourceToTarget = this.getEdgeIndex(source, target);
        const targetToSource = this.getEdgeIndex(target, source);
        const absWeight = Math.abs(weight);
        if (absWeight < Math.abs(this.edges[sourceToTarget]) ||
            absWeight < Math.abs(this.edges[targetToSource]))
            return;
        this.edges[sourceToTarget] = weight;
        if (absWeight > Math.abs(this.edges[targetToSource]))
            this.edges[targetToSource] = 0;
    }
    addEdge(source, target, weight) {
        if (weight <= 0)
            throw new InternalError(`Edge has non-positive weight: ${weight}`);
        this.setEdge(source, target, weight);
    }
    denyEdge(source, target, weight) {
        if (weight <= 0)
            throw new InternalError(`Edge has non-positive weight: ${weight}`);
        this.setEdge(source, target, -weight);
    }
    hasEdge(source, target) {
        return this.edges[this.getEdgeIndex(source, target)] > 0;
    }
    hasPath(source, target) {
        if (!this.sealed)
            throw new InternalError('Graph not yet sealed');
        return this.paths[this.getEdgeIndex(source, target)] > 0;
    }
    hasEdgeBetweenIds(sourceId, targetId) {
        if (sourceId > this.numVertices) {
            throw new InternalError(`Vertex id out of range: ${sourceId} > ${this.numVertices}`);
        }
        if (targetId > this.numVertices) {
            throw new InternalError(`Vertex id out of range: ${targetId} > ${this.numVertices}`);
        }
        return this.edges[sourceId * this.numVertices + targetId] > 0;
    }
    seal() {
        if (this.sealed)
            throw new InternalError('Graph already sealed');
        this.sealed = true;
        this.derivePaths();
        this.checkForCycles();
        this.simplify();
        this.countDependencies();
    }
    checkForCycles() {
        const cycles = this.findCycles();
        if (cycles.length) {
            cycles.sort((x, y) => x.length - y.length);
            throw new CheckError('Precedence cycles detected for the following systems, ' +
                'please resolve by adjusting their schedules: ' +
                cycles.map(cycle => cycle.map(u => u.toString()).join('—')).join(', '));
        }
    }
    findCycles() {
        // This implements Johnson's cycle finding algorithm from
        // https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF
        const blocked = new Array(this.numVertices).fill(false), b = [];
        const stack = [], cycles = [];
        let s, vertices;
        for (let i = 0; i < this.numVertices; i++)
            b[i] = new Set();
        const unblock = (u) => {
            blocked[u] = false;
            for (const w of b[u]) {
                b[u].delete(w);
                if (blocked[w])
                    unblock(w);
            }
        };
        const circuit = (v) => {
            let f = false;
            stack.push(v);
            blocked[v] = true;
            for (let w = 0; w < this.numVertices; w++) {
                if (!vertices.has(w) || !this.hasEdgeBetweenIds(v, w))
                    continue;
                if (w === s) {
                    cycles.push(stack.map(u => this.vertices[u]));
                    f = true;
                }
                else if (!blocked[w] && circuit(w)) {
                    f = true;
                }
            }
            if (f) {
                unblock(v);
            }
            else {
                for (let w = 0; w < this.numVertices; w++) {
                    if (!vertices.has(w) || !this.hasEdgeBetweenIds(v, w))
                        continue;
                    b[w].add(v);
                }
            }
            stack.pop();
            return f;
        };
        for (s = 0; s < this.numVertices; s++) {
            const componentVertices = this.findLeastStronglyConnectedComponent(s);
            s = componentVertices[0];
            for (const v of componentVertices) {
                blocked[v] = false;
                b[v].clear();
            }
            vertices = new Set(componentVertices);
            circuit(s);
        }
        return cycles;
    }
    findLeastStronglyConnectedComponent(minId) {
        // Implements the path-based strong component algorithm on the subgraph consisting of vertices
        // minId through numVertices - 1.
        // https://en.wikipedia.org/wiki/Path-based_strong_component_algorithm
        let leastComponent;
        const preorder = [], s = [], p = [];
        const assigned = [];
        let counter = 0;
        const search = (v) => {
            preorder[v] = ++counter;
            s.push(v);
            p.push(v);
            for (let w = minId; w < this.numVertices; w++) {
                if (!this.hasEdgeBetweenIds(v, w))
                    continue;
                if (preorder[w]) {
                    if (!assigned[w]) {
                        while (p.length && preorder[p[p.length - 1]] > preorder[w])
                            p.pop();
                    }
                }
                else {
                    search(w);
                }
            }
            if (p[p.length - 1] === v) {
                const component = [];
                while (true) {
                    const w = s.pop();
                    component.push(w);
                    assigned[w] = true;
                    if (w === v)
                        break;
                }
                p.pop();
                component.sort((a, b) => a - b);
                if (!leastComponent || component[0] < leastComponent[0])
                    leastComponent = component;
            }
        };
        for (let i = minId; i < this.numVertices; i++) {
            if (!preorder[i])
                search(i);
        }
        return leastComponent;
    }
    induceSubgraph(subvertices) {
        const subgraph = new Graph(subvertices);
        for (const vertex of subvertices) {
            if (!this.vertexIndexMap.has(vertex)) {
                throw new InternalError(`Vertex not in graph: ${vertex}`);
            }
            for (const target of subvertices) {
                const edgeIndex = this.getEdgeIndex(vertex, target);
                const weight = this.edges[edgeIndex];
                if (weight > 0) {
                    subgraph.addEdge(vertex, target, weight);
                }
                else if (weight < 0) {
                    subgraph.denyEdge(vertex, target, -weight);
                }
            }
        }
        if (this.sealed)
            subgraph.seal();
        return subgraph;
    }
    sortTopologically() {
        const edgeCounts = new Array(this.numVertices).fill(0);
        for (let i = 0; i < this.numVertices; i++) {
            for (let j = 0; j < this.numVertices; j++) {
                if (this.hasEdgeBetweenIds(i, j))
                    edgeCounts[j] += 1;
            }
        }
        const vertices = [];
        let changed;
        while (vertices.length < this.numVertices) {
            changed = false;
            for (let i = 0; i < edgeCounts.length; i++) {
                if (edgeCounts[i] === 0) {
                    changed = true;
                    edgeCounts[i] = -1;
                    vertices.push(this.vertices[i]);
                    for (let j = 0; j < this.numVertices; j++) {
                        if (this.hasEdgeBetweenIds(i, j))
                            edgeCounts[j] -= 1;
                    }
                }
            }
            if (!changed) {
                throw new InternalError('Graph has a cycle, topological sort not possible');
            }
        }
        return vertices;
    }
    derivePaths() {
        const n = this.numVertices;
        // Remove denial edges, no longer needed
        for (let i = 0; i < this.edges.length; i++) {
            if (this.edges[i] < 0)
                this.edges[i] = 0;
        }
        // console.log(this.printMatrix(this.edges));
        // Derive path matrix using a variant of the Floyd-Warshall algorithm
        const paths = this.edges.slice();
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i === j)
                    continue;
                for (let k = 0; k < n; k++) {
                    if (k === i || k === j)
                        continue;
                    const weight1 = paths[i * n + k];
                    const weight2 = paths[k * n + j];
                    if (weight1 && weight2) {
                        const weight = Math.min(weight1, weight2);
                        if (paths[i * n + j] < weight && paths[j * n + i] < weight) {
                            paths[i * n + j] = weight;
                            paths[j * n + i] = 0;
                        }
                    }
                }
            }
        }
        this.paths = paths;
        // console.log(this.printMatrix(paths));
        // Overwrite edge weights with stronger paths.
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (this.edges[i * n + j])
                    this.edges[i * n + j] = paths[i * n + j];
            }
        }
    }
    simplify() {
        const n = this.numVertices;
        const paths = this.paths;
        // Perform a transitive reduction
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (!this.edges[i * n + j])
                    continue;
                for (let k = 0; k < n; k++) {
                    if (k === i || k === j)
                        continue;
                    if (paths[i * n + k] && paths[k * n + j])
                        this.edges[i * n + j] = 0;
                }
            }
        }
        // console.log(this.printMatrix(this.edges));
    }
    countDependencies() {
        for (let i = 0; i < this.numVertices; i++) {
            let count = 0;
            for (let j = 0; j < this.numVertices; j++) {
                if (this.edges[j * this.numVertices + i])
                    count += 1;
            }
            this.dependencyCounts[i] = count;
        }
    }
    /**
     * Traverses vertices of the graph based on dependency order.  When called without an argument it
     * initializes (or re-initializes) the traversal and returns vertices with no dependencies.  When
     * called with an argument, it marks that vertex as done and returns the vertices whose
     * dependencies are all satisfied (if any).
     * @param completedVertex The vertex to mark done; if missing, initializes the traversal instead.
     * @returns The list of vertices whose dependencies have all been satisfied, or `undefined` if
     *    this was the last vertex and the traversal is done.
     */
    traverse(completedVertex) {
        if (!this.sealed)
            throw new InternalError('Graph not yet sealed');
        const traversedVertices = [];
        if (completedVertex) {
            this.numTraversedVertices += 1;
            const sourceId = this.vertexIndexMap.get(completedVertex);
            if (sourceId === undefined) {
                throw new InternalError(`Unknown vertex: ${completedVertex}`);
            }
            for (let i = 0; i < this.numVertices; i++) {
                if (this.edges[sourceId * this.numVertices + i]) {
                    if (--this.traversalCounts[i] === 0) {
                        traversedVertices.push(this.vertices[i]);
                    }
                }
            }
        }
        else {
            this.numTraversedVertices = 0;
            for (let i = 0; i < this.numVertices; i++) {
                const count = this.traversalCounts[i] = this.dependencyCounts[i];
                if (count === 0) {
                    traversedVertices.push(this.vertices[i]);
                }
            }
        }
        if (this.numTraversedVertices === this.numVertices)
            return;
        return traversedVertices;
    }
    printMatrix(matrix) {
        const n = this.numVertices;
        const lines = [];
        for (let i = 0; i < n; i++) {
            const line = [];
            for (let j = 0; j < n; j++)
                line.push(matrix[i * n + j]);
            lines.push(line.join(' '));
        }
        return lines.join('\n');
    }
}

class Plan {
    planner;
    group;
    graph;
    constructor(planner, group) {
        this.planner = planner;
        this.group = group;
        this.graph = planner.graph.induceSubgraph(group.__systems);
    }
}
class SimplePlan extends Plan {
    planner;
    group;
    systems;
    constructor(planner, group) {
        super(planner, group);
        this.planner = planner;
        this.group = group;
        this.systems = this.graph.topologicallySortedVertices;
        if (this.systems.length > 1 && (typeof process === 'undefined' || "development" === 'development')) {
            console.log('System execution order:');
            for (const system of this.systems)
                console.log(' ', system.name);
        }
    }
    execute(time, delta) {
        const dispatcher = this.planner.dispatcher;
        const systems = this.systems;
        this.group.__executed = true;
        for (let i = 0; i < systems.length; i++) {
            const system = systems[i];
            system.execute(time, delta);
            dispatcher.flush();
        }
        return Promise.resolve();
    }
    async initialize() {
        const dispatcher = this.planner.dispatcher;
        this.group.__executed = true;
        return new Promise((resolve, reject) => {
            let rejected = false;
            const initSystem = async (system) => {
                try {
                    await system.prepare();
                    if (rejected)
                        return;
                    system.initialize();
                    dispatcher.flush();
                    const systems = this.graph.traverse(system);
                    if (!systems)
                        return resolve();
                    for (let i = 0; i < systems.length; i++)
                        initSystem(systems[i]);
                }
                catch (e) {
                    rejected = true;
                    reject(e);
                }
            };
            const systems = this.graph.traverse();
            if (!systems)
                return resolve();
            for (let i = 0; i < systems.length; i++)
                initSystem(systems[i]);
        });
    }
    async finalize() {
        const dispatcher = this.planner.dispatcher;
        this.group.__executed = true;
        return new Promise((resolve, reject) => {
            const finalizeSystem = (system) => {
                try {
                    system.finalize();
                    dispatcher.flush();
                    const systems = this.graph.traverse(system);
                    if (!systems)
                        return resolve();
                    for (let i = 0; i < systems.length; i++)
                        finalizeSystem(systems[i]);
                }
                catch (e) {
                    reject(e);
                }
            };
            const systems = this.graph.traverse();
            if (!systems)
                return resolve();
            for (let i = 0; i < systems.length; i++)
                finalizeSystem(systems[i]);
        });
    }
}
class ThreadedPlan extends Plan {
    execute(time, delta) {
        return Promise.resolve();
    }
    initialize() {
        return Promise.resolve();
    }
    finalize() {
        return Promise.resolve();
    }
}
class Lane {
    id;
    systems = [];
    constructor(id) {
        this.id = id;
    }
    add(...systems) {
        for (const system of systems)
            system.lane = this;
        this.systems.push(...systems);
    }
    merge(other) {
        if (this === other)
            return this;
        if (this.id === -1 || (other.id !== -1 && other.id < this.id))
            return other.merge(this);
        this.add(...other.systems);
        other.systems.length = 0;
        return this;
    }
}
class Planner {
    dispatcher;
    systems;
    groups;
    graph;
    readers = new Map();
    writers = new Map();
    lanes = [];
    replicatedLane;
    laneCount = 0;
    constructor(dispatcher, systems, groups) {
        this.dispatcher = dispatcher;
        this.systems = systems;
        this.groups = groups;
        this.graph = new Graph(systems);
        for (const componentType of dispatcher.registry.types) {
            this.readers.set(componentType, new Set());
            this.writers.set(componentType, new Set());
        }
        if (dispatcher.threaded) {
            this.createLane();
            // special lane id, and don't keep this in the lanes array
            this.replicatedLane = new Lane(-1);
        }
    }
    get mainLane() {
        return this.lanes[0];
    }
    createLane() {
        const lane = new Lane(this.laneCount++);
        this.lanes.push(lane);
        return lane;
    }
    organize() {
        for (const group of this.groups)
            group.__collectSystems(this.dispatcher);
        for (const system of this.systems)
            system.buildQueries();
        for (const system of this.systems)
            system.buildSchedule();
        for (const group of this.groups)
            group.__buildSchedule();
        this.addComponentEntitlementDependencies();
        this.graph.seal();
        if (this.dispatcher.threaded)
            this.assignSystemsToLanes();
        for (const system of this.systems)
            system.stats.worker = system.lane?.id ?? 0;
        delete this.readers;
        delete this.writers;
        for (const group of this.groups) {
            group.__plan =
                this.dispatcher.threaded ? new ThreadedPlan(this, group) : new SimplePlan(this, group);
        }
    }
    addComponentEntitlementDependencies() {
        for (const [componentType, systems] of this.readers.entries()) {
            for (const reader of systems) {
                for (const writer of this.writers.get(componentType)) {
                    this.graph.addEdge(writer, reader, 1);
                }
            }
        }
    }
    assignSystemsToLanes() {
        this.initSystemLanes();
        this.mergeAccessorsOfUnsharedComponentTypes();
        this.mergeAttachedSystems();
        this.pruneEmptyLanes();
        this.reduceLanes(this.dispatcher.threads + 1);
        this.pruneEmptyLanes();
    }
    initSystemLanes() {
        for (const system of this.systems) {
            if (!system.lane)
                this.createLane().add(system);
        }
    }
    mergeAccessorsOfUnsharedComponentTypes() {
        for (const componentType of this.dispatcher.registry.types) {
            if (componentType.__binding.fields.every(field => field.type.shared))
                continue;
            const readers = this.readers.get(componentType);
            const writers = this.writers.get(componentType);
            if (!readers && !writers)
                continue;
            let lane = componentType.options?.restrictedToMainThread ? this.mainLane : this.createLane();
            readers?.forEach(system => {
                lane = lane.merge(system.lane);
            });
            writers?.forEach(system => {
                lane = lane.merge(system.lane);
            });
        }
    }
    mergeAttachedSystems() {
        for (const system of this.systems) {
            for (const attachedSystem of system.attachedSystems) {
                if (!attachedSystem)
                    continue;
                system.lane.merge(attachedSystem.lane);
            }
        }
    }
    reduceLanes(maxNumLanes) {
        if (this.lanes.length <= maxNumLanes)
            return;
        let pairs = [];
        for (let i = 1; i < this.lanes.length - 1; i++) { // don't merge into lane 0 unless necessary
            const laneA = this.lanes[i];
            for (let j = i + 1; j < this.lanes.length; j++) {
                const laneB = this.lanes[j];
                pairs.push({ laneA, laneB, independence: this.computeIndependence(laneA, laneB) });
            }
        }
        let numLanes = this.lanes.length;
        while (numLanes > maxNumLanes) {
            pairs.sort((pair1, pair2) => pair2.independence - pair1.independence);
            const tangledPair = pairs.pop();
            const combinedLane = tangledPair.laneA.merge(tangledPair.laneB);
            const discardedLane = combinedLane === tangledPair.laneA ? tangledPair.laneB : tangledPair.laneA;
            numLanes -= 1;
            if (numLanes > maxNumLanes) {
                pairs = pairs.filter(pair => {
                    if (pair.laneA === discardedLane || pair.laneB === discardedLane)
                        return false;
                    if (pair.laneA === combinedLane || pair.laneB === combinedLane) {
                        pair.independence = this.computeIndependence(pair.laneA, pair.laneB);
                    }
                    return true;
                });
            }
        }
    }
    computeIndependence(laneA, laneB) {
        return Math.min(this.computeIndependentWeight(laneA, laneB), this.computeIndependentWeight(laneB, laneA));
    }
    computeIndependentWeight(lane, otherLane) {
        let independentWeight = 0;
        for (const system of lane.systems) {
            let otherWeight = 0;
            for (const otherSystem of otherLane.systems) {
                if (!this.graph.hasPath(system, otherSystem) && !this.graph.hasPath(otherSystem, system)) {
                    otherWeight += otherSystem.weight;
                }
            }
            independentWeight += Math.min(system.weight, otherWeight);
        }
        return independentWeight;
    }
    pruneEmptyLanes() {
        this.lanes = this.lanes.filter(lane => lane.id === 0 || lane.systems.length);
        // Never prune the main thread lane.
        for (let i = 1; i < this.lanes.length; i++) {
            this.lanes[i].id = i;
        }
    }
}

class Build extends System {
    __callback;
    start(coroutineFn, ...args) {
        throw new CheckError('The build system cannot run coroutines');
    }
    execute() {
        this.__callback(this);
    }
}
class Validate extends System {
}
var State;
(function (State) {
    State[State["init"] = 0] = "init";
    State[State["setup"] = 1] = "setup";
    State[State["run"] = 2] = "run";
    State[State["finish"] = 3] = "finish";
    State[State["done"] = 4] = "done";
})(State || (State = {}));
class Dispatcher {
    maxEntities;
    defaultComponentStorage;
    registry;
    systems;
    systemsByClass = new Map();
    systemGroups;
    default;
    lastTime;
    executing;
    state = State.init;
    shapeLog;
    writeLog;
    shapeLogFramePointer;
    writeLogFramePointer;
    stats;
    indexer;
    planner;
    threads;
    buffers;
    singleton;
    buildSystem;
    callback;
    deferredControls = new Map();
    constructor({ defs, threads = 1, maxEntities = 10000, maxLimboComponents = Math.ceil(maxEntities / 5), maxShapeChangesPerFrame = maxEntities * 2, maxWritesPerFrame = maxEntities * 4, maxRefChangesPerFrame = maxEntities, defaultComponentStorage = 'packed' }) {
        if (threads < 1)
            throw new CheckError('Minimum of one thread');
        if (threads > 1)
            throw new CheckError('Multithreading not yet implemented');
        if (maxEntities > MAX_NUM_ENTITIES) {
            throw new CheckError(`maxEntities too high, the limit is ${MAX_NUM_ENTITIES}`);
        }
        const { componentTypes: componentTypes$1, componentEnums, systemTypes: systemTypes$1, systemGroups } = this.splitDefs([defs ?? [], componentTypes, systemTypes]);
        if (componentTypes$1.length > MAX_NUM_COMPONENTS) {
            throw new CheckError(`Too many component types, the limit is ${MAX_NUM_COMPONENTS}`);
        }
        this.stats = new Stats();
        this.threads = threads;
        this.buffers = new Buffers(threads > 1);
        this.maxEntities = maxEntities;
        this.defaultComponentStorage = defaultComponentStorage;
        this.registry =
            new Registry(maxEntities, maxLimboComponents, componentTypes$1, componentEnums, this);
        this.indexer = new RefIndexer(this, maxRefChangesPerFrame);
        this.shapeLog = new Log(maxShapeChangesPerFrame, 'maxShapeChangesPerFrame', this.buffers, { sortedByComponentType: true, numComponentTypes: this.registry.types.length });
        this.shapeLogFramePointer = this.shapeLog.createPointer();
        this.systemGroups = systemGroups;
        this.systems = this.createSystems(systemTypes$1);
        this.createBuildSystem();
        this.registry.initializeComponentTypes();
        this.registry.validateSystem = this.createValidateSystem(componentTypes$1);
        this.singleton = this.createSingletons();
        for (const box of this.systems)
            box.replacePlaceholders();
        this.planner = new Planner(this, this.systems, this.systemGroups);
        this.planner.organize();
        this.registry.hasNegativeQueries = this.systems.some(system => system.hasNegativeQueries);
        if (this.systems.some(system => system.hasWriteQueries)) {
            this.writeLog = new Log(maxWritesPerFrame, 'maxWritesPerFrame', this.buffers, { sortedByComponentType: true, numComponentTypes: this.registry.types.length });
            this.writeLogFramePointer = this.writeLog.createPointer();
        }
        for (const box of this.systems)
            box.finishConstructing();
        this.state = State.setup;
    }
    get threaded() { return this.threads > 1; }
    get defaultGroup() { return this.default.group; }
    createSystems(systemTypes) {
        const systems = [];
        const systemClasses = [];
        for (let i = 0; i < systemTypes.length; i++) {
            const SystemClass = systemTypes[i];
            let box = this.systemsByClass.get(SystemClass);
            if (!box) {
                systemClasses.push(SystemClass);
                const system = new SystemClass();
                system.id = (i + 2); // 0 and 1 are reserved for internal systems
                box = new SystemBox(system, this);
                systems.push(box);
                this.systemsByClass.set(SystemClass, box);
            }
            const props = systemTypes[i + 1];
            if (props && typeof props !== 'function') {
                box.assignProps(props);
                i++;
            }
        }
        this.default = this.createSingleGroupFrame(systemClasses);
        return systems;
    }
    createBuildSystem() {
        this.buildSystem = new Build();
        this.buildSystem.id = 0;
        const box = new SystemBox(this.buildSystem, this);
        box.accessMasks.read = undefined;
        box.accessMasks.update = undefined;
        box.accessMasks.create = undefined;
        box.accessMasks.write = undefined;
        box.accessMasks.check = undefined;
        this.systems.push(box);
        this.systemsByClass.set(Build, box);
        this.callback = this.createSingleGroupFrame([Build]);
    }
    createValidateSystem(componentTypes) {
        const system = new Validate();
        system.id = 1;
        const box = new SystemBox(system, this);
        for (const type of componentTypes)
            extendMaskAndSetFlag(box.accessMasks.check, type);
        this.systems.push(box);
        this.systemsByClass.set(Validate, box);
        return box;
    }
    createSingleGroupFrame(systemTypes) {
        const group = new SystemGroupImpl(systemTypes);
        this.systemGroups.push(group);
        const frame = new FrameImpl(this, [group]);
        return { group, frame };
    }
    createSingletons() {
        const types = new Set();
        const singletonComponentDefs = this.systems.flatMap(box => {
            return box.singletonComponentDefs.filter((item, i) => {
                let accepted = true;
                if (typeof item === 'function') {
                    accepted = i < box.singletonComponentDefs.length - 1 &&
                        typeof box.singletonComponentDefs[i + 1] !== 'function';
                    if (accepted)
                        types.add(item);
                }
                return accepted;
            });
        }).concat(this.systems.flatMap(box => {
            return box.singletonComponentDefs.filter(item => {
                if (typeof item === 'function' && !types.has(item)) {
                    types.add(item);
                    return true;
                }
                return false;
            });
        }));
        if (!singletonComponentDefs.length)
            return;
        this.executing = true;
        const singleton = this.createEntity(singletonComponentDefs).hold();
        this.executing = false;
        this.flush();
        return singleton;
    }
    splitDefs(defs) {
        const componentTypes = [];
        const componentTypesSet = new Set();
        const componentEnums = new Set();
        const systemTypes = [];
        const systemGroups = [];
        let lastDefWasSystem = false;
        for (const def of defs.flat(Infinity)) {
            if (def instanceof SystemGroupImpl) {
                systemGroups.push(def);
                const { componentTypes: nestedComponentTypes, systemTypes: nestedSystemTypes, systemGroups: nestedSystemGroups } = this.splitDefs(def.__contents);
                for (const type of nestedComponentTypes)
                    addUniqueComponentType(type);
                systemTypes.push(...nestedSystemTypes);
                systemGroups.push(...nestedSystemGroups);
            }
            else if (typeof def === 'function') {
                lastDefWasSystem = !!def.__system;
                if (lastDefWasSystem) {
                    systemTypes.push(def);
                }
                else {
                    addUniqueComponentType(def);
                }
            }
            else if (def instanceof ComponentEnum) {
                componentEnums.add(def);
                for (const type of def.__types)
                    addUniqueComponentType(type);
            }
            else {
                {
                    if (!lastDefWasSystem)
                        throw new CheckError('Unexpected value in world defs: ' + def);
                }
                systemTypes.push(def);
                lastDefWasSystem = false;
            }
        }
        return { componentTypes, componentEnums: Array.from(componentEnums), systemTypes, systemGroups };
        function addUniqueComponentType(type) {
            if (type.enum && !componentEnums.has(type.enum)) {
                componentEnums.add(type.enum);
                for (const enumType of type.enum.__types)
                    addUniqueComponentType(enumType);
            }
            else if (!componentTypesSet.has(type)) {
                componentTypes.push(type);
                componentTypesSet.add(type);
            }
        }
    }
    getSystems(designator) {
        if (designator instanceof SystemGroupImpl)
            return designator.__systems;
        const system = this.systemsByClass.get(designator);
        if (!system)
            throw new CheckError(`System ${designator.name} not registered in world`);
        return [system];
    }
    async initialize() {
        this.default.frame.begin();
        this.state = State.setup;
        await this.default.group.__plan.initialize();
        this.default.frame.end();
        this.stats.frames -= 1;
    }
    async finalize() {
        this.default.frame.begin();
        this.state = State.done;
        await this.default.group.__plan.finalize();
        this.default.frame.end();
        this.stats.frames -= 1;
        this.registry.releaseComponentTypes();
    }
    async execute(time, delta) {
        this.default.frame.begin();
        await this.default.frame.execute(this.default.group, time, delta);
        this.default.frame.end();
    }
    executeFunction(fn) {
        this.callback.frame.begin();
        this.buildSystem.__callback = fn;
        // We know this execution will always be synchronous.
        this.callback.frame.execute(this.callback.group, 0, 0);
        this.callback.frame.end();
        // This is not really a frame, so back out the count.
        this.stats.frames -= 1;
    }
    completeCycle() {
        this.registry.completeCycle();
        this.indexer.completeCycle();
    }
    startFrame(time) {
        if (this.executing)
            throw new CheckError('Another frame already executing');
        this.executing = true;
        {
            if (this.state !== State.setup && this.state !== State.run && this.state !== State.finish) {
                throw new CheckError('World terminated');
            }
        }
        this.state = State.run;
        this.lastTime = time;
    }
    async completeFrame() {
        if (!this.executing)
            throw new InternalError('No frame executing');
        this.executing = false;
        this.gatherFrameStats();
        this.processDeferredControls();
        if (this.state === State.finish)
            await this.finalize();
    }
    gatherFrameStats() {
        this.stats.frames += 1;
        this.stats.maxShapeChangesPerFrame = this.shapeLog.countSince(this.shapeLogFramePointer);
        this.stats.maxWritesPerFrame = this.writeLog?.countSince(this.writeLogFramePointer) ?? 0;
    }
    flush() {
        this.indexer.flush(); // may update writeLog
        this.registry.flush();
        this.shapeLog.commit();
        this.writeLog?.commit();
    }
    async terminate() {
        {
            if (this.state !== State.setup && this.state !== State.run) {
                throw new CheckError('World terminated');
            }
        }
        this.state = State.finish;
        if (!this.executing)
            await this.finalize();
    }
    createEntity(initialComponents) {
        const entity = this.registry.createEntity(initialComponents);
        if (!this.executing)
            this.flush();
        return entity;
    }
    control(options) {
        this.checkControlOverlap(options);
        this.deferRequestedRunState(options.stop, RunState.STOPPED);
        this.deferRequestedRunState(options.restart, RunState.RUNNING);
        if (!this.executing)
            this.processDeferredControls();
    }
    deferRequestedRunState(defs, state) {
        for (const def of this.splitDefs(defs).systemTypes) {
            if (!def.__system)
                continue;
            const system = this.systemsByClass.get(def);
            if (!system)
                throw new CheckError(`System ${def.name} not defined for this world`);
            this.deferredControls.set(system, state);
        }
    }
    checkControlOverlap(options) {
        const stopSet = new Set();
        for (const def of this.splitDefs(options.stop).systemTypes) {
            if (def.__system)
                stopSet.add(def);
        }
        for (const def of this.splitDefs(options.restart).systemTypes) {
            if (!def.__system)
                continue;
            if (stopSet.has(def)) {
                throw new CheckError(`Request to both stop and restart system ${def.name}`);
            }
        }
    }
    processDeferredControls() {
        if (!this.deferredControls.size)
            return;
        for (const [system, state] of this.deferredControls.entries()) {
            switch (state) {
                case RunState.STOPPED:
                    system.stop();
                    break;
                case RunState.RUNNING:
                    system.restart();
                    break;
            }
        }
        this.deferredControls.clear();
    }
}

const MAGIC_COOKIE = {};
/**
 * A container for entities, components, and systems, and the sole entry point to all functionality.
 * Normally you'll create just one world for your game or app.
 */
class World {
    __dispatcher;
    /**
     * Creates a world that contains entities, components and systems.  All systems will be
     * instantiated and initialized before the returned promise resolves.
     *
     * You cannot add more component or system types once the world has been created. You can create
     * multiple worlds but they will not share entities, and must not share component types.  (They
     * can share system types, but each will have its own instances of them.)
     *
     * @param options The options with which to initialize the world.
     *
     * @returns A promise of a new world to do with as you please.
     */
    static async create(options = {}) {
        const world = new World(options, MAGIC_COOKIE);
        await world.__dispatcher.initialize();
        return world;
    }
    static defineEnum(name, ...componentTypes) {
        if (typeof name === 'function') {
            componentTypes.unshift(name);
            name = '';
        }
        name = name || '<anonymous>';
        return new ComponentEnum(name, componentTypes);
    }
    /**
     * This is a private constructor, please use the World.create() method instead.
     */
    constructor(options, magicCookie) {
        {
            if (magicCookie !== MAGIC_COOKIE) {
                throw new CheckError(`Don't call World constructor directly; use World.create instead`);
            }
        }
        this.__dispatcher = new Dispatcher(options);
    }
    /**
     * Executes a function that creates and updates entities.  The function gets executed in the
     * context of a no-op system so it can access all its convenience methods.  You can only invoke
     * this method when the world is not executing, e.g. during initial setup or between frames.
     *
     * @param callback The function to execute.  It receives a system as the sole argument, which it
     * can use to create new entities.  You can retain references to these entities within the
     * function but you must be careful not to let them leak out, as the entity objects are merely
     * handles that will be reassigned without warning.  (The entities themselves will persist, of
     * course.)
     */
    build(callback) {
        {
            if (this.__dispatcher.state !== State.setup &&
                (typeof process === 'undefined' || "development" !== 'test')) {
                throw new CheckError('This method cannot be called after the world has started executing');
            }
        }
        this.__dispatcher.executeFunction(callback);
    }
    /**
     * Creates a new entity and add it to the world.  The entity is not returned -- if you need that,
     * use `build` instead.
     *
     * @param initialComponents The types of the components to add to the new entity, optionally
     * interleaved with their initial properties.
     */
    createEntity(...initialComponents) {
        {
            if (this.__dispatcher.state !== State.setup &&
                (typeof process === 'undefined' || "development" !== 'test')) {
                throw new CheckError('This method cannot be called after the world has started executing');
            }
        }
        this.__dispatcher.createEntity(initialComponents);
    }
    /**
     * Executes all the systems defined during the world's creation.  The systems will be executed as
     * ordered by their constraints, *not* in the order they were defined.  See
     * {@link System.schedule} for details.
     *
     * @param time The time of this frame's execution.  This will be set on every system's `time`
     * property and defaults to the time when `execute` was called.  It's not used internally so you
     * can pass in any numeric value that's expected by your systems.
     *
     * @param delta The duration since the last frame's execution.  This will be set on every system's
     * `delta` property and default to the duration since the previous call to `execute`. It's not
     * used internally so you can pass in any numeric value that's expected by your systems.
     */
    execute(time, delta) {
        return this.__dispatcher.execute(time, delta);
    }
    /**
     * Controls the running state of systems by stopping or restarting them.  Stopped systems won't
     * update their queries and generally won't consume resources.  Restarting a system is a
     * potentially expensive operation so you should only use this facility for major state changes,
     * e.g. between scenes.  Restarted systems will not backfill any reactive queries with events that
     * happened while they were stopped.
     *
     * You can call this method at any time but the control instructions will only be applied between
     * frames.
     *
     * @param options The control instructions.
     */
    control(options) {
        this.__dispatcher.control(options);
    }
    /**
     * Creates an executor that allows you to run a subset of all defined systems in a frame, or run
     * some of them multiple times.  You can switch which executor you use between frames or even
     * interleave running becsy's default execution strategy with your own executors.  However, if
     * there are systems that won't be running for a while (because they're not in any of your
     * executor's groups) you must still stop them explicitly or you'll run out of reserved buffer
     * space.
     *
     * Creating an executor is a potentially expensive operation so you should create them all up
     * front for the various combinations of system groups you might want to run.
     *
     * @param groups All the possible groups of systems that this executor might want to run.  The
     * groups must be a subset of the world's defined groups.  Every group must be executed regularly
     * at least once every few frames, otherwise you'll likely overflow reserved buffer space.  (This
     * is true even if the groups overlap, as execution is tracked at a group level, not for
     * individual systems.)
     *
     * @returns A frame executor that lets you manually run system groups within a frame.
     */
    createCustomExecutor(...groups) {
        return new FrameImpl(this.__dispatcher, groups);
    }
    /**
     * Terminates this world once the current frame (if any) completes.  All workers will be
     * terminated and no further executions will be allowed.
     */
    async terminate() {
        await this.__dispatcher.terminate();
    }
    get stats() {
        return this.__dispatcher.stats;
    }
    /**
     * Returns whether this world is alive and capable of execution (true), or has been terminated
     * (false).
     */
    get alive() {
        return this.__dispatcher.state !== State.done;
    }
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/core/Constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/Constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AVERAGE": () => (/* binding */ AVERAGE),
/* harmony export */   "BYTES_PER_NODE": () => (/* binding */ BYTES_PER_NODE),
/* harmony export */   "CENTER": () => (/* binding */ CENTER),
/* harmony export */   "CONTAINED": () => (/* binding */ CONTAINED),
/* harmony export */   "FLOAT32_EPSILON": () => (/* binding */ FLOAT32_EPSILON),
/* harmony export */   "INTERSECTED": () => (/* binding */ INTERSECTED),
/* harmony export */   "IS_LEAFNODE_FLAG": () => (/* binding */ IS_LEAFNODE_FLAG),
/* harmony export */   "NOT_INTERSECTED": () => (/* binding */ NOT_INTERSECTED),
/* harmony export */   "SAH": () => (/* binding */ SAH),
/* harmony export */   "TRAVERSAL_COST": () => (/* binding */ TRAVERSAL_COST),
/* harmony export */   "TRIANGLE_INTERSECT_COST": () => (/* binding */ TRIANGLE_INTERSECT_COST)
/* harmony export */ });
// Split strategy constants
const CENTER = 0;
const AVERAGE = 1;
const SAH = 2;

// Traversal constants
const NOT_INTERSECTED = 0;
const INTERSECTED = 1;
const CONTAINED = 2;

// SAH cost constants
// TODO: hone these costs more. The relative difference between them should be the
// difference in measured time to perform a triangle intersection vs traversing
// bounds.
const TRIANGLE_INTERSECT_COST = 1.25;
const TRAVERSAL_COST = 1;


// Build constants
const BYTES_PER_NODE = 6 * 4 + 4 + 4;
const IS_LEAFNODE_FLAG = 0xFFFF;

// EPSILON for computing floating point error during build
// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics
const FLOAT32_EPSILON = Math.pow( 2, - 24 );



/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/core/MeshBVH.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/MeshBVH.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshBVH": () => (/* binding */ MeshBVH)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Constants.js */ "./node_modules/three-mesh-bvh/src/core/Constants.js");
/* harmony import */ var _buildFunctions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./buildFunctions.js */ "./node_modules/three-mesh-bvh/src/core/buildFunctions.js");
/* harmony import */ var _castFunctions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./castFunctions.js */ "./node_modules/three-mesh-bvh/src/core/castFunctions.js");
/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/OrientedBox.js */ "./node_modules/three-mesh-bvh/src/math/OrientedBox.js");
/* harmony import */ var _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/ExtendedTriangle.js */ "./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js");
/* harmony import */ var _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/PrimitivePool.js */ "./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js");
/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/ArrayBoxUtilities.js */ "./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js");
/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/TriangleUtilities.js */ "./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js");










const SKIP_GENERATION = Symbol( 'skip tree generation' );

const aabb = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const aabb2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const tempMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();
const obb2 = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();
const temp = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const temp1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const temp2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const temp3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const temp4 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tempBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const trianglePool = /* @__PURE__ */ new _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_2__.PrimitivePool( () => new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_3__.ExtendedTriangle() );

class MeshBVH {

	static serialize( bvh, options = {} ) {

		if ( options.isBufferGeometry ) {

			console.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );

			return MeshBVH.serialize(
				arguments[ 0 ],
				{
					cloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],
				}
			);

		}

		options = {
			cloneBuffers: true,
			...options,
		};

		const geometry = bvh.geometry;
		const rootData = bvh._roots;
		const indexAttribute = geometry.getIndex();
		let result;
		if ( options.cloneBuffers ) {

			result = {
				roots: rootData.map( root => root.slice() ),
				index: indexAttribute.array.slice(),
			};

		} else {

			result = {
				roots: rootData,
				index: indexAttribute.array,
			};

		}

		return result;

	}

	static deserialize( data, geometry, options = {} ) {

		if ( typeof options === 'boolean' ) {

			console.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );

			return MeshBVH.deserialize(
				arguments[ 0 ],
				arguments[ 1 ],
				{
					setIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],
				}
			);

		}

		options = {
			setIndex: true,
			...options,
		};

		const { index, roots } = data;
		const bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );
		bvh._roots = roots;

		if ( options.setIndex ) {

			const indexAttribute = geometry.getIndex();
			if ( indexAttribute === null ) {

				const newIndex = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( data.index, 1, false );
				geometry.setIndex( newIndex );

			} else if ( indexAttribute.array !== index ) {

				indexAttribute.array.set( index );
				indexAttribute.needsUpdate = true;

			}

		}

		return bvh;

	}

	constructor( geometry, options = {} ) {

		if ( ! geometry.isBufferGeometry ) {

			throw new Error( 'MeshBVH: Only BufferGeometries are supported.' );

		} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {

			throw new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );

		}

		// default options
		options = Object.assign( {

			strategy: _Constants_js__WEBPACK_IMPORTED_MODULE_4__.CENTER,
			maxDepth: 40,
			maxLeafTris: 10,
			verbose: true,
			useSharedArrayBuffer: false,
			setBoundingBox: true,
			onProgress: null,

			// undocumented options

			// Whether to skip generating the tree. Used for deserialization.
			[ SKIP_GENERATION ]: false,

		}, options );

		if ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {

			throw new Error( 'MeshBVH: SharedArrayBuffer is not available.' );

		}

		this._roots = null;
		if ( ! options[ SKIP_GENERATION ] ) {

			this._roots = (0,_buildFunctions_js__WEBPACK_IMPORTED_MODULE_5__.buildPackedTree)( geometry, options );

			if ( ! geometry.boundingBox && options.setBoundingBox ) {

				geometry.boundingBox = this.getBoundingBox( new three__WEBPACK_IMPORTED_MODULE_0__.Box3() );

			}

		}

		// retain references to the geometry so we can use them it without having to
		// take a geometry reference in every function.
		this.geometry = geometry;

	}

	refit( nodeIndices = null ) {

		if ( nodeIndices && Array.isArray( nodeIndices ) ) {

			nodeIndices = new Set( nodeIndices );

		}

		const geometry = this.geometry;
		const indexArr = geometry.index.array;
		const posAttr = geometry.attributes.position;

		let buffer, uint32Array, uint16Array, float32Array;
		let byteOffset = 0;
		const roots = this._roots;
		for ( let i = 0, l = roots.length; i < l; i ++ ) {

			buffer = roots[ i ];
			uint32Array = new Uint32Array( buffer );
			uint16Array = new Uint16Array( buffer );
			float32Array = new Float32Array( buffer );

			_traverse( 0, byteOffset );
			byteOffset += buffer.byteLength;

		}

		function _traverse( node32Index, byteOffset, force = false ) {

			const node16Index = node32Index * 2;
			const isLeaf = uint16Array[ node16Index + 15 ] === _Constants_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAFNODE_FLAG;
			if ( isLeaf ) {

				const offset = uint32Array[ node32Index + 6 ];
				const count = uint16Array[ node16Index + 14 ];

				let minx = Infinity;
				let miny = Infinity;
				let minz = Infinity;
				let maxx = - Infinity;
				let maxy = - Infinity;
				let maxz = - Infinity;

				for ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {

					const index = indexArr[ i ];
					const x = posAttr.getX( index );
					const y = posAttr.getY( index );
					const z = posAttr.getZ( index );

					if ( x < minx ) minx = x;
					if ( x > maxx ) maxx = x;

					if ( y < miny ) miny = y;
					if ( y > maxy ) maxy = y;

					if ( z < minz ) minz = z;
					if ( z > maxz ) maxz = z;

				}

				if (
					float32Array[ node32Index + 0 ] !== minx ||
					float32Array[ node32Index + 1 ] !== miny ||
					float32Array[ node32Index + 2 ] !== minz ||

					float32Array[ node32Index + 3 ] !== maxx ||
					float32Array[ node32Index + 4 ] !== maxy ||
					float32Array[ node32Index + 5 ] !== maxz
				) {

					float32Array[ node32Index + 0 ] = minx;
					float32Array[ node32Index + 1 ] = miny;
					float32Array[ node32Index + 2 ] = minz;

					float32Array[ node32Index + 3 ] = maxx;
					float32Array[ node32Index + 4 ] = maxy;
					float32Array[ node32Index + 5 ] = maxz;

					return true;

				} else {

					return false;

				}

			} else {

				const left = node32Index + 8;
				const right = uint32Array[ node32Index + 6 ];

				// the identifying node indices provided by the shapecast function include offsets of all
				// root buffers to guarantee they're unique between roots so offset left and right indices here.
				const offsetLeft = left + byteOffset;
				const offsetRight = right + byteOffset;
				let forceChildren = force;
				let includesLeft = false;
				let includesRight = false;

				if ( nodeIndices ) {

					// if we see that neither the left or right child are included in the set that need to be updated
					// then we assume that all children need to be updated.
					if ( ! forceChildren ) {

						includesLeft = nodeIndices.has( offsetLeft );
						includesRight = nodeIndices.has( offsetRight );
						forceChildren = ! includesLeft && ! includesRight;

					}

				} else {

					includesLeft = true;
					includesRight = true;

				}

				const traverseLeft = forceChildren || includesLeft;
				const traverseRight = forceChildren || includesRight;

				let leftChange = false;
				if ( traverseLeft ) {

					leftChange = _traverse( left, byteOffset, forceChildren );

				}

				let rightChange = false;
				if ( traverseRight ) {

					rightChange = _traverse( right, byteOffset, forceChildren );

				}

				const didChange = leftChange || rightChange;
				if ( didChange ) {

					for ( let i = 0; i < 3; i ++ ) {

						const lefti = left + i;
						const righti = right + i;
						const minLeftValue = float32Array[ lefti ];
						const maxLeftValue = float32Array[ lefti + 3 ];
						const minRightValue = float32Array[ righti ];
						const maxRightValue = float32Array[ righti + 3 ];

						float32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
						float32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;

					}

				}

				return didChange;

			}

		}

	}

	traverse( callback, rootIndex = 0 ) {

		const buffer = this._roots[ rootIndex ];
		const uint32Array = new Uint32Array( buffer );
		const uint16Array = new Uint16Array( buffer );
		_traverse( 0 );

		function _traverse( node32Index, depth = 0 ) {

			const node16Index = node32Index * 2;
			const isLeaf = uint16Array[ node16Index + 15 ] === _Constants_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAFNODE_FLAG;
			if ( isLeaf ) {

				const offset = uint32Array[ node32Index + 6 ];
				const count = uint16Array[ node16Index + 14 ];
				callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );

			} else {

				// TODO: use node functions here
				const left = node32Index + _Constants_js__WEBPACK_IMPORTED_MODULE_4__.BYTES_PER_NODE / 4;
				const right = uint32Array[ node32Index + 6 ];
				const splitAxis = uint32Array[ node32Index + 7 ];
				const stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );

				if ( ! stopTraversal ) {

					_traverse( left, depth + 1 );
					_traverse( right, depth + 1 );

				}

			}

		}

	}

	/* Core Cast Functions */
	raycast( ray, materialOrSide = three__WEBPACK_IMPORTED_MODULE_0__.FrontSide ) {

		const roots = this._roots;
		const geometry = this.geometry;
		const intersects = [];
		const isMaterial = materialOrSide.isMaterial;
		const isArrayMaterial = Array.isArray( materialOrSide );

		const groups = geometry.groups;
		const side = isMaterial ? materialOrSide.side : materialOrSide;
		for ( let i = 0, l = roots.length; i < l; i ++ ) {

			const materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;
			const startCount = intersects.length;

			(0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.setBuffer)( roots[ i ] );
			(0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.raycast)( 0, geometry, materialSide, ray, intersects );
			(0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.clearBuffer)();

			if ( isArrayMaterial ) {

				const materialIndex = groups[ i ].materialIndex;
				for ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {

					intersects[ j ].face.materialIndex = materialIndex;

				}

			}

		}

		return intersects;

	}

	raycastFirst( ray, materialOrSide = three__WEBPACK_IMPORTED_MODULE_0__.FrontSide ) {

		const roots = this._roots;
		const geometry = this.geometry;
		const isMaterial = materialOrSide.isMaterial;
		const isArrayMaterial = Array.isArray( materialOrSide );

		let closestResult = null;

		const groups = geometry.groups;
		const side = isMaterial ? materialOrSide.side : materialOrSide;
		for ( let i = 0, l = roots.length; i < l; i ++ ) {

			const materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;

			(0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.setBuffer)( roots[ i ] );
			const result = (0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.raycastFirst)( 0, geometry, materialSide, ray );
			(0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.clearBuffer)();

			if ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {

				closestResult = result;
				if ( isArrayMaterial ) {

					result.face.materialIndex = groups[ i ].materialIndex;

				}

			}

		}

		return closestResult;

	}

	intersectsGeometry( otherGeometry, geomToMesh ) {

		const geometry = this.geometry;
		let result = false;
		for ( const root of this._roots ) {

			(0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.setBuffer)( root );
			result = (0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.intersectsGeometry)( 0, geometry, otherGeometry, geomToMesh );
			(0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.clearBuffer)();

			if ( result ) {

				break;

			}

		}

		return result;

	}

	shapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {

		const geometry = this.geometry;
		if ( callbacks instanceof Function ) {

			if ( _intersectsTriangleFunc ) {

				// Support the previous function signature that provided three sequential index buffer
				// indices here.
				const originalTriangleFunc = _intersectsTriangleFunc;
				_intersectsTriangleFunc = ( tri, index, contained, depth ) => {

					const i3 = index * 3;
					return originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );

				};


			}

			callbacks = {

				boundsTraverseOrder: _orderNodesFunc,
				intersectsBounds: callbacks,
				intersectsTriangle: _intersectsTriangleFunc,
				intersectsRange: null,

			};

			console.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );

		}

		const triangle = trianglePool.getPrimitive();
		let {
			boundsTraverseOrder,
			intersectsBounds,
			intersectsRange,
			intersectsTriangle,
		} = callbacks;

		if ( intersectsRange && intersectsTriangle ) {

			const originalIntersectsRange = intersectsRange;
			intersectsRange = ( offset, count, contained, depth, nodeIndex ) => {

				if ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {

					return (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_7__.iterateOverTriangles)( offset, count, geometry, intersectsTriangle, contained, depth, triangle );

				}

				return true;

			};

		} else if ( ! intersectsRange ) {

			if ( intersectsTriangle ) {

				intersectsRange = ( offset, count, contained, depth ) => {

					return (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_7__.iterateOverTriangles)( offset, count, geometry, intersectsTriangle, contained, depth, triangle );

				};

			} else {

				intersectsRange = ( offset, count, contained ) => {

					return contained;

				};

			}

		}

		let result = false;
		let byteOffset = 0;
		for ( const root of this._roots ) {

			(0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.setBuffer)( root );
			result = (0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.shapecast)( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );
			(0,_castFunctions_js__WEBPACK_IMPORTED_MODULE_6__.clearBuffer)();

			if ( result ) {

				break;

			}

			byteOffset += root.byteLength;

		}

		trianglePool.releasePrimitive( triangle );

		return result;

	}

	bvhcast( otherBvh, matrixToLocal, callbacks ) {

		// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather
		// than an approach that walks down the tree (see bvhcast.js file for more info).

		let {
			intersectsRanges,
			intersectsTriangles,
		} = callbacks;

		const indexAttr = this.geometry.index;
		const positionAttr = this.geometry.attributes.position;

		const otherIndexAttr = otherBvh.geometry.index;
		const otherPositionAttr = otherBvh.geometry.attributes.position;

		tempMatrix.copy( matrixToLocal ).invert();

		const triangle = trianglePool.getPrimitive();
		const triangle2 = trianglePool.getPrimitive();

		if ( intersectsTriangles ) {

			function iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {

				for ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {

					(0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_7__.setTriangle)( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );
					triangle2.a.applyMatrix4( matrixToLocal );
					triangle2.b.applyMatrix4( matrixToLocal );
					triangle2.c.applyMatrix4( matrixToLocal );
					triangle2.needsUpdate = true;

					for ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {

						(0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_7__.setTriangle)( triangle, i1 * 3, indexAttr, positionAttr );
						triangle.needsUpdate = true;

						if ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {

							return true;

						}

					}

				}

				return false;

			}

			if ( intersectsRanges ) {

				const originalIntersectsRanges = intersectsRanges;
				intersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {

					if ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {

						return iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );

					}

					return true;

				};

			} else {

				intersectsRanges = iterateOverDoubleTriangles;

			}

		}

		otherBvh.getBoundingBox( aabb2 );
		aabb2.applyMatrix4( matrixToLocal );
		const result = this.shapecast( {

			intersectsBounds: box => aabb2.intersectsBox( box ),

			intersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {

				aabb.copy( box );
				aabb.applyMatrix4( tempMatrix );
				return otherBvh.shapecast( {

					intersectsBounds: box => aabb.intersectsBox( box ),

					intersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {

						return intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );

					},

				} );

			}

		} );

		trianglePool.releasePrimitive( triangle );
		trianglePool.releasePrimitive( triangle2 );
		return result;

	}

	/* Derived Cast Functions */
	intersectsBox( box, boxToMesh ) {

		obb.set( box.min, box.max, boxToMesh );
		obb.needsUpdate = true;

		return this.shapecast(
			{
				intersectsBounds: box => obb.intersectsBox( box ),
				intersectsTriangle: tri => obb.intersectsTriangle( tri )
			}
		);

	}

	intersectsSphere( sphere ) {

		return this.shapecast(
			{
				intersectsBounds: box => sphere.intersectsBox( box ),
				intersectsTriangle: tri => tri.intersectsSphere( sphere )
			}
		);

	}

	closestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {

		if ( ! otherGeometry.boundingBox ) {

			otherGeometry.computeBoundingBox();

		}

		obb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );
		obb.needsUpdate = true;

		const geometry = this.geometry;
		const pos = geometry.attributes.position;
		const index = geometry.index;
		const otherPos = otherGeometry.attributes.position;
		const otherIndex = otherGeometry.index;
		const triangle = trianglePool.getPrimitive();
		const triangle2 = trianglePool.getPrimitive();

		let tempTarget1 = temp1;
		let tempTargetDest1 = temp2;
		let tempTarget2 = null;
		let tempTargetDest2 = null;

		if ( target2 ) {

			tempTarget2 = temp3;
			tempTargetDest2 = temp4;

		}

		let closestDistance = Infinity;
		let closestDistanceTriIndex = null;
		let closestDistanceOtherTriIndex = null;
		tempMatrix.copy( geometryToBvh ).invert();
		obb2.matrix.copy( tempMatrix );
		this.shapecast(
			{

				boundsTraverseOrder: box => {

					return obb.distanceToBox( box );

				},

				intersectsBounds: ( box, isLeaf, score ) => {

					if ( score < closestDistance && score < maxThreshold ) {

						// if we know the triangles of this bounds will be intersected next then
						// save the bounds to use during triangle checks.
						if ( isLeaf ) {

							obb2.min.copy( box.min );
							obb2.max.copy( box.max );
							obb2.needsUpdate = true;

						}

						return true;

					}

					return false;

				},

				intersectsRange: ( offset, count ) => {

					if ( otherGeometry.boundsTree ) {

						// if the other geometry has a bvh then use the accelerated path where we use shapecast to find
						// the closest bounds in the other geometry to check.
						return otherGeometry.boundsTree.shapecast( {
							boundsTraverseOrder: box => {

								return obb2.distanceToBox( box );

							},

							intersectsBounds: ( box, isLeaf, score ) => {

								return score < closestDistance && score < maxThreshold;

							},

							intersectsRange: ( otherOffset, otherCount ) => {

								for ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {

									(0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_7__.setTriangle)( triangle2, i2, otherIndex, otherPos );
									triangle2.a.applyMatrix4( geometryToBvh );
									triangle2.b.applyMatrix4( geometryToBvh );
									triangle2.c.applyMatrix4( geometryToBvh );
									triangle2.needsUpdate = true;

									for ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {

										(0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_7__.setTriangle)( triangle, i, index, pos );
										triangle.needsUpdate = true;

										const dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );
										if ( dist < closestDistance ) {

											tempTargetDest1.copy( tempTarget1 );

											if ( tempTargetDest2 ) {

												tempTargetDest2.copy( tempTarget2 );

											}

											closestDistance = dist;
											closestDistanceTriIndex = i / 3;
											closestDistanceOtherTriIndex = i2 / 3;

										}

										// stop traversal if we find a point that's under the given threshold
										if ( dist < minThreshold ) {

											return true;

										}

									}

								}

							},
						} );

					} else {

						// If no bounds tree then we'll just check every triangle.
						const triCount = otherIndex ? otherIndex.count : otherPos.count;
						for ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {

							(0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_7__.setTriangle)( triangle2, i2, otherIndex, otherPos );
							triangle2.a.applyMatrix4( geometryToBvh );
							triangle2.b.applyMatrix4( geometryToBvh );
							triangle2.c.applyMatrix4( geometryToBvh );
							triangle2.needsUpdate = true;

							for ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {

								(0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_7__.setTriangle)( triangle, i, index, pos );
								triangle.needsUpdate = true;

								const dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );
								if ( dist < closestDistance ) {

									tempTargetDest1.copy( tempTarget1 );

									if ( tempTargetDest2 ) {

										tempTargetDest2.copy( tempTarget2 );

									}

									closestDistance = dist;
									closestDistanceTriIndex = i / 3;
									closestDistanceOtherTriIndex = i2 / 3;

								}

								// stop traversal if we find a point that's under the given threshold
								if ( dist < minThreshold ) {

									return true;

								}

							}

						}

					}

				},

			}

		);

		trianglePool.releasePrimitive( triangle );
		trianglePool.releasePrimitive( triangle2 );

		if ( closestDistance === Infinity ) return null;

		if ( ! target1.point ) target1.point = tempTargetDest1.clone();
		else target1.point.copy( tempTargetDest1 );
		target1.distance = closestDistance,
		target1.faceIndex = closestDistanceTriIndex;

		if ( target2 ) {

			if ( ! target2.point ) target2.point = tempTargetDest2.clone();
			else target2.point.copy( tempTargetDest2 );
			target2.point.applyMatrix4( tempMatrix );
			tempTargetDest1.applyMatrix4( tempMatrix );
			target2.distance = tempTargetDest1.sub( target2.point ).length();
			target2.faceIndex = closestDistanceOtherTriIndex;

		}

		return target1;

	}

	closestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {

		// early out if under minThreshold
		// skip checking if over maxThreshold
		// set minThreshold = maxThreshold to quickly check if a point is within a threshold
		// returns Infinity if no value found
		const minThresholdSq = minThreshold * minThreshold;
		const maxThresholdSq = maxThreshold * maxThreshold;
		let closestDistanceSq = Infinity;
		let closestDistanceTriIndex = null;
		this.shapecast(

			{

				boundsTraverseOrder: box => {

					temp.copy( point ).clamp( box.min, box.max );
					return temp.distanceToSquared( point );

				},

				intersectsBounds: ( box, isLeaf, score ) => {

					return score < closestDistanceSq && score < maxThresholdSq;

				},

				intersectsTriangle: ( tri, triIndex ) => {

					tri.closestPointToPoint( point, temp );
					const distSq = point.distanceToSquared( temp );
					if ( distSq < closestDistanceSq ) {

						temp1.copy( temp );
						closestDistanceSq = distSq;
						closestDistanceTriIndex = triIndex;

					}

					if ( distSq < minThresholdSq ) {

						return true;

					} else {

						return false;

					}

				},

			}

		);

		if ( closestDistanceSq === Infinity ) return null;

		const closestDistance = Math.sqrt( closestDistanceSq );

		if ( ! target.point ) target.point = temp1.clone();
		else target.point.copy( temp1 );
		target.distance = closestDistance,
		target.faceIndex = closestDistanceTriIndex;

		return target;

	}

	getBoundingBox( target ) {

		target.makeEmpty();

		const roots = this._roots;
		roots.forEach( buffer => {

			(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_8__.arrayToBox)( 0, new Float32Array( buffer ), tempBox );
			target.union( tempBox );

		} );

		return target;

	}

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/core/MeshBVHNode.js":
/*!*************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/MeshBVHNode.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshBVHNode": () => (/* binding */ MeshBVHNode)
/* harmony export */ });
class MeshBVHNode {

	constructor() {

		// internal nodes have boundingData, left, right, and splitAxis
		// leaf nodes have offset and count (referring to primitives in the mesh geometry)

	}

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/core/buildFunctions.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/buildFunctions.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildPackedTree": () => (/* binding */ buildPackedTree),
/* harmony export */   "buildTree": () => (/* binding */ buildTree)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MeshBVHNode.js */ "./node_modules/three-mesh-bvh/src/core/MeshBVHNode.js");
/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ArrayBoxUtilities.js */ "./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js");
/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Constants.js */ "./node_modules/three-mesh-bvh/src/core/Constants.js");





function ensureIndex( geo, options ) {

	if ( ! geo.index ) {

		const vertexCount = geo.attributes.position.count;
		const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
		let index;
		if ( vertexCount > 65535 ) {

			index = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );

		} else {

			index = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );

		}

		geo.setIndex( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( index, 1 ) );

		for ( let i = 0; i < vertexCount; i ++ ) {

			index[ i ] = i;

		}

	}

}

// Computes the set of { offset, count } ranges which need independent BVH roots. Each
// region in the geometry index that belongs to a different set of material groups requires
// a separate BVH root, so that triangles indices belonging to one group never get swapped
// with triangle indices belongs to another group. For example, if the groups were like this:
//
// [-------------------------------------------------------------]
// |__________________|
//   g0 = [0, 20]  |______________________||_____________________|
//                      g1 = [16, 40]           g2 = [41, 60]
//
// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].
function getRootIndexRanges( geo ) {

	if ( ! geo.groups || ! geo.groups.length ) {

		return [ { offset: 0, count: geo.index.count / 3 } ];

	}

	const ranges = [];
	const rangeBoundaries = new Set();
	for ( const group of geo.groups ) {

		rangeBoundaries.add( group.start );
		rangeBoundaries.add( group.start + group.count );

	}

	// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(
	const sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );
	for ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {

		const start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];
		ranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );

	}

	return ranges;

}

// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If
// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.
// These are computed together to avoid redundant accesses to bounds array.
function getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {

	let minx = Infinity;
	let miny = Infinity;
	let minz = Infinity;
	let maxx = - Infinity;
	let maxy = - Infinity;
	let maxz = - Infinity;

	let cminx = Infinity;
	let cminy = Infinity;
	let cminz = Infinity;
	let cmaxx = - Infinity;
	let cmaxy = - Infinity;
	let cmaxz = - Infinity;

	const includeCentroid = centroidTarget !== null;
	for ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {

		const cx = triangleBounds[ i + 0 ];
		const hx = triangleBounds[ i + 1 ];
		const lx = cx - hx;
		const rx = cx + hx;
		if ( lx < minx ) minx = lx;
		if ( rx > maxx ) maxx = rx;
		if ( includeCentroid && cx < cminx ) cminx = cx;
		if ( includeCentroid && cx > cmaxx ) cmaxx = cx;

		const cy = triangleBounds[ i + 2 ];
		const hy = triangleBounds[ i + 3 ];
		const ly = cy - hy;
		const ry = cy + hy;
		if ( ly < miny ) miny = ly;
		if ( ry > maxy ) maxy = ry;
		if ( includeCentroid && cy < cminy ) cminy = cy;
		if ( includeCentroid && cy > cmaxy ) cmaxy = cy;

		const cz = triangleBounds[ i + 4 ];
		const hz = triangleBounds[ i + 5 ];
		const lz = cz - hz;
		const rz = cz + hz;
		if ( lz < minz ) minz = lz;
		if ( rz > maxz ) maxz = rz;
		if ( includeCentroid && cz < cminz ) cminz = cz;
		if ( includeCentroid && cz > cmaxz ) cmaxz = cz;

	}

	target[ 0 ] = minx;
	target[ 1 ] = miny;
	target[ 2 ] = minz;

	target[ 3 ] = maxx;
	target[ 4 ] = maxy;
	target[ 5 ] = maxz;

	if ( includeCentroid ) {

		centroidTarget[ 0 ] = cminx;
		centroidTarget[ 1 ] = cminy;
		centroidTarget[ 2 ] = cminz;

		centroidTarget[ 3 ] = cmaxx;
		centroidTarget[ 4 ] = cmaxy;
		centroidTarget[ 5 ] = cmaxz;

	}

}

// A stand alone function for retrieving the centroid bounds.
function getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {

	let cminx = Infinity;
	let cminy = Infinity;
	let cminz = Infinity;
	let cmaxx = - Infinity;
	let cmaxy = - Infinity;
	let cmaxz = - Infinity;

	for ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {

		const cx = triangleBounds[ i + 0 ];
		if ( cx < cminx ) cminx = cx;
		if ( cx > cmaxx ) cmaxx = cx;

		const cy = triangleBounds[ i + 2 ];
		if ( cy < cminy ) cminy = cy;
		if ( cy > cmaxy ) cmaxy = cy;

		const cz = triangleBounds[ i + 4 ];
		if ( cz < cminz ) cminz = cz;
		if ( cz > cmaxz ) cmaxz = cz;

	}

	centroidTarget[ 0 ] = cminx;
	centroidTarget[ 1 ] = cminy;
	centroidTarget[ 2 ] = cminz;

	centroidTarget[ 3 ] = cmaxx;
	centroidTarget[ 4 ] = cmaxy;
	centroidTarget[ 5 ] = cmaxz;

}


// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split
// will be on the left and elements on the right side of the split will be on the right. returns the index
// of the first element on the right side, or offset + count if there are no elements on the right side.
function partition( index, triangleBounds, offset, count, split ) {

	let left = offset;
	let right = offset + count - 1;
	const pos = split.pos;
	const axisOffset = split.axis * 2;

	// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme
	while ( true ) {

		while ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {

			left ++;

		}


		// if a triangle center lies on the partition plane it is considered to be on the right side
		while ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {

			right --;

		}

		if ( left < right ) {

			// we need to swap all of the information associated with the triangles at index
			// left and right; that's the verts in the geometry index, the bounds,
			// and perhaps the SAH planes

			for ( let i = 0; i < 3; i ++ ) {

				let t0 = index[ left * 3 + i ];
				index[ left * 3 + i ] = index[ right * 3 + i ];
				index[ right * 3 + i ] = t0;

				let t1 = triangleBounds[ left * 6 + i * 2 + 0 ];
				triangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];
				triangleBounds[ right * 6 + i * 2 + 0 ] = t1;

				let t2 = triangleBounds[ left * 6 + i * 2 + 1 ];
				triangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];
				triangleBounds[ right * 6 + i * 2 + 1 ] = t2;

			}

			left ++;
			right --;

		} else {

			return left;

		}

	}

}

const BIN_COUNT = 32;
const binsSort = ( a, b ) => a.candidate - b.candidate;
const sahBins = new Array( BIN_COUNT ).fill().map( () => {

	return {

		count: 0,
		bounds: new Float32Array( 6 ),
		rightCacheBounds: new Float32Array( 6 ),
		leftCacheBounds: new Float32Array( 6 ),
		candidate: 0,

	};

} );
const leftBounds = new Float32Array( 6 );

function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {

	let axis = - 1;
	let pos = 0;

	// Center
	if ( strategy === _Constants_js__WEBPACK_IMPORTED_MODULE_1__.CENTER ) {

		axis = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.getLongestEdgeIndex)( centroidBoundingData );
		if ( axis !== - 1 ) {

			pos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;

		}

	} else if ( strategy === _Constants_js__WEBPACK_IMPORTED_MODULE_1__.AVERAGE ) {

		axis = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.getLongestEdgeIndex)( nodeBoundingData );
		if ( axis !== - 1 ) {

			pos = getAverage( triangleBounds, offset, count, axis );

		}

	} else if ( strategy === _Constants_js__WEBPACK_IMPORTED_MODULE_1__.SAH ) {

		const rootSurfaceArea = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.computeSurfaceArea)( nodeBoundingData );
		let bestCost = _Constants_js__WEBPACK_IMPORTED_MODULE_1__.TRIANGLE_INTERSECT_COST * count;

		// iterate over all axes
		const cStart = offset * 6;
		const cEnd = ( offset + count ) * 6;
		for ( let a = 0; a < 3; a ++ ) {

			const axisLeft = centroidBoundingData[ a ];
			const axisRight = centroidBoundingData[ a + 3 ];
			const axisLength = axisRight - axisLeft;
			const binWidth = axisLength / BIN_COUNT;

			// If we have fewer triangles than we're planning to split then just check all
			// the triangle positions because it will be faster.
			if ( count < BIN_COUNT / 4 ) {

				// initialize the bin candidates
				const truncatedBins = [ ...sahBins ];
				truncatedBins.length = count;

				// set the candidates
				let b = 0;
				for ( let c = cStart; c < cEnd; c += 6, b ++ ) {

					const bin = truncatedBins[ b ];
					bin.candidate = triangleBounds[ c + 2 * a ];
					bin.count = 0;

					const {
						bounds,
						leftCacheBounds,
						rightCacheBounds,
					} = bin;
					for ( let d = 0; d < 3; d ++ ) {

						rightCacheBounds[ d ] = Infinity;
						rightCacheBounds[ d + 3 ] = - Infinity;

						leftCacheBounds[ d ] = Infinity;
						leftCacheBounds[ d + 3 ] = - Infinity;

						bounds[ d ] = Infinity;
						bounds[ d + 3 ] = - Infinity;

					}

					(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.expandByTriangleBounds)( c, triangleBounds, bounds );

				}

				truncatedBins.sort( binsSort );

				// remove redundant splits
				let splitCount = count;
				for ( let bi = 0; bi < splitCount; bi ++ ) {

					const bin = truncatedBins[ bi ];
					while ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {

						truncatedBins.splice( bi + 1, 1 );
						splitCount --;

					}

				}

				// find the appropriate bin for each triangle and expand the bounds.
				for ( let c = cStart; c < cEnd; c += 6 ) {

					const center = triangleBounds[ c + 2 * a ];
					for ( let bi = 0; bi < splitCount; bi ++ ) {

						const bin = truncatedBins[ bi ];
						if ( center >= bin.candidate ) {

							(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.expandByTriangleBounds)( c, triangleBounds, bin.rightCacheBounds );

						} else {

							(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.expandByTriangleBounds)( c, triangleBounds, bin.leftCacheBounds );
							bin.count ++;

						}

					}

				}

				// expand all the bounds
				for ( let bi = 0; bi < splitCount; bi ++ ) {

					const bin = truncatedBins[ bi ];
					const leftCount = bin.count;
					const rightCount = count - bin.count;

					// check the cost of this split
					const leftBounds = bin.leftCacheBounds;
					const rightBounds = bin.rightCacheBounds;

					let leftProb = 0;
					if ( leftCount !== 0 ) {

						leftProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.computeSurfaceArea)( leftBounds ) / rootSurfaceArea;

					}

					let rightProb = 0;
					if ( rightCount !== 0 ) {

						rightProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.computeSurfaceArea)( rightBounds ) / rootSurfaceArea;

					}

					const cost = _Constants_js__WEBPACK_IMPORTED_MODULE_1__.TRAVERSAL_COST + _Constants_js__WEBPACK_IMPORTED_MODULE_1__.TRIANGLE_INTERSECT_COST * (
						leftProb * leftCount + rightProb * rightCount
					);

					if ( cost < bestCost ) {

						axis = a;
						bestCost = cost;
						pos = bin.candidate;

					}

				}

			} else {

				// reset the bins
				for ( let i = 0; i < BIN_COUNT; i ++ ) {

					const bin = sahBins[ i ];
					bin.count = 0;
					bin.candidate = axisLeft + binWidth + i * binWidth;

					const bounds = bin.bounds;
					for ( let d = 0; d < 3; d ++ ) {

						bounds[ d ] = Infinity;
						bounds[ d + 3 ] = - Infinity;

					}

				}

				// iterate over all center positions
				for ( let c = cStart; c < cEnd; c += 6 ) {

					const triCenter = triangleBounds[ c + 2 * a ];
					const relativeCenter = triCenter - axisLeft;

					// in the partition function if the centroid lies on the split plane then it is
					// considered to be on the right side of the split
					let binIndex = ~ ~ ( relativeCenter / binWidth );
					if ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;

					const bin = sahBins[ binIndex ];
					bin.count ++;

					(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.expandByTriangleBounds)( c, triangleBounds, bin.bounds );

				}

				// cache the unioned bounds from right to left so we don't have to regenerate them each time
				const lastBin = sahBins[ BIN_COUNT - 1 ];
				(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.copyBounds)( lastBin.bounds, lastBin.rightCacheBounds );
				for ( let i = BIN_COUNT - 2; i >= 0; i -- ) {

					const bin = sahBins[ i ];
					const nextBin = sahBins[ i + 1 ];
					(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.unionBounds)( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );

				}

				let leftCount = 0;
				for ( let i = 0; i < BIN_COUNT - 1; i ++ ) {

					const bin = sahBins[ i ];
					const binCount = bin.count;
					const bounds = bin.bounds;

					const nextBin = sahBins[ i + 1 ];
					const rightBounds = nextBin.rightCacheBounds;

					// don't do anything with the bounds if the new bounds have no triangles
					if ( binCount !== 0 ) {

						if ( leftCount === 0 ) {

							(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.copyBounds)( bounds, leftBounds );

						} else {

							(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.unionBounds)( bounds, leftBounds, leftBounds );

						}

					}

					leftCount += binCount;

					// check the cost of this split
					let leftProb = 0;
					let rightProb = 0;

					if ( leftCount !== 0 ) {

						leftProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.computeSurfaceArea)( leftBounds ) / rootSurfaceArea;

					}

					const rightCount = count - leftCount;
					if ( rightCount !== 0 ) {

						rightProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_2__.computeSurfaceArea)( rightBounds ) / rootSurfaceArea;

					}

					const cost = _Constants_js__WEBPACK_IMPORTED_MODULE_1__.TRAVERSAL_COST + _Constants_js__WEBPACK_IMPORTED_MODULE_1__.TRIANGLE_INTERSECT_COST * (
						leftProb * leftCount + rightProb * rightCount
					);

					if ( cost < bestCost ) {

						axis = a;
						bestCost = cost;
						pos = bin.candidate;

					}

				}

			}

		}

	} else {

		console.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );

	}

	return { axis, pos };

}

// returns the average coordinate on the specified axis of the all the provided triangles
function getAverage( triangleBounds, offset, count, axis ) {

	let avg = 0;
	for ( let i = offset, end = offset + count; i < end; i ++ ) {

		avg += triangleBounds[ i * 6 + axis * 2 ];

	}

	return avg / count;

}

// precomputes the bounding box for each triangle; required for quickly calculating tree splits.
// result is an array of size tris.length * 6 where triangle i maps to a
// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,
// representing the center and half-extent in each dimension of triangle i
function computeTriangleBounds( geo, fullBounds ) {

	const posAttr = geo.attributes.position;
	const index = geo.index.array;
	const triCount = index.length / 3;
	const triangleBounds = new Float32Array( triCount * 6 );
	const normalized = posAttr.normalized;

	// used for non-normalized positions
	const posArr = posAttr.array;

	// support for an interleaved position buffer
	const bufferOffset = posAttr.offset || 0;
	let stride = 3;
	if ( posAttr.isInterleavedBufferAttribute ) {

		stride = posAttr.data.stride;

	}

	// used for normalized positions
	const getters = [ 'getX', 'getY', 'getZ' ];

	for ( let tri = 0; tri < triCount; tri ++ ) {

		const tri3 = tri * 3;
		const tri6 = tri * 6;

		let ai, bi, ci;

		if ( normalized ) {

			ai = index[ tri3 + 0 ];
			bi = index[ tri3 + 1 ];
			ci = index[ tri3 + 2 ];

		} else {

			ai = index[ tri3 + 0 ] * stride + bufferOffset;
			bi = index[ tri3 + 1 ] * stride + bufferOffset;
			ci = index[ tri3 + 2 ] * stride + bufferOffset;

		}

		for ( let el = 0; el < 3; el ++ ) {

			let a, b, c;

			if ( normalized ) {

				a = posAttr[ getters[ el ] ]( ai );
				b = posAttr[ getters[ el ] ]( bi );
				c = posAttr[ getters[ el ] ]( ci );

			} else {

				a = posArr[ ai + el ];
				b = posArr[ bi + el ];
				c = posArr[ ci + el ];

			}

			let min = a;
			if ( b < min ) min = b;
			if ( c < min ) min = c;

			let max = a;
			if ( b > max ) max = b;
			if ( c > max ) max = c;

			// Increase the bounds size by float32 epsilon to avoid precision errors when
			// converting to 32 bit float. Scale the epsilon by the size of the numbers being
			// worked with.
			const halfExtents = ( max - min ) / 2;
			const el2 = el * 2;
			triangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;
			triangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * _Constants_js__WEBPACK_IMPORTED_MODULE_1__.FLOAT32_EPSILON;

			if ( min < fullBounds[ el ] ) fullBounds[ el ] = min;
			if ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;

		}

	}

	return triangleBounds;

}

function buildTree( geo, options ) {

	function triggerProgress( trianglesProcessed ) {

		if ( onProgress ) {

			onProgress( trianglesProcessed / totalTriangles );

		}

	}

	// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,
	// recording the offset and count of its triangles and writing them into the reordered geometry index.
	function splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {

		if ( ! reachedMaxDepth && depth >= maxDepth ) {

			reachedMaxDepth = true;
			if ( verbose ) {

				console.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );
				console.warn( geo );

			}

		}

		// early out if we've met our capacity
		if ( count <= maxLeafTris || depth >= maxDepth ) {

			triggerProgress( offset + count );
			node.offset = offset;
			node.count = count;
			return node;

		}

		// Find where to split the volume
		const split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );
		if ( split.axis === - 1 ) {

			triggerProgress( offset + count );
			node.offset = offset;
			node.count = count;
			return node;

		}

		const splitOffset = partition( indexArray, triangleBounds, offset, count, split );

		// create the two new child nodes
		if ( splitOffset === offset || splitOffset === offset + count ) {

			triggerProgress( offset + count );
			node.offset = offset;
			node.count = count;

		} else {

			node.splitAxis = split.axis;

			// create the left child and compute its bounding box
			const left = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_3__.MeshBVHNode();
			const lstart = offset;
			const lcount = splitOffset - offset;
			node.left = left;
			left.boundingData = new Float32Array( 6 );

			getBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );
			splitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );

			// repeat for right
			const right = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_3__.MeshBVHNode();
			const rstart = splitOffset;
			const rcount = count - lcount;
			node.right = right;
			right.boundingData = new Float32Array( 6 );

			getBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );
			splitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );

		}

		return node;

	}

	ensureIndex( geo, options );

	// Compute the full bounds of the geometry at the same time as triangle bounds because
	// we'll need it for the root bounds in the case with no groups and it should be fast here.
	// We can't use the geometrying bounding box if it's available because it may be out of date.
	const fullBounds = new Float32Array( 6 );
	const cacheCentroidBoundingData = new Float32Array( 6 );
	const triangleBounds = computeTriangleBounds( geo, fullBounds );
	const indexArray = geo.index.array;
	const maxDepth = options.maxDepth;
	const verbose = options.verbose;
	const maxLeafTris = options.maxLeafTris;
	const strategy = options.strategy;
	const onProgress = options.onProgress;
	const totalTriangles = geo.index.count / 3;
	let reachedMaxDepth = false;

	const roots = [];
	const ranges = getRootIndexRanges( geo );

	if ( ranges.length === 1 ) {

		const range = ranges[ 0 ];
		const root = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_3__.MeshBVHNode();
		root.boundingData = fullBounds;
		getCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );

		splitNode( root, range.offset, range.count, cacheCentroidBoundingData );
		roots.push( root );

	} else {

		for ( let range of ranges ) {

			const root = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_3__.MeshBVHNode();
			root.boundingData = new Float32Array( 6 );
			getBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );

			splitNode( root, range.offset, range.count, cacheCentroidBoundingData );
			roots.push( root );

		}

	}

	return roots;

}

function buildPackedTree( geo, options ) {

	// boundingData  				: 6 float32
	// right / offset 				: 1 uint32
	// splitAxis / isLeaf + count 	: 1 uint32 / 2 uint16
	const roots = buildTree( geo, options );

	let float32Array;
	let uint32Array;
	let uint16Array;
	const packedRoots = [];
	const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
	for ( let i = 0; i < roots.length; i ++ ) {

		const root = roots[ i ];
		let nodeCount = countNodes( root );

		const buffer = new BufferConstructor( _Constants_js__WEBPACK_IMPORTED_MODULE_1__.BYTES_PER_NODE * nodeCount );
		float32Array = new Float32Array( buffer );
		uint32Array = new Uint32Array( buffer );
		uint16Array = new Uint16Array( buffer );
		populateBuffer( 0, root );
		packedRoots.push( buffer );

	}

	return packedRoots;

	function countNodes( node ) {

		if ( node.count ) {

			return 1;

		} else {

			return 1 + countNodes( node.left ) + countNodes( node.right );

		}

	}

	function populateBuffer( byteOffset, node ) {

		const stride4Offset = byteOffset / 4;
		const stride2Offset = byteOffset / 2;
		const isLeaf = ! ! node.count;
		const boundingData = node.boundingData;
		for ( let i = 0; i < 6; i ++ ) {

			float32Array[ stride4Offset + i ] = boundingData[ i ];

		}

		if ( isLeaf ) {

			const offset = node.offset;
			const count = node.count;
			uint32Array[ stride4Offset + 6 ] = offset;
			uint16Array[ stride2Offset + 14 ] = count;
			uint16Array[ stride2Offset + 15 ] = _Constants_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAFNODE_FLAG;
			return byteOffset + _Constants_js__WEBPACK_IMPORTED_MODULE_1__.BYTES_PER_NODE;

		} else {

			const left = node.left;
			const right = node.right;
			const splitAxis = node.splitAxis;

			let nextUnusedPointer;
			nextUnusedPointer = populateBuffer( byteOffset + _Constants_js__WEBPACK_IMPORTED_MODULE_1__.BYTES_PER_NODE, left );

			if ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {

				throw new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );

			}

			uint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;
			nextUnusedPointer = populateBuffer( nextUnusedPointer, right );

			uint32Array[ stride4Offset + 7 ] = splitAxis;
			return nextUnusedPointer;

		}

	}

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/core/castFunctions.js":
/*!***************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/castFunctions.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearBuffer": () => (/* binding */ clearBuffer),
/* harmony export */   "intersectsGeometry": () => (/* binding */ intersectsGeometry),
/* harmony export */   "raycast": () => (/* binding */ raycast),
/* harmony export */   "raycastFirst": () => (/* binding */ raycastFirst),
/* harmony export */   "setBuffer": () => (/* binding */ setBuffer),
/* harmony export */   "shapecast": () => (/* binding */ shapecast)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Constants.js */ "./node_modules/three-mesh-bvh/src/core/Constants.js");
/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/OrientedBox.js */ "./node_modules/three-mesh-bvh/src/math/OrientedBox.js");
/* harmony import */ var _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/ExtendedTriangle.js */ "./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js");
/* harmony import */ var _utils_GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/GeometryRayIntersectUtilities.js */ "./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js");
/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/TriangleUtilities.js */ "./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js");
/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/ArrayBoxUtilities.js */ "./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js");
/* harmony import */ var _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/PrimitivePool.js */ "./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js");
/* harmony import */ var _nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodeBufferFunctions.js */ "./node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js");











const boundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const boxIntersection = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const xyzFields = [ 'x', 'y', 'z' ];

function raycast( nodeIndex32, geometry, side, ray, intersects ) {

	let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;

	const isLeaf = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAF)( nodeIndex16, uint16Array );
	if ( isLeaf ) {

		const offset = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.OFFSET)( nodeIndex32, uint32Array );
		const count = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.COUNT)( nodeIndex16, uint16Array );

		(0,_utils_GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_2__.intersectTris)( geometry, side, ray, offset, count, intersects );

	} else {

		const leftIndex = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.LEFT_NODE)( nodeIndex32 );
		if ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {

			raycast( leftIndex, geometry, side, ray, intersects );

		}

		const rightIndex = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.RIGHT_NODE)( nodeIndex32, uint32Array );
		if ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {

			raycast( rightIndex, geometry, side, ray, intersects );

		}

	}

}

function raycastFirst( nodeIndex32, geometry, side, ray ) {

	let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;

	const isLeaf = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAF)( nodeIndex16, uint16Array );
	if ( isLeaf ) {

		const offset = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.OFFSET)( nodeIndex32, uint32Array );
		const count = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.COUNT)( nodeIndex16, uint16Array );
		return (0,_utils_GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_2__.intersectClosestTri)( geometry, side, ray, offset, count );

	} else {

		// consider the position of the split plane with respect to the oncoming ray; whichever direction
		// the ray is coming from, look for an intersection among that side of the tree first
		const splitAxis = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.SPLIT_AXIS)( nodeIndex32, uint32Array );
		const xyzAxis = xyzFields[ splitAxis ];
		const rayDir = ray.direction[ xyzAxis ];
		const leftToRight = rayDir >= 0;

		// c1 is the child to check first
		let c1, c2;
		if ( leftToRight ) {

			c1 = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.LEFT_NODE)( nodeIndex32 );
			c2 = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.RIGHT_NODE)( nodeIndex32, uint32Array );

		} else {

			c1 = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.RIGHT_NODE)( nodeIndex32, uint32Array );
			c2 = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.LEFT_NODE)( nodeIndex32 );

		}

		const c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );
		const c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;

		// if we got an intersection in the first node and it's closer than the second node's bounding
		// box, we don't need to consider the second node because it couldn't possibly be a better result
		if ( c1Result ) {

			// check if the point is within the second bounds
			// "point" is in the local frame of the bvh
			const point = c1Result.point[ xyzAxis ];
			const isOutside = leftToRight ?
				point <= float32Array[ c2 + splitAxis ] : // min bounding data
				point >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data

			if ( isOutside ) {

				return c1Result;

			}

		}

		// either there was no intersection in the first node, or there could still be a closer
		// intersection in the second, so check the second node and then take the better of the two
		const c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );
		const c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;

		if ( c1Result && c2Result ) {

			return c1Result.distance <= c2Result.distance ? c1Result : c2Result;

		} else {

			return c1Result || c2Result || null;

		}

	}

}

const shapecast = ( function () {

	let _box1, _box2;
	const boxStack = [];
	const boxPool = new _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_3__.PrimitivePool( () => new three__WEBPACK_IMPORTED_MODULE_0__.Box3() );

	return function shapecast( ...args ) {

		_box1 = boxPool.getPrimitive();
		_box2 = boxPool.getPrimitive();
		boxStack.push( _box1, _box2 );

		const result = shapecastTraverse( ...args );

		boxPool.releasePrimitive( _box1 );
		boxPool.releasePrimitive( _box2 );
		boxStack.pop();
		boxStack.pop();

		const length = boxStack.length;
		if ( length > 0 ) {

			_box2 = boxStack[ length - 1 ];
			_box1 = boxStack[ length - 2 ];

		}

		return result;

	};

	function shapecastTraverse(
		nodeIndex32,
		geometry,
		intersectsBoundsFunc,
		intersectsRangeFunc,
		nodeScoreFunc = null,
		nodeIndexByteOffset = 0, // offset for unique node identifier
		depth = 0
	) {

		// Define these inside the function so it has access to the local variables needed
		// when converting to the buffer equivalents
		function getLeftOffset( nodeIndex32 ) {

			let nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;

			// traverse until we find a leaf
			while ( ! (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAF)( nodeIndex16, uint16Array ) ) {

				nodeIndex32 = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.LEFT_NODE)( nodeIndex32 );
				nodeIndex16 = nodeIndex32 * 2;

			}

			return (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.OFFSET)( nodeIndex32, uint32Array );

		}

		function getRightEndOffset( nodeIndex32 ) {

			let nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;

			// traverse until we find a leaf
			while ( ! (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAF)( nodeIndex16, uint16Array ) ) {

				// adjust offset to point to the right node
				nodeIndex32 = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.RIGHT_NODE)( nodeIndex32, uint32Array );
				nodeIndex16 = nodeIndex32 * 2;

			}

			// return the end offset of the triangle range
			return (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.OFFSET)( nodeIndex32, uint32Array ) + (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.COUNT)( nodeIndex16, uint16Array );

		}

		let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;

		const isLeaf = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAF)( nodeIndex16, uint16Array );
		if ( isLeaf ) {

			const offset = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.OFFSET)( nodeIndex32, uint32Array );
			const count = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.COUNT)( nodeIndex16, uint16Array );
			(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)( (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.BOUNDING_DATA_INDEX)( nodeIndex32 ), float32Array, _box1 );
			return intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );

		} else {

			const left = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.LEFT_NODE)( nodeIndex32 );
			const right = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.RIGHT_NODE)( nodeIndex32, uint32Array );
			let c1 = left;
			let c2 = right;

			let score1, score2;
			let box1, box2;
			if ( nodeScoreFunc ) {

				box1 = _box1;
				box2 = _box2;

				// bounding data is not offset
				(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)( (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.BOUNDING_DATA_INDEX)( c1 ), float32Array, box1 );
				(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)( (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.BOUNDING_DATA_INDEX)( c2 ), float32Array, box2 );

				score1 = nodeScoreFunc( box1 );
				score2 = nodeScoreFunc( box2 );

				if ( score2 < score1 ) {

					c1 = right;
					c2 = left;

					const temp = score1;
					score1 = score2;
					score2 = temp;

					box1 = box2;
					// box2 is always set before use below

				}

			}

			// Check box 1 intersection
			if ( ! box1 ) {

				box1 = _box1;
				(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)( (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.BOUNDING_DATA_INDEX)( c1 ), float32Array, box1 );

			}

			const isC1Leaf = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAF)( c1 * 2, uint16Array );
			const c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );

			let c1StopTraversal;
			if ( c1Intersection === _Constants_js__WEBPACK_IMPORTED_MODULE_5__.CONTAINED ) {

				const offset = getLeftOffset( c1 );
				const end = getRightEndOffset( c1 );
				const count = end - offset;

				c1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );

			} else {

				c1StopTraversal =
					c1Intersection &&
					shapecastTraverse(
						c1,
						geometry,
						intersectsBoundsFunc,
						intersectsRangeFunc,
						nodeScoreFunc,
						nodeIndexByteOffset,
						depth + 1
					);

			}

			if ( c1StopTraversal ) return true;

			// Check box 2 intersection
			// cached box2 will have been overwritten by previous traversal
			box2 = _box2;
			(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)( (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.BOUNDING_DATA_INDEX)( c2 ), float32Array, box2 );

			const isC2Leaf = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAF)( c2 * 2, uint16Array );
			const c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );

			let c2StopTraversal;
			if ( c2Intersection === _Constants_js__WEBPACK_IMPORTED_MODULE_5__.CONTAINED ) {

				const offset = getLeftOffset( c2 );
				const end = getRightEndOffset( c2 );
				const count = end - offset;

				c2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );

			} else {

				c2StopTraversal =
					c2Intersection &&
					shapecastTraverse(
						c2,
						geometry,
						intersectsBoundsFunc,
						intersectsRangeFunc,
						nodeScoreFunc,
						nodeIndexByteOffset,
						depth + 1
					);

			}

			if ( c2StopTraversal ) return true;

			return false;

		}

	}

} )();

const intersectsGeometry = ( function () {

	const triangle = new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_6__.ExtendedTriangle();
	const triangle2 = new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_6__.ExtendedTriangle();
	const invertedMat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();

	const obb = new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_7__.OrientedBox();
	const obb2 = new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_7__.OrientedBox();

	return function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {

		let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;

		if ( cachedObb === null ) {

			if ( ! otherGeometry.boundingBox ) {

				otherGeometry.computeBoundingBox();

			}

			obb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );
			cachedObb = obb;

		}

		const isLeaf = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAF)( nodeIndex16, uint16Array );
		if ( isLeaf ) {

			const thisGeometry = geometry;
			const thisIndex = thisGeometry.index;
			const thisPos = thisGeometry.attributes.position;

			const index = otherGeometry.index;
			const pos = otherGeometry.attributes.position;

			const offset = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.OFFSET)( nodeIndex32, uint32Array );
			const count = (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.COUNT)( nodeIndex16, uint16Array );

			// get the inverse of the geometry matrix so we can transform our triangles into the
			// geometry space we're trying to test. We assume there are fewer triangles being checked
			// here.
			invertedMat.copy( geometryToBvh ).invert();

			if ( otherGeometry.boundsTree ) {

				(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)( (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.BOUNDING_DATA_INDEX)( nodeIndex32 ), float32Array, obb2 );
				obb2.matrix.copy( invertedMat );
				obb2.needsUpdate = true;

				const res = otherGeometry.boundsTree.shapecast( {

					intersectsBounds: box => obb2.intersectsBox( box ),

					intersectsTriangle: tri => {

						tri.a.applyMatrix4( geometryToBvh );
						tri.b.applyMatrix4( geometryToBvh );
						tri.c.applyMatrix4( geometryToBvh );
						tri.needsUpdate = true;

						for ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {

							// this triangle needs to be transformed into the current BVH coordinate frame
							(0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_8__.setTriangle)( triangle2, i, thisIndex, thisPos );
							triangle2.needsUpdate = true;
							if ( tri.intersectsTriangle( triangle2 ) ) {

								return true;

							}

						}

						return false;

					}

				} );

				return res;

			} else {

				for ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {

					// this triangle needs to be transformed into the current BVH coordinate frame
					(0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_8__.setTriangle)( triangle, i, thisIndex, thisPos );
					triangle.a.applyMatrix4( invertedMat );
					triangle.b.applyMatrix4( invertedMat );
					triangle.c.applyMatrix4( invertedMat );
					triangle.needsUpdate = true;

					for ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {

						(0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_8__.setTriangle)( triangle2, i2, index, pos );
						triangle2.needsUpdate = true;

						if ( triangle.intersectsTriangle( triangle2 ) ) {

							return true;

						}

					}

				}

			}

		} else {

			const left = nodeIndex32 + 8;
			const right = uint32Array[ nodeIndex32 + 6 ];

			(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)( (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.BOUNDING_DATA_INDEX)( left ), float32Array, boundingBox );
			const leftIntersection =
				cachedObb.intersectsBox( boundingBox ) &&
				intersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );

			if ( leftIntersection ) return true;

			(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)( (0,_nodeBufferFunctions_js__WEBPACK_IMPORTED_MODULE_1__.BOUNDING_DATA_INDEX)( right ), float32Array, boundingBox );
			const rightIntersection =
				cachedObb.intersectsBox( boundingBox ) &&
				intersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );

			if ( rightIntersection ) return true;

			return false;

		}

	};

} )();

function intersectRay( nodeIndex32, array, ray, target ) {

	(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)( nodeIndex32, array, boundingBox );
	return ray.intersectBox( boundingBox, target );

}

const bufferStack = [];
let _prevBuffer;
let _float32Array;
let _uint16Array;
let _uint32Array;
function setBuffer( buffer ) {

	if ( _prevBuffer ) {

		bufferStack.push( _prevBuffer );

	}

	_prevBuffer = buffer;
	_float32Array = new Float32Array( buffer );
	_uint16Array = new Uint16Array( buffer );
	_uint32Array = new Uint32Array( buffer );

}

function clearBuffer() {

	_prevBuffer = null;
	_float32Array = null;
	_uint16Array = null;
	_uint32Array = null;

	if ( bufferStack.length ) {

		setBuffer( bufferStack.pop() );

	}

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BOUNDING_DATA_INDEX": () => (/* binding */ BOUNDING_DATA_INDEX),
/* harmony export */   "COUNT": () => (/* binding */ COUNT),
/* harmony export */   "IS_LEAF": () => (/* binding */ IS_LEAF),
/* harmony export */   "LEFT_NODE": () => (/* binding */ LEFT_NODE),
/* harmony export */   "OFFSET": () => (/* binding */ OFFSET),
/* harmony export */   "RIGHT_NODE": () => (/* binding */ RIGHT_NODE),
/* harmony export */   "SPLIT_AXIS": () => (/* binding */ SPLIT_AXIS)
/* harmony export */ });
function IS_LEAF( n16, uint16Array ) {

	return uint16Array[ n16 + 15 ] === 0xFFFF;

}

function OFFSET( n32, uint32Array ) {

	return uint32Array[ n32 + 6 ];

}

function COUNT( n16, uint16Array ) {

	return uint16Array[ n16 + 14 ];

}

function LEFT_NODE( n32 ) {

	return n32 + 8;

}

function RIGHT_NODE( n32, uint32Array ) {

	return uint32Array[ n32 + 6 ];

}

function SPLIT_AXIS( n32, uint32Array ) {

	return uint32Array[ n32 + 7 ];

}

function BOUNDING_DATA_INDEX( n32 ) {

	return n32;

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js":
/*!******************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExtendedTriangle": () => (/* binding */ ExtendedTriangle)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SeparatingAxisBounds.js */ "./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js");
/* harmony import */ var _MathUtilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MathUtilities.js */ "./node_modules/three-mesh-bvh/src/math/MathUtilities.js");




const DIST_EPSILON = 1e-15;
function isNearZero( value ) {

	return Math.abs( value ) < DIST_EPSILON;

}

class ExtendedTriangle extends three__WEBPACK_IMPORTED_MODULE_0__.Triangle {

	constructor( ...args ) {

		super( ...args );

		this.isExtendedTriangle = true;
		this.satAxes = new Array( 4 ).fill().map( () => new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() );
		this.satBounds = new Array( 4 ).fill().map( () => new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds() );
		this.points = [ this.a, this.b, this.c ];
		this.sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();
		this.plane = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();
		this.needsUpdate = true;

	}

	intersectsSphere( sphere ) {

		return (0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_2__.sphereIntersectTriangle)( sphere, this );

	}

	update() {

		const a = this.a;
		const b = this.b;
		const c = this.c;
		const points = this.points;

		const satAxes = this.satAxes;
		const satBounds = this.satBounds;

		const axis0 = satAxes[ 0 ];
		const sab0 = satBounds[ 0 ];
		this.getNormal( axis0 );
		sab0.setFromPoints( axis0, points );

		const axis1 = satAxes[ 1 ];
		const sab1 = satBounds[ 1 ];
		axis1.subVectors( a, b );
		sab1.setFromPoints( axis1, points );

		const axis2 = satAxes[ 2 ];
		const sab2 = satBounds[ 2 ];
		axis2.subVectors( b, c );
		sab2.setFromPoints( axis2, points );

		const axis3 = satAxes[ 3 ];
		const sab3 = satBounds[ 3 ];
		axis3.subVectors( c, a );
		sab3.setFromPoints( axis3, points );

		this.sphere.setFromPoints( this.points );
		this.plane.setFromNormalAndCoplanarPoint( axis0, a );
		this.needsUpdate = false;

	}

}

ExtendedTriangle.prototype.closestPointToSegment = ( function () {

	const point1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const point2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const edge = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();

	return function distanceToSegment( segment, target1 = null, target2 = null ) {

		const { start, end } = segment;
		const points = this.points;
		let distSq;
		let closestDistanceSq = Infinity;

		// check the triangle edges
		for ( let i = 0; i < 3; i ++ ) {

			const nexti = ( i + 1 ) % 3;
			edge.start.copy( points[ i ] );
			edge.end.copy( points[ nexti ] );

			(0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_2__.closestPointsSegmentToSegment)( edge, segment, point1, point2 );

			distSq = point1.distanceToSquared( point2 );
			if ( distSq < closestDistanceSq ) {

				closestDistanceSq = distSq;
				if ( target1 ) target1.copy( point1 );
				if ( target2 ) target2.copy( point2 );

			}

		}

		// check end points
		this.closestPointToPoint( start, point1 );
		distSq = start.distanceToSquared( point1 );
		if ( distSq < closestDistanceSq ) {

			closestDistanceSq = distSq;
			if ( target1 ) target1.copy( point1 );
			if ( target2 ) target2.copy( start );

		}

		this.closestPointToPoint( end, point1 );
		distSq = end.distanceToSquared( point1 );
		if ( distSq < closestDistanceSq ) {

			closestDistanceSq = distSq;
			if ( target1 ) target1.copy( point1 );
			if ( target2 ) target2.copy( end );

		}

		return Math.sqrt( closestDistanceSq );

	};

} )();

ExtendedTriangle.prototype.intersectsTriangle = ( function () {

	const saTri2 = new ExtendedTriangle();
	const arr1 = new Array( 3 );
	const arr2 = new Array( 3 );
	const cachedSatBounds = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();
	const cachedSatBounds2 = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();
	const cachedAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const dir1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const dir2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const tempDir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const edge = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();
	const edge1 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();
	const edge2 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();

	// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least
	// be a line contained by both triangles if not a different special case somehow represented in the return result.
	return function intersectsTriangle( other, target = null, suppressLog = false ) {

		if ( this.needsUpdate ) {

			this.update();

		}

		if ( ! other.isExtendedTriangle ) {

			saTri2.copy( other );
			saTri2.update();
			other = saTri2;

		} else if ( other.needsUpdate ) {

			other.update();

		}

		const plane1 = this.plane;
		const plane2 = other.plane;

		if ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {

			// perform separating axis intersection test only for coplanar triangles
			const satBounds1 = this.satBounds;
			const satAxes1 = this.satAxes;
			arr2[ 0 ] = other.a;
			arr2[ 1 ] = other.b;
			arr2[ 2 ] = other.c;
			for ( let i = 0; i < 4; i ++ ) {

				const sb = satBounds1[ i ];
				const sa = satAxes1[ i ];
				cachedSatBounds.setFromPoints( sa, arr2 );
				if ( sb.isSeparated( cachedSatBounds ) ) return false;

			}

			const satBounds2 = other.satBounds;
			const satAxes2 = other.satAxes;
			arr1[ 0 ] = this.a;
			arr1[ 1 ] = this.b;
			arr1[ 2 ] = this.c;
			for ( let i = 0; i < 4; i ++ ) {

				const sb = satBounds2[ i ];
				const sa = satAxes2[ i ];
				cachedSatBounds.setFromPoints( sa, arr1 );
				if ( sb.isSeparated( cachedSatBounds ) ) return false;

			}

			// check crossed axes
			for ( let i = 0; i < 4; i ++ ) {

				const sa1 = satAxes1[ i ];
				for ( let i2 = 0; i2 < 4; i2 ++ ) {

					const sa2 = satAxes2[ i2 ];
					cachedAxis.crossVectors( sa1, sa2 );
					cachedSatBounds.setFromPoints( cachedAxis, arr1 );
					cachedSatBounds2.setFromPoints( cachedAxis, arr2 );
					if ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;

				}

			}

			if ( target ) {

				// TODO find two points that intersect on the edges and make that the result
				if ( ! suppressLog ) {

					console.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );

				}

				target.start.set( 0, 0, 0 );
				target.end.set( 0, 0, 0 );

			}

			return true;

		} else {

			// find the edge that intersects the other triangle plane
			const points1 = this.points;
			let found1 = false;
			let count1 = 0;
			for ( let i = 0; i < 3; i ++ ) {

				const p = points1[ i ];
				const pNext = points1[ ( i + 1 ) % 3 ];

				edge.start.copy( p );
				edge.end.copy( pNext );
				edge.delta( dir1 );

				const targetPoint = found1 ? edge1.start : edge1.end;
				const startIntersects = isNearZero( plane2.distanceToPoint( p ) );
				if ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {

					// if the edge lies on the plane then take the line
					edge1.copy( edge );
					count1 = 2;
					break;

				}

				// check if the start point is near the plane because "intersectLine" is not robust to that case
				const doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;
				if ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {

					count1 ++;
					if ( found1 ) {

						break;

					}

					found1 = true;

				}

			}

			if ( count1 === 1 && other.containsPoint( edge1.end ) ) {

				if ( target ) {

					target.start.copy( edge1.end );
					target.end.copy( edge1.end );

				}

				return true;

			} else if ( count1 !== 2 ) {

				return false;

			}

			// find the other triangles edge that intersects this plane
			const points2 = other.points;
			let found2 = false;
			let count2 = 0;
			for ( let i = 0; i < 3; i ++ ) {

				const p = points2[ i ];
				const pNext = points2[ ( i + 1 ) % 3 ];

				edge.start.copy( p );
				edge.end.copy( pNext );
				edge.delta( dir2 );

				const targetPoint = found2 ? edge2.start : edge2.end;
				const startIntersects = isNearZero( plane1.distanceToPoint( p ) );
				if ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {

					// if the edge lies on the plane then take the line
					edge2.copy( edge );
					count2 = 2;
					break;

				}

				// check if the start point is near the plane because "intersectLine" is not robust to that case
				const doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;
				if ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {

					count2 ++;
					if ( found2 ) {

						break;

					}

					found2 = true;

				}

			}

			if ( count2 === 1 && this.containsPoint( edge2.end ) ) {

				if ( target ) {

					target.start.copy( edge2.end );
					target.end.copy( edge2.end );

				}

				return true;

			} else if ( count2 !== 2 ) {

				return false;

			}

			// find swap the second edge so both lines are running the same direction
			edge1.delta( dir1 );
			edge2.delta( dir2 );

			if ( dir1.dot( dir2 ) < 0 ) {

				let tmp = edge2.start;
				edge2.start = edge2.end;
				edge2.end = tmp;

			}

			// check if the edges are overlapping
			const s1 = edge1.start.dot( dir1 );
			const e1 = edge1.end.dot( dir1 );
			const s2 = edge2.start.dot( dir1 );
			const e2 = edge2.end.dot( dir1 );
			const separated1 = e1 < s2;
			const separated2 = s1 < e2;

			if ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {

				return false;

			}

			// assign the target output
			if ( target ) {

				tempDir.subVectors( edge1.start, edge2.start );
				if ( tempDir.dot( dir1 ) > 0 ) {

					target.start.copy( edge1.start );

				} else {

					target.start.copy( edge2.start );

				}

				tempDir.subVectors( edge1.end, edge2.end );
				if ( tempDir.dot( dir1 ) < 0 ) {

					target.end.copy( edge1.end );

				} else {

					target.end.copy( edge2.end );

				}

			}

			return true;

		}

	};

} )();


ExtendedTriangle.prototype.distanceToPoint = ( function () {

	const target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	return function distanceToPoint( point ) {

		this.closestPointToPoint( point, target );
		return point.distanceTo( target );

	};

} )();


ExtendedTriangle.prototype.distanceToTriangle = ( function () {

	const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const point2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const cornerFields = [ 'a', 'b', 'c' ];
	const line1 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();
	const line2 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();

	return function distanceToTriangle( other, target1 = null, target2 = null ) {

		const lineTarget = target1 || target2 ? line1 : null;
		if ( this.intersectsTriangle( other, lineTarget ) ) {

			if ( target1 || target2 ) {

				if ( target1 ) lineTarget.getCenter( target1 );
				if ( target2 ) lineTarget.getCenter( target2 );

			}

			return 0;

		}

		let closestDistanceSq = Infinity;

		// check all point distances
		for ( let i = 0; i < 3; i ++ ) {

			let dist;
			const field = cornerFields[ i ];
			const otherVec = other[ field ];
			this.closestPointToPoint( otherVec, point );

			dist = otherVec.distanceToSquared( point );

			if ( dist < closestDistanceSq ) {

				closestDistanceSq = dist;
				if ( target1 ) target1.copy( point );
				if ( target2 ) target2.copy( otherVec );

			}


			const thisVec = this[ field ];
			other.closestPointToPoint( thisVec, point );

			dist = thisVec.distanceToSquared( point );

			if ( dist < closestDistanceSq ) {

				closestDistanceSq = dist;
				if ( target1 ) target1.copy( thisVec );
				if ( target2 ) target2.copy( point );

			}

		}

		for ( let i = 0; i < 3; i ++ ) {

			const f11 = cornerFields[ i ];
			const f12 = cornerFields[ ( i + 1 ) % 3 ];
			line1.set( this[ f11 ], this[ f12 ] );
			for ( let i2 = 0; i2 < 3; i2 ++ ) {

				const f21 = cornerFields[ i2 ];
				const f22 = cornerFields[ ( i2 + 1 ) % 3 ];
				line2.set( other[ f21 ], other[ f22 ] );

				(0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_2__.closestPointsSegmentToSegment)( line1, line2, point, point2 );

				const dist = point.distanceToSquared( point2 );
				if ( dist < closestDistanceSq ) {

					closestDistanceSq = dist;
					if ( target1 ) target1.copy( point );
					if ( target2 ) target2.copy( point2 );

				}

			}

		}

		return Math.sqrt( closestDistanceSq );

	};

} )();


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/math/MathUtilities.js":
/*!***************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/math/MathUtilities.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "closestPointLineToLine": () => (/* binding */ closestPointLineToLine),
/* harmony export */   "closestPointsSegmentToSegment": () => (/* binding */ closestPointsSegmentToSegment),
/* harmony export */   "sphereIntersectTriangle": () => (/* binding */ sphereIntersectTriangle)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


const closestPointLineToLine = ( function () {

	// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56
	const dir1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const dir2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const v02 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	return function closestPointLineToLine( l1, l2, result ) {

		const v0 = l1.start;
		const v10 = dir1;
		const v2 = l2.start;
		const v32 = dir2;

		v02.subVectors( v0, v2 );
		dir1.subVectors( l1.end, l1.start );
		dir2.subVectors( l2.end, l2.start );

		// float d0232 = v02.Dot(v32);
		const d0232 = v02.dot( v32 );

		// float d3210 = v32.Dot(v10);
		const d3210 = v32.dot( v10 );

		// float d3232 = v32.Dot(v32);
		const d3232 = v32.dot( v32 );

		// float d0210 = v02.Dot(v10);
		const d0210 = v02.dot( v10 );

		// float d1010 = v10.Dot(v10);
		const d1010 = v10.dot( v10 );

		// float denom = d1010*d3232 - d3210*d3210;
		const denom = d1010 * d3232 - d3210 * d3210;

		let d, d2;
		if ( denom !== 0 ) {

			d = ( d0232 * d3210 - d0210 * d3232 ) / denom;

		} else {

			d = 0;

		}

		d2 = ( d0232 + d * d3210 ) / d3232;

		result.x = d;
		result.y = d2;

	};

} )();

const closestPointsSegmentToSegment = ( function () {

	// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187
	const paramResult = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
	const temp1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const temp2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	return function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {

		closestPointLineToLine( l1, l2, paramResult );

		let d = paramResult.x;
		let d2 = paramResult.y;
		if ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {

			l1.at( d, target1 );
			l2.at( d2, target2 );

			return;

		} else if ( d >= 0 && d <= 1 ) {

			// Only d2 is out of bounds.
			if ( d2 < 0 ) {

				l2.at( 0, target2 );

			} else {

				l2.at( 1, target2 );

			}

			l1.closestPointToPoint( target2, true, target1 );
			return;

		} else if ( d2 >= 0 && d2 <= 1 ) {

			// Only d is out of bounds.
			if ( d < 0 ) {

				l1.at( 0, target1 );

			} else {

				l1.at( 1, target1 );

			}

			l2.closestPointToPoint( target1, true, target2 );
			return;

		} else {

			// Both u and u2 are out of bounds.
			let p;
			if ( d < 0 ) {

				p = l1.start;

			} else {

				p = l1.end;

			}

			let p2;
			if ( d2 < 0 ) {

				p2 = l2.start;

			} else {

				p2 = l2.end;

			}

			const closestPoint = temp1;
			const closestPoint2 = temp2;
			l1.closestPointToPoint( p2, true, temp1 );
			l2.closestPointToPoint( p, true, temp2 );

			if ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {

				target1.copy( closestPoint );
				target2.copy( p2 );
				return;

			} else {

				target1.copy( p );
				target2.copy( closestPoint2 );
				return;

			}

		}

	};

} )();


const sphereIntersectTriangle = ( function () {

	// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js
	const closestPointTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const projectedPointTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const planeTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();
	const lineTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();
	return function sphereIntersectTriangle( sphere, triangle ) {

		const { radius, center } = sphere;
		const { a, b, c } = triangle;

		// phase 1
		lineTemp.start = a;
		lineTemp.end = b;
		const closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );
		if ( closestPoint1.distanceTo( center ) <= radius ) return true;

		lineTemp.start = a;
		lineTemp.end = c;
		const closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );
		if ( closestPoint2.distanceTo( center ) <= radius ) return true;

		lineTemp.start = b;
		lineTemp.end = c;
		const closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );
		if ( closestPoint3.distanceTo( center ) <= radius ) return true;

		// phase 2
		const plane = triangle.getPlane( planeTemp );
		const dp = Math.abs( plane.distanceToPoint( center ) );
		if ( dp <= radius ) {

			const pp = plane.projectPoint( center, projectedPointTemp );
			const cp = triangle.containsPoint( pp );
			if ( cp ) return true;

		}

		return false;

	};

} )();


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/math/OrientedBox.js":
/*!*************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/math/OrientedBox.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrientedBox": () => (/* binding */ OrientedBox)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SeparatingAxisBounds.js */ "./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js");
/* harmony import */ var _ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExtendedTriangle.js */ "./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js");
/* harmony import */ var _MathUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MathUtilities.js */ "./node_modules/three-mesh-bvh/src/math/MathUtilities.js");





class OrientedBox {

	constructor( min, max, matrix ) {

		this.isOrientedBox = true;
		this.min = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this.max = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this.matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
		this.invMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
		this.points = new Array( 8 ).fill().map( () => new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() );
		this.satAxes = new Array( 3 ).fill().map( () => new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() );
		this.satBounds = new Array( 3 ).fill().map( () => new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds() );
		this.alignedSatBounds = new Array( 3 ).fill().map( () => new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds() );
		this.needsUpdate = false;

		if ( min ) this.min.copy( min );
		if ( max ) this.max.copy( max );
		if ( matrix ) this.matrix.copy( matrix );

	}

	set( min, max, matrix ) {

		this.min.copy( min );
		this.max.copy( max );
		this.matrix.copy( matrix );
		this.needsUpdate = true;

	}

	copy( other ) {

		this.min.copy( other.min );
		this.max.copy( other.max );
		this.matrix.copy( other.matrix );
		this.needsUpdate = true;

	}

}

OrientedBox.prototype.update = ( function () {

	return function update() {

		const matrix = this.matrix;
		const min = this.min;
		const max = this.max;

		const points = this.points;
		for ( let x = 0; x <= 1; x ++ ) {

			for ( let y = 0; y <= 1; y ++ ) {

				for ( let z = 0; z <= 1; z ++ ) {

					const i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );
					const v = points[ i ];
					v.x = x ? max.x : min.x;
					v.y = y ? max.y : min.y;
					v.z = z ? max.z : min.z;

					v.applyMatrix4( matrix );

				}

			}

		}

		const satBounds = this.satBounds;
		const satAxes = this.satAxes;
		const minVec = points[ 0 ];
		for ( let i = 0; i < 3; i ++ ) {

			const axis = satAxes[ i ];
			const sb = satBounds[ i ];
			const index = 1 << i;
			const pi = points[ index ];

			axis.subVectors( minVec, pi );
			sb.setFromPoints( axis, points );

		}

		const alignedSatBounds = this.alignedSatBounds;
		alignedSatBounds[ 0 ].setFromPointsField( points, 'x' );
		alignedSatBounds[ 1 ].setFromPointsField( points, 'y' );
		alignedSatBounds[ 2 ].setFromPointsField( points, 'z' );

		this.invMatrix.copy( this.matrix ).invert();
		this.needsUpdate = false;

	};

} )();

OrientedBox.prototype.intersectsBox = ( function () {

	const aabbBounds = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();
	return function intersectsBox( box ) {

		// TODO: should this be doing SAT against the AABB?
		if ( this.needsUpdate ) {

			this.update();

		}

		const min = box.min;
		const max = box.max;
		const satBounds = this.satBounds;
		const satAxes = this.satAxes;
		const alignedSatBounds = this.alignedSatBounds;

		aabbBounds.min = min.x;
		aabbBounds.max = max.x;
		if ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;

		aabbBounds.min = min.y;
		aabbBounds.max = max.y;
		if ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;

		aabbBounds.min = min.z;
		aabbBounds.max = max.z;
		if ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;

		for ( let i = 0; i < 3; i ++ ) {

			const axis = satAxes[ i ];
			const sb = satBounds[ i ];
			aabbBounds.setFromBox( axis, box );
			if ( sb.isSeparated( aabbBounds ) ) return false;

		}

		return true;

	};

} )();

OrientedBox.prototype.intersectsTriangle = ( function () {

	const saTri = new _ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTriangle();
	const pointsArr = new Array( 3 );
	const cachedSatBounds = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();
	const cachedSatBounds2 = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();
	const cachedAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	return function intersectsTriangle( triangle ) {

		if ( this.needsUpdate ) {

			this.update();

		}

		if ( ! triangle.isExtendedTriangle ) {

			saTri.copy( triangle );
			saTri.update();
			triangle = saTri;

		} else if ( triangle.needsUpdate ) {

			triangle.update();

		}

		const satBounds = this.satBounds;
		const satAxes = this.satAxes;

		pointsArr[ 0 ] = triangle.a;
		pointsArr[ 1 ] = triangle.b;
		pointsArr[ 2 ] = triangle.c;

		for ( let i = 0; i < 3; i ++ ) {

			const sb = satBounds[ i ];
			const sa = satAxes[ i ];
			cachedSatBounds.setFromPoints( sa, pointsArr );
			if ( sb.isSeparated( cachedSatBounds ) ) return false;

		}

		const triSatBounds = triangle.satBounds;
		const triSatAxes = triangle.satAxes;
		const points = this.points;
		for ( let i = 0; i < 3; i ++ ) {

			const sb = triSatBounds[ i ];
			const sa = triSatAxes[ i ];
			cachedSatBounds.setFromPoints( sa, points );
			if ( sb.isSeparated( cachedSatBounds ) ) return false;

		}

		// check crossed axes
		for ( let i = 0; i < 3; i ++ ) {

			const sa1 = satAxes[ i ];
			for ( let i2 = 0; i2 < 4; i2 ++ ) {

				const sa2 = triSatAxes[ i2 ];
				cachedAxis.crossVectors( sa1, sa2 );
				cachedSatBounds.setFromPoints( cachedAxis, pointsArr );
				cachedSatBounds2.setFromPoints( cachedAxis, points );
				if ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;

			}

		}

		return true;

	};

} )();

OrientedBox.prototype.closestPointToPoint = ( function () {

	return function closestPointToPoint( point, target1 ) {

		if ( this.needsUpdate ) {

			this.update();

		}

		target1
			.copy( point )
			.applyMatrix4( this.invMatrix )
			.clamp( this.min, this.max )
			.applyMatrix4( this.matrix );

		return target1;

	};

} )();

OrientedBox.prototype.distanceToPoint = ( function () {

	const target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	return function distanceToPoint( point ) {

		this.closestPointToPoint( point, target );
		return point.distanceTo( target );

	};

} )();

OrientedBox.prototype.distanceToBox = ( function () {

	const xyzFields = [ 'x', 'y', 'z' ];
	const segments1 = new Array( 12 ).fill().map( () => new three__WEBPACK_IMPORTED_MODULE_0__.Line3() );
	const segments2 = new Array( 12 ).fill().map( () => new three__WEBPACK_IMPORTED_MODULE_0__.Line3() );

	const point1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const point2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

	// early out if we find a value below threshold
	return function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {

		if ( this.needsUpdate ) {

			this.update();

		}

		if ( this.intersectsBox( box ) ) {

			if ( target1 || target2 ) {

				box.getCenter( point2 );
				this.closestPointToPoint( point2, point1 );
				box.closestPointToPoint( point1, point2 );

				if ( target1 ) target1.copy( point1 );
				if ( target2 ) target2.copy( point2 );

			}

			return 0;

		}

		const threshold2 = threshold * threshold;
		const min = box.min;
		const max = box.max;
		const points = this.points;


		// iterate over every edge and compare distances
		let closestDistanceSq = Infinity;

		// check over all these points
		for ( let i = 0; i < 8; i ++ ) {

			const p = points[ i ];
			point2.copy( p ).clamp( min, max );

			const dist = p.distanceToSquared( point2 );
			if ( dist < closestDistanceSq ) {

				closestDistanceSq = dist;
				if ( target1 ) target1.copy( p );
				if ( target2 ) target2.copy( point2 );

				if ( dist < threshold2 ) return Math.sqrt( dist );

			}

		}

		// generate and check all line segment distances
		let count = 0;
		for ( let i = 0; i < 3; i ++ ) {

			for ( let i1 = 0; i1 <= 1; i1 ++ ) {

				for ( let i2 = 0; i2 <= 1; i2 ++ ) {

					const nextIndex = ( i + 1 ) % 3;
					const nextIndex2 = ( i + 2 ) % 3;

					// get obb line segments
					const index = i1 << nextIndex | i2 << nextIndex2;
					const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
					const p1 = points[ index ];
					const p2 = points[ index2 ];
					const line1 = segments1[ count ];
					line1.set( p1, p2 );


					// get aabb line segments
					const f1 = xyzFields[ i ];
					const f2 = xyzFields[ nextIndex ];
					const f3 = xyzFields[ nextIndex2 ];
					const line2 = segments2[ count ];
					const start = line2.start;
					const end = line2.end;

					start[ f1 ] = min[ f1 ];
					start[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];
					start[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];

					end[ f1 ] = max[ f1 ];
					end[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];
					end[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];

					count ++;

				}

			}

		}

		// check all the other boxes point
		for ( let x = 0; x <= 1; x ++ ) {

			for ( let y = 0; y <= 1; y ++ ) {

				for ( let z = 0; z <= 1; z ++ ) {

					point2.x = x ? max.x : min.x;
					point2.y = y ? max.y : min.y;
					point2.z = z ? max.z : min.z;

					this.closestPointToPoint( point2, point1 );
					const dist = point2.distanceToSquared( point1 );
					if ( dist < closestDistanceSq ) {

						closestDistanceSq = dist;
						if ( target1 ) target1.copy( point1 );
						if ( target2 ) target2.copy( point2 );

						if ( dist < threshold2 ) return Math.sqrt( dist );

					}

				}

			}

		}

		for ( let i = 0; i < 12; i ++ ) {

			const l1 = segments1[ i ];
			for ( let i2 = 0; i2 < 12; i2 ++ ) {

				const l2 = segments2[ i2 ];
				(0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_3__.closestPointsSegmentToSegment)( l1, l2, point1, point2 );
				const dist = point1.distanceToSquared( point2 );
				if ( dist < closestDistanceSq ) {

					closestDistanceSq = dist;
					if ( target1 ) target1.copy( point1 );
					if ( target2 ) target2.copy( point2 );

					if ( dist < threshold2 ) return Math.sqrt( dist );

				}

			}

		}

		return Math.sqrt( closestDistanceSq );

	};

} )();


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SeparatingAxisBounds": () => (/* binding */ SeparatingAxisBounds),
/* harmony export */   "areIntersecting": () => (/* binding */ areIntersecting)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


class SeparatingAxisBounds {

	constructor() {

		this.min = Infinity;
		this.max = - Infinity;

	}

	setFromPointsField( points, field ) {

		let min = Infinity;
		let max = - Infinity;
		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const p = points[ i ];
			const val = p[ field ];
			min = val < min ? val : min;
			max = val > max ? val : max;

		}

		this.min = min;
		this.max = max;

	}

	setFromPoints( axis, points ) {

		let min = Infinity;
		let max = - Infinity;
		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const p = points[ i ];
			const val = axis.dot( p );
			min = val < min ? val : min;
			max = val > max ? val : max;

		}

		this.min = min;
		this.max = max;

	}

	isSeparated( other ) {

		return this.min > other.max || other.min > this.max;

	}

}

SeparatingAxisBounds.prototype.setFromBox = ( function () {

	const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	return function setFromBox( axis, box ) {

		const boxMin = box.min;
		const boxMax = box.max;
		let min = Infinity;
		let max = - Infinity;
		for ( let x = 0; x <= 1; x ++ ) {

			for ( let y = 0; y <= 1; y ++ ) {

				for ( let z = 0; z <= 1; z ++ ) {

					p.x = boxMin.x * x + boxMax.x * ( 1 - x );
					p.y = boxMin.y * y + boxMax.y * ( 1 - y );
					p.z = boxMin.z * z + boxMax.z * ( 1 - z );

					const val = axis.dot( p );
					min = Math.min( val, min );
					max = Math.max( val, max );

				}

			}

		}

		this.min = min;
		this.max = max;

	};

} )();

const areIntersecting = ( function () {

	const cacheSatBounds = new SeparatingAxisBounds();
	return function areIntersecting( shape1, shape2 ) {

		const points1 = shape1.points;
		const satAxes1 = shape1.satAxes;
		const satBounds1 = shape1.satBounds;

		const points2 = shape2.points;
		const satAxes2 = shape2.satAxes;
		const satBounds2 = shape2.satBounds;

		// check axes of the first shape
		for ( let i = 0; i < 3; i ++ ) {

			const sb = satBounds1[ i ];
			const sa = satAxes1[ i ];
			cacheSatBounds.setFromPoints( sa, points2 );
			if ( sb.isSeparated( cacheSatBounds ) ) return false;

		}

		// check axes of the second shape
		for ( let i = 0; i < 3; i ++ ) {

			const sb = satBounds2[ i ];
			const sa = satAxes2[ i ];
			cacheSatBounds.setFromPoints( sa, points1 );
			if ( sb.isSeparated( cacheSatBounds ) ) return false;

		}

	};

} )();


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshBVHVisualizer": () => (/* binding */ MeshBVHVisualizer)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ArrayBoxUtilities.js */ "./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js");



const boundingBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
class MeshBVHRootVisualizer extends three__WEBPACK_IMPORTED_MODULE_0__.Object3D {

	get isMesh() {

		return ! this.displayEdges;

	}

	get isLineSegments() {

		return this.displayEdges;

	}

	get isLine() {

		return this.displayEdges;

	}

	constructor( mesh, material, depth = 10, group = 0 ) {

		super();

		this.material = material;
		this.geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
		this.name = 'MeshBVHRootVisualizer';
		this.depth = depth;
		this.displayParents = false;
		this.mesh = mesh;
		this.displayEdges = true;
		this._group = group;

	}

	raycast() {}

	update() {

		const geometry = this.geometry;
		const boundsTree = this.mesh.geometry.boundsTree;
		const group = this._group;
		geometry.dispose();
		this.visible = false;
		if ( boundsTree ) {

			// count the number of bounds required
			const targetDepth = this.depth - 1;
			const displayParents = this.displayParents;
			let boundsCount = 0;
			boundsTree.traverse( ( depth, isLeaf ) => {

				if ( depth === targetDepth || isLeaf ) {

					boundsCount ++;
					return true;

				} else if ( displayParents ) {

					boundsCount ++;

				}

			}, group );

			// fill in the position buffer with the bounds corners
			let posIndex = 0;
			const positionArray = new Float32Array( 8 * 3 * boundsCount );
			boundsTree.traverse( ( depth, isLeaf, boundingData ) => {

				const terminate = depth === targetDepth || isLeaf;
				if ( terminate || displayParents ) {

					(0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.arrayToBox)( 0, boundingData, boundingBox );

					const { min, max } = boundingBox;
					for ( let x = - 1; x <= 1; x += 2 ) {

						const xVal = x < 0 ? min.x : max.x;
						for ( let y = - 1; y <= 1; y += 2 ) {

							const yVal = y < 0 ? min.y : max.y;
							for ( let z = - 1; z <= 1; z += 2 ) {

								const zVal = z < 0 ? min.z : max.z;
								positionArray[ posIndex + 0 ] = xVal;
								positionArray[ posIndex + 1 ] = yVal;
								positionArray[ posIndex + 2 ] = zVal;

								posIndex += 3;

							}

						}

					}

					return terminate;

				}

			}, group );

			let indexArray;
			let indices;
			if ( this.displayEdges ) {

				// fill in the index buffer to point to the corner points
				indices = new Uint8Array( [
					// x axis
					0, 4,
					1, 5,
					2, 6,
					3, 7,

					// y axis
					0, 2,
					1, 3,
					4, 6,
					5, 7,

					// z axis
					0, 1,
					2, 3,
					4, 5,
					6, 7,
				] );

			} else {

				indices = new Uint8Array( [

					// X-, X+
					0, 1, 2,
					2, 1, 3,

					4, 6, 5,
					6, 7, 5,

					// Y-, Y+
					1, 4, 5,
					0, 4, 1,

					2, 3, 6,
					3, 7, 6,

					// Z-, Z+
					0, 2, 4,
					2, 6, 4,

					1, 5, 3,
					3, 5, 7,

				] );

			}

			if ( positionArray.length > 65535 ) {

				indexArray = new Uint32Array( indices.length * boundsCount );

			} else {

				indexArray = new Uint16Array( indices.length * boundsCount );

			}

			const indexLength = indices.length;
			for ( let i = 0; i < boundsCount; i ++ ) {

				const posOffset = i * 8;
				const indexOffset = i * indexLength;
				for ( let j = 0; j < indexLength; j ++ ) {

					indexArray[ indexOffset + j ] = posOffset + indices[ j ];

				}

			}

			// update the geometry
			geometry.setIndex(
				new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( indexArray, 1, false ),
			);
			geometry.setAttribute(
				'position',
				new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( positionArray, 3, false ),
			);
			this.visible = true;

		}

	}

}

class MeshBVHVisualizer extends three__WEBPACK_IMPORTED_MODULE_0__.Group {

	get color() {

		return this.edgeMaterial.color;

	}

	get opacity() {

		return this.edgeMaterial.opacity;

	}

	set opacity( v ) {

		this.edgeMaterial.opacity = v;
		this.meshMaterial.opacity = v;

	}

	constructor( mesh, depth = 10 ) {

		super();

		this.name = 'MeshBVHVisualizer';
		this.depth = depth;
		this.mesh = mesh;
		this.displayParents = false;
		this.displayEdges = true;
		this._roots = [];

		const edgeMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial( {
			color: 0x00FF88,
			transparent: true,
			opacity: 0.3,
			depthWrite: false,
		} );

		const meshMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial( {
			color: 0x00FF88,
			transparent: true,
			opacity: 0.3,
			depthWrite: false,
		} );

		meshMaterial.color = edgeMaterial.color;

		this.edgeMaterial = edgeMaterial;
		this.meshMaterial = meshMaterial;

		this.update();

	}

	update() {

		const bvh = this.mesh.geometry.boundsTree;
		const totalRoots = bvh ? bvh._roots.length : 0;
		while ( this._roots.length > totalRoots ) {

			const root = this._roots.pop();
			root.geometry.dispose();
			this.remove( root );

		}

		for ( let i = 0; i < totalRoots; i ++ ) {

			if ( i >= this._roots.length ) {

				const root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );
				this.add( root );
				this._roots.push( root );

			}

			const root = this._roots[ i ];
			root.depth = this.depth;
			root.mesh = this.mesh;
			root.displayParents = this.displayParents;
			root.displayEdges = this.displayEdges;
			root.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;
			root.update();

		}

	}

	updateMatrixWorld( ...args ) {

		this.position.copy( this.mesh.position );
		this.rotation.copy( this.mesh.rotation );
		this.scale.copy( this.mesh.scale );

		super.updateMatrixWorld( ...args );

	}

	copy( source ) {

		this.depth = source.depth;
		this.mesh = source.mesh;

	}

	clone() {

		return new MeshBVHVisualizer( this.mesh, this.depth );

	}

	dispose() {

		this.edgeMaterial.dispose();
		this.meshMaterial.dispose();

		const children = this.children;
		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].geometry.dispose();

		}

	}

}





/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js":
/*!********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayToBox": () => (/* binding */ arrayToBox),
/* harmony export */   "computeSurfaceArea": () => (/* binding */ computeSurfaceArea),
/* harmony export */   "copyBounds": () => (/* binding */ copyBounds),
/* harmony export */   "expandByTriangleBounds": () => (/* binding */ expandByTriangleBounds),
/* harmony export */   "getLongestEdgeIndex": () => (/* binding */ getLongestEdgeIndex),
/* harmony export */   "unionBounds": () => (/* binding */ unionBounds)
/* harmony export */ });
function arrayToBox( nodeIndex32, array, target ) {

	target.min.x = array[ nodeIndex32 ];
	target.min.y = array[ nodeIndex32 + 1 ];
	target.min.z = array[ nodeIndex32 + 2 ];

	target.max.x = array[ nodeIndex32 + 3 ];
	target.max.y = array[ nodeIndex32 + 4 ];
	target.max.z = array[ nodeIndex32 + 5 ];

	return target;

}

function getLongestEdgeIndex( bounds ) {

	let splitDimIdx = - 1;
	let splitDist = - Infinity;

	for ( let i = 0; i < 3; i ++ ) {

		const dist = bounds[ i + 3 ] - bounds[ i ];
		if ( dist > splitDist ) {

			splitDist = dist;
			splitDimIdx = i;

		}

	}

	return splitDimIdx;

}

// copies bounds a into bounds b
function copyBounds( source, target ) {

	target.set( source );

}

// sets bounds target to the union of bounds a and b
function unionBounds( a, b, target ) {

	let aVal, bVal;
	for ( let d = 0; d < 3; d ++ ) {

		const d3 = d + 3;

		// set the minimum values
		aVal = a[ d ];
		bVal = b[ d ];
		target[ d ] = aVal < bVal ? aVal : bVal;

		// set the max values
		aVal = a[ d3 ];
		bVal = b[ d3 ];
		target[ d3 ] = aVal > bVal ? aVal : bVal;

	}

}

// expands the given bounds by the provided triangle bounds
function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {

	for ( let d = 0; d < 3; d ++ ) {

		const tCenter = triangleBounds[ startIndex + 2 * d ];
		const tHalf = triangleBounds[ startIndex + 2 * d + 1 ];

		const tMin = tCenter - tHalf;
		const tMax = tCenter + tHalf;

		if ( tMin < bounds[ d ] ) {

			bounds[ d ] = tMin;

		}

		if ( tMax > bounds[ d + 3 ] ) {

			bounds[ d + 3 ] = tMax;

		}

	}

}

// compute bounds surface area
function computeSurfaceArea( bounds ) {

	const d0 = bounds[ 3 ] - bounds[ 0 ];
	const d1 = bounds[ 4 ] - bounds[ 1 ];
	const d2 = bounds[ 5 ] - bounds[ 2 ];

	return 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js":
/*!*********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "acceleratedRaycast": () => (/* binding */ acceleratedRaycast),
/* harmony export */   "computeBoundsTree": () => (/* binding */ computeBoundsTree),
/* harmony export */   "disposeBoundsTree": () => (/* binding */ disposeBoundsTree)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryRayIntersectUtilities.js */ "./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js");
/* harmony import */ var _core_MeshBVH_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/MeshBVH.js */ "./node_modules/three-mesh-bvh/src/core/MeshBVH.js");




const ray = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Ray();
const tmpInverseMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const origMeshRaycastFunc = three__WEBPACK_IMPORTED_MODULE_0__.Mesh.prototype.raycast;

function acceleratedRaycast( raycaster, intersects ) {

	if ( this.geometry.boundsTree ) {

		if ( this.material === undefined ) return;

		tmpInverseMatrix.copy( this.matrixWorld ).invert();
		ray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );

		const bvh = this.geometry.boundsTree;
		if ( raycaster.firstHitOnly === true ) {

			const hit = (0,_GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_1__.convertRaycastIntersect)( bvh.raycastFirst( ray, this.material ), this, raycaster );
			if ( hit ) {

				intersects.push( hit );

			}

		} else {

			const hits = bvh.raycast( ray, this.material );
			for ( let i = 0, l = hits.length; i < l; i ++ ) {

				const hit = (0,_GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_1__.convertRaycastIntersect)( hits[ i ], this, raycaster );
				if ( hit ) {

					intersects.push( hit );

				}

			}

		}

	} else {

		origMeshRaycastFunc.call( this, raycaster, intersects );

	}

}

function computeBoundsTree( options ) {

	this.boundsTree = new _core_MeshBVH_js__WEBPACK_IMPORTED_MODULE_2__.MeshBVH( this, options );
	return this.boundsTree;

}

function disposeBoundsTree() {

	this.boundsTree = null;

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js":
/*!********************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertRaycastIntersect": () => (/* binding */ convertRaycastIntersect),
/* harmony export */   "intersectClosestTri": () => (/* binding */ intersectClosestTri),
/* harmony export */   "intersectTris": () => (/* binding */ intersectTris)
/* harmony export */ });
/* harmony import */ var _ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ThreeRayIntersectUtilities.js */ "./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js");


function intersectTris( geo, side, ray, offset, count, intersections ) {

	for ( let i = offset, end = offset + count; i < end; i ++ ) {

		(0,_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)( geo, side, ray, i, intersections );

	}

}

function intersectClosestTri( geo, side, ray, offset, count ) {

	let dist = Infinity;
	let res = null;
	for ( let i = offset, end = offset + count; i < end; i ++ ) {

		const intersection = (0,_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)( geo, side, ray, i );
		if ( intersection && intersection.distance < dist ) {

			res = intersection;
			dist = intersection.distance;

		}

	}

	return res;

}

// converts the given BVH raycast intersection to align with the three.js raycast
// structure (include object, world space distance and point).
function convertRaycastIntersect( hit, object, raycaster ) {

	if ( hit === null ) {

		return null;

	}

	hit.point.applyMatrix4( object.matrixWorld );
	hit.distance = hit.point.distanceTo( raycaster.ray.origin );
	hit.object = object;

	if ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {

		return null;

	} else {

		return hit;

	}

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrimitivePool": () => (/* binding */ PrimitivePool)
/* harmony export */ });
class PrimitivePool {

	constructor( getNewPrimitive ) {

		this._getNewPrimitive = getNewPrimitive;
		this._primitives = [];

	}

	getPrimitive() {

		const primitives = this._primitives;
		if ( primitives.length === 0 ) {

			return this._getNewPrimitive();

		} else {

			return primitives.pop();

		}

	}

	releasePrimitive( primitive ) {

		this._primitives.push( primitive );

	}

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StaticGeometryGenerator": () => (/* binding */ StaticGeometryGenerator)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


const _positionVector = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _normalVector = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _tangentVector = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _tangentVector4 = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();

const _morphVector = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _temp = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

const _skinIndex = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();
const _skinWeight = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();
const _matrix = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _boneMatrix = /*@__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();

// Confirms that the two provided attributes are compatible
function validateAttributes( attr1, attr2 ) {

	if ( ! attr1 && ! attr2 ) {

		return;

	}

	const sameCount = attr1.count === attr2.count;
	const sameNormalized = attr1.normalized === attr2.normalized;
	const sameType = attr1.array.constructor === attr2.array.constructor;
	const sameItemSize = attr1.itemSize === attr2.itemSize;

	if ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {

		throw new Error();

	}

}

// Clones the given attribute with a new compatible buffer attribute but no data
function createAttributeClone( attr, countOverride = null ) {

	const cons = attr.array.constructor;
	const normalized = attr.normalized;
	const itemSize = attr.itemSize;
	const count = countOverride === null ? attr.count : countOverride;

	return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( new cons( itemSize * count ), itemSize, normalized );

}

// target offset is the number of elements in the target buffer stride to skip before copying the
// attributes contents in to.
function copyAttributeContents( attr, target, targetOffset = 0 ) {

	if ( attr.isInterleavedBufferAttribute ) {

		const itemSize = attr.itemSize;
		for ( let i = 0, l = attr.count; i < l; i ++ ) {

			const io = i + targetOffset;
			target.setX( io, attr.getX( i ) );
			if ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );
			if ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );
			if ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );

		}

	} else {

		const array = target.array;
		const cons = array.constructor;
		const byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;
		const temp = new cons( array.buffer, byteOffset, attr.array.length );
		temp.set( attr.array );

	}

}

// Adds the "matrix" multiplied by "scale" to "target"
function addScaledMatrix( target, matrix, scale ) {

	const targetArray = target.elements;
	const matrixArray = matrix.elements;
	for ( let i = 0, l = matrixArray.length; i < l; i ++ ) {

		targetArray[ i ] += matrixArray[ i ] * scale;

	}

}

// A version of "SkinnedMesh.boneTransform" for normals
function boneNormalTransform( mesh, index, target ) {

	const skeleton = mesh.skeleton;
	const geometry = mesh.geometry;
	const bones = skeleton.bones;
	const boneInverses = skeleton.boneInverses;

	_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
	_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

	_matrix.elements.fill( 0 );

	for ( let i = 0; i < 4; i ++ ) {

		const weight = _skinWeight.getComponent( i );

		if ( weight !== 0 ) {

			const boneIndex = _skinIndex.getComponent( i );
			_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );

			addScaledMatrix( _matrix, _boneMatrix, weight );

		}

	}

	_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );
	target.transformDirection( _matrix );

	return target;

}

// Applies the morph target data to the target vector
function applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {

	_morphVector.set( 0, 0, 0 );
	for ( let j = 0, jl = morphData.length; j < jl; j ++ ) {

		const influence = morphInfluences[ j ];
		const morphAttribute = morphData[ j ];

		if ( influence === 0 ) continue;

		_temp.fromBufferAttribute( morphAttribute, i );

		if ( morphTargetsRelative ) {

			_morphVector.addScaledVector( _temp, influence );

		} else {

			_morphVector.addScaledVector( _temp.sub( target ), influence );

		}

	}

	target.add( _morphVector );

}

// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place
function mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry() ) {

	const isIndexed = geometries[ 0 ].index !== null;
	const { useGroups = false, updateIndex = false, skipAttributes = [] } = options;

	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
	const attributes = {};

	let offset = 0;

	targetGeometry.clearGroups();
	for ( let i = 0; i < geometries.length; ++ i ) {

		const geometry = geometries[ i ];
		let attributesCount = 0;

		// ensure that all geometries are indexed, or none
		if ( isIndexed !== ( geometry.index !== null ) ) {

			throw new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );

		}

		// gather attributes, exit early if they're different
		for ( const name in geometry.attributes ) {

			if ( ! attributesUsed.has( name ) ) {

				throw new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );

			}

			if ( attributes[ name ] === undefined ) {

				attributes[ name ] = [];

			}

			attributes[ name ].push( geometry.attributes[ name ] );
			attributesCount ++;

		}

		// ensure geometries have the same number of attributes
		if ( attributesCount !== attributesUsed.size ) {

			throw new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );

		}

		if ( useGroups ) {

			let count;
			if ( isIndexed ) {

				count = geometry.index.count;

			} else if ( geometry.attributes.position !== undefined ) {

				count = geometry.attributes.position.count;

			} else {

				throw new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );

			}

			targetGeometry.addGroup( offset, count, i );
			offset += count;

		}

	}

	// merge indices
	if ( isIndexed ) {

		let forceUpdateIndex = false;
		if ( ! targetGeometry.index ) {

			let indexCount = 0;
			for ( let i = 0; i < geometries.length; ++ i ) {

				indexCount += geometries[ i ].index.count;

			}

			targetGeometry.setIndex( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( new Uint32Array( indexCount ), 1, false ) );
			forceUpdateIndex = true;

		}

		if ( updateIndex || forceUpdateIndex ) {

			const targetIndex = targetGeometry.index;
			let targetOffset = 0;
			let indexOffset = 0;
			for ( let i = 0; i < geometries.length; ++ i ) {

				const geometry = geometries[ i ];
				const index = geometry.index;
				if ( skipAttributes[ i ] !== true ) {

					for ( let j = 0; j < index.count; ++ j ) {

						targetIndex.setX( targetOffset, index.getX( j ) + indexOffset );
						targetOffset ++;

					}

				}

				indexOffset += geometry.attributes.position.count;

			}

		}

	}

	// merge attributes
	for ( const name in attributes ) {

		const attrList = attributes[ name ];
		if ( ! ( name in targetGeometry.attributes ) ) {

			let count = 0;
			for ( const key in attrList ) {

				count += attrList[ key ].count;

			}

			targetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );

		}

		const targetAttribute = targetGeometry.attributes[ name ];
		let offset = 0;
		for ( let i = 0, l = attrList.length; i < l; i ++ ) {

			const attr = attrList[ i ];
			if ( skipAttributes[ i ] !== true ) {

				copyAttributeContents( attr, targetAttribute, offset );

			}

			offset += attr.count;

		}

	}

	return targetGeometry;

}

function checkTypedArrayEquality( a, b ) {

	if ( a === null || b === null ) {

		return a === b;

	}

	if ( a.length !== b.length ) {

		return false;

	}

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) {

			return false;

		}

	}

	return true;

}

// Checks whether the geometry changed between this and last evaluation
class GeometryDiff {

	constructor( mesh ) {

		this.matrixWorld = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
		this.geometryHash = null;
		this.boneMatrices = null;
		this.primitiveCount = - 1;
		this.mesh = mesh;

		this.update();

	}

	update() {

		const mesh = this.mesh;
		const geometry = mesh.geometry;
		const skeleton = mesh.skeleton;
		const primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;
		this.matrixWorld.copy( mesh.matrixWorld );
		this.geometryHash = geometry.attributes.position.version;
		this.primitiveCount = primitiveCount;

		if ( skeleton ) {

			// ensure the bone matrix array is updated to the appropriate length
			if ( ! skeleton.boneTexture ) {

				skeleton.computeBoneTexture();

			}

			skeleton.update();

			// copy data if possible otherwise clone it
			const boneMatrices = skeleton.boneMatrices;
			if ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {

				this.boneMatrices = boneMatrices.slice();

			} else {

				this.boneMatrices.set( boneMatrices );

			}

		} else {

			this.boneMatrices = null;

		}

	}

	didChange() {

		const mesh = this.mesh;
		const geometry = mesh.geometry;
		const primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;
		const identical =
			this.matrixWorld.equals( mesh.matrixWorld ) &&
			this.geometryHash === geometry.attributes.position.version &&
			checkTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&
			this.primitiveCount === primitiveCount;

		return ! identical;

	}

}

class StaticGeometryGenerator {

	constructor( meshes ) {

		if ( ! Array.isArray( meshes ) ) {

			meshes = [ meshes ];

		}

		const finalMeshes = [];
		meshes.forEach( object => {

			object.traverseVisible( c => {

				if ( c.isMesh ) {

					finalMeshes.push( c );

				}

			} );

		} );

		this.meshes = finalMeshes;
		this.useGroups = true;
		this.applyWorldTransforms = true;
		this.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];
		this._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry() );
		this._diffMap = new WeakMap();

	}

	getMaterials() {

		const materials = [];
		this.meshes.forEach( mesh => {

			if ( Array.isArray( mesh.material ) ) {

				materials.push( ...mesh.material );

			} else {

				materials.push( mesh.material );

			}

		} );
		return materials;

	}

	generate( targetGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry() ) {

		// track which attributes have been updated and which to skip to avoid unnecessary attribute copies
		let skipAttributes = [];
		const { meshes, useGroups, _intermediateGeometry, _diffMap } = this;
		for ( let i = 0, l = meshes.length; i < l; i ++ ) {

			const mesh = meshes[ i ];
			const geom = _intermediateGeometry[ i ];
			const diff = _diffMap.get( mesh );
			if ( ! diff || diff.didChange( mesh ) ) {

				this._convertToStaticGeometry( mesh, geom );
				skipAttributes.push( false );

				if ( ! diff ) {

					_diffMap.set( mesh, new GeometryDiff( mesh ) );

				} else {

					diff.update();

				}

			} else {

				skipAttributes.push( true );

			}

		}

		mergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );

		for ( const key in targetGeometry.attributes ) {

			targetGeometry.attributes[ key ].needsUpdate = true;

		}

		return targetGeometry;

	}

	_convertToStaticGeometry( mesh, targetGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry() ) {

		const geometry = mesh.geometry;
		const applyWorldTransforms = this.applyWorldTransforms;
		const includeNormal = this.attributes.includes( 'normal' );
		const includeTangent = this.attributes.includes( 'tangent' );
		const attributes = geometry.attributes;
		const targetAttributes = targetGeometry.attributes;

		// initialize the attributes if they don't exist
		if ( ! targetGeometry.index ) {

			targetGeometry.index = geometry.index;

		}

		if ( ! targetAttributes.position ) {

			targetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );

		}

		if ( includeNormal && ! targetAttributes.normal && attributes.normal ) {

			targetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );

		}

		if ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {

			targetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );

		}

		// ensure the attributes are consistent
		validateAttributes( geometry.index, targetGeometry.index );
		validateAttributes( attributes.position, targetAttributes.position );

		if ( includeNormal ) {

			validateAttributes( attributes.normal, targetAttributes.normal );

		}

		if ( includeTangent ) {

			validateAttributes( attributes.tangent, targetAttributes.tangent );

		}

		// generate transformed vertex attribute data
		const position = attributes.position;
		const normal = includeNormal ? attributes.normal : null;
		const tangent = includeTangent ? attributes.tangent : null;
		const morphPosition = geometry.morphAttributes.position;
		const morphNormal = geometry.morphAttributes.normal;
		const morphTangent = geometry.morphAttributes.tangent;
		const morphTargetsRelative = geometry.morphTargetsRelative;
		const morphInfluences = mesh.morphTargetInfluences;
		const normalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();
		normalMatrix.getNormalMatrix( mesh.matrixWorld );

		for ( let i = 0, l = attributes.position.count; i < l; i ++ ) {

			_positionVector.fromBufferAttribute( position, i );
			if ( normal ) {

				_normalVector.fromBufferAttribute( normal, i );

			}

			if ( tangent ) {

				_tangentVector4.fromBufferAttribute( tangent, i );
				_tangentVector.fromBufferAttribute( tangent, i );

			}

			// apply morph target transform
			if ( morphInfluences ) {

				if ( morphPosition ) {

					applyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );

				}

				if ( morphNormal ) {

					applyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );

				}

				if ( morphTangent ) {

					applyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );

				}

			}

			// apply bone transform
			if ( mesh.isSkinnedMesh ) {

				mesh.boneTransform( i, _positionVector );
				if ( normal ) {

					boneNormalTransform( mesh, i, _normalVector );

				}

				if ( tangent ) {

					boneNormalTransform( mesh, i, _tangentVector );

				}

			}

			// update the vectors of the attributes
			if ( applyWorldTransforms ) {

				_positionVector.applyMatrix4( mesh.matrixWorld );

			}

			targetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );

			if ( normal ) {

				if ( applyWorldTransforms ) {

					_normalVector.applyNormalMatrix( normalMatrix );

				}

				targetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );

			}

			if ( tangent ) {

				if ( applyWorldTransforms ) {

					_tangentVector.transformDirection( mesh.matrixWorld );

				}

				targetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );

			}

		}

		// copy other attributes over
		for ( const i in this.attributes ) {

			const key = this.attributes[ i ];
			if ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {

				continue;

			}

			if ( ! targetAttributes[ key ] ) {

				targetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );

			}

			validateAttributes( attributes[ key ], targetAttributes[ key ] );
			copyAttributeContents( attributes[ key ], targetAttributes[ key ] );

		}

		return targetGeometry;

	}

}


/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "intersectTri": () => (/* binding */ intersectTri)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


// Ripped and modified From THREE.js Mesh raycast
// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115
const vA = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const vB = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const vC = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

const uvA = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
const uvB = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
const uvC = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

const intersectionPoint = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
function checkIntersection( ray, pA, pB, pC, point, side ) {

	let intersect;
	if ( side === three__WEBPACK_IMPORTED_MODULE_0__.BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, side !== three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide, point );

	}

	if ( intersect === null ) return null;

	const distance = ray.origin.distanceTo( point );

	return {

		distance: distance,
		point: point.clone(),

	};

}

function checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {

	vA.fromBufferAttribute( position, a );
	vB.fromBufferAttribute( position, b );
	vC.fromBufferAttribute( position, c );

	const intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );

	if ( intersection ) {

		if ( uv ) {

			uvA.fromBufferAttribute( uv, a );
			uvB.fromBufferAttribute( uv, b );
			uvC.fromBufferAttribute( uv, c );

			intersection.uv = three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( ) );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
			materialIndex: 0
		};

		three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getNormal( vA, vB, vC, face.normal );

		intersection.face = face;
		intersection.faceIndex = a;

	}

	return intersection;

}

// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258
function intersectTri( geo, side, ray, tri, intersections ) {

	const triOffset = tri * 3;
	const a = geo.index.getX( triOffset );
	const b = geo.index.getX( triOffset + 1 );
	const c = geo.index.getX( triOffset + 2 );

	const intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );

	if ( intersection ) {

		intersection.faceIndex = tri;
		if ( intersections ) intersections.push( intersection );
		return intersection;

	}

	return null;

}




/***/ }),

/***/ "./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js":
/*!********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTriangleHitPointInfo": () => (/* binding */ getTriangleHitPointInfo),
/* harmony export */   "iterateOverTriangles": () => (/* binding */ iterateOverTriangles),
/* harmony export */   "setTriangle": () => (/* binding */ setTriangle)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");



// sets the vertices of triangle `tri` with the 3 vertices after i
function setTriangle( tri, i, index, pos ) {

	const ta = tri.a;
	const tb = tri.b;
	const tc = tri.c;

	let i0 = i;
	let i1 = i + 1;
	let i2 = i + 2;
	if ( index ) {

		i0 = index.getX( i );
		i1 = index.getX( i + 1 );
		i2 = index.getX( i + 2 );

	}

	ta.x = pos.getX( i0 );
	ta.y = pos.getY( i0 );
	ta.z = pos.getZ( i0 );

	tb.x = pos.getX( i1 );
	tb.y = pos.getY( i1 );
	tb.z = pos.getZ( i1 );

	tc.x = pos.getX( i2 );
	tc.y = pos.getY( i2 );
	tc.z = pos.getZ( i2 );

}

function iterateOverTriangles(
	offset,
	count,
	geometry,
	intersectsTriangleFunc,
	contained,
	depth,
	triangle
) {

	const index = geometry.index;
	const pos = geometry.attributes.position;
	for ( let i = offset, l = count + offset; i < l; i ++ ) {

		setTriangle( triangle, i * 3, index, pos );
		triangle.needsUpdate = true;

		if ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {

			return true;

		}

	}

	return false;

}

const tempV1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tempV2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tempV3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tempUV1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
const tempUV2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
const tempUV3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {

	const indices = geometry.getIndex().array;
	const positions = geometry.getAttribute( 'position' );
	const uvs = geometry.getAttribute( 'uv' );

	const a = indices[ triangleIndex * 3 ];
	const b = indices[ triangleIndex * 3 + 1 ];
	const c = indices[ triangleIndex * 3 + 2 ];

	tempV1.fromBufferAttribute( positions, a );
	tempV2.fromBufferAttribute( positions, b );
	tempV3.fromBufferAttribute( positions, c );

	// find the associated material index
	let materialIndex = 0;
	const groups = geometry.groups;
	const firstVertexIndex = triangleIndex * 3;
	for ( let i = 0, l = groups.length; i < l; i ++ ) {

		const group = groups[ i ];
		const { start, count } = group;
		if ( firstVertexIndex >= start && firstVertexIndex < start + count ) {

			materialIndex = group.materialIndex;
			break;

		}

	}

	// extract uvs
	let uv = null;
	if ( uvs ) {

		tempUV1.fromBufferAttribute( uvs, a );
		tempUV2.fromBufferAttribute( uvs, b );
		tempUV3.fromBufferAttribute( uvs, c );

		if ( target && target.uv ) uv = target.uv;
		else uv = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getUV( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );

	}

	// adjust the provided target or create a new one
	if ( target ) {

		if ( ! target.face ) target.face = { };
		target.face.a = a;
		target.face.b = b;
		target.face.c = c;
		target.face.materialIndex = materialIndex;
		if ( ! target.face.normal ) target.face.normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );

		if ( uv ) target.uv = uv;

		return target;

	} else {

		return {
			face: {
				a: a,
				b: b,
				c: c,
				materialIndex: materialIndex,
				normal: three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getNormal( tempV1, tempV2, tempV3, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() )
			},
			uv: uv
		};

	}

}


/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ACESFilmicToneMapping": () => (/* binding */ ACESFilmicToneMapping),
/* harmony export */   "AddEquation": () => (/* binding */ AddEquation),
/* harmony export */   "AddOperation": () => (/* binding */ AddOperation),
/* harmony export */   "AdditiveAnimationBlendMode": () => (/* binding */ AdditiveAnimationBlendMode),
/* harmony export */   "AdditiveBlending": () => (/* binding */ AdditiveBlending),
/* harmony export */   "AlphaFormat": () => (/* binding */ AlphaFormat),
/* harmony export */   "AlwaysDepth": () => (/* binding */ AlwaysDepth),
/* harmony export */   "AlwaysStencilFunc": () => (/* binding */ AlwaysStencilFunc),
/* harmony export */   "AmbientLight": () => (/* binding */ AmbientLight),
/* harmony export */   "AmbientLightProbe": () => (/* binding */ AmbientLightProbe),
/* harmony export */   "AnimationClip": () => (/* binding */ AnimationClip),
/* harmony export */   "AnimationLoader": () => (/* binding */ AnimationLoader),
/* harmony export */   "AnimationMixer": () => (/* binding */ AnimationMixer),
/* harmony export */   "AnimationObjectGroup": () => (/* binding */ AnimationObjectGroup),
/* harmony export */   "AnimationUtils": () => (/* binding */ AnimationUtils),
/* harmony export */   "ArcCurve": () => (/* binding */ ArcCurve),
/* harmony export */   "ArrayCamera": () => (/* binding */ ArrayCamera),
/* harmony export */   "ArrowHelper": () => (/* binding */ ArrowHelper),
/* harmony export */   "Audio": () => (/* binding */ Audio),
/* harmony export */   "AudioAnalyser": () => (/* binding */ AudioAnalyser),
/* harmony export */   "AudioContext": () => (/* binding */ AudioContext),
/* harmony export */   "AudioListener": () => (/* binding */ AudioListener),
/* harmony export */   "AudioLoader": () => (/* binding */ AudioLoader),
/* harmony export */   "AxesHelper": () => (/* binding */ AxesHelper),
/* harmony export */   "BackSide": () => (/* binding */ BackSide),
/* harmony export */   "BasicDepthPacking": () => (/* binding */ BasicDepthPacking),
/* harmony export */   "BasicShadowMap": () => (/* binding */ BasicShadowMap),
/* harmony export */   "Bone": () => (/* binding */ Bone),
/* harmony export */   "BooleanKeyframeTrack": () => (/* binding */ BooleanKeyframeTrack),
/* harmony export */   "Box2": () => (/* binding */ Box2),
/* harmony export */   "Box3": () => (/* binding */ Box3),
/* harmony export */   "Box3Helper": () => (/* binding */ Box3Helper),
/* harmony export */   "BoxBufferGeometry": () => (/* binding */ BoxBufferGeometry),
/* harmony export */   "BoxGeometry": () => (/* binding */ BoxGeometry),
/* harmony export */   "BoxHelper": () => (/* binding */ BoxHelper),
/* harmony export */   "BufferAttribute": () => (/* binding */ BufferAttribute),
/* harmony export */   "BufferGeometry": () => (/* binding */ BufferGeometry),
/* harmony export */   "BufferGeometryLoader": () => (/* binding */ BufferGeometryLoader),
/* harmony export */   "ByteType": () => (/* binding */ ByteType),
/* harmony export */   "Cache": () => (/* binding */ Cache),
/* harmony export */   "Camera": () => (/* binding */ Camera),
/* harmony export */   "CameraHelper": () => (/* binding */ CameraHelper),
/* harmony export */   "CanvasTexture": () => (/* binding */ CanvasTexture),
/* harmony export */   "CapsuleBufferGeometry": () => (/* binding */ CapsuleBufferGeometry),
/* harmony export */   "CapsuleGeometry": () => (/* binding */ CapsuleGeometry),
/* harmony export */   "CatmullRomCurve3": () => (/* binding */ CatmullRomCurve3),
/* harmony export */   "CineonToneMapping": () => (/* binding */ CineonToneMapping),
/* harmony export */   "CircleBufferGeometry": () => (/* binding */ CircleBufferGeometry),
/* harmony export */   "CircleGeometry": () => (/* binding */ CircleGeometry),
/* harmony export */   "ClampToEdgeWrapping": () => (/* binding */ ClampToEdgeWrapping),
/* harmony export */   "Clock": () => (/* binding */ Clock),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorKeyframeTrack": () => (/* binding */ ColorKeyframeTrack),
/* harmony export */   "ColorManagement": () => (/* binding */ ColorManagement),
/* harmony export */   "CompressedArrayTexture": () => (/* binding */ CompressedArrayTexture),
/* harmony export */   "CompressedTexture": () => (/* binding */ CompressedTexture),
/* harmony export */   "CompressedTextureLoader": () => (/* binding */ CompressedTextureLoader),
/* harmony export */   "ConeBufferGeometry": () => (/* binding */ ConeBufferGeometry),
/* harmony export */   "ConeGeometry": () => (/* binding */ ConeGeometry),
/* harmony export */   "CubeCamera": () => (/* binding */ CubeCamera),
/* harmony export */   "CubeReflectionMapping": () => (/* binding */ CubeReflectionMapping),
/* harmony export */   "CubeRefractionMapping": () => (/* binding */ CubeRefractionMapping),
/* harmony export */   "CubeTexture": () => (/* binding */ CubeTexture),
/* harmony export */   "CubeTextureLoader": () => (/* binding */ CubeTextureLoader),
/* harmony export */   "CubeUVReflectionMapping": () => (/* binding */ CubeUVReflectionMapping),
/* harmony export */   "CubicBezierCurve": () => (/* binding */ CubicBezierCurve),
/* harmony export */   "CubicBezierCurve3": () => (/* binding */ CubicBezierCurve3),
/* harmony export */   "CubicInterpolant": () => (/* binding */ CubicInterpolant),
/* harmony export */   "CullFaceBack": () => (/* binding */ CullFaceBack),
/* harmony export */   "CullFaceFront": () => (/* binding */ CullFaceFront),
/* harmony export */   "CullFaceFrontBack": () => (/* binding */ CullFaceFrontBack),
/* harmony export */   "CullFaceNone": () => (/* binding */ CullFaceNone),
/* harmony export */   "Curve": () => (/* binding */ Curve),
/* harmony export */   "CurvePath": () => (/* binding */ CurvePath),
/* harmony export */   "CustomBlending": () => (/* binding */ CustomBlending),
/* harmony export */   "CustomToneMapping": () => (/* binding */ CustomToneMapping),
/* harmony export */   "CylinderBufferGeometry": () => (/* binding */ CylinderBufferGeometry),
/* harmony export */   "CylinderGeometry": () => (/* binding */ CylinderGeometry),
/* harmony export */   "Cylindrical": () => (/* binding */ Cylindrical),
/* harmony export */   "Data3DTexture": () => (/* binding */ Data3DTexture),
/* harmony export */   "DataArrayTexture": () => (/* binding */ DataArrayTexture),
/* harmony export */   "DataTexture": () => (/* binding */ DataTexture),
/* harmony export */   "DataTextureLoader": () => (/* binding */ DataTextureLoader),
/* harmony export */   "DataUtils": () => (/* binding */ DataUtils),
/* harmony export */   "DecrementStencilOp": () => (/* binding */ DecrementStencilOp),
/* harmony export */   "DecrementWrapStencilOp": () => (/* binding */ DecrementWrapStencilOp),
/* harmony export */   "DefaultLoadingManager": () => (/* binding */ DefaultLoadingManager),
/* harmony export */   "DepthFormat": () => (/* binding */ DepthFormat),
/* harmony export */   "DepthStencilFormat": () => (/* binding */ DepthStencilFormat),
/* harmony export */   "DepthTexture": () => (/* binding */ DepthTexture),
/* harmony export */   "DirectionalLight": () => (/* binding */ DirectionalLight),
/* harmony export */   "DirectionalLightHelper": () => (/* binding */ DirectionalLightHelper),
/* harmony export */   "DiscreteInterpolant": () => (/* binding */ DiscreteInterpolant),
/* harmony export */   "DisplayP3ColorSpace": () => (/* binding */ DisplayP3ColorSpace),
/* harmony export */   "DodecahedronBufferGeometry": () => (/* binding */ DodecahedronBufferGeometry),
/* harmony export */   "DodecahedronGeometry": () => (/* binding */ DodecahedronGeometry),
/* harmony export */   "DoubleSide": () => (/* binding */ DoubleSide),
/* harmony export */   "DstAlphaFactor": () => (/* binding */ DstAlphaFactor),
/* harmony export */   "DstColorFactor": () => (/* binding */ DstColorFactor),
/* harmony export */   "DynamicCopyUsage": () => (/* binding */ DynamicCopyUsage),
/* harmony export */   "DynamicDrawUsage": () => (/* binding */ DynamicDrawUsage),
/* harmony export */   "DynamicReadUsage": () => (/* binding */ DynamicReadUsage),
/* harmony export */   "EdgesGeometry": () => (/* binding */ EdgesGeometry),
/* harmony export */   "EllipseCurve": () => (/* binding */ EllipseCurve),
/* harmony export */   "EqualDepth": () => (/* binding */ EqualDepth),
/* harmony export */   "EqualStencilFunc": () => (/* binding */ EqualStencilFunc),
/* harmony export */   "EquirectangularReflectionMapping": () => (/* binding */ EquirectangularReflectionMapping),
/* harmony export */   "EquirectangularRefractionMapping": () => (/* binding */ EquirectangularRefractionMapping),
/* harmony export */   "Euler": () => (/* binding */ Euler),
/* harmony export */   "EventDispatcher": () => (/* binding */ EventDispatcher),
/* harmony export */   "ExtrudeBufferGeometry": () => (/* binding */ ExtrudeBufferGeometry),
/* harmony export */   "ExtrudeGeometry": () => (/* binding */ ExtrudeGeometry),
/* harmony export */   "FileLoader": () => (/* binding */ FileLoader),
/* harmony export */   "Float16BufferAttribute": () => (/* binding */ Float16BufferAttribute),
/* harmony export */   "Float32BufferAttribute": () => (/* binding */ Float32BufferAttribute),
/* harmony export */   "Float64BufferAttribute": () => (/* binding */ Float64BufferAttribute),
/* harmony export */   "FloatType": () => (/* binding */ FloatType),
/* harmony export */   "Fog": () => (/* binding */ Fog),
/* harmony export */   "FogExp2": () => (/* binding */ FogExp2),
/* harmony export */   "FramebufferTexture": () => (/* binding */ FramebufferTexture),
/* harmony export */   "FrontSide": () => (/* binding */ FrontSide),
/* harmony export */   "Frustum": () => (/* binding */ Frustum),
/* harmony export */   "GLBufferAttribute": () => (/* binding */ GLBufferAttribute),
/* harmony export */   "GLSL1": () => (/* binding */ GLSL1),
/* harmony export */   "GLSL3": () => (/* binding */ GLSL3),
/* harmony export */   "GreaterDepth": () => (/* binding */ GreaterDepth),
/* harmony export */   "GreaterEqualDepth": () => (/* binding */ GreaterEqualDepth),
/* harmony export */   "GreaterEqualStencilFunc": () => (/* binding */ GreaterEqualStencilFunc),
/* harmony export */   "GreaterStencilFunc": () => (/* binding */ GreaterStencilFunc),
/* harmony export */   "GridHelper": () => (/* binding */ GridHelper),
/* harmony export */   "Group": () => (/* binding */ Group),
/* harmony export */   "HalfFloatType": () => (/* binding */ HalfFloatType),
/* harmony export */   "HemisphereLight": () => (/* binding */ HemisphereLight),
/* harmony export */   "HemisphereLightHelper": () => (/* binding */ HemisphereLightHelper),
/* harmony export */   "HemisphereLightProbe": () => (/* binding */ HemisphereLightProbe),
/* harmony export */   "IcosahedronBufferGeometry": () => (/* binding */ IcosahedronBufferGeometry),
/* harmony export */   "IcosahedronGeometry": () => (/* binding */ IcosahedronGeometry),
/* harmony export */   "ImageBitmapLoader": () => (/* binding */ ImageBitmapLoader),
/* harmony export */   "ImageLoader": () => (/* binding */ ImageLoader),
/* harmony export */   "ImageUtils": () => (/* binding */ ImageUtils),
/* harmony export */   "IncrementStencilOp": () => (/* binding */ IncrementStencilOp),
/* harmony export */   "IncrementWrapStencilOp": () => (/* binding */ IncrementWrapStencilOp),
/* harmony export */   "InstancedBufferAttribute": () => (/* binding */ InstancedBufferAttribute),
/* harmony export */   "InstancedBufferGeometry": () => (/* binding */ InstancedBufferGeometry),
/* harmony export */   "InstancedInterleavedBuffer": () => (/* binding */ InstancedInterleavedBuffer),
/* harmony export */   "InstancedMesh": () => (/* binding */ InstancedMesh),
/* harmony export */   "Int16BufferAttribute": () => (/* binding */ Int16BufferAttribute),
/* harmony export */   "Int32BufferAttribute": () => (/* binding */ Int32BufferAttribute),
/* harmony export */   "Int8BufferAttribute": () => (/* binding */ Int8BufferAttribute),
/* harmony export */   "IntType": () => (/* binding */ IntType),
/* harmony export */   "InterleavedBuffer": () => (/* binding */ InterleavedBuffer),
/* harmony export */   "InterleavedBufferAttribute": () => (/* binding */ InterleavedBufferAttribute),
/* harmony export */   "Interpolant": () => (/* binding */ Interpolant),
/* harmony export */   "InterpolateDiscrete": () => (/* binding */ InterpolateDiscrete),
/* harmony export */   "InterpolateLinear": () => (/* binding */ InterpolateLinear),
/* harmony export */   "InterpolateSmooth": () => (/* binding */ InterpolateSmooth),
/* harmony export */   "InvertStencilOp": () => (/* binding */ InvertStencilOp),
/* harmony export */   "KeepStencilOp": () => (/* binding */ KeepStencilOp),
/* harmony export */   "KeyframeTrack": () => (/* binding */ KeyframeTrack),
/* harmony export */   "LOD": () => (/* binding */ LOD),
/* harmony export */   "LatheBufferGeometry": () => (/* binding */ LatheBufferGeometry),
/* harmony export */   "LatheGeometry": () => (/* binding */ LatheGeometry),
/* harmony export */   "Layers": () => (/* binding */ Layers),
/* harmony export */   "LessDepth": () => (/* binding */ LessDepth),
/* harmony export */   "LessEqualDepth": () => (/* binding */ LessEqualDepth),
/* harmony export */   "LessEqualStencilFunc": () => (/* binding */ LessEqualStencilFunc),
/* harmony export */   "LessStencilFunc": () => (/* binding */ LessStencilFunc),
/* harmony export */   "Light": () => (/* binding */ Light),
/* harmony export */   "LightProbe": () => (/* binding */ LightProbe),
/* harmony export */   "Line": () => (/* binding */ Line),
/* harmony export */   "Line3": () => (/* binding */ Line3),
/* harmony export */   "LineBasicMaterial": () => (/* binding */ LineBasicMaterial),
/* harmony export */   "LineCurve": () => (/* binding */ LineCurve),
/* harmony export */   "LineCurve3": () => (/* binding */ LineCurve3),
/* harmony export */   "LineDashedMaterial": () => (/* binding */ LineDashedMaterial),
/* harmony export */   "LineLoop": () => (/* binding */ LineLoop),
/* harmony export */   "LineSegments": () => (/* binding */ LineSegments),
/* harmony export */   "LinearEncoding": () => (/* binding */ LinearEncoding),
/* harmony export */   "LinearFilter": () => (/* binding */ LinearFilter),
/* harmony export */   "LinearInterpolant": () => (/* binding */ LinearInterpolant),
/* harmony export */   "LinearMipMapLinearFilter": () => (/* binding */ LinearMipMapLinearFilter),
/* harmony export */   "LinearMipMapNearestFilter": () => (/* binding */ LinearMipMapNearestFilter),
/* harmony export */   "LinearMipmapLinearFilter": () => (/* binding */ LinearMipmapLinearFilter),
/* harmony export */   "LinearMipmapNearestFilter": () => (/* binding */ LinearMipmapNearestFilter),
/* harmony export */   "LinearSRGBColorSpace": () => (/* binding */ LinearSRGBColorSpace),
/* harmony export */   "LinearToneMapping": () => (/* binding */ LinearToneMapping),
/* harmony export */   "Loader": () => (/* binding */ Loader),
/* harmony export */   "LoaderUtils": () => (/* binding */ LoaderUtils),
/* harmony export */   "LoadingManager": () => (/* binding */ LoadingManager),
/* harmony export */   "LoopOnce": () => (/* binding */ LoopOnce),
/* harmony export */   "LoopPingPong": () => (/* binding */ LoopPingPong),
/* harmony export */   "LoopRepeat": () => (/* binding */ LoopRepeat),
/* harmony export */   "LuminanceAlphaFormat": () => (/* binding */ LuminanceAlphaFormat),
/* harmony export */   "LuminanceFormat": () => (/* binding */ LuminanceFormat),
/* harmony export */   "MOUSE": () => (/* binding */ MOUSE),
/* harmony export */   "Material": () => (/* binding */ Material),
/* harmony export */   "MaterialLoader": () => (/* binding */ MaterialLoader),
/* harmony export */   "MathUtils": () => (/* binding */ MathUtils),
/* harmony export */   "Matrix3": () => (/* binding */ Matrix3),
/* harmony export */   "Matrix4": () => (/* binding */ Matrix4),
/* harmony export */   "MaxEquation": () => (/* binding */ MaxEquation),
/* harmony export */   "Mesh": () => (/* binding */ Mesh),
/* harmony export */   "MeshBasicMaterial": () => (/* binding */ MeshBasicMaterial),
/* harmony export */   "MeshDepthMaterial": () => (/* binding */ MeshDepthMaterial),
/* harmony export */   "MeshDistanceMaterial": () => (/* binding */ MeshDistanceMaterial),
/* harmony export */   "MeshLambertMaterial": () => (/* binding */ MeshLambertMaterial),
/* harmony export */   "MeshMatcapMaterial": () => (/* binding */ MeshMatcapMaterial),
/* harmony export */   "MeshNormalMaterial": () => (/* binding */ MeshNormalMaterial),
/* harmony export */   "MeshPhongMaterial": () => (/* binding */ MeshPhongMaterial),
/* harmony export */   "MeshPhysicalMaterial": () => (/* binding */ MeshPhysicalMaterial),
/* harmony export */   "MeshStandardMaterial": () => (/* binding */ MeshStandardMaterial),
/* harmony export */   "MeshToonMaterial": () => (/* binding */ MeshToonMaterial),
/* harmony export */   "MinEquation": () => (/* binding */ MinEquation),
/* harmony export */   "MirroredRepeatWrapping": () => (/* binding */ MirroredRepeatWrapping),
/* harmony export */   "MixOperation": () => (/* binding */ MixOperation),
/* harmony export */   "MultiplyBlending": () => (/* binding */ MultiplyBlending),
/* harmony export */   "MultiplyOperation": () => (/* binding */ MultiplyOperation),
/* harmony export */   "NearestFilter": () => (/* binding */ NearestFilter),
/* harmony export */   "NearestMipMapLinearFilter": () => (/* binding */ NearestMipMapLinearFilter),
/* harmony export */   "NearestMipMapNearestFilter": () => (/* binding */ NearestMipMapNearestFilter),
/* harmony export */   "NearestMipmapLinearFilter": () => (/* binding */ NearestMipmapLinearFilter),
/* harmony export */   "NearestMipmapNearestFilter": () => (/* binding */ NearestMipmapNearestFilter),
/* harmony export */   "NeverDepth": () => (/* binding */ NeverDepth),
/* harmony export */   "NeverStencilFunc": () => (/* binding */ NeverStencilFunc),
/* harmony export */   "NoBlending": () => (/* binding */ NoBlending),
/* harmony export */   "NoColorSpace": () => (/* binding */ NoColorSpace),
/* harmony export */   "NoToneMapping": () => (/* binding */ NoToneMapping),
/* harmony export */   "NormalAnimationBlendMode": () => (/* binding */ NormalAnimationBlendMode),
/* harmony export */   "NormalBlending": () => (/* binding */ NormalBlending),
/* harmony export */   "NotEqualDepth": () => (/* binding */ NotEqualDepth),
/* harmony export */   "NotEqualStencilFunc": () => (/* binding */ NotEqualStencilFunc),
/* harmony export */   "NumberKeyframeTrack": () => (/* binding */ NumberKeyframeTrack),
/* harmony export */   "Object3D": () => (/* binding */ Object3D),
/* harmony export */   "ObjectLoader": () => (/* binding */ ObjectLoader),
/* harmony export */   "ObjectSpaceNormalMap": () => (/* binding */ ObjectSpaceNormalMap),
/* harmony export */   "OctahedronBufferGeometry": () => (/* binding */ OctahedronBufferGeometry),
/* harmony export */   "OctahedronGeometry": () => (/* binding */ OctahedronGeometry),
/* harmony export */   "OneFactor": () => (/* binding */ OneFactor),
/* harmony export */   "OneMinusDstAlphaFactor": () => (/* binding */ OneMinusDstAlphaFactor),
/* harmony export */   "OneMinusDstColorFactor": () => (/* binding */ OneMinusDstColorFactor),
/* harmony export */   "OneMinusSrcAlphaFactor": () => (/* binding */ OneMinusSrcAlphaFactor),
/* harmony export */   "OneMinusSrcColorFactor": () => (/* binding */ OneMinusSrcColorFactor),
/* harmony export */   "OrthographicCamera": () => (/* binding */ OrthographicCamera),
/* harmony export */   "PCFShadowMap": () => (/* binding */ PCFShadowMap),
/* harmony export */   "PCFSoftShadowMap": () => (/* binding */ PCFSoftShadowMap),
/* harmony export */   "PMREMGenerator": () => (/* binding */ PMREMGenerator),
/* harmony export */   "Path": () => (/* binding */ Path),
/* harmony export */   "PerspectiveCamera": () => (/* binding */ PerspectiveCamera),
/* harmony export */   "Plane": () => (/* binding */ Plane),
/* harmony export */   "PlaneBufferGeometry": () => (/* binding */ PlaneBufferGeometry),
/* harmony export */   "PlaneGeometry": () => (/* binding */ PlaneGeometry),
/* harmony export */   "PlaneHelper": () => (/* binding */ PlaneHelper),
/* harmony export */   "PointLight": () => (/* binding */ PointLight),
/* harmony export */   "PointLightHelper": () => (/* binding */ PointLightHelper),
/* harmony export */   "Points": () => (/* binding */ Points),
/* harmony export */   "PointsMaterial": () => (/* binding */ PointsMaterial),
/* harmony export */   "PolarGridHelper": () => (/* binding */ PolarGridHelper),
/* harmony export */   "PolyhedronBufferGeometry": () => (/* binding */ PolyhedronBufferGeometry),
/* harmony export */   "PolyhedronGeometry": () => (/* binding */ PolyhedronGeometry),
/* harmony export */   "PositionalAudio": () => (/* binding */ PositionalAudio),
/* harmony export */   "PropertyBinding": () => (/* binding */ PropertyBinding),
/* harmony export */   "PropertyMixer": () => (/* binding */ PropertyMixer),
/* harmony export */   "QuadraticBezierCurve": () => (/* binding */ QuadraticBezierCurve),
/* harmony export */   "QuadraticBezierCurve3": () => (/* binding */ QuadraticBezierCurve3),
/* harmony export */   "Quaternion": () => (/* binding */ Quaternion),
/* harmony export */   "QuaternionKeyframeTrack": () => (/* binding */ QuaternionKeyframeTrack),
/* harmony export */   "QuaternionLinearInterpolant": () => (/* binding */ QuaternionLinearInterpolant),
/* harmony export */   "RED_GREEN_RGTC2_Format": () => (/* binding */ RED_GREEN_RGTC2_Format),
/* harmony export */   "RED_RGTC1_Format": () => (/* binding */ RED_RGTC1_Format),
/* harmony export */   "REVISION": () => (/* binding */ REVISION),
/* harmony export */   "RGBADepthPacking": () => (/* binding */ RGBADepthPacking),
/* harmony export */   "RGBAFormat": () => (/* binding */ RGBAFormat),
/* harmony export */   "RGBAIntegerFormat": () => (/* binding */ RGBAIntegerFormat),
/* harmony export */   "RGBA_ASTC_10x10_Format": () => (/* binding */ RGBA_ASTC_10x10_Format),
/* harmony export */   "RGBA_ASTC_10x5_Format": () => (/* binding */ RGBA_ASTC_10x5_Format),
/* harmony export */   "RGBA_ASTC_10x6_Format": () => (/* binding */ RGBA_ASTC_10x6_Format),
/* harmony export */   "RGBA_ASTC_10x8_Format": () => (/* binding */ RGBA_ASTC_10x8_Format),
/* harmony export */   "RGBA_ASTC_12x10_Format": () => (/* binding */ RGBA_ASTC_12x10_Format),
/* harmony export */   "RGBA_ASTC_12x12_Format": () => (/* binding */ RGBA_ASTC_12x12_Format),
/* harmony export */   "RGBA_ASTC_4x4_Format": () => (/* binding */ RGBA_ASTC_4x4_Format),
/* harmony export */   "RGBA_ASTC_5x4_Format": () => (/* binding */ RGBA_ASTC_5x4_Format),
/* harmony export */   "RGBA_ASTC_5x5_Format": () => (/* binding */ RGBA_ASTC_5x5_Format),
/* harmony export */   "RGBA_ASTC_6x5_Format": () => (/* binding */ RGBA_ASTC_6x5_Format),
/* harmony export */   "RGBA_ASTC_6x6_Format": () => (/* binding */ RGBA_ASTC_6x6_Format),
/* harmony export */   "RGBA_ASTC_8x5_Format": () => (/* binding */ RGBA_ASTC_8x5_Format),
/* harmony export */   "RGBA_ASTC_8x6_Format": () => (/* binding */ RGBA_ASTC_8x6_Format),
/* harmony export */   "RGBA_ASTC_8x8_Format": () => (/* binding */ RGBA_ASTC_8x8_Format),
/* harmony export */   "RGBA_BPTC_Format": () => (/* binding */ RGBA_BPTC_Format),
/* harmony export */   "RGBA_ETC2_EAC_Format": () => (/* binding */ RGBA_ETC2_EAC_Format),
/* harmony export */   "RGBA_PVRTC_2BPPV1_Format": () => (/* binding */ RGBA_PVRTC_2BPPV1_Format),
/* harmony export */   "RGBA_PVRTC_4BPPV1_Format": () => (/* binding */ RGBA_PVRTC_4BPPV1_Format),
/* harmony export */   "RGBA_S3TC_DXT1_Format": () => (/* binding */ RGBA_S3TC_DXT1_Format),
/* harmony export */   "RGBA_S3TC_DXT3_Format": () => (/* binding */ RGBA_S3TC_DXT3_Format),
/* harmony export */   "RGBA_S3TC_DXT5_Format": () => (/* binding */ RGBA_S3TC_DXT5_Format),
/* harmony export */   "RGB_ETC1_Format": () => (/* binding */ RGB_ETC1_Format),
/* harmony export */   "RGB_ETC2_Format": () => (/* binding */ RGB_ETC2_Format),
/* harmony export */   "RGB_PVRTC_2BPPV1_Format": () => (/* binding */ RGB_PVRTC_2BPPV1_Format),
/* harmony export */   "RGB_PVRTC_4BPPV1_Format": () => (/* binding */ RGB_PVRTC_4BPPV1_Format),
/* harmony export */   "RGB_S3TC_DXT1_Format": () => (/* binding */ RGB_S3TC_DXT1_Format),
/* harmony export */   "RGFormat": () => (/* binding */ RGFormat),
/* harmony export */   "RGIntegerFormat": () => (/* binding */ RGIntegerFormat),
/* harmony export */   "RawShaderMaterial": () => (/* binding */ RawShaderMaterial),
/* harmony export */   "Ray": () => (/* binding */ Ray),
/* harmony export */   "Raycaster": () => (/* binding */ Raycaster),
/* harmony export */   "RectAreaLight": () => (/* binding */ RectAreaLight),
/* harmony export */   "RedFormat": () => (/* binding */ RedFormat),
/* harmony export */   "RedIntegerFormat": () => (/* binding */ RedIntegerFormat),
/* harmony export */   "ReinhardToneMapping": () => (/* binding */ ReinhardToneMapping),
/* harmony export */   "RepeatWrapping": () => (/* binding */ RepeatWrapping),
/* harmony export */   "ReplaceStencilOp": () => (/* binding */ ReplaceStencilOp),
/* harmony export */   "ReverseSubtractEquation": () => (/* binding */ ReverseSubtractEquation),
/* harmony export */   "RingBufferGeometry": () => (/* binding */ RingBufferGeometry),
/* harmony export */   "RingGeometry": () => (/* binding */ RingGeometry),
/* harmony export */   "SIGNED_RED_GREEN_RGTC2_Format": () => (/* binding */ SIGNED_RED_GREEN_RGTC2_Format),
/* harmony export */   "SIGNED_RED_RGTC1_Format": () => (/* binding */ SIGNED_RED_RGTC1_Format),
/* harmony export */   "SRGBColorSpace": () => (/* binding */ SRGBColorSpace),
/* harmony export */   "Scene": () => (/* binding */ Scene),
/* harmony export */   "ShaderChunk": () => (/* binding */ ShaderChunk),
/* harmony export */   "ShaderLib": () => (/* binding */ ShaderLib),
/* harmony export */   "ShaderMaterial": () => (/* binding */ ShaderMaterial),
/* harmony export */   "ShadowMaterial": () => (/* binding */ ShadowMaterial),
/* harmony export */   "Shape": () => (/* binding */ Shape),
/* harmony export */   "ShapeBufferGeometry": () => (/* binding */ ShapeBufferGeometry),
/* harmony export */   "ShapeGeometry": () => (/* binding */ ShapeGeometry),
/* harmony export */   "ShapePath": () => (/* binding */ ShapePath),
/* harmony export */   "ShapeUtils": () => (/* binding */ ShapeUtils),
/* harmony export */   "ShortType": () => (/* binding */ ShortType),
/* harmony export */   "Skeleton": () => (/* binding */ Skeleton),
/* harmony export */   "SkeletonHelper": () => (/* binding */ SkeletonHelper),
/* harmony export */   "SkinnedMesh": () => (/* binding */ SkinnedMesh),
/* harmony export */   "Source": () => (/* binding */ Source),
/* harmony export */   "Sphere": () => (/* binding */ Sphere),
/* harmony export */   "SphereBufferGeometry": () => (/* binding */ SphereBufferGeometry),
/* harmony export */   "SphereGeometry": () => (/* binding */ SphereGeometry),
/* harmony export */   "Spherical": () => (/* binding */ Spherical),
/* harmony export */   "SphericalHarmonics3": () => (/* binding */ SphericalHarmonics3),
/* harmony export */   "SplineCurve": () => (/* binding */ SplineCurve),
/* harmony export */   "SpotLight": () => (/* binding */ SpotLight),
/* harmony export */   "SpotLightHelper": () => (/* binding */ SpotLightHelper),
/* harmony export */   "Sprite": () => (/* binding */ Sprite),
/* harmony export */   "SpriteMaterial": () => (/* binding */ SpriteMaterial),
/* harmony export */   "SrcAlphaFactor": () => (/* binding */ SrcAlphaFactor),
/* harmony export */   "SrcAlphaSaturateFactor": () => (/* binding */ SrcAlphaSaturateFactor),
/* harmony export */   "SrcColorFactor": () => (/* binding */ SrcColorFactor),
/* harmony export */   "StaticCopyUsage": () => (/* binding */ StaticCopyUsage),
/* harmony export */   "StaticDrawUsage": () => (/* binding */ StaticDrawUsage),
/* harmony export */   "StaticReadUsage": () => (/* binding */ StaticReadUsage),
/* harmony export */   "StereoCamera": () => (/* binding */ StereoCamera),
/* harmony export */   "StreamCopyUsage": () => (/* binding */ StreamCopyUsage),
/* harmony export */   "StreamDrawUsage": () => (/* binding */ StreamDrawUsage),
/* harmony export */   "StreamReadUsage": () => (/* binding */ StreamReadUsage),
/* harmony export */   "StringKeyframeTrack": () => (/* binding */ StringKeyframeTrack),
/* harmony export */   "SubtractEquation": () => (/* binding */ SubtractEquation),
/* harmony export */   "SubtractiveBlending": () => (/* binding */ SubtractiveBlending),
/* harmony export */   "TOUCH": () => (/* binding */ TOUCH),
/* harmony export */   "TangentSpaceNormalMap": () => (/* binding */ TangentSpaceNormalMap),
/* harmony export */   "TetrahedronBufferGeometry": () => (/* binding */ TetrahedronBufferGeometry),
/* harmony export */   "TetrahedronGeometry": () => (/* binding */ TetrahedronGeometry),
/* harmony export */   "Texture": () => (/* binding */ Texture),
/* harmony export */   "TextureLoader": () => (/* binding */ TextureLoader),
/* harmony export */   "TorusBufferGeometry": () => (/* binding */ TorusBufferGeometry),
/* harmony export */   "TorusGeometry": () => (/* binding */ TorusGeometry),
/* harmony export */   "TorusKnotBufferGeometry": () => (/* binding */ TorusKnotBufferGeometry),
/* harmony export */   "TorusKnotGeometry": () => (/* binding */ TorusKnotGeometry),
/* harmony export */   "Triangle": () => (/* binding */ Triangle),
/* harmony export */   "TriangleFanDrawMode": () => (/* binding */ TriangleFanDrawMode),
/* harmony export */   "TriangleStripDrawMode": () => (/* binding */ TriangleStripDrawMode),
/* harmony export */   "TrianglesDrawMode": () => (/* binding */ TrianglesDrawMode),
/* harmony export */   "TubeBufferGeometry": () => (/* binding */ TubeBufferGeometry),
/* harmony export */   "TubeGeometry": () => (/* binding */ TubeGeometry),
/* harmony export */   "TwoPassDoubleSide": () => (/* binding */ TwoPassDoubleSide),
/* harmony export */   "UVMapping": () => (/* binding */ UVMapping),
/* harmony export */   "Uint16BufferAttribute": () => (/* binding */ Uint16BufferAttribute),
/* harmony export */   "Uint32BufferAttribute": () => (/* binding */ Uint32BufferAttribute),
/* harmony export */   "Uint8BufferAttribute": () => (/* binding */ Uint8BufferAttribute),
/* harmony export */   "Uint8ClampedBufferAttribute": () => (/* binding */ Uint8ClampedBufferAttribute),
/* harmony export */   "Uniform": () => (/* binding */ Uniform),
/* harmony export */   "UniformsGroup": () => (/* binding */ UniformsGroup),
/* harmony export */   "UniformsLib": () => (/* binding */ UniformsLib),
/* harmony export */   "UniformsUtils": () => (/* binding */ UniformsUtils),
/* harmony export */   "UnsignedByteType": () => (/* binding */ UnsignedByteType),
/* harmony export */   "UnsignedInt248Type": () => (/* binding */ UnsignedInt248Type),
/* harmony export */   "UnsignedIntType": () => (/* binding */ UnsignedIntType),
/* harmony export */   "UnsignedShort4444Type": () => (/* binding */ UnsignedShort4444Type),
/* harmony export */   "UnsignedShort5551Type": () => (/* binding */ UnsignedShort5551Type),
/* harmony export */   "UnsignedShortType": () => (/* binding */ UnsignedShortType),
/* harmony export */   "VSMShadowMap": () => (/* binding */ VSMShadowMap),
/* harmony export */   "Vector2": () => (/* binding */ Vector2),
/* harmony export */   "Vector3": () => (/* binding */ Vector3),
/* harmony export */   "Vector4": () => (/* binding */ Vector4),
/* harmony export */   "VectorKeyframeTrack": () => (/* binding */ VectorKeyframeTrack),
/* harmony export */   "VideoTexture": () => (/* binding */ VideoTexture),
/* harmony export */   "WebGL1Renderer": () => (/* binding */ WebGL1Renderer),
/* harmony export */   "WebGL3DRenderTarget": () => (/* binding */ WebGL3DRenderTarget),
/* harmony export */   "WebGLArrayRenderTarget": () => (/* binding */ WebGLArrayRenderTarget),
/* harmony export */   "WebGLCubeRenderTarget": () => (/* binding */ WebGLCubeRenderTarget),
/* harmony export */   "WebGLMultipleRenderTargets": () => (/* binding */ WebGLMultipleRenderTargets),
/* harmony export */   "WebGLRenderTarget": () => (/* binding */ WebGLRenderTarget),
/* harmony export */   "WebGLRenderer": () => (/* binding */ WebGLRenderer),
/* harmony export */   "WebGLUtils": () => (/* binding */ WebGLUtils),
/* harmony export */   "WireframeGeometry": () => (/* binding */ WireframeGeometry),
/* harmony export */   "WrapAroundEnding": () => (/* binding */ WrapAroundEnding),
/* harmony export */   "ZeroCurvatureEnding": () => (/* binding */ ZeroCurvatureEnding),
/* harmony export */   "ZeroFactor": () => (/* binding */ ZeroFactor),
/* harmony export */   "ZeroSlopeEnding": () => (/* binding */ ZeroSlopeEnding),
/* harmony export */   "ZeroStencilOp": () => (/* binding */ ZeroStencilOp),
/* harmony export */   "_SRGBAFormat": () => (/* binding */ _SRGBAFormat),
/* harmony export */   "sRGBEncoding": () => (/* binding */ sRGBEncoding)
/* harmony export */ });
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '150';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const TwoPassDoubleSide = 2; // r149
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
const NoColorSpace = '';
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';
const DisplayP3ColorSpace = 'display-p3';

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = '100';
const GLSL3 = '300 es';

const _SRGBAFormat = 1035; // fallback for WebGL 1

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {

	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	}

	hasEventListener( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	}

	removeEventListener( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	dispatchEvent( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;

	t = Math.imul( t ^ t >>> 15, t | 1 );

	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

function denormalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int16Array:

			return Math.max( value / 32767.0, - 1.0 );

		case Int8Array:

			return Math.max( value / 127.0, - 1.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

function normalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

const MathUtils = {
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	normalize: normalize,
	denormalize: denormalize
};

class Vector2 {

	constructor( x = 0, y = 0 ) {

		Vector2.prototype.isVector2 = true;

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

class Matrix3 {

	constructor() {

		Matrix3.prototype.isMatrix3 = true;

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	//

	scale( sx, sy ) {

		this.premultiply( _m3.makeScale( sx, sy ) );

		return this;

	}

	rotate( theta ) {

		this.premultiply( _m3.makeRotation( - theta ) );

		return this;

	}

	translate( tx, ty ) {

		this.premultiply( _m3.makeTranslation( tx, ty ) );

		return this;

	}

	// for 2D Transforms

	makeTranslation( x, y ) {

		this.set(

			1, 0, x,
			0, 1, y,
			0, 0, 1

		);

		return this;

	}

	makeRotation( theta ) {

		// counterclockwise

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		this.set(

			c, - s, 0,
			s, c, 0,
			0, 0, 1

		);

		return this;

	}

	makeScale( x, y ) {

		this.set(

			x, 0, 0,
			0, y, 0,
			0, 0, 1

		);

		return this;

	}

	//

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

const _m3 = /*@__PURE__*/ new Matrix3();

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.isQuaternion = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q ) {

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	random() {

		// Derived from http://planning.cs.uiuc.edu/node198.html
		// Note, this source uses w, x, y, z ordering,
		// so we swap the order below.

		const u1 = Math.random();
		const sqrt1u1 = Math.sqrt( 1 - u1 );
		const sqrtu1 = Math.sqrt( u1 );

		const u2 = 2 * Math.PI * Math.random();

		const u3 = 2 * Math.PI * Math.random();

		return this.set(
			sqrt1u1 * Math.cos( u2 ),
			sqrtu1 * Math.sin( u3 ),
			sqrtu1 * Math.cos( u3 ),
			sqrt1u1 * Math.sin( u2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;

	}

}

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		Vector3.prototype.isVector3 = true;

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v ) {

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$d.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$d );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$d.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

		const u = ( Math.random() - 0.5 ) * 2;
		const t = Math.random() * Math.PI * 2;
		const f = Math.sqrt( 1 - u ** 2 );

		this.x = f * Math.cos( t );
		this.y = f * Math.sin( t );
		this.z = u;

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

const _vector$d = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}


/**
 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
 * or clipping. Based on W3C specifications for sRGB and Display P3,
 * and ICC specifications for the D50 connection space. Values in/out
 * are _linear_ sRGB and _linear_ Display P3.
 *
 * Note that both sRGB and Display P3 use the sRGB transfer functions.
 *
 * Reference:
 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
 */

const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().fromArray( [
	0.8224621, 0.0331941, 0.0170827,
	0.1775380, 0.9668058, 0.0723974,
	- 0.0000001, 0.0000001, 0.9105199
] );

const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().fromArray( [
	1.2249401, - 0.0420569, - 0.0196376,
	- 0.2249404, 1.0420571, - 0.0786361,
	0.0000001, 0.0000000, 1.0982735
] );

const _vector$c = new Vector3();

function DisplayP3ToLinearSRGB( color ) {

	color.convertSRGBToLinear();

	_vector$c.set( color.r, color.g, color.b ).applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB );

	return color.setRGB( _vector$c.x, _vector$c.y, _vector$c.z );

}

function LinearSRGBToDisplayP3( color ) {

	_vector$c.set( color.r, color.g, color.b ).applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 );

	return color.setRGB( _vector$c.x, _vector$c.y, _vector$c.z ).convertLinearToSRGB();

}

// Conversions from <source> to Linear-sRGB reference space.
const TO_LINEAR = {
	[ LinearSRGBColorSpace ]: ( color ) => color,
	[ SRGBColorSpace ]: ( color ) => color.convertSRGBToLinear(),
	[ DisplayP3ColorSpace ]: DisplayP3ToLinearSRGB,
};

// Conversions to <target> from Linear-sRGB reference space.
const FROM_LINEAR = {
	[ LinearSRGBColorSpace ]: ( color ) => color,
	[ SRGBColorSpace ]: ( color ) => color.convertLinearToSRGB(),
	[ DisplayP3ColorSpace ]: LinearSRGBToDisplayP3,
};

const ColorManagement = {

	enabled: false,

	get legacyMode() {

		console.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );

		return ! this.enabled;

	},

	set legacyMode( legacyMode ) {

		console.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );

		this.enabled = ! legacyMode;

	},

	get workingColorSpace() {

		return LinearSRGBColorSpace;

	},

	set workingColorSpace( colorSpace ) {

		console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );

	},

	convert: function ( color, sourceColorSpace, targetColorSpace ) {

		if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

			return color;

		}

		const sourceToLinear = TO_LINEAR[ sourceColorSpace ];
		const targetFromLinear = FROM_LINEAR[ targetColorSpace ];

		if ( sourceToLinear === undefined || targetFromLinear === undefined ) {

			throw new Error( `Unsupported color space conversion, "${ sourceColorSpace }" to "${ targetColorSpace }".` );

		}

		return targetFromLinear( sourceToLinear( color ) );

	},

	fromWorkingColorSpace: function ( color, targetColorSpace ) {

		return this.convert( color, this.workingColorSpace, targetColorSpace );

	},

	toWorkingColorSpace: function ( color, sourceColorSpace ) {

		return this.convert( color, sourceColorSpace, this.workingColorSpace );

	},

};

let _canvas;

class ImageUtils {

	static getDataURL( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

class Source {

	constructor( data = null ) {

		this.isSource = true;

		this.uuid = generateUUID();

		this.data = data;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.from( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

let textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, encoding = LinearEncoding ) {

		super();

		this.isTexture = true;

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = generateUUID();

		this.name = '';

		this.source = new Source( image );
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.userData = {};

		this.version = 0;
		this.onUpdate = null;

		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

	}

	get image() {

		return this.source.data;

	}

	set image( value = null ) {

		this.source.data = value;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

}

Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		Vector4.prototype.isVector4 = true;

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class WebGLRenderTarget extends EventDispatcher {

	constructor( width = 1, height = 1, options = {} ) {

		super();

		this.isWebGLRenderTarget = true;

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		const image = { width: width, height: height, depth: 1 };

		this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
		this.texture.isRenderTargetTexture = true;

		this.texture.flipY = false;
		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;

		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

		this.samples = options.samples !== undefined ? options.samples : 0;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = depth;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();
		this.texture.isRenderTargetTexture = true;

		// ensure image object is not shared, see #20328

		const image = Object.assign( {}, source.texture.image );
		this.texture.source = new Source( image );

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

		this.samples = source.samples;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

class DataArrayTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.isDataArrayTexture = true;

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

class WebGLArrayRenderTarget extends WebGLRenderTarget {

	constructor( width = 1, height = 1, depth = 1 ) {

		super( width, height );

		this.isWebGLArrayRenderTarget = true;

		this.depth = depth;

		this.texture = new DataArrayTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

class Data3DTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		this.isData3DTexture = true;

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

class WebGL3DRenderTarget extends WebGLRenderTarget {

	constructor( width = 1, height = 1, depth = 1 ) {

		super( width, height );

		this.isWebGL3DRenderTarget = true;

		this.depth = depth;

		this.texture = new Data3DTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

class WebGLMultipleRenderTargets extends WebGLRenderTarget {

	constructor( width = 1, height = 1, count = 1, options = {} ) {

		super( width, height, options );

		this.isWebGLMultipleRenderTargets = true;

		const texture = this.texture;

		this.texture = [];

		for ( let i = 0; i < count; i ++ ) {

			this.texture[ i ] = texture.clone();
			this.texture[ i ].isRenderTargetTexture = true;

		}

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			for ( let i = 0, il = this.texture.length; i < il; i ++ ) {

				this.texture[ i ].image.width = width;
				this.texture[ i ].image.height = height;
				this.texture[ i ].image.depth = depth;

			}

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

		return this;

	}

	copy( source ) {

		this.dispose();

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.set( 0, 0, this.width, this.height );
		this.scissor.set( 0, 0, this.width, this.height );

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

		this.texture.length = 0;

		for ( let i = 0, il = source.texture.length; i < il; i ++ ) {

			this.texture[ i ] = source.texture[ i ].clone();
			this.texture[ i ].isRenderTargetTexture = true;

		}

		return this;

	}

}

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.isBox3 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {

				const position = geometry.attributes.position;
				for ( let i = 0, l = position.count; i < l; i ++ ) {

					_vector$b.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( geometry.boundingBox === null ) {

					geometry.computeBoundingBox();

				}

				_box$3.copy( geometry.boundingBox );
				_box$3.applyMatrix4( object.matrixWorld );

				this.union( _box$3 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$4.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$4, _v1$7 );
		_f2.subVectors( _v0$2, _v2$4 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$b ).distanceTo( point );

	}

	getBoundingSphere( target ) {

		if ( this.isEmpty() ) {

			target.makeEmpty();

		} else {

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$b ).length() * 0.5;

		}

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$3 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$4 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$2 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = - 1 ) {

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$2.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		if ( this.isEmpty() ) {

			this.center.copy( point );

			this.radius = 0;

			return this;

		}

		_v1$6.subVectors( point, this.center );

		const lengthSq = _v1$6.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			// calculate the minimal sphere

			const length = Math.sqrt( lengthSq );

			const delta = ( length - this.radius ) * 0.5;

			this.center.addScaledVector( _v1$6, delta / length );

			this.radius += delta;

		}

		return this;

	}

	union( sphere ) {

		if ( sphere.isEmpty() ) {

			return this;

		}

		if ( this.isEmpty() ) {

			this.copy( sphere );

			return this;

		}

		if ( this.center.equals( sphere.center ) === true ) {

			 this.radius = Math.max( this.radius, sphere.radius );

		} else {

			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

		}

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		return target.copy( this.origin ).addScaledVector( this.direction, t );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if t1 is behind the ray - if so, return null
		if ( t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor() {

		Matrix4.prototype.isMatrix4 = true;

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

		this.isEuler = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order = this._order, update = true ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$1.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$1, order, update );

	}

	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;

	}

}

Euler.DEFAULT_ORDER = 'XYZ';

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = ( 1 << channel | 0 ) >>> 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	isEnabled( channel ) {

		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

class Object3D extends EventDispatcher {

	constructor() {

		super();

		this.isObject3D = true;

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DEFAULT_UP.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
		this.matrixWorldNeedsUpdate = false;

		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position$3, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getObjectsByProperty( name, value ) {

		let result = [];

		if ( this[ name ] === value ) result.push( this );

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const childResult = this.children[ i ].getObjectsByProperty( name, value );

			if ( childResult.length > 0 ) {

				result = result.concat( childResult );

			}

		}

		return result;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	raycast( /* raycaster, intersects */ ) {}

	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			const child = children[ i ];

			if ( child.matrixWorldAutoUpdate === true || force === true ) {

				child.updateMatrixWorld( force );

			}

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				if ( child.matrixWorldAutoUpdate === true ) {

					child.updateWorldMatrix( false, true );

				}

			}

		}

	}

	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3$1 );

		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3$1 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3$1.x );
		target.addScaledVector( uv2, _v3$1.y );
		target.addScaledVector( uv3, _v3$1.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

let materialId = 0;

class Material extends EventDispatcher {

	constructor() {

		super();

		this.isMaterial = true;

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Material';

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;
		this.forceSinglePass = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

		this._alphaTest = 0;

	}

	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	onBuild( /* shaderobject, renderer */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	onBeforeCompile( /* shaderobject, renderer */ ) {}

	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

		}

		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
		if ( this.forceSinglePass === true ) data.forceSinglePass = this.forceSinglePass;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = this.flatShading;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( this.fog === false ) data.fog = false;

		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.forceSinglePass = source.forceSinglePass;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

class Color {

	constructor( r, g, b ) {

		this.isColor = true;

		this.r = 1;
		this.g = 1;
		this.b = 1;

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseFloat( color[ 2 ] ) / 100;
						const l = parseFloat( color[ 3 ] ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l, colorSpace );

					}

					break;

				default:

					console.warn( 'THREE.Color: Unknown color model ' + style );

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			} else {

				console.warn( 'THREE.Color: Invalid hex color ' + style );

			}

		} else if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		return clamp( _color.r * 255, 0, 255 ) << 16 ^ clamp( _color.g * 255, 0, 255 ) << 8 ^ clamp( _color.b * 255, 0, 255 ) << 0;

	}

	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

	}

	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		target.r = _color.r;
		target.g = _color.g;
		target.b = _color.b;

		return target;

	}

	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

		}

		return `rgb(${( r * 255 ) | 0},${( g * 255 ) | 0},${( b * 255 ) | 0})`;

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		return this;

	}

	toJSON() {

		return this.getHex();

	}

	*[ Symbol.iterator ]() {

		yield this.r;
		yield this.g;
		yield this.b;

	}

}

const _color = new Color();

Color.NAMES = _colorKeywords;

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshBasicMaterial = true;

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

class BufferAttribute {

	constructor( array, itemSize, normalized = false ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.isBufferAttribute = true;

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	set( value, offset = 0 ) {

		// Matching BufferAttribute constructor, do not normalize the array.
		this.array.set( value, offset );

		return this;

	}

	getX( index ) {

		let x = this.array[ index * this.itemSize ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	getY( index ) {

		let y = this.array[ index * this.itemSize + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	getZ( index ) {

		let z = this.array[ index * this.itemSize + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	getW( index ) {

		let w = this.array[ index * this.itemSize + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		return data;

	}

	// @deprecated

	copyColorsArray() {

		console.error( 'THREE.BufferAttribute: copyColorsArray() was removed in r144.' );

	}

	copyVector2sArray() {

		console.error( 'THREE.BufferAttribute: copyVector2sArray() was removed in r144.' );

	}

	copyVector3sArray() {

		console.error( 'THREE.BufferAttribute: copyVector3sArray() was removed in r144.' );

	}

	copyVector4sArray() {

		console.error( 'THREE.BufferAttribute: copyVector4sArray() was removed in r144.' );

	}

}

//

class Int8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int8Array( array ), itemSize, normalized );

	}

}

class Uint8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8Array( array ), itemSize, normalized );

	}

}

class Uint8ClampedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8ClampedArray( array ), itemSize, normalized );

	}

}

class Int16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int16Array( array ), itemSize, normalized );

	}

}

class Uint16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

class Int32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int32Array( array ), itemSize, normalized );

	}

}

class Uint32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}

class Float16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

		this.isFloat16BufferAttribute = true;

	}

}


class Float32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

class Float64BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float64Array( array ), itemSize, normalized );

	}

}

let _id$1 = 0;

const _m1 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$1 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

class BufferGeometry extends EventDispatcher {

	constructor() {

		super();

		this.isBufferGeometry = true;

		Object.defineProperty( this, 'id', { value: _id$1 ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	getIndex() {

		return this.index;

	}

	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	getAttribute( name ) {

		return this.attributes[ name ];

	}

	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	clearGroups() {

		this.groups = [];

	}

	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	applyQuaternion( q ) {

		_m1.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1.makeRotationX( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1.makeRotationY( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1.makeRotationZ( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	translate( x, y, z ) {

		// translate geometry

		_m1.makeTranslation( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	scale( x, y, z ) {

		// scale geometry

		_m1.makeScale( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	setFromPoints( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$1.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$1.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$1.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$1.min );
						this.boundingBox.expandByPoint( _box$1.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$1.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
						_box$1.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
						_box$1.expandByPoint( _vector$8 );

					} else {

						_box$1.expandByPoint( _boxMorphTargets.min );
						_box$1.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$1.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;

		const nVertices = positions.length / 3;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		const tangents = this.getAttribute( 'tangent' ).array;

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < nVertices; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: indices.length
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					indices[ j + 0 ],
					indices[ j + 1 ],
					indices[ j + 2 ]
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4 ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( indices[ j + 0 ] );
				handleVertex( indices[ j + 1 ] );
				handleVertex( indices[ j + 2 ] );

			}

		}

	}

	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	// @deprecated since r144

	merge() {

		console.error( 'THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.' );
		return this;

	}

	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();
const _sphere$3 = /*@__PURE__*/ new Sphere();
const _sphereHitAt = /*@__PURE__*/ new Vector3();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _morphA = /*@__PURE__*/ new Vector3();

const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

class Mesh extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		this.isMesh = true;

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

	getVertexPosition( index, target ) {

		const geometry = this.geometry;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;

		target.fromBufferAttribute( position, index );

		const morphInfluences = this.morphTargetInfluences;

		if ( morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, index );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( target ), influence );

				}

			}

			target.add( _morphA );

		}

		if ( this.isSkinnedMesh ) {

			this.boneTransform( index, target );

		}

		return target;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );

		_ray$2.copy( raycaster.ray ).recast( raycaster.near );

		if ( _sphere$3.containsPoint( _ray$2.origin ) === false ) {

			if ( _ray$2.intersectSphere( _sphere$3, _sphereHitAt ) === null ) return;

			if ( _ray$2.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

		}

		//

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		const index = geometry.index;
		const position = geometry.attributes.position;
		const uv = geometry.attributes.uv;
		const uv2 = geometry.attributes.uv2;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;

		if ( index !== null ) {

			// indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = index.getX( j );
						const b = index.getX( j + 1 );
						const c = index.getX( j + 2 );

						intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );
					const c = index.getX( i + 2 );

					intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, uv, uv2, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( position !== undefined ) {

			// non-indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = j;
						const b = j + 1;
						const c = j + 2;

						intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = i;
					const b = i + 1;
					const c = i + 2;

					intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, uv, uv2, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		}

	}

}

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, uv, uv2, a, b, c ) {

	object.getVertexPosition( a, _vA$1 );
	object.getVertexPosition( b, _vB$1 );
	object.getVertexPosition( c, _vC$1 );

	const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA$1.fromBufferAttribute( uv, a );
			_uvB$1.fromBufferAttribute( uv, b );
			_uvC$1.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( uv2 ) {

			_uvA$1.fromBufferAttribute( uv2, a );
			_uvB$1.fromBufferAttribute( uv2, b );
			_uvC$1.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

function cloneUniformsGroups( src ) {

	const dst = [];

	for ( let u = 0; u < src.length; u ++ ) {

		dst.push( src[ u ].clone() );

	}

	return dst;

}

function getUnlitUniformColorSpace( renderer ) {

	if ( renderer.getRenderTarget() === null ) {

		// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
		return renderer.outputEncoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;

	}

	return LinearSRGBColorSpace;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShaderMaterial = true;

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};
		this.uniformsGroups = [];

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );
		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

class Camera extends Object3D {

	constructor() {

		super();

		this.isCamera = true;

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class PerspectiveCamera extends Camera {

	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		this.isPerspectiveCamera = true;

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

const fov = - 90; // negative fov is not an error
const aspect = 1;

class CubeCamera extends Object3D {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		this.renderTarget = renderTarget;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		cameraPX.up.set( 0, 1, 0 );
		cameraPX.lookAt( 1, 0, 0 );
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		cameraNX.up.set( 0, 1, 0 );
		cameraNX.lookAt( - 1, 0, 0 );
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		cameraPY.up.set( 0, 0, - 1 );
		cameraPY.lookAt( 0, 1, 0 );
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		cameraNY.up.set( 0, 0, 1 );
		cameraNY.lookAt( 0, - 1, 0 );
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		cameraPZ.up.set( 0, 1, 0 );
		cameraPZ.lookAt( 0, 0, 1 );
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		cameraNZ.up.set( 0, 1, 0 );
		cameraNZ.lookAt( 0, 0, - 1 );
		this.add( cameraNZ );

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const renderTarget = this.renderTarget;

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentRenderTarget = renderer.getRenderTarget();

		const currentToneMapping = renderer.toneMapping;
		const currentXrEnabled = renderer.xr.enabled;

		renderer.toneMapping = NoToneMapping;
		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

		renderer.toneMapping = currentToneMapping;
		renderer.xr.enabled = currentXrEnabled;

		renderTarget.texture.needsPMREMUpdate = true;

	}

}

class CubeTexture extends Texture {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.isCubeTexture = true;

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

class WebGLCubeRenderTarget extends WebGLRenderTarget {

	constructor( size = 1, options = {} ) {

		super( size, size, options );

		this.isWebGLCubeRenderTarget = true;

		const image = { width: size, height: size, depth: 1 };
		const images = [ image, image, image, image, image, image ];

		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.encoding = texture.encoding;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		this.isPlane = true;

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

	}

	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( line.start ).addScaledVector( direction, t );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$7 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	}

	intersectsObject( object ) {

		const geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSprite( sprite ) {

		_sphere$2.center.set( 0, 0, 0 );
		_sphere$2.radius = 0.7071067811865476;
		_sphere$2.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type;

		if ( array instanceof Float32Array ) {

			type = 5126;

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				if ( isWebGL2 ) {

					type = 5131;

				} else {

					throw new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				}

			} else {

				type = 5123;

			}

		} else if ( array instanceof Int16Array ) {

			type = 5122;

		} else if ( array instanceof Uint32Array ) {

			type = 5125;

		} else if ( array instanceof Int32Array ) {

			type = 5124;

		} else if ( array instanceof Int8Array ) {

			type = 5120;

		} else if ( array instanceof Uint8Array ) {

			type = 5121;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = 5121;

		} else {

			throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

		attribute.onUploadCallback();

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\t\n\t\tvec2 lodFudge = pow( 1.95, lod ) / fullSize;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec2 fullSize = vec2( textureSize( sampler, 0 ) );\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	iridescence_fragment: iridescence_fragment,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_fragment: lights_lambert_fragment,
	lights_lambert_pars_fragment: lights_lambert_pars_fragment,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphcolor_vertex: morphcolor_vertex,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	iridescence_pars_fragment: iridescence_pars_fragment,
	output_fragment: output_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_vert: vertex$h,
	background_frag: fragment$h,
	backgroundCube_vert: vertex$g,
	backgroundCube_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: /*@__PURE__*/ new Matrix3() },
		uv2Transform: { value: /*@__PURE__*/ new Matrix3() },

		alphaMap: { value: null },
		alphaTest: { value: 0 }

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 }, // basic, lambert, phong
		ior: { value: 1.5 }, // physical
		refractionRatio: { value: 0.98 }, // basic, lambert, phong

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotLightMap: { value: [] },
		spotShadowMap: { value: [] },
		spotLightMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	sprite: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

	}

};

const ShaderLib = {

	basic: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag

	},

	sprite: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: /*@__PURE__*/ new Matrix3() },
			t2D: { value: null },
			backgroundIntensity: { value: 1 }
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},

	backgroundCube: {

		uniforms: {
			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			backgroundBlurriness: { value: 0 },
			backgroundIntensity: { value: 1 }
		},

		vertexShader: ShaderChunk.backgroundCube_vert,
		fragmentShader: ShaderChunk.backgroundCube_frag

	},

	cube: {

		uniforms: {
			tCube: { value: null },
			tFlip: { value: - 1 },
			opacity: { value: 1.0 }
		},

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: /*@__PURE__*/ new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: /*@__PURE__*/ mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			iridescence: { value: 0 },
			iridescenceMap: { value: null },
			iridescenceIOR: { value: 1.3 },
			iridescenceThicknessMinimum: { value: 100 },
			iridescenceThicknessMaximum: { value: 400 },
			iridescenceThicknessMap: { value: null },
			sheen: { value: 0 },
			sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			sheenColorMap: { value: null },
			sheenRoughness: { value: 1 },
			sheenRoughnessMap: { value: null },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			specularIntensity: { value: 1 },
			specularIntensityMap: { value: null },
			specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
			specularColorMap: { value: null },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

const _rgb = { r: 0, b: 0, g: 0 };

function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

	const clearColor = new Color( 0x000000 );
	let clearAlpha = alpha === true ? 0 : 1;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function render( renderList, scene ) {

		let forceClear = false;
		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
			background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
						vertexShader: ShaderLib.backgroundCube.vertexShader,
						fragmentShader: ShaderLib.backgroundCube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// add "envMap" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;
			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
			boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			boxMesh.material.toneMapped = ( background.encoding === sRGBEncoding ) ? false : true;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			boxMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// add "map" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;
			planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			planeMesh.material.toneMapped = ( background.encoding === sRGBEncoding ) ? false : true;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			planeMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

		state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

	const maxVertexAttributes = gl.getParameter( 34921 );

	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;
	let forceUpdate = false;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		if ( vaoAvailable ) {

			const state = getBindingState( geometry, program, material );

			if ( currentState !== state ) {

				currentState = state;
				bindVertexArrayObject( currentState.object );

			}

			updateBuffers = needsUpdate( object, geometry, program, index );

			if ( updateBuffers ) saveCache( object, geometry, program, index );

		} else {

			const wireframe = ( material.wireframe === true );

			if ( currentState.geometry !== geometry.id ||
				currentState.program !== program.id ||
				currentState.wireframe !== wireframe ) {

				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;

				updateBuffers = true;

			}

		}

		if ( index !== null ) {

			attributes.update( index, 34963 );

		}

		if ( updateBuffers || forceUpdate ) {

			forceUpdate = false;

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( 34963, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		return extension.createVertexArrayOES();

	}

	function bindVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		return extension.bindVertexArrayOES( vao );

	}

	function deleteVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		return extension.deleteVertexArrayOES( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( object, geometry, program, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				const cachedAttribute = cachedAttributes[ name ];
				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( cachedAttribute === undefined ) return true;

				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

				if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

				attributesNum ++;

			}

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( object, geometry, program, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let attribute = attributes[ name ];

				if ( attribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

				}

				const data = {};
				data.attribute = attribute;

				if ( attribute && attribute.data ) {

					data.data = attribute.data;

				}

				cache[ name ] = data;

				attributesNum ++;

			}

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data.isInstancedInterleavedBuffer ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( 34962, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								stride * bytesPerElement,
								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement
							);

						}

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( 34962, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								size * bytesPerElement,
								( size / programAttribute.locationSize ) * i * bytesPerElement
							);

						}

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute.location, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute.location, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute.location, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute.location, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();
		forceUpdate = true;

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatibility

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLCapabilities( gl, extensions, parameters ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( 34930 );
	const maxVertexTextures = gl.getParameter( 35660 );
	const maxTextureSize = gl.getParameter( 3379 );
	const maxCubemapSize = gl.getParameter( 34076 );

	const maxAttributes = gl.getParameter( 34921 );
	const maxVertexUniforms = gl.getParameter( 36347 );
	const maxVaryings = gl.getParameter( 36348 );
	const maxFragmentUniforms = gl.getParameter( 36349 );

	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
	const floatVertexTextures = vertexTextures && floatFragmentTextures;

	const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	return {

		isWebGL2: isWebGL2,

		drawBuffers: drawBuffers,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;

	};

	this.setGlobalState = function ( planes, camera ) {

		globalState = projectPlanes( planes, camera, 0 );

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class OrthographicCamera extends Camera {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.isOrthographicCamera = true;

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];

		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();

		this._setSize( 256 );

		const cubeUVRenderTarget = this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular, renderTarget = null ) {

		return this._fromTexture( equirectangular, renderTarget );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap, renderTarget = null ) {

		return this._fromTexture( cubemap, renderTarget );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapMaterial === null ) {

			this._cubemapMaterial = _getCubemapMaterial();
			this._compileMaterial( this._cubemapMaterial );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectMaterial === null ) {

			this._equirectMaterial = _getEquirectMaterial();
			this._compileMaterial( this._equirectMaterial );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._dispose();

		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

	}

	// private interface

	_setSize( cubeSize ) {

		this._lodMax = Math.floor( Math.log2( cubeSize ) );
		this._cubeSize = Math.pow( 2, this._lodMax );

	}

	_dispose() {

		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

			this._lodPlanes[ i ].dispose();

		}

	}

	_cleanup( outputTarget ) {

		this._renderer.setRenderTarget( _oldTarget );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture, renderTarget ) {

		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

		} else { // Equirectangular

			this._setSize( texture.image.width / 4 );

		}

		_oldTarget = this._renderer.getRenderTarget();

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets() {

		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
		const height = 4 * this._cubeSize;

		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			encoding: LinearEncoding,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

			if ( this._pingPongRenderTarget !== null ) {

				this._dispose();

			}

			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

			const { _lodMax } = this;
			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

			this._blurMaterial = _getBlurShader( _lodMax, width, height );

		}

		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = NoToneMapping;
		renderer.autoClear = false;

		const backgroundMaterial = new MeshBasicMaterial( {
			name: 'PMREM.Background',
			side: BackSide,
			depthWrite: false,
			depthTest: false,
		} );

		const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

		let useSolidColor = false;
		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor );
			useSolidColor = true;

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;

			if ( col === 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col === 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		backgroundBox.geometry.dispose();
		backgroundBox.material.dispose();

		renderer.toneMapping = toneMapping;
		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();

			}

			this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

		} else {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();

			}

		}

		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		const mesh = new Mesh( this._lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		const size = this._cubeSize;

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;

		for ( let i = 1; i < this._lodPlanes.length; i ++ ) {

			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = this._sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i === 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		const { _lodMax } = this;
		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}



function _createPlanes( lodMax ) {

	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];

	let lod = lodMax;

	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

	for ( let i = 0; i < totalLods; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > lodMax - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

		} else if ( i === 0 ) {

			sigma = 0;

		}

		sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 2 );
		const min = - texelSize;
		const max = 1 + texelSize;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { lodPlanes, sizeLods, sigmas };

}

function _createRenderTarget( width, height, params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( lodMax, width, height ) {

	const weights = new Float32Array( MAX_SAMPLES );
	const poleAxis = new Vector3( 0, 1, 0 );
	const shaderMaterial = new ShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: {
			'n': MAX_SAMPLES,
			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
			'CUBEUV_MAX_MIP': `${lodMax}.0`,
		},

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectMaterial() {

	return new ShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCubemapMaterial() {

	return new ShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'flipEnvMap': { value: - 1 }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function WebGLCubeUVMaps( renderer ) {

	let cubeUVmaps = new WeakMap();

	let pmremGenerator = null;

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

			// equirect/cube map to cubeUV conversion

			if ( isEquirectMap || isCubeMap ) {

				if ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {

					texture.needsPMREMUpdate = false;

					let renderTarget = cubeUVmaps.get( texture );

					if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
					cubeUVmaps.set( texture, renderTarget );

					return renderTarget.texture;

				} else {

					if ( cubeUVmaps.has( texture ) ) {

						return cubeUVmaps.get( texture ).texture;

					} else {

						const image = texture.image;

						if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

							if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
							cubeUVmaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return renderTarget.texture;

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

		}

		return texture;

	}

	function isCubeTextureComplete( image ) {

		let count = 0;
		const length = 6;

		for ( let i = 0; i < length; i ++ ) {

			if ( image[ i ] !== undefined ) count ++;

		}

		return count === length;


	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemapUV = cubeUVmaps.get( texture );

		if ( cubemapUV !== undefined ) {

			cubeUVmaps.delete( texture );
			cubemapUV.dispose();

		}

	}

	function dispose() {

		cubeUVmaps = new WeakMap();

		if ( pmremGenerator !== null ) {

			pmremGenerator.dispose();
			pmremGenerator = null;

		}

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		let extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function ( capabilities ) {

			if ( capabilities.isWebGL2 ) {

				getExtension( 'EXT_color_buffer_float' );

			} else {

				getExtension( 'WEBGL_depth_texture' );
				getExtension( 'OES_texture_float' );
				getExtension( 'OES_texture_half_float' );
				getExtension( 'OES_texture_half_float_linear' );
				getExtension( 'OES_standard_derivatives' );
				getExtension( 'OES_element_index_uint' );
				getExtension( 'OES_vertex_array_object' );
				getExtension( 'ANGLE_instanced_arrays' );

			}

			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );
			getExtension( 'WEBGL_multisampled_render_to_texture' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], 34962 );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], 34962 );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case 4:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case 1:
				render.lines += instanceCount * ( count / 2 );
				break;

			case 3:
				render.lines += instanceCount * ( count - 1 );
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

function numericalSort( a, b ) {

	return a[ 0 ] - b[ 0 ];

}

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function WebGLMorphtargets( gl, capabilities, textures ) {

	const influencesList = {};
	const morphInfluences = new Float32Array( 8 );
	const morphTextures = new WeakMap();
	const morph = new Vector4();

	const workInfluences = [];

	for ( let i = 0; i < 8; i ++ ) {

		workInfluences[ i ] = [ i, 0 ];

	}

	function update( object, geometry, program ) {

		const objectInfluences = object.morphTargetInfluences;

		if ( capabilities.isWebGL2 === true ) {

			// instead of using attributes, the WebGL 2 code path encodes morph targets
			// into an array of data textures. Each layer represents a single morph target.

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			let entry = morphTextures.get( geometry );

			if ( entry === undefined || entry.count !== morphTargetsCount ) {

				if ( entry !== undefined ) entry.texture.dispose();

				const hasMorphPosition = geometry.morphAttributes.position !== undefined;
				const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
				const hasMorphColors = geometry.morphAttributes.color !== undefined;

				const morphTargets = geometry.morphAttributes.position || [];
				const morphNormals = geometry.morphAttributes.normal || [];
				const morphColors = geometry.morphAttributes.color || [];

				let vertexDataCount = 0;

				if ( hasMorphPosition === true ) vertexDataCount = 1;
				if ( hasMorphNormals === true ) vertexDataCount = 2;
				if ( hasMorphColors === true ) vertexDataCount = 3;

				let width = geometry.attributes.position.count * vertexDataCount;
				let height = 1;

				if ( width > capabilities.maxTextureSize ) {

					height = Math.ceil( width / capabilities.maxTextureSize );
					width = capabilities.maxTextureSize;

				}

				const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

				const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
				texture.type = FloatType;
				texture.needsUpdate = true;

				// fill buffer

				const vertexDataStride = vertexDataCount * 4;

				for ( let i = 0; i < morphTargetsCount; i ++ ) {

					const morphTarget = morphTargets[ i ];
					const morphNormal = morphNormals[ i ];
					const morphColor = morphColors[ i ];

					const offset = width * height * 4 * i;

					for ( let j = 0; j < morphTarget.count; j ++ ) {

						const stride = j * vertexDataStride;

						if ( hasMorphPosition === true ) {

							morph.fromBufferAttribute( morphTarget, j );

							buffer[ offset + stride + 0 ] = morph.x;
							buffer[ offset + stride + 1 ] = morph.y;
							buffer[ offset + stride + 2 ] = morph.z;
							buffer[ offset + stride + 3 ] = 0;

						}

						if ( hasMorphNormals === true ) {

							morph.fromBufferAttribute( morphNormal, j );

							buffer[ offset + stride + 4 ] = morph.x;
							buffer[ offset + stride + 5 ] = morph.y;
							buffer[ offset + stride + 6 ] = morph.z;
							buffer[ offset + stride + 7 ] = 0;

						}

						if ( hasMorphColors === true ) {

							morph.fromBufferAttribute( morphColor, j );

							buffer[ offset + stride + 8 ] = morph.x;
							buffer[ offset + stride + 9 ] = morph.y;
							buffer[ offset + stride + 10 ] = morph.z;
							buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

						}

					}

				}

				entry = {
					count: morphTargetsCount,
					texture: texture,
					size: new Vector2( width, height )
				};

				morphTextures.set( geometry, entry );

				function disposeTexture() {

					texture.dispose();

					morphTextures.delete( geometry );

					geometry.removeEventListener( 'dispose', disposeTexture );

				}

				geometry.addEventListener( 'dispose', disposeTexture );

			}

			//

			let morphInfluencesSum = 0;

			for ( let i = 0; i < objectInfluences.length; i ++ ) {

				morphInfluencesSum += objectInfluences[ i ];

			}

			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

			program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
			program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );


		} else {

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;

			let influences = influencesList[ geometry.id ];

			if ( influences === undefined || influences.length !== length ) {

				// initialise list

				influences = [];

				for ( let i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			// Collect influences

			for ( let i = 0; i < length; i ++ ) {

				const influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			for ( let i = 0; i < 8; i ++ ) {

				if ( i < length && influences[ i ][ 1 ] ) {

					workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
					workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

				} else {

					workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
					workInfluences[ i ][ 1 ] = 0;

				}

			}

			workInfluences.sort( numericalSort );

			const morphTargets = geometry.morphAttributes.position;
			const morphNormals = geometry.morphAttributes.normal;

			let morphInfluencesSum = 0;

			for ( let i = 0; i < 8; i ++ ) {

				const influence = workInfluences[ i ];
				const index = influence[ 0 ];
				const value = influence[ 1 ];

				if ( index !== Number.MAX_SAFE_INTEGER && value ) {

					if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

						geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

					}

					if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

						geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

					}

					morphInfluences[ i ] = value;
					morphInfluencesSum += value;

				} else {

					if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

						geometry.deleteAttribute( 'morphTarget' + i );

					}

					if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

						geometry.deleteAttribute( 'morphNormal' + i );

					}

					morphInfluences[ i ] = 0;

				}

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			attributes.update( object.instanceMatrix, 34962 );

			if ( object.instanceColor !== null ) {

				attributes.update( object.instanceColor, 34962 );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = /*@__PURE__*/ new Texture();
const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single integer / boolean

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single integer / boolean vector (from flat array or THREE.VectorN)

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2i( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3i( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single unsigned integer

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Single unsigned integer vector (from flat array or THREE.VectorN)

function setValueV2ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2ui( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2uiv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3ui( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3uiv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4uiv( this.addr, v );

		copyArray( cache, v );

	}

}


// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2D( v || emptyTexture, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || empty3dTexture, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTextureCube( v || emptyCubeTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyArrayTexture, unit );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT
		case 0x8dc6: return setValueV2ui; // _VEC2
		case 0x8dc7: return setValueV3ui; // _VEC3
		case 0x8dc8: return setValueV4ui; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}


// Array of scalars

function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of integer / boolean

function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}

// Array of unsigned integer

function setValueV1uiArray( gl, v ) {

	gl.uniform1uiv( this.addr, v );

}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray( gl, v ) {

	gl.uniform2uiv( this.addr, v );

}

function setValueV3uiArray( gl, v ) {

	gl.uniform3uiv( this.addr, v );

}

function setValueV4uiArray( gl, v ) {

	gl.uniform4uiv( this.addr, v );

}


// Array of textures (2D / 3D / Cube / 2DArray)

function setValueT1Array( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT3DArray( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

function setValueT2DArrayArray( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

	}

}


// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x1405: return setValueV1uiArray; // UINT
		case 0x8dc6: return setValueV2uiArray; // _VEC2
		case 0x8dc7: return setValueV3uiArray; // _VEC3
		case 0x8dc8: return setValueV4uiArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3DArray;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArrayArray;

	}

}

// --- Uniform Classes ---

class SingleUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class PureArrayUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class StructuredUniform {

	constructor( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	setValue( gl, value, textures ) {

		const seq = this.seq;

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	}

}

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

class WebGLUniforms {

	constructor( gl, program ) {

		this.seq = [];
		this.map = {};

		const n = gl.getProgramParameter( program, 35718 );

		for ( let i = 0; i < n; ++ i ) {

			const info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	setValue( gl, name, value, textures ) {

		const u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	}

	setOptional( gl, object, name ) {

		const v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	}

	static upload( gl, seq, values, textures ) {

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	}

	static seqWithValue( seq, values ) {

		const r = [];

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	}

}

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

let programIdCount = 0;

function handleSource( string, errorLine ) {

	const lines = string.split( '\n' );
	const lines2 = [];

	const from = Math.max( errorLine - 6, 0 );
	const to = Math.min( errorLine + 6, lines.length );

	for ( let i = from; i < to; i ++ ) {

		const line = i + 1;
		lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

	}

	return lines2.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		default:
			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			return [ 'Linear', '( value )' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, 35713 );
	const errors = gl.getShaderInfoLog( shader ).trim();

	if ( status && errors === '' ) return '';

	const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
	if ( errorMatches ) {

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const errorLine = parseInt( errorMatches[ 1 ] );
		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

	} else {

		return errors;

	}

}

function getTexelEncodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	const chunks = [
		( parameters.extensionDerivatives || !! parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, 35721 );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		let locationSize = 1;
		if ( info.type === 35674 ) locationSize = 2;
		if ( info.type === 35675 ) locationSize = 3;
		if ( info.type === 35676 ) locationSize = 4;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = {
			type: info.type,
			location: gl.getAttribLocation( program, name ),
			locationSize: locationSize
		};

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
		.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	const string = ShaderChunk[ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string.replace( unrollLoopPattern, loopReplacer );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function generateCubeUVSize( parameters ) {

	const imageHeight = parameters.envMapCubeUVHeight;

	if ( imageHeight === null ) return null;

	const maxMip = Math.log2( imageHeight ) - 2;

	const texelHeight = 1.0 / imageHeight;

	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

	return { texelWidth, texelHeight, maxMip };

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	// TODO Send this event to Three.js DevTools
	// console.log( 'WebGLProgram', cacheKey );

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
	const envMapCubeUVSize = generateCubeUVSize( parameters );

	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			( parameters.morphColors && parameters.isWebGL2 ) ? '#define USE_MORPHCOLORS' : '',
			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',
			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#if defined( USE_COLOR_ALPHA )',

			'	attribute vec4 color;',

			'#elif defined( USE_COLOR )',

			'	attribute vec3 color;',

			'#endif',

			'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
			envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaTest ? '#define USE_ALPHATEST' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',
			parameters.opaque ? '#define OPAQUE' : '',

			ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

			parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			'precision mediump sampler2DArray;',
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		const programLog = gl.getProgramInfoLog( program ).trim();
		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		let runnable = true;
		let haveDiagnostics = true;

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error(
				'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
				'VALIDATE_STATUS ' + gl.getProgramParameter( program, 35715 ) + '\n\n' +
				'Program Info Log: ' + programLog + '\n' +
				vertexErrors + '\n' +
				fragmentErrors
			);

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

let _id = 0;

class WebGLShaderCache {

	constructor() {

		this.shaderCache = new Map();
		this.materialCache = new Map();

	}

	update( material ) {

		const vertexShader = material.vertexShader;
		const fragmentShader = material.fragmentShader;

		const vertexShaderStage = this._getShaderStage( vertexShader );
		const fragmentShaderStage = this._getShaderStage( fragmentShader );

		const materialShaders = this._getShaderCacheForMaterial( material );

		if ( materialShaders.has( vertexShaderStage ) === false ) {

			materialShaders.add( vertexShaderStage );
			vertexShaderStage.usedTimes ++;

		}

		if ( materialShaders.has( fragmentShaderStage ) === false ) {

			materialShaders.add( fragmentShaderStage );
			fragmentShaderStage.usedTimes ++;

		}

		return this;

	}

	remove( material ) {

		const materialShaders = this.materialCache.get( material );

		for ( const shaderStage of materialShaders ) {

			shaderStage.usedTimes --;

			if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

		}

		this.materialCache.delete( material );

		return this;

	}

	getVertexShaderID( material ) {

		return this._getShaderStage( material.vertexShader ).id;

	}

	getFragmentShaderID( material ) {

		return this._getShaderStage( material.fragmentShader ).id;

	}

	dispose() {

		this.shaderCache.clear();
		this.materialCache.clear();

	}

	_getShaderCacheForMaterial( material ) {

		const cache = this.materialCache;
		let set = cache.get( material );

		if ( set === undefined ) {

			set = new Set();
			cache.set( material, set );

		}

		return set;

	}

	_getShaderStage( code ) {

		const cache = this.shaderCache;
		let stage = cache.get( code );

		if ( stage === undefined ) {

			stage = new WebGLShaderStage( code );
			cache.set( code, stage );

		}

		return stage;

	}

}

class WebGLShaderStage {

	constructor( code ) {

		this.id = _id ++;

		this.code = code;
		this.usedTimes = 0;

	}

}

function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

	const _programLayers = new Layers();
	const _customShaders = new WebGLShaderCache();
	const programs = [];

	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const vertexTextures = capabilities.vertexTextures;
	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const geometry = object.geometry;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		//

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		let morphTextureStride = 0;

		if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
		if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
		if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

		//

		let vertexShader, fragmentShader;
		let customVertexShaderID, customFragmentShaderID;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

			_customShaders.update( material );

			customVertexShaderID = _customShaders.getVertexShaderID( material );
			customFragmentShaderID = _customShaders.getFragmentShaderID( material );

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const useAlphaTest = material.alphaTest > 0;
		const useClearcoat = material.clearcoat > 0;
		const useIridescence = material.iridescence > 0;

		const parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: material.type,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			customVertexShaderID: customVertexShaderID,
			customFragmentShaderID: customFragmentShaderID,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget === null ) ? renderer.outputEncoding : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding ),
			map: !! material.map,
			matcap: !! material.matcap,
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapCubeUVHeight: envMapCubeUVHeight,
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,

			decodeVideoTexture: !! material.map && ( material.map.isVideoTexture === true ) && ( material.map.encoding === sRGBEncoding ),

			clearcoat: useClearcoat,
			clearcoatMap: useClearcoat && !! material.clearcoatMap,
			clearcoatRoughnessMap: useClearcoat && !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: useClearcoat && !! material.clearcoatNormalMap,

			iridescence: useIridescence,
			iridescenceMap: useIridescence && !! material.iridescenceMap,
			iridescenceThicknessMap: useIridescence && !! material.iridescenceThicknessMap,

			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			specularIntensityMap: !! material.specularIntensityMap,
			specularColorMap: !! material.specularColorMap,

			opaque: material.transparent === false && material.blending === NormalBlending,

			alphaMap: !! material.alphaMap,
			alphaTest: useAlphaTest,

			gradientMap: !! material.gradientMap,

			sheen: material.sheen > 0,
			sheenColorMap: !! material.sheenColorMap,
			sheenRoughnessMap: !! material.sheenRoughnessMap,

			transmission: material.transmission > 0,
			transmissionMap: !! material.transmissionMap,
			thicknessMap: !! material.thicknessMap,

			combine: material.combine,

			vertexTangents: ( !! material.normalMap && !! geometry.attributes.tangent ),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.iridescenceMap || !! material.iridescenceThicknessMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || !! material.sheenColorMap || !! material.sheenRoughnessMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.iridescenceMap || !! material.iridescenceThicknessMap || material.transmission > 0 || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || material.sheen > 0 || !! material.sheenColorMap || !! material.sheenRoughnessMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog === true,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: !! material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: object.isSkinnedMesh === true,

			morphTargets: geometry.morphAttributes.position !== undefined,
			morphNormals: geometry.morphAttributes.normal !== undefined,
			morphColors: geometry.morphAttributes.color !== undefined,
			morphTargetsCount: morphTargetsCount,
			morphTextureStride: morphTextureStride,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numSpotLightMaps: lights.spotLightMap.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,
			numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			useLegacyLights: renderer.useLegacyLights,

			premultipliedAlpha: material.premultipliedAlpha,

			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			useDepthPacking: !! material.depthPacking,
			depthPacking: material.depthPacking || 0,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.customVertexShaderID );
			array.push( parameters.customFragmentShaderID );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			getProgramCacheKeyParameters( array, parameters );
			getProgramCacheKeyBooleans( array, parameters );
			array.push( renderer.outputEncoding );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getProgramCacheKeyParameters( array, parameters ) {

		array.push( parameters.precision );
		array.push( parameters.outputEncoding );
		array.push( parameters.envMapMode );
		array.push( parameters.envMapCubeUVHeight );
		array.push( parameters.combine );
		array.push( parameters.vertexUvs );
		array.push( parameters.fogExp2 );
		array.push( parameters.sizeAttenuation );
		array.push( parameters.morphTargetsCount );
		array.push( parameters.morphAttributeCount );
		array.push( parameters.numDirLights );
		array.push( parameters.numPointLights );
		array.push( parameters.numSpotLights );
		array.push( parameters.numSpotLightMaps );
		array.push( parameters.numHemiLights );
		array.push( parameters.numRectAreaLights );
		array.push( parameters.numDirLightShadows );
		array.push( parameters.numPointLightShadows );
		array.push( parameters.numSpotLightShadows );
		array.push( parameters.numSpotLightShadowsWithMaps );
		array.push( parameters.shadowMapType );
		array.push( parameters.toneMapping );
		array.push( parameters.numClippingPlanes );
		array.push( parameters.numClipIntersection );
		array.push( parameters.depthPacking );

	}

	function getProgramCacheKeyBooleans( array, parameters ) {

		_programLayers.disableAll();

		if ( parameters.isWebGL2 )
			_programLayers.enable( 0 );
		if ( parameters.supportsVertexTextures )
			_programLayers.enable( 1 );
		if ( parameters.instancing )
			_programLayers.enable( 2 );
		if ( parameters.instancingColor )
			_programLayers.enable( 3 );
		if ( parameters.map )
			_programLayers.enable( 4 );
		if ( parameters.matcap )
			_programLayers.enable( 5 );
		if ( parameters.envMap )
			_programLayers.enable( 6 );
		if ( parameters.lightMap )
			_programLayers.enable( 7 );
		if ( parameters.aoMap )
			_programLayers.enable( 8 );
		if ( parameters.emissiveMap )
			_programLayers.enable( 9 );
		if ( parameters.bumpMap )
			_programLayers.enable( 10 );
		if ( parameters.normalMap )
			_programLayers.enable( 11 );
		if ( parameters.objectSpaceNormalMap )
			_programLayers.enable( 12 );
		if ( parameters.tangentSpaceNormalMap )
			_programLayers.enable( 13 );
		if ( parameters.clearcoat )
			_programLayers.enable( 14 );
		if ( parameters.clearcoatMap )
			_programLayers.enable( 15 );
		if ( parameters.clearcoatRoughnessMap )
			_programLayers.enable( 16 );
		if ( parameters.clearcoatNormalMap )
			_programLayers.enable( 17 );
		if ( parameters.iridescence )
			_programLayers.enable( 18 );
		if ( parameters.iridescenceMap )
			_programLayers.enable( 19 );
		if ( parameters.iridescenceThicknessMap )
			_programLayers.enable( 20 );
		if ( parameters.displacementMap )
			_programLayers.enable( 21 );
		if ( parameters.specularMap )
			_programLayers.enable( 22 );
		if ( parameters.roughnessMap )
			_programLayers.enable( 23 );
		if ( parameters.metalnessMap )
			_programLayers.enable( 24 );
		if ( parameters.gradientMap )
			_programLayers.enable( 25 );
		if ( parameters.alphaMap )
			_programLayers.enable( 26 );
		if ( parameters.alphaTest )
			_programLayers.enable( 27 );
		if ( parameters.vertexColors )
			_programLayers.enable( 28 );
		if ( parameters.vertexAlphas )
			_programLayers.enable( 29 );
		if ( parameters.vertexUvs )
			_programLayers.enable( 30 );
		if ( parameters.vertexTangents )
			_programLayers.enable( 31 );
		if ( parameters.uvsVertexOnly )
			_programLayers.enable( 32 );

		array.push( _programLayers.mask );
		_programLayers.disableAll();

		if ( parameters.fog )
			_programLayers.enable( 0 );
		if ( parameters.useFog )
			_programLayers.enable( 1 );
		if ( parameters.flatShading )
			_programLayers.enable( 2 );
		if ( parameters.logarithmicDepthBuffer )
			_programLayers.enable( 3 );
		if ( parameters.skinning )
			_programLayers.enable( 4 );
		if ( parameters.morphTargets )
			_programLayers.enable( 5 );
		if ( parameters.morphNormals )
			_programLayers.enable( 6 );
		if ( parameters.morphColors )
			_programLayers.enable( 7 );
		if ( parameters.premultipliedAlpha )
			_programLayers.enable( 8 );
		if ( parameters.shadowMapEnabled )
			_programLayers.enable( 9 );
		if ( parameters.useLegacyLights )
			_programLayers.enable( 10 );
		if ( parameters.doubleSided )
			_programLayers.enable( 11 );
		if ( parameters.flipSided )
			_programLayers.enable( 12 );
		if ( parameters.useDepthPacking )
			_programLayers.enable( 13 );
		if ( parameters.dithering )
			_programLayers.enable( 14 );
		if ( parameters.specularIntensityMap )
			_programLayers.enable( 15 );
		if ( parameters.specularColorMap )
			_programLayers.enable( 16 );
		if ( parameters.transmission )
			_programLayers.enable( 17 );
		if ( parameters.transmissionMap )
			_programLayers.enable( 18 );
		if ( parameters.thicknessMap )
			_programLayers.enable( 19 );
		if ( parameters.sheen )
			_programLayers.enable( 20 );
		if ( parameters.sheenColorMap )
			_programLayers.enable( 21 );
		if ( parameters.sheenRoughnessMap )
			_programLayers.enable( 22 );
		if ( parameters.decodeVideoTexture )
			_programLayers.enable( 23 );
		if ( parameters.opaque )
			_programLayers.enable( 24 );

		array.push( _programLayers.mask );

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	function releaseShaderCache( material ) {

		_customShaders.remove( material );

	}

	function dispose() {

		_customShaders.dispose();

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		releaseShaderCache: releaseShaderCache,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs,
		dispose: dispose
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList() {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transmissive = [];
	const transparent = [];

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.push( renderItem );

		} else if ( material.transparent === true ) {

			transparent.push( renderItem );

		} else {

			opaque.push( renderItem );

		}

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.unshift( renderItem );

		} else if ( material.transparent === true ) {

			transparent.unshift( renderItem );

		} else {

			opaque.unshift( renderItem );

		}

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists() {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		const listArray = lists.get( scene );
		let list;

		if ( listArray === undefined ) {

			list = new WebGLRenderList();
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= listArray.length ) {

				list = new WebGLRenderList();
				listArray.push( list );

			} else {

				list = listArray[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

}

function WebGLLights( extensions, capabilities ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1,
			numSpotMaps: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotLightMap: [],
		spotShadow: [],
		spotShadowMap: [],
		spotLightMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],
		numSpotLightShadowsWithMaps: 0

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights, useLegacyLights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;
		let numSpotMaps = 0;
		let numSpotShadowsWithMaps = 0;

		// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
		lights.sort( shadowCastingAndTexturingLightsFirst );

		// artist-friendly light intensity scaling factor
		const scaleFactor = ( useLegacyLights === true ) ? Math.PI : 1;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity * scaleFactor;
				g += color.g * intensity * scaleFactor;
				b += color.b * intensity * scaleFactor;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				state.spot[ spotLength ] = uniforms;

				const shadow = light.shadow;

				if ( light.map ) {

					state.spotLightMap[ numSpotMaps ] = light.map;
					numSpotMaps ++;

					// make sure the lightMatrix is up to date
					// TODO : do it if required only
					shadow.updateMatrices( light );

					if ( light.castShadow ) numSpotShadowsWithMaps ++;

				}

				state.spotLightMatrix[ spotLength ] = shadow.matrix;

				if ( light.castShadow ) {

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;

					numSpotShadows ++;

				}

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( capabilities.isWebGL2 ) {

				// WebGL 2

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				// WebGL 1

				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

				} else {

					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				}

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ||
			hash.numSpotMaps !== numSpotMaps ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
			state.spotLightMap.length = numSpotMaps;
			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;
			hash.numSpotMaps = numSpotMaps;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}

function WebGLRenderState( extensions, capabilities ) {

	const lights = new WebGLLights( extensions, capabilities );

	const lightsArray = [];
	const shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( useLegacyLights ) {

		lights.setup( lightsArray, useLegacyLights );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions, capabilities ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		const renderStateArray = renderStates.get( scene );
		let renderState;

		if ( renderStateArray === undefined ) {

			renderState = new WebGLRenderState( extensions, capabilities );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStateArray.length ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStateArray.push( renderState );

			} else {

				renderState = renderStateArray[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class MeshDepthMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshDepthMaterial = true;

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

class MeshDistanceMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshDistanceMaterial = true;

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap( _renderer, _objects, _capabilities ) {

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
		_distanceMaterial = new MeshDistanceMaterial(),

		_materialCache = {},

		_maxTextureSize = _capabilities.maxTextureSize;

	const shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {
		defines: {
			VSM_SAMPLES: 8
		},
		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vertex,
		fragmentShader: fragment

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		'position',
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				if ( _shadowMapSize.x > _maxTextureSize ) {

					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > _maxTextureSize ) {

					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null ) {

				const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = _objects.update( fullScreenMesh );

		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;

		}

		if ( shadow.mapPass === null ) {

			shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

		}

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {

		let result = null;

		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

		if ( customMaterial !== undefined ) {

			result = customMaterial;

		} else {

			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

			if ( ( _renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
				( material.displacementMap && material.displacementScale !== 0 ) ||
				( material.alphaMap && material.alphaTest > 0 ) ||
				( material.map && material.alphaTest > 0 ) ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid, keyB = material.uuid;

				let materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				let cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.alphaMap = material.alphaMap;
		result.alphaTest = material.alphaTest;
		result.map = material.map;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = _objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}

function WebGLState( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( 2929 );

				} else {

					disable( 2929 );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					switch ( depthFunc ) {

						case NeverDepth:

							gl.depthFunc( 512 );
							break;

						case AlwaysDepth:

							gl.depthFunc( 519 );
							break;

						case LessDepth:

							gl.depthFunc( 513 );
							break;

						case LessEqualDepth:

							gl.depthFunc( 515 );
							break;

						case EqualDepth:

							gl.depthFunc( 514 );
							break;

						case GreaterEqualDepth:

							gl.depthFunc( 518 );
							break;

						case GreaterDepth:

							gl.depthFunc( 516 );
							break;

						case NotEqualDepth:

							gl.depthFunc( 517 );
							break;

						default:

							gl.depthFunc( 515 );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	const uboBindings = new WeakMap();
	const uboProgramMap = new WeakMap();

	let enabledCapabilities = {};

	let currentBoundFramebuffers = {};
	let currentDrawbuffers = new WeakMap();
	let defaultDrawbuffers = [];

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( 35661 );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( 7938 );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const scissorParam = gl.getParameter( 3088 );
	const viewportParam = gl.getParameter( 2978 );

	const currentScissor = new Vector4().fromArray( scissorParam );
	const currentViewport = new Vector4().fromArray( viewportParam );

	function createTexture( type, target, count ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, 10241, 9728 );
		gl.texParameteri( type, 10240, 9728 );

		for ( let i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( 2929 );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( 2884 );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function bindFramebuffer( target, framebuffer ) {

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			if ( isWebGL2 ) {

				// 36009 is equivalent to 36160

				if ( target === 36009 ) {

					currentBoundFramebuffers[ 36160 ] = framebuffer;

				}

				if ( target === 36160 ) {

					currentBoundFramebuffers[ 36009 ] = framebuffer;

				}

			}

			return true;

		}

		return false;

	}

	function drawBuffers( renderTarget, framebuffer ) {

		let drawBuffers = defaultDrawbuffers;

		let needsUpdate = false;

		if ( renderTarget ) {

			drawBuffers = currentDrawbuffers.get( framebuffer );

			if ( drawBuffers === undefined ) {

				drawBuffers = [];
				currentDrawbuffers.set( framebuffer, drawBuffers );

			}

			if ( renderTarget.isWebGLMultipleRenderTargets ) {

				const textures = renderTarget.texture;

				if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== 36064 ) {

					for ( let i = 0, il = textures.length; i < il; i ++ ) {

						drawBuffers[ i ] = 36064 + i;

					}

					drawBuffers.length = textures.length;

					needsUpdate = true;

				}

			} else {

				if ( drawBuffers[ 0 ] !== 36064 ) {

					drawBuffers[ 0 ] = 36064;

					needsUpdate = true;

				}

			}

		} else {

			if ( drawBuffers[ 0 ] !== 1029 ) {

				drawBuffers[ 0 ] = 1029;

				needsUpdate = true;

			}

		}

		if ( needsUpdate ) {

			if ( capabilities.isWebGL2 ) {

				gl.drawBuffers( drawBuffers );

			} else {

				extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );

			}

		}


	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: 32774,
		[ SubtractEquation ]: 32778,
		[ ReverseSubtractEquation ]: 32779
	};

	if ( isWebGL2 ) {

		equationToGL[ MinEquation ] = 32775;
		equationToGL[ MaxEquation ] = 32776;

	} else {

		const extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ MinEquation ] = extension.MIN_EXT;
			equationToGL[ MaxEquation ] = extension.MAX_EXT;

		}

	}

	const factorToGL = {
		[ ZeroFactor ]: 0,
		[ OneFactor ]: 1,
		[ SrcColorFactor ]: 768,
		[ SrcAlphaFactor ]: 770,
		[ SrcAlphaSaturateFactor ]: 776,
		[ DstColorFactor ]: 774,
		[ DstAlphaFactor ]: 772,
		[ OneMinusSrcColorFactor ]: 769,
		[ OneMinusSrcAlphaFactor ]: 771,
		[ OneMinusDstColorFactor ]: 775,
		[ OneMinusDstAlphaFactor ]: 773
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled === true ) {

				disable( 3042 );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( 3042 );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( 32774 );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 1, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 1, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 769, 0, 1 );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( 0, 768, 0, 770 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 770, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 770, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 769, 0, 1 );
							break;

						case MultiplyBlending:
							gl.blendFunc( 0, 768 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = false;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( 2884 )
			: enable( 2884 );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true
			? enable( 32926 )
			: disable( 32926 );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( 2304 );

			} else {

				gl.frontFace( 2305 );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( 2884 );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( 1029 );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( 1028 );

				} else {

					gl.cullFace( 1032 );

				}

			}

		} else {

			disable( 2884 );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( 32823 );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( 32823 );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( 3089 );

		} else {

			disable( 3089 );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture, webglSlot ) {

		if ( webglSlot === undefined ) {

			if ( currentTextureSlot === null ) {

				webglSlot = 33984 + maxTextures - 1;

			} else {

				webglSlot = currentTextureSlot;

			}

		}

		let boundTexture = currentBoundTextures[ webglSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ webglSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexImage3D() {

		try {

			gl.compressedTexImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage2D() {

		try {

			gl.texSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage3D() {

		try {

			gl.texSubImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexSubImage2D() {

		try {

			gl.compressedTexSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexSubImage3D() {

		try {

			gl.compressedTexSubImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage2D() {

		try {

			gl.texStorage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage3D() {

		try {

			gl.texStorage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	function updateUBOMapping( uniformsGroup, program ) {

		let mapping = uboProgramMap.get( program );

		if ( mapping === undefined ) {

			mapping = new WeakMap();

			uboProgramMap.set( program, mapping );

		}

		let blockIndex = mapping.get( uniformsGroup );

		if ( blockIndex === undefined ) {

			blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

			mapping.set( uniformsGroup, blockIndex );

		}

	}

	function uniformBlockBinding( uniformsGroup, program ) {

		const mapping = uboProgramMap.get( program );
		const blockIndex = mapping.get( uniformsGroup );

		if ( uboBindings.get( program ) !== blockIndex ) {

			// bind shader specific block index to global block point
			gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

			uboBindings.set( program, blockIndex );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( 3042 );
		gl.disable( 2884 );
		gl.disable( 2929 );
		gl.disable( 32823 );
		gl.disable( 3089 );
		gl.disable( 2960 );
		gl.disable( 32926 );

		gl.blendEquation( 32774 );
		gl.blendFunc( 1, 0 );
		gl.blendFuncSeparate( 1, 0, 1, 0 );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( 513 );
		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( 519, 0, 0xffffffff );
		gl.stencilOp( 7680, 7680, 7680 );
		gl.clearStencil( 0 );

		gl.cullFace( 1029 );
		gl.frontFace( 2305 );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( 33984 );

		gl.bindFramebuffer( 36160, null );

		if ( isWebGL2 === true ) {

			gl.bindFramebuffer( 36009, null );
			gl.bindFramebuffer( 36008, null );

		}

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBoundFramebuffers = {};
		currentDrawbuffers = new WeakMap();
		defaultDrawbuffers = [];

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		bindFramebuffer: bindFramebuffer,
		drawBuffers: drawBuffers,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		compressedTexImage3D: compressedTexImage3D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		updateUBOMapping: updateUBOMapping,
		uniformBlockBinding: uniformBlockBinding,

		texStorage2D: texStorage2D,
		texStorage3D: texStorage3D,
		texSubImage2D: texSubImage2D,
		texSubImage3D: texSubImage3D,
		compressedTexSubImage2D: compressedTexSubImage2D,
		compressedTexSubImage3D: compressedTexSubImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;
	const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
	const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

	const _videoTextures = new WeakMap();
	let _canvas;

	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			// eslint-disable-next-line compat/compat
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			// eslint-disable-next-line compat/compat
			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		let scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

				const width = floor( scale * image.width );
				const height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo$1( image ) {

		return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target ) {

		_gl.generateMipmap( target );

	}

	function getInternalFormat( internalFormatName, glFormat, glType, encoding, forceLinearEncoding = false ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === 6403 ) {

			if ( glType === 5126 ) internalFormat = 33326;
			if ( glType === 5131 ) internalFormat = 33325;
			if ( glType === 5121 ) internalFormat = 33321;

		}

		if ( glFormat === 33319 ) {

			if ( glType === 5126 ) internalFormat = 33328;
			if ( glType === 5131 ) internalFormat = 33327;
			if ( glType === 5121 ) internalFormat = 33323;

		}

		if ( glFormat === 6408 ) {

			if ( glType === 5126 ) internalFormat = 34836;
			if ( glType === 5131 ) internalFormat = 34842;
			if ( glType === 5121 ) internalFormat = ( encoding === sRGBEncoding && forceLinearEncoding === false ) ? 35907 : 32856;
			if ( glType === 32819 ) internalFormat = 32854;
			if ( glType === 32820 ) internalFormat = 32855;

		}

		if ( internalFormat === 33325 || internalFormat === 33326 ||
			internalFormat === 33327 || internalFormat === 33328 ||
			internalFormat === 34842 || internalFormat === 34836 ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	function getMipLevels( texture, image, supportsMips ) {

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

			return Math.log2( Math.max( image.width, image.height ) ) + 1;

		} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

			// user-defined mipmaps

			return texture.mipmaps.length;

		} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

			return image.mipmaps.length;

		} else {

			// texture without mipmaps (only base level)

			return 1;

		}

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return 9728;

		}

		return 9729;

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		// check if it's necessary to remove the WebGLTexture object

		const source = texture.source;
		const webglTextures = _sources.get( source );

		if ( webglTextures ) {

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];
			webglTexture.usedTimes --;

			// the WebGLTexture object is not used anymore, remove it

			if ( webglTexture.usedTimes === 0 ) {

				deleteTexture( texture );

			}

			// remove the weak map entry if no WebGLTexture uses the source anymore

			if ( Object.keys( webglTextures ).length === 0 ) {

				_sources.delete( source );

			}

		}

		properties.remove( texture );

	}

	function deleteTexture( texture ) {

		const textureProperties = properties.get( texture );
		_gl.deleteTexture( textureProperties.__webglTexture );

		const source = texture.source;
		const webglTextures = _sources.get( source );
		delete webglTextures[ textureProperties.__cacheKey ];

		info.memory.textures --;

	}

	function deallocateRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

			info.memory.textures --;

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

			if ( renderTargetProperties.__webglColorRenderbuffer ) {

				for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

					if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

			}

			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		if ( renderTarget.isWebGLMultipleRenderTargets ) {

			for ( let i = 0, il = texture.length; i < il; i ++ ) {

				const attachmentProperties = properties.get( texture[ i ] );

				if ( attachmentProperties.__webglTexture ) {

					_gl.deleteTexture( attachmentProperties.__webglTexture );

					info.memory.textures --;

				}

				properties.remove( texture[ i ] );

			}

		}

		properties.remove( texture );
		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	function getTextureCacheKey( texture ) {

		const array = [];

		array.push( texture.wrapS );
		array.push( texture.wrapT );
		array.push( texture.wrapR || 0 );
		array.push( texture.magFilter );
		array.push( texture.minFilter );
		array.push( texture.anisotropy );
		array.push( texture.internalFormat );
		array.push( texture.format );
		array.push( texture.type );
		array.push( texture.generateMipmaps );
		array.push( texture.premultiplyAlpha );
		array.push( texture.flipY );
		array.push( texture.unpackAlignment );
		array.push( texture.encoding );

		return array.join();

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === null ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.bindTexture( 3553, textureProperties.__webglTexture, 33984 + slot );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( 35866, textureProperties.__webglTexture, 33984 + slot );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( 32879, textureProperties.__webglTexture, 33984 + slot );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( 34067, textureProperties.__webglTexture, 33984 + slot );

	}

	const wrappingToGL = {
		[ RepeatWrapping ]: 10497,
		[ ClampToEdgeWrapping ]: 33071,
		[ MirroredRepeatWrapping ]: 33648
	};

	const filterToGL = {
		[ NearestFilter ]: 9728,
		[ NearestMipmapNearestFilter ]: 9984,
		[ NearestMipmapLinearFilter ]: 9986,

		[ LinearFilter ]: 9729,
		[ LinearMipmapNearestFilter ]: 9985,
		[ LinearMipmapLinearFilter ]: 9987
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, 10242, 33071 );
			_gl.texParameteri( textureType, 10243, 33071 );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, 33071 );

			}

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( texture.magFilter === NearestFilter ) return;
			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
			if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		let forceUpload = false;

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

		}

		// create Source <-> WebGLTextures mapping if necessary

		const source = texture.source;
		let webglTextures = _sources.get( source );

		if ( webglTextures === undefined ) {

			webglTextures = {};
			_sources.set( source, webglTextures );

		}

		// check if there is already a WebGLTexture object for the given texture parameters

		const textureCacheKey = getTextureCacheKey( texture );

		if ( textureCacheKey !== textureProperties.__cacheKey ) {

			// if not, create a new instance of WebGLTexture

			if ( webglTextures[ textureCacheKey ] === undefined ) {

				// create new entry

				webglTextures[ textureCacheKey ] = {
					texture: _gl.createTexture(),
					usedTimes: 0
				};

				info.memory.textures ++;

				// when a new instance of WebGLTexture was created, a texture upload is required
				// even if the image contents are identical

				forceUpload = true;

			}

			webglTextures[ textureCacheKey ].usedTimes ++;

			// every time the texture cache key changes, it's necessary to check if an instance of
			// WebGLTexture can be deleted in order to avoid a memory leak.

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];

			if ( webglTexture !== undefined ) {

				webglTextures[ textureProperties.__cacheKey ].usedTimes --;

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

			}

			// store references to cache key and WebGLTexture object

			textureProperties.__cacheKey = textureCacheKey;
			textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

		}

		return forceUpload;

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = 3553;

		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = 35866;
		if ( texture.isData3DTexture ) textureType = 32879;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.bindTexture( textureType, textureProperties.__webglTexture, 33984 + slot );

		const sourceProperties = properties.get( source );

		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

			state.activeTexture( 33984 + slot );

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );
			_gl.pixelStorei( 37443, 0 );

			const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
			let image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
			image = verifyColorSpace( texture, image );

			const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
				glFormat = utils.convert( texture.format, texture.encoding );

			let glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture );

			setTextureParameters( textureType, texture, supportsMips );

			let mipmap;
			const mipmaps = texture.mipmaps;

			const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
			const levels = getMipLevels( texture, image, supportsMips );

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = 6402;

				if ( isWebGL2 ) {

					if ( texture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( texture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					} else if ( texture.type === UnsignedInt248Type ) {

						glInternalFormat = 35056;

					} else {

						glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

					}

				} else {

					if ( texture.type === FloatType ) {

						console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

					}

				}

				// validation checks for WebGL 1

				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedIntType;
						glType = utils.convert( texture.type );

					}

				}

				if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = 34041;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				//

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( 3553, 1, glInternalFormat, image.width, image.height );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

					}

				}

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

						} else {

							state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

						}

						state.texSubImage2D( 3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

					}

				}

			} else if ( texture.isCompressedTexture ) {

				if ( texture.isCompressedArrayTexture ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage3D( 35866, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									state.compressedTexSubImage3D( 35866, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );

								} else {

									state.compressedTexImage3D( 35866, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage3D( 35866, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

							} else {

								state.texImage3D( 35866, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				} else {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									state.compressedTexSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

								} else {

									state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else if ( texture.isDataArrayTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( 35866, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					state.texSubImage3D( 35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

				} else {

					state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isData3DTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( 32879, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					state.texSubImage3D( 32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

				} else {

					state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isFramebufferTexture ) {

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

					} else {

						let width = image.width, height = image.height;

						for ( let i = 0; i < levels; i ++ ) {

							state.texImage2D( 3553, i, glInternalFormat, width, height, 0, glFormat, glType, null );

							width >>= 1;
							height >>= 1;

						}

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							state.texSubImage2D( 3553, i, 0, 0, glFormat, glType, mipmap );

						} else {

							state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

						}

						state.texSubImage2D( 3553, 0, 0, 0, glFormat, glType, image );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( textureType );

			}

			sourceProperties.__version = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.bindTexture( 34067, textureProperties.__webglTexture, 33984 + slot );

		const sourceProperties = properties.get( source );

		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

			state.activeTexture( 33984 + slot );

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );
			_gl.pixelStorei( 37443, 0 );

			const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			const cubeImage = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

				cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

			}

			const image = cubeImage[ 0 ],
				supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
				glFormat = utils.convert( texture.format, texture.encoding ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

			const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
			let levels = getMipLevels( texture, image, supportsMips );

			setTextureParameters( 34067, texture, supportsMips );

			let mipmaps;

			if ( isCompressed ) {

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( 34067, levels, glInternalFormat, image.width, image.height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									state.compressedTexSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

								} else {

									state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else {

				mipmaps = texture.mipmaps;

				if ( useTexStorage && allocateMemory ) {

					// TODO: Uniformly handle mipmap definitions
					// Normal textures and compressed cube textures define base level + mips with their mipmap array
					// Uncompressed cube textures use their mipmap array only for mips (no base level)

					if ( mipmaps.length > 0 ) levels ++;

					state.texStorage2D( 34067, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						if ( useTexStorage ) {

							state.texSubImage2D( 34069 + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];
							const mipmapImage = mipmap.image[ i ].image;

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

							} else {

								state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

							}

						}

					} else {

						if ( useTexStorage ) {

							state.texSubImage2D( 34069 + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

						} else {

							state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

							} else {

								state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

							}

						}

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( 34067 );

			}

			sourceProperties.__version = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

		const glFormat = utils.convert( texture.format, texture.encoding );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
		const renderTargetProperties = properties.get( renderTarget );

		if ( ! renderTargetProperties.__hasExternalTextures ) {

			if ( textureTarget === 32879 || textureTarget === 35866 ) {

				state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

			} else {

				state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

			}

		}

		state.bindFramebuffer( 36160, framebuffer );

		if ( useMultisampledRTT( renderTarget ) ) {

			multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

		} else if ( textureTarget === 3553 || ( textureTarget >= 34069 && textureTarget <= 34074 ) ) { // see #24753

			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );

		}

		state.bindFramebuffer( 36160, null );

	}


	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( 36161, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = 33189;

			if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			const samples = getRenderTargetSamples( renderTarget );

			if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		} else {

			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				const glFormat = utils.convert( texture.format, texture.encoding );
				const glType = utils.convert( texture.type );
				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

		}

		_gl.bindRenderbuffer( 36161, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		state.bindFramebuffer( 36160, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
		const samples = getRenderTargetSamples( renderTarget );

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 36096, 3553, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

			}

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 33306, 3553, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

			}

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );
		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		state.bindFramebuffer( 36160, null );

	}

	// rebind framebuffer with external textures
	function rebindTextures( renderTarget, colorTexture, depthTexture ) {

		const renderTargetProperties = properties.get( renderTarget );

		if ( colorTexture !== undefined ) {

			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553 );

		}

		if ( depthTexture !== undefined ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

			if ( textureProperties.__webglTexture === undefined ) {

				textureProperties.__webglTexture = _gl.createTexture();

			}

			textureProperties.__version = texture.version;
			info.memory.textures ++;

		}

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultipleRenderTargets ) {

				if ( capabilities.drawBuffers ) {

					const textures = renderTarget.texture;

					for ( let i = 0, il = textures.length; i < il; i ++ ) {

						const attachmentProperties = properties.get( textures[ i ] );

						if ( attachmentProperties.__webglTexture === undefined ) {

							attachmentProperties.__webglTexture = _gl.createTexture();

							info.memory.textures ++;

						}

					}

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

				}

			}

			if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				const textures = isMultipleRenderTargets ? texture : [ texture ];

				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
				renderTargetProperties.__webglColorRenderbuffer = [];

				state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					const texture = textures[ i ];
					renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					const glFormat = utils.convert( texture.format, texture.encoding );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding, renderTarget.isXRRenderTarget === true );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

				_gl.bindRenderbuffer( 36161, null );

				if ( renderTarget.depthBuffer ) {

					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

				}

				state.bindFramebuffer( 36160, null );

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( 34067, textureProperties.__webglTexture );
			setTextureParameters( 34067, texture, supportsMips );

			for ( let i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 34067 );

			}

			state.unbindTexture();

		} else if ( isMultipleRenderTargets ) {

			const textures = renderTarget.texture;

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const attachment = textures[ i ];
				const attachmentProperties = properties.get( attachment );

				state.bindTexture( 3553, attachmentProperties.__webglTexture );
				setTextureParameters( 3553, attachment, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

				if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

					generateMipmap( 3553 );

				}

			}

			state.unbindTexture();

		} else {

			let glTextureType = 3553;

			if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

				if ( isWebGL2 ) {

					glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;

				} else {

					console.error( 'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.' );

				}

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( glTextureType );

			}

			state.unbindTexture();

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
				const webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target );
				state.unbindTexture();

			}

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

			const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [ renderTarget.texture ];
			const width = renderTarget.width;
			const height = renderTarget.height;
			let mask = 16384;
			const invalidationArray = [];
			const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
			const renderTargetProperties = properties.get( renderTarget );
			const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );

			// If MRT we need to remove FBO attachments
			if ( isMultipleRenderTargets ) {

				for ( let i = 0; i < textures.length; i ++ ) {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, null );

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					_gl.framebufferTexture2D( 36009, 36064 + i, 3553, null, 0 );

				}

			}

			state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
			state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

			for ( let i = 0; i < textures.length; i ++ ) {

				invalidationArray.push( 36064 + i );

				if ( renderTarget.depthBuffer ) {

					invalidationArray.push( depthStyle );

				}

				const ignoreDepthValues = ( renderTargetProperties.__ignoreDepthValues !== undefined ) ? renderTargetProperties.__ignoreDepthValues : false;

				if ( ignoreDepthValues === false ) {

					if ( renderTarget.depthBuffer ) mask |= 256;
					if ( renderTarget.stencilBuffer ) mask |= 1024;

				}

				if ( isMultipleRenderTargets ) {

					_gl.framebufferRenderbuffer( 36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

				if ( ignoreDepthValues === true ) {

					_gl.invalidateFramebuffer( 36008, [ depthStyle ] );
					_gl.invalidateFramebuffer( 36009, [ depthStyle ] );

				}

				if ( isMultipleRenderTargets ) {

					const webglTexture = properties.get( textures[ i ] ).__webglTexture;
					_gl.framebufferTexture2D( 36009, 36064, 3553, webglTexture, 0 );

				}

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				if ( supportsInvalidateFramebuffer ) {

					_gl.invalidateFramebuffer( 36008, invalidationArray );

				}


			}

			state.bindFramebuffer( 36008, null );
			state.bindFramebuffer( 36009, null );

			// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
			if ( isMultipleRenderTargets ) {

				for ( let i = 0; i < textures.length; i ++ ) {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					const webglTexture = properties.get( textures[ i ] ).__webglTexture;

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					_gl.framebufferTexture2D( 36009, 36064 + i, 3553, webglTexture, 0 );

				}

			}

			state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return Math.min( maxSamples, renderTarget.samples );

	}

	function useMultisampledRTT( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		return isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	function verifyColorSpace( texture, image ) {

		const encoding = texture.encoding;
		const format = texture.format;
		const type = texture.type;

		if ( texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat ) return image;

		if ( encoding !== LinearEncoding ) {

			// sRGB

			if ( encoding === sRGBEncoding ) {

				if ( isWebGL2 === false ) {

					// in WebGL 1, try to use EXT_sRGB extension and unsized formats

					if ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {

						texture.format = _SRGBAFormat;

						// it's not possible to generate mips in WebGL 1 with this extension

						texture.minFilter = LinearFilter;
						texture.generateMipmaps = false;

					} else {

						// slow fallback (CPU decode)

						image = ImageUtils.sRGBToLinear( image );

					}

				} else {

					// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

					if ( format !== RGBAFormat || type !== UnsignedByteType ) {

						console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

					}

				}

			} else {

				console.error( 'THREE.WebGLTextures: Unsupported texture encoding:', encoding );

			}

		}

		return image;

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.rebindTextures = rebindTextures;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
	this.setupFrameBufferTexture = setupFrameBufferTexture;
	this.useMultisampledRTT = useMultisampledRTT;

}

function WebGLUtils( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function convert( p, encoding = null ) {

		let extension;

		if ( p === UnsignedByteType ) return 5121;
		if ( p === UnsignedShort4444Type ) return 32819;
		if ( p === UnsignedShort5551Type ) return 32820;

		if ( p === ByteType ) return 5120;
		if ( p === ShortType ) return 5122;
		if ( p === UnsignedShortType ) return 5123;
		if ( p === IntType ) return 5124;
		if ( p === UnsignedIntType ) return 5125;
		if ( p === FloatType ) return 5126;

		if ( p === HalfFloatType ) {

			if ( isWebGL2 ) return 5131;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === AlphaFormat ) return 6406;
		if ( p === RGBAFormat ) return 6408;
		if ( p === LuminanceFormat ) return 6409;
		if ( p === LuminanceAlphaFormat ) return 6410;
		if ( p === DepthFormat ) return 6402;
		if ( p === DepthStencilFormat ) return 34041;

		// WebGL 1 sRGB fallback

		if ( p === _SRGBAFormat ) {

			extension = extensions.get( 'EXT_sRGB' );

			if ( extension !== null ) {

				return extension.SRGB_ALPHA_EXT;

			} else {

				return null;

			}

		}

		// WebGL2 formats.

		if ( p === RedFormat ) return 6403;
		if ( p === RedIntegerFormat ) return 36244;
		if ( p === RGFormat ) return 33319;
		if ( p === RGIntegerFormat ) return 33320;
		if ( p === RGBAIntegerFormat ) return 36249;

		// S3TC

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			if ( encoding === sRGBEncoding ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			} else {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

		}

		// PVRTC

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		// ETC1

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		// ETC2

		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC2_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

			} else {

				return null;

			}

		}

		// ASTC

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				if ( p === RGBA_ASTC_4x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if ( p === RGBA_ASTC_5x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if ( p === RGBA_ASTC_5x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if ( p === RGBA_ASTC_6x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if ( p === RGBA_ASTC_6x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if ( p === RGBA_ASTC_8x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if ( p === RGBA_ASTC_8x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if ( p === RGBA_ASTC_8x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if ( p === RGBA_ASTC_10x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if ( p === RGBA_ASTC_10x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if ( p === RGBA_ASTC_10x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if ( p === RGBA_ASTC_10x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if ( p === RGBA_ASTC_12x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if ( p === RGBA_ASTC_12x12_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

			} else {

				return null;

			}

		}

		// BPTC

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

			} else {

				return null;

			}

		}

		// RGTC

		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

			extension = extensions.get( 'EXT_texture_compression_rgtc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

			} else {

				return null;

			}

		}

		//

		if ( p === UnsignedInt248Type ) {

			if ( isWebGL2 ) return 34042;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

	}

	return { convert: convert };

}

class ArrayCamera extends PerspectiveCamera {

	constructor( array = [] ) {

		super();

		this.isArrayCamera = true;

		this.cameras = array;

	}

}

class Group extends Object3D {

	constructor() {

		super();

		this.isGroup = true;

		this.type = 'Group';

	}

}

const _moveEvent = { type: 'move' };

class WebXRController {

	constructor() {

		this._targetRay = null;
		this._grip = null;
		this._hand = null;

	}

	getHandSpace() {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	}

	getTargetRaySpace() {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();

		}

		return this._targetRay;

	}

	getGripSpace() {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();

		}

		return this._grip;

	}

	dispatchEvent( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	}

	connect( inputSource ) {

		if ( inputSource && inputSource.hand ) {

			const hand = this._hand;

			if ( hand ) {

				for ( const inputjoint of inputSource.hand.values() ) {

					// Initialize hand with joints when connected
					this._getHandJoint( hand, inputjoint );

				}

			}

		}

		this.dispatchEvent( { type: 'connected', data: inputSource } );

		return this;

	}

	disconnect( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	}

	update( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					// The transform of this joint will be updated with the joint pose on each frame
					const joint = this._getHandJoint( hand, inputjoint );

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

						if ( gripPose.linearVelocity ) {

							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy( gripPose.linearVelocity );

						} else {

							grip.hasLinearVelocity = false;

						}

						if ( gripPose.angularVelocity ) {

							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy( gripPose.angularVelocity );

						} else {

							grip.hasAngularVelocity = false;

						}

					}

				}

			}

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
				if ( inputPose === null && gripPose !== null ) {

					inputPose = gripPose;

				}

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

					if ( inputPose.linearVelocity ) {

						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy( inputPose.linearVelocity );

					} else {

						targetRay.hasLinearVelocity = false;

					}

					if ( inputPose.angularVelocity ) {

						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy( inputPose.angularVelocity );

					} else {

						targetRay.hasAngularVelocity = false;

					}

					this.dispatchEvent( _moveEvent );

				}

			}


		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

	// private method

	_getHandJoint( hand, inputjoint ) {

		if ( hand.joints[ inputjoint.jointName ] === undefined ) {

			const joint = new Group();
			joint.matrixAutoUpdate = false;
			joint.visible = false;
			hand.joints[ inputjoint.jointName ] = joint;

			hand.add( joint );

		}

		return hand.joints[ inputjoint.jointName ];

	}

}

class DepthTexture extends Texture {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isDepthTexture = true;

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps = false;

	}


}

class WebXRManager extends EventDispatcher {

	constructor( renderer, gl ) {

		super();

		const scope = this;

		let session = null;
		let framebufferScaleFactor = 1.0;

		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';
		// Set default foveation to maximum.
		let foveation = 1.0;
		let customReferenceSpace = null;

		let pose = null;
		let glBinding = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let xrFrame = null;
		const attributes = gl.getContextAttributes();
		let initialRenderTarget = null;
		let newRenderTarget = null;

		const controllers = [];
		const controllerInputSources = [];

		const planes = new Set();
		const planesLastChangedTimes = new Map();

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		const cameras = [ cameraL, cameraR ];

		const cameraVR = new ArrayCamera();
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.cameraAutoUpdate = true;
		this.enabled = false;

		this.isPresenting = false;

		this.getController = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		this.getControllerGrip = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		this.getHand = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			const controllerIndex = controllerInputSources.indexOf( event.inputSource );

			if ( controllerIndex === - 1 ) {

				return;

			}

			const controller = controllers[ controllerIndex ];

			if ( controller !== undefined ) {

				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			session.removeEventListener( 'select', onSessionEvent );
			session.removeEventListener( 'selectstart', onSessionEvent );
			session.removeEventListener( 'selectend', onSessionEvent );
			session.removeEventListener( 'squeeze', onSessionEvent );
			session.removeEventListener( 'squeezestart', onSessionEvent );
			session.removeEventListener( 'squeezeend', onSessionEvent );
			session.removeEventListener( 'end', onSessionEnd );
			session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

			for ( let i = 0; i < controllers.length; i ++ ) {

				const inputSource = controllerInputSources[ i ];

				if ( inputSource === null ) continue;

				controllerInputSources[ i ] = null;

				controllers[ i ].disconnect( inputSource );

			}

			_currentDepthNear = null;
			_currentDepthFar = null;

			// restore framebuffer/rendering state

			renderer.setRenderTarget( initialRenderTarget );

			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;
			newRenderTarget = null;

			//

			animation.stop();

			scope.isPresenting = false;

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		this.getReferenceSpace = function () {

			return customReferenceSpace || referenceSpace;

		};

		this.setReferenceSpace = function ( space ) {

			customReferenceSpace = space;

		};

		this.getBaseLayer = function () {

			return glProjLayer !== null ? glProjLayer : glBaseLayer;

		};

		this.getBinding = function () {

			return glBinding;

		};

		this.getFrame = function () {

			return xrFrame;

		};

		this.getSession = function () {

			return session;

		};

		this.setSession = async function ( value ) {

			session = value;

			if ( session !== null ) {

				initialRenderTarget = renderer.getRenderTarget();

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				if ( attributes.xrCompatible !== true ) {

					await gl.makeXRCompatible();

				}

				if ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {

					const layerInit = {
						antialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,
						alpha: attributes.alpha,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};

					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

					session.updateRenderState( { baseLayer: glBaseLayer } );

					newRenderTarget = new WebGLRenderTarget(
						glBaseLayer.framebufferWidth,
						glBaseLayer.framebufferHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							encoding: renderer.outputEncoding,
							stencilBuffer: attributes.stencil
						}
					);

				} else {

					let depthFormat = null;
					let depthType = null;
					let glDepthFormat = null;

					if ( attributes.depth ) {

						glDepthFormat = attributes.stencil ? 35056 : 33190;
						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

					}

					const projectionlayerInit = {
						colorFormat: 32856,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};

					glBinding = new XRWebGLBinding( session, gl );

					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

					session.updateRenderState( { layers: [ glProjLayer ] } );

					newRenderTarget = new WebGLRenderTarget(
						glProjLayer.textureWidth,
						glProjLayer.textureHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
							stencilBuffer: attributes.stencil,
							encoding: renderer.outputEncoding,
							samples: attributes.antialias ? 4 : 0
						} );

					const renderTargetProperties = renderer.properties.get( newRenderTarget );
					renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;

				}

				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

				this.setFoveation( foveation );

				customReferenceSpace = null;
				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

		};

		function onInputSourcesChange( event ) {

			// Notify disconnected

			for ( let i = 0; i < event.removed.length; i ++ ) {

				const inputSource = event.removed[ i ];
				const index = controllerInputSources.indexOf( inputSource );

				if ( index >= 0 ) {

					controllerInputSources[ index ] = null;
					controllers[ index ].disconnect( inputSource );

				}

			}

			// Notify connected

			for ( let i = 0; i < event.added.length; i ++ ) {

				const inputSource = event.added[ i ];

				let controllerIndex = controllerInputSources.indexOf( inputSource );

				if ( controllerIndex === - 1 ) {

					// Assign input source a controller that currently has no input source

					for ( let i = 0; i < controllers.length; i ++ ) {

						if ( i >= controllerInputSources.length ) {

							controllerInputSources.push( inputSource );
							controllerIndex = i;
							break;

						} else if ( controllerInputSources[ i ] === null ) {

							controllerInputSources[ i ] = inputSource;
							controllerIndex = i;
							break;

						}

					}

					// If all controllers do currently receive input we ignore new ones

					if ( controllerIndex === - 1 ) break;

				}

				const controller = controllers[ controllerIndex ];

				if ( controller ) {

					controller.connect( inputSource );

				}

			}

		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			const ipd = cameraLPos.distanceTo( cameraRPos );

			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / ( - leftFov + rightFov );
			const xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + ( ipd - xOffset );
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;

			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		this.updateCamera = function ( camera ) {

			if ( session === null ) return;

			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;

			if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				} );

				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;

			}

			const parent = camera.parent;
			const cameras = cameraVR.cameras;

			updateCamera( cameraVR, parent );

			for ( let i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );

			// update user camera and its children

			camera.matrix.copy( cameraVR.matrix );
			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );

			const children = camera.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( true );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

		};

		this.getCamera = function () {

			return cameraVR;

		};

		this.getFoveation = function () {

			if ( glProjLayer === null && glBaseLayer === null ) {

				return undefined;

			}

			return foveation;

		};

		this.setFoveation = function ( value ) {

			// 0 = no foveation = full resolution
			// 1 = maximum foveation = the edges render at lower resolution

			foveation = value;

			if ( glProjLayer !== null ) {

				glProjLayer.fixedFoveation = value;

			}

			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

				glBaseLayer.fixedFoveation = value;

			}

		};

		this.getPlanes = function () {

			return planes;

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
			xrFrame = frame;

			if ( pose !== null ) {

				const views = pose.views;

				if ( glBaseLayer !== null ) {

					renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
					renderer.setRenderTarget( newRenderTarget );

				}

				let cameraVRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraVR's camera list

				if ( views.length !== cameraVR.cameras.length ) {

					cameraVR.cameras.length = 0;
					cameraVRNeedsUpdate = true;

				}

				for ( let i = 0; i < views.length; i ++ ) {

					const view = views[ i ];

					let viewport = null;

					if ( glBaseLayer !== null ) {

						viewport = glBaseLayer.getViewport( view );

					} else {

						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
						viewport = glSubImage.viewport;

						// For side-by-side projection, we only produce a single texture for both eyes.
						if ( i === 0 ) {

							renderer.setRenderTargetTextures(
								newRenderTarget,
								glSubImage.colorTexture,
								glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

							renderer.setRenderTarget( newRenderTarget );

						}

					}

					let camera = cameras[ i ];

					if ( camera === undefined ) {

						camera = new PerspectiveCamera();
						camera.layers.enable( i );
						camera.viewport = new Vector4();
						cameras[ i ] = camera;

					}

					camera.matrix.fromArray( view.transform.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

					}

					if ( cameraVRNeedsUpdate === true ) {

						cameraVR.cameras.push( camera );

					}

				}

			}

			//

			for ( let i = 0; i < controllers.length; i ++ ) {

				const inputSource = controllerInputSources[ i ];
				const controller = controllers[ i ];

				if ( inputSource !== null && controller !== undefined ) {

					controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

				}

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

			if ( frame.detectedPlanes ) {

				scope.dispatchEvent( { type: 'planesdetected', data: frame.detectedPlanes } );

				let planesToRemove = null;

				for ( const plane of planes ) {

					if ( ! frame.detectedPlanes.has( plane ) ) {

						if ( planesToRemove === null ) {

							planesToRemove = [];

						}

						planesToRemove.push( plane );

					}

				}

				if ( planesToRemove !== null ) {

					for ( const plane of planesToRemove ) {

						planes.delete( plane );
						planesLastChangedTimes.delete( plane );
						scope.dispatchEvent( { type: 'planeremoved', data: plane } );

					}

				}

				for ( const plane of frame.detectedPlanes ) {

					if ( ! planes.has( plane ) ) {

						planes.add( plane );
						planesLastChangedTimes.set( plane, frame.lastChangedTime );
						scope.dispatchEvent( { type: 'planeadded', data: plane } );

					} else {

						const lastKnownTime = planesLastChangedTimes.get( plane );

						if ( plane.lastChangedTime > lastKnownTime ) {

							planesLastChangedTimes.set( plane, plane.lastChangedTime );
							scope.dispatchEvent( { type: 'planechanged', data: plane } );

						}

					}

				}

			}

			xrFrame = null;

		}

		const animation = new WebGLAnimation();

		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

}

function WebGLMaterials( renderer, properties ) {

	function refreshFogUniforms( uniforms, fog ) {

		fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsStandard( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;

			// artist-friendly light intensity scaling factor
			const scaleFactor = ( renderer.useLegacyLights === true ) ? Math.PI : 1;

			uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map
		// 13. iridescence map
		// 14. iridescence thickness map
		// 15. specular intensity map
		// 16. specular tint map
		// 17. transmission map
		// 18. thickness map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		} else if ( material.clearcoatMap ) {

			uvScaleMap = material.clearcoatMap;

		} else if ( material.clearcoatNormalMap ) {

			uvScaleMap = material.clearcoatNormalMap;

		} else if ( material.clearcoatRoughnessMap ) {

			uvScaleMap = material.clearcoatRoughnessMap;

		} else if ( material.iridescenceMap ) {

			uvScaleMap = material.iridescenceMap;

		} else if ( material.iridescenceThicknessMap ) {

			uvScaleMap = material.iridescenceThicknessMap;

		} else if ( material.specularIntensityMap ) {

			uvScaleMap = material.specularIntensityMap;

		} else if ( material.specularColorMap ) {

			uvScaleMap = material.specularColorMap;

		} else if ( material.transmissionMap ) {

			uvScaleMap = material.transmissionMap;

		} else if ( material.thicknessMap ) {

			uvScaleMap = material.thicknessMap;

		} else if ( material.sheenColorMap ) {

			uvScaleMap = material.sheenColorMap;

		} else if ( material.sheenRoughnessMap ) {

			uvScaleMap = material.sheenRoughnessMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

		uniforms.ior.value = material.ior; // also part of uniforms common

		if ( material.sheen > 0 ) {

			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

			uniforms.sheenRoughness.value = material.sheenRoughness;

			if ( material.sheenColorMap ) {

				uniforms.sheenColorMap.value = material.sheenColorMap;

			}

			if ( material.sheenRoughnessMap ) {

				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

			}

		}

		if ( material.clearcoat > 0 ) {

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

		}

		if ( material.iridescence > 0 ) {

			uniforms.iridescence.value = material.iridescence;
			uniforms.iridescenceIOR.value = material.iridescenceIOR;
			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

			if ( material.iridescenceMap ) {

				uniforms.iridescenceMap.value = material.iridescenceMap;

			}

			if ( material.iridescenceThicknessMap ) {

				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

			}

		}

		if ( material.transmission > 0 ) {

			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

			}

			uniforms.thickness.value = material.thickness;

			if ( material.thicknessMap ) {

				uniforms.thicknessMap.value = material.thicknessMap;

			}

			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy( material.attenuationColor );

		}

		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy( material.specularColor );

		if ( material.specularIntensityMap ) {

			uniforms.specularIntensityMap.value = material.specularIntensityMap;

		}

		if ( material.specularColorMap ) {

			uniforms.specularColorMap.value = material.specularColorMap;

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function WebGLUniformsGroups( gl, info, capabilities, state ) {

	let buffers = {};
	let updateList = {};
	let allocatedBindingPoints = [];

	const maxBindingPoints = ( capabilities.isWebGL2 ) ? gl.getParameter( 35375 ) : 0; // binding points are global whereas block indices are per shader program

	function bind( uniformsGroup, program ) {

		const webglProgram = program.program;
		state.uniformBlockBinding( uniformsGroup, webglProgram );

	}

	function update( uniformsGroup, program ) {

		let buffer = buffers[ uniformsGroup.id ];

		if ( buffer === undefined ) {

			prepareUniformsGroup( uniformsGroup );

			buffer = createBuffer( uniformsGroup );
			buffers[ uniformsGroup.id ] = buffer;

			uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

		}

		// ensure to update the binding points/block indices mapping for this program

		const webglProgram = program.program;
		state.updateUBOMapping( uniformsGroup, webglProgram );

		// update UBO once per frame

		const frame = info.render.frame;

		if ( updateList[ uniformsGroup.id ] !== frame ) {

			updateBufferData( uniformsGroup );

			updateList[ uniformsGroup.id ] = frame;

		}

	}

	function createBuffer( uniformsGroup ) {

		// the setup of an UBO is independent of a particular shader program but global

		const bindingPointIndex = allocateBindingPointIndex();
		uniformsGroup.__bindingPointIndex = bindingPointIndex;

		const buffer = gl.createBuffer();
		const size = uniformsGroup.__size;
		const usage = uniformsGroup.usage;

		gl.bindBuffer( 35345, buffer );
		gl.bufferData( 35345, size, usage );
		gl.bindBuffer( 35345, null );
		gl.bindBufferBase( 35345, bindingPointIndex, buffer );

		return buffer;

	}

	function allocateBindingPointIndex() {

		for ( let i = 0; i < maxBindingPoints; i ++ ) {

			if ( allocatedBindingPoints.indexOf( i ) === - 1 ) {

				allocatedBindingPoints.push( i );
				return i;

			}

		}

		console.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

		return 0;

	}

	function updateBufferData( uniformsGroup ) {

		const buffer = buffers[ uniformsGroup.id ];
		const uniforms = uniformsGroup.uniforms;
		const cache = uniformsGroup.__cache;

		gl.bindBuffer( 35345, buffer );

		for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

			const uniform = uniforms[ i ];

			// partly update the buffer if necessary

			if ( hasUniformChanged( uniform, i, cache ) === true ) {

				const offset = uniform.__offset;

				const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

				let arrayOffset = 0;

				for ( let i = 0; i < values.length; i ++ ) {

					const value = values[ i ];

					const info = getUniformSize( value );

					if ( typeof value === 'number' ) {

						uniform.__data[ 0 ] = value;
						gl.bufferSubData( 35345, offset + arrayOffset, uniform.__data );

					} else if ( value.isMatrix3 ) {

						// manually converting 3x3 to 3x4

						uniform.__data[ 0 ] = value.elements[ 0 ];
						uniform.__data[ 1 ] = value.elements[ 1 ];
						uniform.__data[ 2 ] = value.elements[ 2 ];
						uniform.__data[ 3 ] = value.elements[ 0 ];
						uniform.__data[ 4 ] = value.elements[ 3 ];
						uniform.__data[ 5 ] = value.elements[ 4 ];
						uniform.__data[ 6 ] = value.elements[ 5 ];
						uniform.__data[ 7 ] = value.elements[ 0 ];
						uniform.__data[ 8 ] = value.elements[ 6 ];
						uniform.__data[ 9 ] = value.elements[ 7 ];
						uniform.__data[ 10 ] = value.elements[ 8 ];
						uniform.__data[ 11 ] = value.elements[ 0 ];

					} else {

						value.toArray( uniform.__data, arrayOffset );

						arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;

					}

				}

				gl.bufferSubData( 35345, offset, uniform.__data );

			}

		}

		gl.bindBuffer( 35345, null );

	}

	function hasUniformChanged( uniform, index, cache ) {

		const value = uniform.value;

		if ( cache[ index ] === undefined ) {

			// cache entry does not exist so far

			if ( typeof value === 'number' ) {

				cache[ index ] = value;

			} else {

				const values = Array.isArray( value ) ? value : [ value ];

				const tempValues = [];

				for ( let i = 0; i < values.length; i ++ ) {

					tempValues.push( values[ i ].clone() );

				}

				cache[ index ] = tempValues;

			}

			return true;

		} else {

			// compare current value with cached entry

			if ( typeof value === 'number' ) {

				if ( cache[ index ] !== value ) {

					cache[ index ] = value;
					return true;

				}

			} else {

				const cachedObjects = Array.isArray( cache[ index ] ) ? cache[ index ] : [ cache[ index ] ];
				const values = Array.isArray( value ) ? value : [ value ];

				for ( let i = 0; i < cachedObjects.length; i ++ ) {

					const cachedObject = cachedObjects[ i ];

					if ( cachedObject.equals( values[ i ] ) === false ) {

						cachedObject.copy( values[ i ] );
						return true;

					}

				}

			}

		}

		return false;

	}

	function prepareUniformsGroup( uniformsGroup ) {

		// determine total buffer size according to the STD140 layout
		// Hint: STD140 is the only supported layout in WebGL 2

		const uniforms = uniformsGroup.uniforms;

		let offset = 0; // global buffer offset in bytes
		const chunkSize = 16; // size of a chunk in bytes
		let chunkOffset = 0; // offset within a single chunk in bytes

		for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

			const uniform = uniforms[ i ];

			const infos = {
				boundary: 0, // bytes
				storage: 0 // bytes
			};

			const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

			for ( let j = 0, jl = values.length; j < jl; j ++ ) {

				const value = values[ j ];

				const info = getUniformSize( value );

				infos.boundary += info.boundary;
				infos.storage += info.storage;

			}

			// the following two properties will be used for partial buffer updates

			uniform.__data = new Float32Array( infos.storage / Float32Array.BYTES_PER_ELEMENT );
			uniform.__offset = offset;

			//

			if ( i > 0 ) {

				chunkOffset = offset % chunkSize;

				const remainingSizeInChunk = chunkSize - chunkOffset;

				// check for chunk overflow

				if ( chunkOffset !== 0 && ( remainingSizeInChunk - infos.boundary ) < 0 ) {

					// add padding and adjust offset

					offset += ( chunkSize - chunkOffset );
					uniform.__offset = offset;

				}

			}

			offset += infos.storage;

		}

		// ensure correct final padding

		chunkOffset = offset % chunkSize;

		if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

		//

		uniformsGroup.__size = offset;
		uniformsGroup.__cache = {};

		return this;

	}

	function getUniformSize( value ) {

		const info = {
			boundary: 0, // bytes
			storage: 0 // bytes
		};

		// determine sizes according to STD140

		if ( typeof value === 'number' ) {

			// float/int

			info.boundary = 4;
			info.storage = 4;

		} else if ( value.isVector2 ) {

			// vec2

			info.boundary = 8;
			info.storage = 8;

		} else if ( value.isVector3 || value.isColor ) {

			// vec3

			info.boundary = 16;
			info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

		} else if ( value.isVector4 ) {

			// vec4

			info.boundary = 16;
			info.storage = 16;

		} else if ( value.isMatrix3 ) {

			// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

			info.boundary = 48;
			info.storage = 48;

		} else if ( value.isMatrix4 ) {

			// mat4

			info.boundary = 64;
			info.storage = 64;

		} else if ( value.isTexture ) {

			console.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

		} else {

			console.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );

		}

		return info;

	}

	function onUniformsGroupsDispose( event ) {

		const uniformsGroup = event.target;

		uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

		const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
		allocatedBindingPoints.splice( index, 1 );

		gl.deleteBuffer( buffers[ uniformsGroup.id ] );

		delete buffers[ uniformsGroup.id ];
		delete updateList[ uniformsGroup.id ];

	}

	function dispose() {

		for ( const id in buffers ) {

			gl.deleteBuffer( buffers[ id ] );

		}

		allocatedBindingPoints = [];
		buffers = {};
		updateList = {};

	}

	return {

		bind: bind,
		update: update,

		dispose: dispose

	};

}

function createCanvasElement() {

	const canvas = createElementNS( 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

function WebGLRenderer( parameters = {} ) {

	this.isWebGLRenderer = true;

	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,

		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	let _alpha;

	if ( _context !== null ) {

		_alpha = _context.getContextAttributes().alpha;

	} else {

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false;

	}

	let currentRenderList = null;
	let currentRenderState = null;

	// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.

	const renderListStack = [];
	const renderStateStack = [];

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.outputEncoding = LinearEncoding;

	// physical lights

	this.useLegacyLights = true;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;

	// internal properties

	const _this = this;

	let _isContextLost = false;

	// internal state cache

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentMaterialId = - 1;

	let _currentCamera = null;

	const _currentViewport = new Vector4();
	const _currentScissor = new Vector4();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;

	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;

	const _viewport = new Vector4( 0, 0, _width, _height );
	const _scissor = new Vector4( 0, 0, _width, _height );
	let _scissorTest = false;

	// frustum

	const _frustum = new Frustum();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// transmission

	let _transmissionRenderTarget = null;

	// camera matrices cache

	const _projScreenMatrix = new Matrix4();

	const _vector3 = new Vector3();

	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	let _gl = _context;

	function getContext( contextNames, contextAttributes ) {

		for ( let i = 0; i < contextNames.length; i ++ ) {

			const contextName = contextNames[ i ];
			const context = _canvas.getContext( contextName, contextAttributes );
			if ( context !== null ) return context;

		}

		return null;

	}

	try {

		const contextAttributes = {
			alpha: true,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// OffscreenCanvas does not have setAttribute, see #22811
		if ( 'setAttribute' in _canvas ) _canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

		// event listeners must be registered before WebGL context is created, see #12753
		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
		_canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

		if ( _gl === null ) {

			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			if ( _this.isWebGL1Renderer === true ) {

				contextNames.shift();

			}

			_gl = getContext( contextNames, contextAttributes );

			if ( _gl === null ) {

				if ( getContext( contextNames ) ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping, shadowMap;

	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	let utils, bindingStates, uniformsGroups;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		extensions.init( capabilities );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, capabilities );

		info = new WebGLInfo();
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		cubemaps = new WebGLCubeMaps( _this );
		cubeuvmaps = new WebGLCubeUVMaps( _this );
		attributes = new WebGLAttributes( _gl, capabilities );
		bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
		geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
		objects = new WebGLObjects( _gl, geometries, attributes, info );
		morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
		clipping = new WebGLClipping( properties );
		programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
		materials = new WebGLMaterials( _this, properties );
		renderLists = new WebGLRenderLists();
		renderStates = new WebGLRenderStates( extensions, capabilities );
		background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, _premultipliedAlpha );
		shadowMap = new WebGLShadowMap( _this, objects, capabilities );
		uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.shadowMap = shadowMap;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	const xr = new WebXRManager( _this, _gl );

	this.xr = xr;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle = true ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle === true ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function ( target ) {

		return target.copy( background.getClearColor() );

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color = true, depth = true, stencil = true ) {

		let bits = 0;

		if ( color ) bits |= 16384;
		if ( depth ) bits |= 256;
		if ( stencil ) bits |= 1024;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
		_canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		cubeuvmaps.dispose();
		objects.dispose();
		bindingStates.dispose();
		uniformsGroups.dispose();
		programCache.dispose();

		xr.dispose();

		xr.removeEventListener( 'sessionstart', onXRSessionStart );
		xr.removeEventListener( 'sessionend', onXRSessionEnd );

		if ( _transmissionRenderTarget ) {

			_transmissionRenderTarget.dispose();
			_transmissionRenderTarget = null;

		}

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		const infoAutoReset = info.autoReset;
		const shadowMapEnabled = shadowMap.enabled;
		const shadowMapAutoUpdate = shadowMap.autoUpdate;
		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		const shadowMapType = shadowMap.type;

		initGLContext();

		info.autoReset = infoAutoReset;
		shadowMap.enabled = shadowMapEnabled;
		shadowMap.autoUpdate = shadowMapAutoUpdate;
		shadowMap.needsUpdate = shadowMapNeedsUpdate;
		shadowMap.type = shadowMapType;

	}

	function onContextCreationError( event ) {

		console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReferences( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReferences( material ) {

		const programs = properties.get( material ).programs;

		if ( programs !== undefined ) {

			programs.forEach( function ( program ) {

				programCache.releaseProgram( program );

			} );

			if ( material.isShaderMaterial ) {

				programCache.releaseShaderCache( material );

			}

		}

	}

	// Buffer rendering

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		const program = setProgram( camera, scene, geometry, material, object );

		state.setMaterial( material, frontFaceCW );

		//

		let index = geometry.index;
		let rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		//

		const drawRange = geometry.drawRange;
		const position = geometry.attributes.position;

		let drawStart = drawRange.start * rangeFactor;
		let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

		if ( group !== null ) {

			drawStart = Math.max( drawStart, group.start * rangeFactor );
			drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

		}

		if ( index !== null ) {

			drawStart = Math.max( drawStart, 0 );
			drawEnd = Math.min( drawEnd, index.count );

		} else if ( position !== undefined && position !== null ) {

			drawStart = Math.max( drawStart, 0 );
			drawEnd = Math.min( drawEnd, position.count );

		}

		const drawCount = drawEnd - drawStart;

		if ( drawCount < 0 || drawCount === Infinity ) return;

		//

		bindingStates.setup( object, material, program, geometry, index );

		let attribute;
		let renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( 1 );

			} else {

				renderer.setMode( 4 );

			}

		} else if ( object.isLine ) {

			let lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( 1 );

			} else if ( object.isLineLoop ) {

				renderer.setMode( 2 );

			} else {

				renderer.setMode( 3 );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( 0 );

		} else if ( object.isSprite ) {

			renderer.setMode( 4 );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
			const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

			renderer.renderInstances( drawStart, drawCount, instanceCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	// Compile

	this.compile = function ( scene, camera ) {

		function prepare( material, scene, object ) {

			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

				material.side = BackSide;
				material.needsUpdate = true;
				getProgram( material, scene, object );

				material.side = FrontSide;
				material.needsUpdate = true;
				getProgram( material, scene, object );

				material.side = DoubleSide;

			} else {

				getProgram( material, scene, object );

			}

		}

		currentRenderState = renderStates.get( scene );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		scene.traverseVisible( function ( object ) {

			if ( object.isLight && object.layers.test( camera.layers ) ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights( _this.useLegacyLights );

		scene.traverse( function ( object ) {

			const material = object.material;

			if ( material ) {

				if ( Array.isArray( material ) ) {

					for ( let i = 0; i < material.length; i ++ ) {

						const material2 = material[ i ];

						prepare( material2, scene, object );

					}

				} else {

					prepare( material, scene, object );

				}

			}

		} );

		renderStateStack.pop();
		currentRenderState = null;

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	function onXRSessionStart() {

		animation.stop();

	}

	function onXRSessionEnd() {

		animation.start();

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof self !== 'undefined' ) animation.setContext( self );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		( callback === null ) ? animation.stop() : animation.start();

	};

	xr.addEventListener( 'sessionstart', onXRSessionStart );
	xr.addEventListener( 'sessionend', onXRSessionEnd );

	// Rendering

	this.render = function ( scene, camera ) {

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost === true ) return;

		// update scene graph

		if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

		if ( xr.enabled === true && xr.isPresenting === true ) {

			if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

			camera = xr.getCamera(); // use XR camera for rendering

		}

		//
		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

		currentRenderState = renderStates.get( scene, renderStateStack.length );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );

		currentRenderList = renderLists.get( scene, renderListStack.length );
		currentRenderList.init();

		renderListStack.push( currentRenderList );

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled === true ) clipping.beginShadows();

		const shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		if ( _clippingEnabled === true ) clipping.endShadows();

		//

		if ( this.info.autoReset === true ) this.info.reset();

		//

		background.render( currentRenderList, scene );

		// render scene

		currentRenderState.setupLights( _this.useLegacyLights );

		if ( camera.isArrayCamera ) {

			const cameras = camera.cameras;

			for ( let i = 0, l = cameras.length; i < l; i ++ ) {

				const camera2 = cameras[ i ];

				renderScene( currentRenderList, scene, camera2, camera2.viewport );

			}

		} else {

			renderScene( currentRenderList, scene, camera );

		}

		//

		if ( _currentRenderTarget !== null ) {

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

		}

		//

		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		// _gl.finish();

		bindingStates.resetDefaultState();
		_currentMaterialId = - 1;
		_currentCamera = null;

		renderStateStack.pop();

		if ( renderStateStack.length > 0 ) {

			currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

		} else {

			currentRenderState = null;

		}

		renderListStack.pop();

		if ( renderListStack.length > 0 ) {

			currentRenderList = renderListStack[ renderListStack.length - 1 ];

		} else {

			currentRenderList = null;

		}

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderScene( currentRenderList, scene, camera, viewport ) {

		const opaqueObjects = currentRenderList.opaque;
		const transmissiveObjects = currentRenderList.transmissive;
		const transparentObjects = currentRenderList.transparent;

		currentRenderState.setupLightsView( camera );

		if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

		if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );

		if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

	}

	function renderTransmissionPass( opaqueObjects, scene, camera ) {

		const isWebGL2 = capabilities.isWebGL2;

		if ( _transmissionRenderTarget === null ) {

			_transmissionRenderTarget = new WebGLRenderTarget( 1024, 1024, {
				generateMipmaps: true,
				type: extensions.has( 'EXT_color_buffer_half_float' ) ? HalfFloatType : UnsignedByteType,
				minFilter: LinearMipmapLinearFilter,
				samples: ( isWebGL2 && _antialias === true ) ? 4 : 0
			} );

		}

		//

		const currentRenderTarget = _this.getRenderTarget();
		_this.setRenderTarget( _transmissionRenderTarget );
		_this.clear();

		// Turn off the features which can affect the frag color for opaque objects pass.
		// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
		const currentToneMapping = _this.toneMapping;
		_this.toneMapping = NoToneMapping;

		renderObjects( opaqueObjects, scene, camera );

		_this.toneMapping = currentToneMapping;

		textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
		textures.updateRenderTargetMipmap( _transmissionRenderTarget );

		_this.setRenderTarget( currentRenderTarget );

	}

	function renderObjects( renderList, scene, camera ) {

		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			const renderItem = renderList[ i ];

			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;

			if ( object.layers.test( camera.layers ) ) {

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		material.onBeforeRender( _this, scene, camera, geometry, object, group );

		if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

			material.side = BackSide;
			material.needsUpdate = true;
			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			material.side = FrontSide;
			material.needsUpdate = true;
			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			material.side = DoubleSide;

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );

	}

	function getProgram( material, scene, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get( material );

		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;

		const lightsStateVersion = lights.state.version;

		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		const programCacheKey = programCache.getProgramCacheKey( parameters );

		let programs = materialProperties.programs;

		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );

		if ( programs === undefined ) {

			// new material

			material.addEventListener( 'dispose', onMaterialDispose );

			programs = new Map();
			materialProperties.programs = programs;

		}

		let program = programs.get( programCacheKey );

		if ( program !== undefined ) {

			// early out if program and light state is identical

			if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

				updateCommonMaterialProperties( material, parameters );

				return program;

			}

		} else {

			parameters.uniforms = programCache.getUniforms( material );

			material.onBuild( object, parameters, _this );

			material.onBeforeCompile( parameters, _this );

			program = programCache.acquireProgram( parameters, programCacheKey );
			programs.set( programCacheKey, program );

			materialProperties.uniforms = parameters.uniforms;

		}

		const uniforms = materialProperties.uniforms;

		if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

			uniforms.clippingPlanes = clipping.uniform;

		}

		updateCommonMaterialProperties( material, parameters );

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
			uniforms.spotLightMap.value = lights.state.spotLightMap;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		const progUniforms = program.getUniforms();
		const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.currentProgram = program;
		materialProperties.uniformsList = uniformsList;

		return program;

	}

	function updateCommonMaterialProperties( material, parameters ) {

		const materialProperties = properties.get( material );

		materialProperties.outputEncoding = parameters.outputEncoding;
		materialProperties.instancing = parameters.instancing;
		materialProperties.skinning = parameters.skinning;
		materialProperties.morphTargets = parameters.morphTargets;
		materialProperties.morphNormals = parameters.morphNormals;
		materialProperties.morphColors = parameters.morphColors;
		materialProperties.morphTargetsCount = parameters.morphTargetsCount;
		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		materialProperties.numIntersection = parameters.numClipIntersection;
		materialProperties.vertexAlphas = parameters.vertexAlphas;
		materialProperties.vertexTangents = parameters.vertexTangents;
		materialProperties.toneMapping = parameters.toneMapping;

	}

	function setProgram( camera, scene, geometry, material, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding );
		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
		const vertexTangents = !! material.normalMap && !! geometry.attributes.tangent;
		const morphTargets = !! geometry.morphAttributes.position;
		const morphNormals = !! geometry.morphAttributes.normal;
		const morphColors = !! geometry.morphAttributes.color;
		const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		const materialProperties = properties.get( material );
		const lights = currentRenderState.state.lights;

		if ( _clippingEnabled === true ) {

			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				const useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState( material, camera, useCache );

			}

		}

		//

		let needsProgramChange = false;

		if ( material.version === materialProperties.__version ) {

			if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.outputEncoding !== encoding ) {

				needsProgramChange = true;

			} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

				needsProgramChange = true;

			} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

				needsProgramChange = true;

			} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

				needsProgramChange = true;

			} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

				needsProgramChange = true;

			} else if ( materialProperties.envMap !== envMap ) {

				needsProgramChange = true;

			} else if ( material.fog === true && materialProperties.fog !== fog ) {

				needsProgramChange = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				materialProperties.numIntersection !== clipping.numIntersection ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexTangents !== vertexTangents ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphTargets !== morphTargets ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphNormals !== morphNormals ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphColors !== morphColors ) {

				needsProgramChange = true;

			} else if ( materialProperties.toneMapping !== toneMapping ) {

				needsProgramChange = true;

			} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {

				needsProgramChange = true;

			}

		} else {

			needsProgramChange = true;
			materialProperties.__version = material.version;

		}

		//

		let program = materialProperties.currentProgram;

		if ( needsProgramChange === true ) {

			program = getProgram( material, scene, object );

		}

		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;

		const p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.isShadowMaterial ||
				object.isSkinnedMesh ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning and morph target uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone and morph texture must go before other textures
		// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

		if ( object.isSkinnedMesh ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			const skeleton = object.skeleton;

			if ( skeleton ) {

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					console.warn( 'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.' );

				}

			}

		}

		const morphAttributes = geometry.morphAttributes;

		if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {

			morphtargets.update( object, geometry, program );

		}

		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

		if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

			m_uniforms.envMap.value = envMap;

			m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog === true ) {

				materials.refreshFogUniforms( m_uniforms, fog );

			}

			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		// UBOs

		if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

			const groups = material.uniformsGroups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				if ( capabilities.isWebGL2 ) {

					const group = groups[ i ];

					uniformsGroups.update( group, program );
					uniformsGroups.bind( group, program );

				} else {

					console.warn( 'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.' );

				}

			}

		}

		return program;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

		properties.get( renderTarget.texture ).__webglTexture = colorTexture;
		properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

		const renderTargetProperties = properties.get( renderTarget );
		renderTargetProperties.__hasExternalTextures = true;

		if ( renderTargetProperties.__hasExternalTextures ) {

			renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

			if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				// The multisample_render_to_texture extension doesn't work properly if there
				// are midframe flushes and an external depth buffer. Disable use of the extension.
				if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

					console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
					renderTargetProperties.__useRenderToTexture = false;

				}

			}

		}

	};

	this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

		const renderTargetProperties = properties.get( renderTarget );
		renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
		renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		let useDefaultFramebuffer = true;
		let framebuffer = null;
		let isCube = false;
		let isRenderTarget3D = false;

		if ( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

				// We need to make sure to rebind the framebuffer.
				state.bindFramebuffer( 36160, null );
				useDefaultFramebuffer = false;

			} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			} else if ( renderTargetProperties.__hasExternalTextures ) {

				// Color and depth texture must be rebound in order for the swapchain to update.
				textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

			}

			const texture = renderTarget.texture;

			if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

				isRenderTarget3D = true;

			}

			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace ];
				isCube = true;

			} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

		if ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {

			state.drawBuffers( renderTarget, framebuffer );

		}

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			const textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		} else if ( isRenderTarget3D ) {

			const textureProperties = properties.get( renderTarget.texture );
			const layer = activeCubeFace || 0;
			_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

		}

		_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			state.bindFramebuffer( 36160, framebuffer );

			try {

				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! halfFloatSupportedByExt ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

				if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

					_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

				}

			} finally {

				// restore framebuffer of current render target if necessary

				const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
				state.bindFramebuffer( 36160, framebuffer );

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		const levelScale = Math.pow( 2, - level );
		const width = Math.floor( texture.image.width * levelScale );
		const height = Math.floor( texture.image.height * levelScale );

		textures.setTexture2D( texture, 0 );

		_gl.copyTexSubImage2D( 3553, level, 0, 0, position.x, position.y, width, height );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			} else {

				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		}

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		state.unbindTexture();

	};

	this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

		if ( _this.isWebGL1Renderer ) {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
			return;

		}

		const width = sourceBox.max.x - sourceBox.min.x + 1;
		const height = sourceBox.max.y - sourceBox.min.y + 1;
		const depth = sourceBox.max.z - sourceBox.min.z + 1;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );
		let glTarget;

		if ( dstTexture.isData3DTexture ) {

			textures.setTexture3D( dstTexture, 0 );
			glTarget = 32879;

		} else if ( dstTexture.isDataArrayTexture ) {

			textures.setTexture2DArray( dstTexture, 0 );
			glTarget = 35866;

		} else {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
			return;

		}

		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		const unpackRowLen = _gl.getParameter( 3314 );
		const unpackImageHeight = _gl.getParameter( 32878 );
		const unpackSkipPixels = _gl.getParameter( 3316 );
		const unpackSkipRows = _gl.getParameter( 3315 );
		const unpackSkipImages = _gl.getParameter( 32877 );

		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

		_gl.pixelStorei( 3314, image.width );
		_gl.pixelStorei( 32878, image.height );
		_gl.pixelStorei( 3316, sourceBox.min.x );
		_gl.pixelStorei( 3315, sourceBox.min.y );
		_gl.pixelStorei( 32877, sourceBox.min.z );

		if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

			_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

		} else {

			if ( srcTexture.isCompressedArrayTexture ) {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
				_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

			} else {

				_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

			}

		}

		_gl.pixelStorei( 3314, unpackRowLen );
		_gl.pixelStorei( 32878, unpackImageHeight );
		_gl.pixelStorei( 3316, unpackSkipPixels );
		_gl.pixelStorei( 3315, unpackSkipRows );
		_gl.pixelStorei( 32877, unpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		if ( texture.isCubeTexture ) {

			textures.setTextureCube( texture, 0 );

		} else if ( texture.isData3DTexture ) {

			textures.setTexture3D( texture, 0 );

		} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

			textures.setTexture2DArray( texture, 0 );

		} else {

			textures.setTexture2D( texture, 0 );

		}

		state.unbindTexture();

	};

	this.resetState = function () {

		_currentActiveCubeFace = 0;
		_currentActiveMipmapLevel = 0;
		_currentRenderTarget = null;

		state.reset();
		bindingStates.reset();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

	}

}

Object.defineProperties( WebGLRenderer.prototype, {

	// @deprecated since r150

	physicallyCorrectLights: {

		get: function () {

			console.warn( 'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.' );
			return ! this.useLegacyLights;

		},

		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.' );
			this.useLegacyLights = ! value;

		}

	}

} );

class WebGL1Renderer extends WebGLRenderer {}

WebGL1Renderer.prototype.isWebGL1Renderer = true;

class FogExp2 {

	constructor( color, density = 0.00025 ) {

		this.isFogExp2 = true;

		this.name = '';

		this.color = new Color( color );
		this.density = density;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	}

}

class Fog {

	constructor( color, near = 1, far = 1000 ) {

		this.isFog = true;

		this.name = '';

		this.color = new Color( color );

		this.near = near;
		this.far = far;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

class Scene extends Object3D {

	constructor() {

		super();

		this.isScene = true;

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.backgroundBlurriness = 0;
		this.backgroundIntensity = 1;

		this.overrideMaterial = null;

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		this.backgroundBlurriness = source.backgroundBlurriness;
		this.backgroundIntensity = source.backgroundIntensity;

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;

		return data;

	}

	// @deprecated

	get autoUpdate() {

		console.warn( 'THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.' );
		return this.matrixWorldAutoUpdate;

	}

	set autoUpdate( value ) {

		console.warn( 'THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.' );
		this.matrixWorldAutoUpdate = value;

	}

}

class InterleavedBuffer {

	constructor( array, stride ) {

		this.isInterleavedBuffer = true;

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

		this.uuid = generateUUID();

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

const _vector$6 = /*@__PURE__*/ new Vector3();

class InterleavedBufferAttribute {

	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		this.isInterleavedBufferAttribute = true;

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized;

	}

	get count() {

		return this.data.count;

	}

	get array() {

		return this.data.array;

	}

	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyNormalMatrix( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.transformDirection( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	getX( index ) {

		let x = this.data.array[ index * this.data.stride + this.offset ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	getY( index ) {

		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	getZ( index ) {

		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	getW( index ) {

		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	clone( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	toJSON( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// de-interleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interleaved attribute

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

class SpriteMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isSpriteMaterial = true;

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

let _geometry;

const _intersectPoint = /*@__PURE__*/ new Vector3();
const _worldScale = /*@__PURE__*/ new Vector3();
const _mvPosition = /*@__PURE__*/ new Vector3();

const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

const _vA = /*@__PURE__*/ new Vector3();
const _vB = /*@__PURE__*/ new Vector3();
const _vC = /*@__PURE__*/ new Vector3();

const _uvA = /*@__PURE__*/ new Vector2();
const _uvB = /*@__PURE__*/ new Vector2();
const _uvC = /*@__PURE__*/ new Vector2();

class Sprite extends Object3D {

	constructor( material ) {

		super();

		this.isSprite = true;

		this.type = 'Sprite';

		if ( _geometry === undefined ) {

			_geometry = new BufferGeometry();

			const float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = _geometry;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA.set( 0, 0 );
		_uvB.set( 1, 0 );
		_uvC.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
			face: null,
			object: this

		} );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

const _v1$2 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();

class LOD extends Object3D {

	constructor() {

		super();

		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			isLOD: {
				value: true,
			}
		} );

		this.autoUpdate = true;

	}

	copy( source ) {

		super.copy( source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance, level.hysteresis );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	}

	addLevel( object, distance = 0, hysteresis = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );

		this.add( object );

		return this;

	}

	getCurrentLevel() {

		return this._currentLevel;

	}



	getObjectForDistance( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				let levelDistance = levels[ i ].distance;

				if ( levels[ i ].object.visible ) {

					levelDistance -= levelDistance * levels[ i ].hysteresis;

				}

				if ( distance < levelDistance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	}

	raycast( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$2.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1$2 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	}

	update( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$2.setFromMatrixPosition( camera.matrixWorld );
			_v2$1.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				let levelDistance = levels[ i ].distance;

				if ( levels[ i ].object.visible ) {

					levelDistance -= levelDistance * levels[ i ].hysteresis;

				}

				if ( distance >= levelDistance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance,
				hysteresis: level.hysteresis
			} );

		}

		return data;

	}

}

const _basePosition = /*@__PURE__*/ new Vector3();

const _skinIndex = /*@__PURE__*/ new Vector4();
const _skinWeight = /*@__PURE__*/ new Vector4();

const _vector$5 = /*@__PURE__*/ new Vector3();
const _matrix = /*@__PURE__*/ new Matrix4();

class SkinnedMesh extends Mesh {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isSkinnedMesh = true;

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	}

	bind( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	}

	pose() {

		this.skeleton.pose();

	}

	normalizeSkinWeights() {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.fromBufferAttribute( skinWeight, i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	}

	boneTransform( index, target ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.copy( target ).applyMatrix4( this.bindMatrix );

		target.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );

			}

		}

		return target.applyMatrix4( this.bindMatrixInverse );

	}

}

class Bone extends Object3D {

	constructor() {

		super();

		this.isBone = true;

		this.type = 'Bone';

	}

}

class DataTexture extends Texture {

	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.isDataTexture = true;

		this.image = { data: data, width: width, height: height };

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;
		this.boneTextureSize = 0;

		this.frame = - 1;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	computeBoneTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = ceilPowerOfTwo( size );
		size = Math.max( size, 4 );

		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		boneMatrices.set( this.boneMatrices ); // copy current values

		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
		boneTexture.needsUpdate = true;

		this.boneMatrices = boneMatrices;
		this.boneTexture = boneTexture;
		this.boneTextureSize = size;

		return this;

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

class InstancedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

		super( array, itemSize, normalized );

		this.isInstancedBufferAttribute = true;

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

}

const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

const _instanceIntersects = [];

const _identity = /*@__PURE__*/ new Matrix4();
const _mesh = /*@__PURE__*/ new Mesh();

class InstancedMesh extends Mesh {

	constructor( geometry, material, count ) {

		super( geometry, material );

		this.isInstancedMesh = true;

		this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
		this.instanceColor = null;

		this.count = count;

		this.frustumCulled = false;

		for ( let i = 0; i < count; i ++ ) {

			this.setMatrixAt( i, _identity );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		return this;

	}

	getColorAt( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	}

	getMatrixAt( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	}

	raycast( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined ) return;

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	}

	setColorAt( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	}

	setMatrixAt( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	}

	updateMorphTargets() {

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isLineBasicMaterial = true;

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.fog = source.fog;

		return this;

	}

}

const _start$1 = /*@__PURE__*/ new Vector3();
const _end$1 = /*@__PURE__*/ new Vector3();
const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();

class Line extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		super();

		this.isLine = true;

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [ 0 ];

			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

				_start$1.fromBufferAttribute( positionAttribute, i - 1 );
				_end$1.fromBufferAttribute( positionAttribute, i );

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += _start$1.distanceTo( _end$1 );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = this.isLineSegments ? 2 : 1;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const a = index.getX( i );
				const b = index.getX( i + 1 );

				vStart.fromBufferAttribute( positionAttribute, a );
				vEnd.fromBufferAttribute( positionAttribute, b );

				const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				vStart.fromBufferAttribute( positionAttribute, i );
				vEnd.fromBufferAttribute( positionAttribute, i + 1 );

				const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

const _start = /*@__PURE__*/ new Vector3();
const _end = /*@__PURE__*/ new Vector3();

class LineSegments extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineSegments = true;

		this.type = 'LineSegments';

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [];

			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

				_start.fromBufferAttribute( positionAttribute, i );
				_end.fromBufferAttribute( positionAttribute, i + 1 );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

}

class LineLoop extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineLoop = true;

		this.type = 'LineLoop';

	}

}

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isPointsMaterial = true;

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

class Points extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		this.isPoints = true;

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, il = end; i < il; i ++ ) {

				const a = index.getX( i );

				_position$2.fromBufferAttribute( positionAttribute, a );

				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end; i < l; i ++ ) {

				_position$2.fromBufferAttribute( positionAttribute, i );

				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

class VideoTexture extends Texture {

	constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isVideoTexture = true;

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;

		const scope = this;

		function updateVideo() {

			scope.needsUpdate = true;
			video.requestVideoFrameCallback( updateVideo );

		}

		if ( 'requestVideoFrameCallback' in video ) {

			video.requestVideoFrameCallback( updateVideo );

		}

	}

	clone() {

		return new this.constructor( this.image ).copy( this );

	}

	update() {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

}

class FramebufferTexture extends Texture {

	constructor( width, height, format ) {

		super( { width, height } );

		this.isFramebufferTexture = true;

		this.format = format;

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.generateMipmaps = false;

		this.needsUpdate = true;

	}

}

class CompressedTexture extends Texture {

	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.isCompressedTexture = true;

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

}

class CompressedArrayTexture extends CompressedTexture {

	constructor( mipmaps, width, height, depth, format, type ) {

		super( mipmaps, width, height, format, type );

		this.isCompressedArrayTexture = true;
		this.image.depth = depth;
		this.wrapR = ClampToEdgeWrapping;

	}

}

class CanvasTexture extends Texture {

	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isCanvasTexture = true;

		this.needsUpdate = true;

	}

}

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

class Curve {

	constructor() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	}

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	}

	// Get sequence of points using getPoint( t )

	getPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	}

	// Get sequence of points using getPointAt( u )

	getSpacedPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	}

	// Get total curve arc length

	getLength() {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	}

	// Get list of cumulative segment lengths

	getLengths( divisions = this.arcLengthDivisions ) {

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	}

	updateArcLengths() {

		this.needsUpdate = true;
		this.getLengths();

	}

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	}

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	}

	getTangentAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	}

	computeFrenetFrames( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	}

	fromJSON( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

}

class EllipseCurve extends Curve {

	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		this.isEllipseCurve = true;

		this.type = 'EllipseCurve';

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation;

	}

	getPoint( t, optionalTarget ) {

		const point = optionalTarget || new Vector2();

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

class ArcCurve extends EllipseCurve {

	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.isArcCurve = true;

		this.type = 'ArcCurve';

	}

}

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = /*@__PURE__*/ new Vector3();
const px = /*@__PURE__*/ new CubicPoly();
const py = /*@__PURE__*/ new CubicPoly();
const pz = /*@__PURE__*/ new CubicPoly();

class CatmullRomCurve3 extends Curve {

	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		this.isCatmullRomCurve3 = true;

		this.type = 'CatmullRomCurve3';

		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

class CubicBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		super();

		this.isCubicBezierCurve = true;

		this.type = 'CubicBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

class CubicBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

		super();

		this.isCubicBezierCurve3 = true;

		this.type = 'CubicBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

class LineCurve extends Curve {

	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.isLineCurve = true;

		this.type = 'LineCurve';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector2() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class LineCurve3 extends Curve {

	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.isLineCurve3 = true;

		this.type = 'LineCurve3';

		this.v1 = v1;
		this.v2 = v2;

	}
	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}
	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector3() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}
	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}
	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.isQuadraticBezierCurve = true;

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.isQuadraticBezierCurve3 = true;

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class SplineCurve extends Curve {

	constructor( points = [] ) {

		super();

		this.isSplineCurve = true;

		this.type = 'SplineCurve';

		this.points = points;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	}

}

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {

	constructor() {

		super();

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	add( curve ) {

		this.curves.push( curve );

	}

	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint( t, optionalTarget ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u, optionalTarget );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	// cacheLengths must be recalculated.
	updateArcLengths() {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = curve.isEllipseCurve ? divisions * 2
				: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1
					: curve.isSplineCurve ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}

class Path extends CurvePath {

	constructor( points ) {

		super();

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	lineTo( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	splineThru( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}

class LatheGeometry extends BufferGeometry {

	constructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];
		const initNormals = [];
		const normals = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();
		const normal = new Vector3();
		const curNormal = new Vector3();
		const prevNormal = new Vector3();
		let dx = 0;
		let dy = 0;

		// pre-compute normals for initial "meridian"

		for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

			switch ( j ) {

				case 0:				// special handling for 1st vertex on path

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					prevNormal.copy( normal );

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					break;

				case ( points.length - 1 ):	// special handling for last Vertex on path

					initNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );

					break;

				default:			// default handling for all vertices in between

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					curNormal.copy( normal );

					normal.x += prevNormal.x;
					normal.y += prevNormal.y;
					normal.z += prevNormal.z;

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					prevNormal.copy( curNormal );

			}

		}

		// generate vertices, uvs and normals

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );

				// normal

				const x = initNormals[ 3 * j + 0 ] * sin;
				const y = initNormals[ 3 * j + 1 ];
				const z = initNormals[ 3 * j + 0 ] * cos;

				normals.push( x, y, z );

			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( c, d, b );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );

	}

}

class CapsuleGeometry extends LatheGeometry {

	constructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {

		const path = new Path();
		path.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );
		path.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );

		super( path.getPoints( capSegments ), radialSegments );

		this.type = 'CapsuleGeometry';

		this.parameters = {
			radius: radius,
			height: length,
			capSegments: capSegments,
			radialSegments: radialSegments,
		};

	}

	static fromJSON( data ) {

		return new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );

	}

}

class CircleGeometry extends BufferGeometry {

	constructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

	}

}

class CylinderGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class ConeGeometry extends CylinderGeometry {

	constructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	static fromJSON( data ) {

		return new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class PolyhedronGeometry extends BufferGeometry {

	constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivision with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

	}

}

class DodecahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new DodecahedronGeometry( data.radius, data.detail );

	}

}

const _v0 = /*@__PURE__*/ new Vector3();
const _v1$1 = /*@__PURE__*/ new Vector3();
const _normal = /*@__PURE__*/ new Vector3();
const _triangle = /*@__PURE__*/ new Triangle();

class EdgesGeometry extends BufferGeometry {

	constructor( geometry = null, thresholdAngle = 1 ) {

		super();

		this.type = 'EdgesGeometry';

		this.parameters = {
			geometry: geometry,
			thresholdAngle: thresholdAngle
		};

		if ( geometry !== null ) {

			const precisionPoints = 4;
			const precision = Math.pow( 10, precisionPoints );
			const thresholdDot = Math.cos( DEG2RAD * thresholdAngle );

			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute( 'position' );
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

			const indexArr = [ 0, 0, 0 ];
			const vertKeys = [ 'a', 'b', 'c' ];
			const hashes = new Array( 3 );

			const edgeData = {};
			const vertices = [];
			for ( let i = 0; i < indexCount; i += 3 ) {

				if ( indexAttr ) {

					indexArr[ 0 ] = indexAttr.getX( i );
					indexArr[ 1 ] = indexAttr.getX( i + 1 );
					indexArr[ 2 ] = indexAttr.getX( i + 2 );

				} else {

					indexArr[ 0 ] = i;
					indexArr[ 1 ] = i + 1;
					indexArr[ 2 ] = i + 2;

				}

				const { a, b, c } = _triangle;
				a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
				b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
				c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
				_triangle.getNormal( _normal );

				// create hashes for the edge from the vertices
				hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
				hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
				hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

				// skip degenerate triangles
				if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

					continue;

				}

				// iterate over every edge
				for ( let j = 0; j < 3; j ++ ) {

					// get the first and next vertex making up the edge
					const jNext = ( j + 1 ) % 3;
					const vecHash0 = hashes[ j ];
					const vecHash1 = hashes[ jNext ];
					const v0 = _triangle[ vertKeys[ j ] ];
					const v1 = _triangle[ vertKeys[ jNext ] ];

					const hash = `${ vecHash0 }_${ vecHash1 }`;
					const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

					if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

							vertices.push( v0.x, v0.y, v0.z );
							vertices.push( v1.x, v1.y, v1.z );

						}

						edgeData[ reverseHash ] = null;

					} else if ( ! ( hash in edgeData ) ) {

						// if we've already got an edge here then skip adding a new one
						edgeData[ hash ] = {

							index0: indexArr[ j ],
							index1: indexArr[ jNext ],
							normal: _normal.clone(),

						};

					}

				}

			}

			// iterate over all remaining, unmatched edges and add them to the vertex array
			for ( const key in edgeData ) {

				if ( edgeData[ key ] ) {

					const { index0, index1 } = edgeData[ key ];
					_v0.fromBufferAttribute( positionAttr, index0 );
					_v1$1.fromBufferAttribute( positionAttr, index1 );

					vertices.push( _v0.x, _v0.y, _v0.z );
					vertices.push( _v1$1.x, _v1$1.y, _v1$1.z );

				}

			}

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

}

class Shape extends Path {

	constructor( points ) {

		super( points );

		this.uuid = generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim = 2 ) {

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 32767 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim | 0 );
			triangles.push( ear.i / dim | 0 );
			triangles.push( next.i / dim | 0 );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

	let p = c.next;
	while ( p !== a ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( x0, y0, minX, minY, invSize ),
		maxZ = zOrder( x1, y1, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim | 0 );
			triangles.push( p.i / dim | 0 );
			triangles.push( b.i / dim | 0 );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize, 0 );
				earcutLinked( c, triangles, dim, minX, minY, invSize, 0 );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		outerNode = eliminateHole( queue[ i ], outerNode );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole( hole, outerNode ) {

	const bridge = findHoleBridge( hole, outerNode );
	if ( ! bridge ) {

		return outerNode;

	}

	const bridgeReverse = splitPolygon( bridge, hole );

	// filter collinear points around the cuts
	filterPoints( bridgeReverse, bridgeReverse.next );
	return filterPoints( bridge, bridge.next );

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode,
		qx = - Infinity,
		m;

	const hx = hole.x, hy = hole.y;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				m = p.x < p.next.x ? p : p.next;
				if ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = ( x - minX ) * invSize | 0;
	y = ( y - minY ) * invSize | 0;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&
           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&
           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign( area( p1, q1, p2 ) );
	const o2 = sign( area( p1, q1, q2 ) );
	const o3 = sign( area( p2, q2, p1 ) );
	const o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
			intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
			( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = 0;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

class ShapeUtils {

	// calculate area of the contour polygon

	static area( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	}

	static isClockWise( pts ) {

		return ShapeUtils.area( pts ) < 0;

	}

	static triangulateShape( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

}

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

class ExtrudeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {

		super();

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			const depth = options.depth !== undefined ? options.depth : 1;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			const faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				return pt.clone().addScaledVector( vec, size );

			}

			const vlen = vertices.length, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( let b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON$1( shapes, options, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		const extrudePath = data.options.extrudePath;

		if ( extrudePath !== undefined ) {

			data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

		}

		return new ExtrudeGeometry( geometryShapes, data.options );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON$1( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	data.options = Object.assign( {}, options );

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

class IcosahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new IcosahedronGeometry( data.radius, data.detail );

	}

}

class OctahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new OctahedronGeometry( data.radius, data.detail );

	}

}

class RingGeometry extends BufferGeometry {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

	}

}

class ShapeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {

		super();

		this.type = 'ShapeGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// indices

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		return new ShapeGeometry( geometryShapes, data.curveSegments );

	}

}

function toJSON( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class SphereGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy == 0 && thetaStart == 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	}

}

class TetrahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new TetrahedronGeometry( data.radius, data.detail );

	}

}

class TorusGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {

		super();

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

	}

}

class TorusKnotGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segment

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );

	}

}

class TubeGeometry extends BufferGeometry {

	constructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.path = this.parameters.path.toJSON();

		return data;

	}

	static fromJSON( data ) {

		// This only works for built-in curves (e.g. CatmullRomCurve3).
		// User defined curves or instances of CurvePath will not be deserialized.
		return new TubeGeometry(
			new Curves[ data.path.type ]().fromJSON( data.path ),
			data.tubularSegments,
			data.radius,
			data.radialSegments,
			data.closed
		);

	}

}

class WireframeGeometry extends BufferGeometry {

	constructor( geometry = null ) {

		super();

		this.type = 'WireframeGeometry';

		this.parameters = {
			geometry: geometry
		};

		if ( geometry !== null ) {

			// buffer

			const vertices = [];
			const edges = new Set();

			// helper variables

			const start = new Vector3();
			const end = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all edges without duplicates

				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

					const group = groups[ o ];

					const groupStart = group.start;
					const groupCount = group.count;

					for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {

						for ( let j = 0; j < 3; j ++ ) {

							const index1 = indices.getX( i + j );
							const index2 = indices.getX( i + ( j + 1 ) % 3 );

							start.fromBufferAttribute( position, index1 );
							end.fromBufferAttribute( position, index2 );

							if ( isUniqueEdge( start, end, edges ) === true ) {

								vertices.push( start.x, start.y, start.z );
								vertices.push( end.x, end.y, end.z );

							}

						}

					}

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position;

				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( let j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						const index2 = 3 * i + ( ( j + 1 ) % 3 );

						start.fromBufferAttribute( position, index1 );
						end.fromBufferAttribute( position, index2 );

						if ( isUniqueEdge( start, end, edges ) === true ) {

							vertices.push( start.x, start.y, start.z );
							vertices.push( end.x, end.y, end.z );

						}

					}

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

}

function isUniqueEdge( start, end, edges ) {

	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

	if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {

		return false;

	} else {

		edges.add( hash1 );
		edges.add( hash2 );
		return true;

	}

}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	CapsuleGeometry: CapsuleGeometry,
	CircleGeometry: CircleGeometry,
	ConeGeometry: ConeGeometry,
	CylinderGeometry: CylinderGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	LatheGeometry: LatheGeometry,
	OctahedronGeometry: OctahedronGeometry,
	PlaneGeometry: PlaneGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	RingGeometry: RingGeometry,
	ShapeGeometry: ShapeGeometry,
	SphereGeometry: SphereGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TorusGeometry: TorusGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TubeGeometry: TubeGeometry,
	WireframeGeometry: WireframeGeometry
});

class ShadowMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShadowMaterial = true;

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.fog = source.fog;

		return this;

	}

}

class RawShaderMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( parameters );

		this.isRawShaderMaterial = true;

		this.type = 'RawShaderMaterial';

	}

}

class MeshStandardMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshStandardMaterial = true;

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshPhysicalMaterial extends MeshStandardMaterial {

	constructor( parameters ) {

		super();

		this.isMeshPhysicalMaterial = true;

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.ior = 1.5;

		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		this.iridescenceMap = null;
		this.iridescenceIOR = 1.3;
		this.iridescenceThicknessRange = [ 100, 400 ];
		this.iridescenceThicknessMap = null;

		this.sheenColor = new Color( 0x000000 );
		this.sheenColorMap = null;
		this.sheenRoughness = 1.0;
		this.sheenRoughnessMap = null;

		this.transmissionMap = null;

		this.thickness = 0;
		this.thicknessMap = null;
		this.attenuationDistance = Infinity;
		this.attenuationColor = new Color( 1, 1, 1 );

		this.specularIntensity = 1.0;
		this.specularIntensityMap = null;
		this.specularColor = new Color( 1, 1, 1 );
		this.specularColorMap = null;

		this._sheen = 0.0;
		this._clearcoat = 0;
		this._iridescence = 0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}

	get iridescence() {

		return this._iridescence;

	}

	set iridescence( value ) {

		if ( this._iridescence > 0 !== value > 0 ) {

			this.version ++;

		}

		this._iridescence = value;

	}

	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.ior = source.ior;

		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

class MeshPhongMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshPhongMaterial = true;

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshToonMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshToonMaterial = true;

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

class MeshNormalMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshNormalMaterial = true;

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.flatShading = source.flatShading;

		return this;

	}

}

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshLambertMaterial = true;

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshMatcapMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshMatcapMaterial = true;

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class LineDashedMaterial extends LineBasicMaterial {

	constructor( parameters ) {

		super();

		this.isLineDashedMaterial = true;

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

// same as Array.prototype.slice, but also works on typed arrays
function arraySlice( array, from, to ) {

	if ( isTypedArray( array ) ) {

		// in ios9 array.subarray(from, undefined) will return empty array
		// but array.subarray(from) or array.subarray(from, len) is correct
		return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

	}

	return array.slice( from, to );

}

// converts an array to a specific type
function convertArray( array, type, forceClone ) {

	if ( ! array || // let 'undefined' and 'null' pass
		! forceClone && array.constructor === type ) return array;

	if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

		return new type( array ); // create typed array

	}

	return Array.prototype.slice.call( array ); // create Array

}

function isTypedArray( object ) {

	return ArrayBuffer.isView( object ) &&
		! ( object instanceof DataView );

}

// returns an array by which times and values can be sorted
function getKeyframeOrder( times ) {

	function compareTime( i, j ) {

		return times[ i ] - times[ j ];

	}

	const n = times.length;
	const result = new Array( n );
	for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

	result.sort( compareTime );

	return result;

}

// uses the array previously returned by 'getKeyframeOrder' to sort data
function sortedArray( values, stride, order ) {

	const nValues = values.length;
	const result = new values.constructor( nValues );

	for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

		const srcOffset = order[ i ] * stride;

		for ( let j = 0; j !== stride; ++ j ) {

			result[ dstOffset ++ ] = values[ srcOffset + j ];

		}

	}

	return result;

}

// function for parsing AOS keyframe formats
function flattenJSON( jsonKeys, times, values, valuePropertyName ) {

	let i = 1, key = jsonKeys[ 0 ];

	while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

		key = jsonKeys[ i ++ ];

	}

	if ( key === undefined ) return; // no data

	let value = key[ valuePropertyName ];
	if ( value === undefined ) return; // no data

	if ( Array.isArray( value ) ) {

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push.apply( values, value ); // push all elements

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else if ( value.toArray !== undefined ) {

		// ...assume THREE.Math-ish

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				value.toArray( values, values.length );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else {

		// otherwise push as-is

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push( value );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	}

}

function subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {

	const clip = sourceClip.clone();

	clip.name = name;

	const tracks = [];

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		const track = clip.tracks[ i ];
		const valueSize = track.getValueSize();

		const times = [];
		const values = [];

		for ( let j = 0; j < track.times.length; ++ j ) {

			const frame = track.times[ j ] * fps;

			if ( frame < startFrame || frame >= endFrame ) continue;

			times.push( track.times[ j ] );

			for ( let k = 0; k < valueSize; ++ k ) {

				values.push( track.values[ j * valueSize + k ] );

			}

		}

		if ( times.length === 0 ) continue;

		track.times = convertArray( times, track.times.constructor );
		track.values = convertArray( values, track.values.constructor );

		tracks.push( track );

	}

	clip.tracks = tracks;

	// find minimum .times value across all tracks in the trimmed clip

	let minStartTime = Infinity;

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

			minStartTime = clip.tracks[ i ].times[ 0 ];

		}

	}

	// shift all tracks such that clip begins at t=0

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		clip.tracks[ i ].shift( - 1 * minStartTime );

	}

	clip.resetDuration();

	return clip;

}

function makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

	if ( fps <= 0 ) fps = 30;

	const numTracks = referenceClip.tracks.length;
	const referenceTime = referenceFrame / fps;

	// Make each track's values relative to the values at the reference frame
	for ( let i = 0; i < numTracks; ++ i ) {

		const referenceTrack = referenceClip.tracks[ i ];
		const referenceTrackType = referenceTrack.ValueTypeName;

		// Skip this track if it's non-numeric
		if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

		// Find the track in the target clip whose name and type matches the reference track
		const targetTrack = targetClip.tracks.find( function ( track ) {

			return track.name === referenceTrack.name
				&& track.ValueTypeName === referenceTrackType;

		} );

		if ( targetTrack === undefined ) continue;

		let referenceOffset = 0;
		const referenceValueSize = referenceTrack.getValueSize();

		if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

			referenceOffset = referenceValueSize / 3;

		}

		let targetOffset = 0;
		const targetValueSize = targetTrack.getValueSize();

		if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

			targetOffset = targetValueSize / 3;

		}

		const lastIndex = referenceTrack.times.length - 1;
		let referenceValue;

		// Find the value to subtract out of the track
		if ( referenceTime <= referenceTrack.times[ 0 ] ) {

			// Reference frame is earlier than the first keyframe, so just use the first keyframe
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			referenceValue = arraySlice( referenceTrack.values, startIndex, endIndex );

		} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

			// Reference frame is after the last keyframe, so just use the last keyframe
			const startIndex = lastIndex * referenceValueSize + referenceOffset;
			const endIndex = startIndex + referenceValueSize - referenceOffset;
			referenceValue = arraySlice( referenceTrack.values, startIndex, endIndex );

		} else {

			// Interpolate to the reference value
			const interpolant = referenceTrack.createInterpolant();
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			interpolant.evaluate( referenceTime );
			referenceValue = arraySlice( interpolant.resultBuffer, startIndex, endIndex );

		}

		// Conjugate the quaternion
		if ( referenceTrackType === 'quaternion' ) {

			const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
			referenceQuat.toArray( referenceValue );

		}

		// Subtract the reference value from all of the track values

		const numTimes = targetTrack.times.length;
		for ( let j = 0; j < numTimes; ++ j ) {

			const valueStart = j * targetValueSize + targetOffset;

			if ( referenceTrackType === 'quaternion' ) {

				// Multiply the conjugate for quaternion track types
				Quaternion.multiplyQuaternionsFlat(
					targetTrack.values,
					valueStart,
					referenceValue,
					0,
					targetTrack.values,
					valueStart
				);

			} else {

				const valueEnd = targetValueSize - targetOffset * 2;

				// Subtract each value for all other numeric track types
				for ( let k = 0; k < valueEnd; ++ k ) {

					targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

				}

			}

		}

	}

	targetClip.blendMode = AdditiveAnimationBlendMode;

	return targetClip;

}

const AnimationUtils = {
	arraySlice: arraySlice,
	convertArray: convertArray,
	isTypedArray: isTypedArray,
	getKeyframeOrder: getKeyframeOrder,
	sortedArray: sortedArray,
	flattenJSON: flattenJSON,
	subclip: subclip,
	makeClipAdditive: makeClipAdditive
};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

class Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

		this.settings = null;
		this.DefaultSettings_ = {};

	}

	evaluate( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.copySampleValue_( i1 - 1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.copySampleValue_( 0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.copySampleValue_( 0 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.copySampleValue_( i1 - 1 );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	}

	getSettings_() {

		return this.settings || this.DefaultSettings_;

	}

	copySampleValue_( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	// Template methods for derived classes:

	interpolate_( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	}

	intervalChanged_( /* i1, t0, t1 */ ) {

		// empty

	}

}

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

class CubicInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

		this.DefaultSettings_ = {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		};

	}

	intervalChanged_( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

}

class LinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

}

/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */

class DiscreteInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

}

class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = convertArray( times, this.TimeBufferType );
		this.values = convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': convertArray( track.times, Array ),
				'values': convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = arraySlice( times, from, to );
			this.values = arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = arraySlice( this.times ),
			values = arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = arraySlice( times, 0, writeIndex );
			this.values = arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = arraySlice( this.times, 0 );
		const values = arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

class QuaternionLinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

}

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {

	constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = getKeyframeOrder( times );
			times = sortedArray( times, 1, order );
			values = sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * fps;

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

class LoadingManager {

	constructor( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

}

const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

class Loader {

	constructor( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	load( /* url, onLoad, onProgress, onError */ ) {}

	loadAsync( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	}

	parse( /* data */ ) {}

	setCrossOrigin( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	}

	setWithCredentials( value ) {

		this.withCredentials = value;
		return this;

	}

	setPath( path ) {

		this.path = path;
		return this;

	}

	setResourcePath( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

	setRequestHeader( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

}

const loading = {};

class HttpError extends Error {

	constructor( message, response ) {

		super( message );
		this.response = response;

	}

}

class FileLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			this.manager.itemStart( url );

			setTimeout( () => {

				if ( onLoad ) onLoad( cached );

				this.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Initialise array for duplicate requests
		loading[ url ] = [];

		loading[ url ].push( {
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError,
		} );

		// create request
		const req = new Request( url, {
			headers: new Headers( this.requestHeader ),
			credentials: this.withCredentials ? 'include' : 'same-origin',
			// An abort controller could be added within a future PR
		} );

		// record states ( avoid data race )
		const mimeType = this.mimeType;
		const responseType = this.responseType;

		// start the fetch
		fetch( req )
			.then( response => {

				if ( response.status === 200 || response.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( response.status === 0 ) {

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					}

					// Workaround: Checking if response.body === undefined for Alipay browser #23548

					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

						return response;

					}

					const callbacks = loading[ url ];
					const reader = response.body.getReader();

					// Nginx needs X-File-Size check
					// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
					const contentLength = response.headers.get( 'Content-Length' ) || response.headers.get( 'X-File-Size' );
					const total = contentLength ? parseInt( contentLength ) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0;

					// periodically read data into the new stream tracking while download progress
					const stream = new ReadableStream( {
						start( controller ) {

							readData();

							function readData() {

								reader.read().then( ( { done, value } ) => {

									if ( done ) {

										controller.close();

									} else {

										loaded += value.byteLength;

										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

											const callback = callbacks[ i ];
											if ( callback.onProgress ) callback.onProgress( event );

										}

										controller.enqueue( value );
										readData();

									}

								} );

							}

						}

					} );

					return new Response( stream );

				} else {

					throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

				}

			} )
			.then( response => {

				switch ( responseType ) {

					case 'arraybuffer':

						return response.arrayBuffer();

					case 'blob':

						return response.blob();

					case 'document':

						return response.text()
							.then( text => {

								const parser = new DOMParser();
								return parser.parseFromString( text, mimeType );

							} );

					case 'json':

						return response.json();

					default:

						if ( mimeType === undefined ) {

							return response.text();

						} else {

							// sniff encoding
							const re = /charset="?([^;"\s]*)"?/i;
							const exec = re.exec( mimeType );
							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
							const decoder = new TextDecoder( label );
							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

						}

				}

			} )
			.then( data => {

				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add( url, data );

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onLoad ) callback.onLoad( data );

				}

			} )
			.catch( err => {

				// Abort errors and other errors are handled the same

				const callbacks = loading[ url ];

				if ( callbacks === undefined ) {

					// When onLoad was called and url was deleted in `loading`
					this.manager.itemError( url );
					throw err;

				}

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( err );

				}

				this.manager.itemError( url );

			} )
			.finally( () => {

				this.manager.itemEnd( url );

			} );

		this.manager.itemStart( url );

	}

	setResponseType( value ) {

		this.responseType = value;
		return this;

	}

	setMimeType( value ) {

		this.mimeType = value;
		return this;

	}

}

class AnimationLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

}

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class CompressedTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new CompressedTexture();

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

					texture.image = images;

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

}

class ImageLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = createElementNS( 'img' );

		function onImageLoad() {

			removeEventListeners();

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			removeEventListeners();

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		function removeEventListeners() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.slice( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

class CubeTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( urls, onLoad, onProgress, onError ) {

		const texture = new CubeTexture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

}

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class DataTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			const texData = scope.parse( buffer );

			if ( ! texData ) return;

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.encoding !== undefined ) {

				texture.encoding = texData.encoding;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			if ( texData.generateMipmaps !== undefined ) {

				texture.generateMipmaps = texData.generateMipmaps;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

}

class TextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

}

class Light extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.isLight = true;

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity;

	}

	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

class HemisphereLight extends Light {

	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		this.isHemisphereLight = true;

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( _projScreenMatrix$1 );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.isSpotLightShadow = true;

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

class SpotLight extends Light {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

		super( color, intensity );

		this.isSpotLight = true;

		this.type = 'SpotLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay;

		this.map = null;

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this.isPointLightShadow = true;

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

class PointLight extends Light {

	constructor( color, intensity, distance = 0, decay = 2 ) {

		super( color, intensity );

		this.isPointLight = true;

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay;

		this.shadow = new PointLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		this.isDirectionalLightShadow = true;

	}

}

class DirectionalLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isDirectionalLight = true;

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

class AmbientLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isAmbientLight = true;

		this.type = 'AmbientLight';

	}

}

class RectAreaLight extends Light {

	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		this.isRectAreaLight = true;

		this.type = 'RectAreaLight';

		this.width = width;
		this.height = height;

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in nits)
		return this.intensity * this.width * this.height * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in nits) from the desired luminous power (in lumens)
		this.intensity = power / ( this.width * this.height * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		this.isSphericalHarmonics3 = true;

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

class LightProbe extends Light {

	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		super( undefined, intensity );

		this.isLightProbe = true;

		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

class MaterialLoader extends Loader {

	constructor( manager ) {

		super( manager );
		this.textures = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = MaterialLoader.createMaterialFromType( json.type );

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = json.sheen;
		if ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );
		if ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;
		if ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.iridescence !== undefined ) material.iridescence = json.iridescence;
		if ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;
		if ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.thickness !== undefined ) material.thickness = json.thickness;
		if ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;
		if ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;
		if ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
		if ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );
		if ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );
		if ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );

		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );
		if ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );

		if ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );
		if ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );

		return material;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

	static createMaterialFromType( type ) {

		const materialLib = {
			ShadowMaterial,
			SpriteMaterial,
			RawShaderMaterial,
			ShaderMaterial,
			PointsMaterial,
			MeshPhysicalMaterial,
			MeshStandardMaterial,
			MeshPhongMaterial,
			MeshToonMaterial,
			MeshNormalMaterial,
			MeshLambertMaterial,
			MeshDepthMaterial,
			MeshDistanceMaterial,
			MeshBasicMaterial,
			MeshMatcapMaterial,
			LineDashedMaterial,
			LineBasicMaterial,
			Material
		};

		return new materialLib[ type ]();

	}

}

class LoaderUtils {

	static decodeText( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	}

	static extractUrlBase( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.slice( 0, index + 1 );

	}

	static resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return '';

		// Host Relative URL
		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		}

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) return url;

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) return url;

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) return url;

		// Relative URL
		return path + url;

	}

}

class InstancedBufferGeometry extends BufferGeometry {

	constructor() {

		super();

		this.isInstancedBufferGeometry = true;

		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;

	}

	copy( source ) {

		super.copy( source );

		this.instanceCount = source.instanceCount;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

}

class BufferGeometryLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = getTypedArray( interleavedBuffer.type, buffer );
			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = getTypedArray( index.type, index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = getTypedArray( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

			if ( attribute.updateRange !== undefined ) {

				bufferAttribute.updateRange.offset = attribute.updateRange.offset;
				bufferAttribute.updateRange.count = attribute.updateRange.count;

			}

			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = getTypedArray( attribute.type, attribute.array );
						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

}

class ObjectLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				if ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\'t load ' + url ) );

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	async loadAsync( url, onProgress ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		const text = await loader.loadAsync( url, onProgress );

		const json = JSON.parse( text );

		const metadata = json.metadata;

		if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

			throw new Error( 'THREE.ObjectLoader: Can\'t load ' + url );

		}

		return await scope.parseAsync( json );

	}

	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ].data instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	async parseAsync( json ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = await this.parseImagesAsync( json.images );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};

		if ( json !== undefined ) {

			const bufferGeometryLoader = new BufferGeometryLoader();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );
						break;

					default:

						if ( data.type in Geometries ) {

							geometry = Geometries[ data.type ].fromJSON( data, shapes );

						} else {

							console.warn( `THREE.ObjectLoader: Unsupported geometry type "${ data.type }"` );

						}

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( cache[ data.uuid ] === undefined ) {

					cache[ data.uuid ] = loader.parse( data );

				}

				materials[ data.uuid ] = cache[ data.uuid ];

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new LoadingManager( onLoad );

			loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );


				}

			}

		}

		return images;

	}

	async parseImagesAsync( json ) {

		const scope = this;
		const images = {};

		let loader;

		async function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return await loader.loadAsync( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = await deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = await deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				const source = images[ data.image ];
				const image = source.data;

				let texture;

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture();

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture();

					} else {

						texture = new Texture();

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.source = source;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;
				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

				if ( data.userData !== undefined ) texture.userData = data.userData;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, textures, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		function getTexture( uuid ) {

			if ( textures[ uuid ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined texture', uuid );

			}

			return textures[ uuid ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					} else {

						object.background = getTexture( data.background );

					}

				}

				if ( data.environment !== undefined ) {

					object.environment = getTexture( data.environment );

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

				}

				if ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;
				if ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
				if ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			case 'Bone':

				object = new Bone();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance, level.hysteresis );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

class ImageBitmapLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.isImageBitmapLoader = true;

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.options = { premultiplyAlpha: 'none' };

	}

	setOptions( options ) {

		this.options = options;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

}

let _context;

class AudioContext {

	static getContext() {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	}

	static setContext( value ) {

		_context = value;

	}

}

class AudioLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

}

class HemisphereLightProbe extends LightProbe {

	constructor( skyColor, groundColor, intensity = 1 ) {

		super( undefined, intensity );

		this.isHemisphereLightProbe = true;

		const color1 = new Color().set( skyColor );
		const color2 = new Color().set( groundColor );

		const sky = new Vector3( color1.r, color1.g, color1.b );
		const ground = new Vector3( color2.r, color2.g, color2.b );

		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		const c0 = Math.sqrt( Math.PI );
		const c1 = c0 * Math.sqrt( 0.75 );

		this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
		this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

	}

}

class AmbientLightProbe extends LightProbe {

	constructor( color, intensity = 1 ) {

		super( undefined, intensity );

		this.isAmbientLightProbe = true;

		const color1 = new Color().set( color );

		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

	}

}

const _eyeRight = /*@__PURE__*/ new Matrix4();
const _eyeLeft = /*@__PURE__*/ new Matrix4();
const _projectionMatrix = /*@__PURE__*/ new Matrix4();

class StereoCamera {

	constructor() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	update( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			_projectionMatrix.copy( camera.projectionMatrix );
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( _projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( _projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

}

class Clock {

	constructor( autoStart = true ) {

		this.autoStart = autoStart;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

}

const _position$1 = /*@__PURE__*/ new Vector3();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();

class AudioListener extends Object3D {

	constructor() {

		super();

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	getInput() {

		return this.gain;

	}

	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	getFilter() {

		return this.filter;

	}

	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	getMasterVolume() {

		return this.gain.gain.value;

	}

	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );

		_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$1.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$1.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$1.x, _position$1.y, _position$1.z );
			listener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );

		}

	}

}

class Audio extends Object3D {

	constructor( listener ) {

		super();

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		this.filters = [];

	}

	getOutput() {

		return this.gain;

	}

	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	stop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		if ( this.source !== null ) {

			this.source.stop();
			this.source.onended = null;

		}

		this.isPlaying = false;

		return this;

	}

	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	disconnect() {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	getFilters() {

		return this.filters;

	}

	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	setDetune( value ) {

		this.detune = value;

		if ( this.source.detune === undefined ) return; // only set detune when available

		if ( this.isPlaying === true ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getDetune() {

		return this.detune;

	}

	getFilter() {

		return this.getFilters()[ 0 ];

	}

	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getPlaybackRate() {

		return this.playbackRate;

	}

	onEnded() {

		this.isPlaying = false;

	}

	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	getVolume() {

		return this.gain.gain.value;

	}

	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

}

const _position = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();
const _scale = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();

class PositionalAudio extends Audio {

	constructor( listener ) {

		super( listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	disconnect() {

		super.disconnect();

		this.panner.disconnect( this.gain );

	}

	getOutput() {

		return this.panner;

	}

	getRefDistance() {

		return this.panner.refDistance;

	}

	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	getDistanceModel() {

		return this.panner.distanceModel;

	}

	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	getMaxDistance() {

		return this.panner.maxDistance;

	}

	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position, _quaternion, _scale );

		_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

		} else {

			panner.setPosition( _position.x, _position.y, _position.z );
			panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

		}

	}

}

class AudioAnalyser {

	constructor( audio, fftSize = 2048 ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}


	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}

class PropertyMixer {

	constructor( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		let mixFunction,
			mixFunctionAdditive,
			setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;

				this.buffer = new Float64Array( valueSize * 6 );
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;

				setIdentity = this._setAdditiveIdentityOther;

				this.buffer = new Array( valueSize * 5 );
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;

				this.buffer = new Float64Array( valueSize * 5 );

		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	}

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	}

	// apply the state of 'accu<i>' to the binding when accus differ
	apply( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	}

	// remember the state of the bound property and copy it to both accus
	saveOriginalState() {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	}

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState() {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	}

	_setAdditiveIdentityNumeric() {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	}

	_setAdditiveIdentityQuaternion() {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	}

	_setAdditiveIdentityOther() {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	}


	// mix functions

	_select( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	}

	_slerp( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	}

	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	}

	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];

class Composite {

	constructor( targetGroup, path, optionalParsedPath ) {

		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	getValue( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	}

	setValue( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	}

	bind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	}

	unbind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

}

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding {

	constructor( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );

		this.rootNode = rootNode;

		// initial state of these methods that calls 'bind'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}


	static create( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	}

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	static sanitizeNodeName( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	}

	static parseTrackName( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( matches === null ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	}

	static findNode( root, nodeName ) {

		if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

	// these are used to "bind" a nonexistent property
	_getValue_unavailable() {}
	_setValue_unavailable() {}

	// Getters

	_getValue_direct( buffer, offset ) {

		buffer[ offset ] = this.targetObject[ this.propertyName ];

	}

	_getValue_array( buffer, offset ) {

		const source = this.resolvedProperty;

		for ( let i = 0, n = source.length; i !== n; ++ i ) {

			buffer[ offset ++ ] = source[ i ];

		}

	}

	_getValue_arrayElement( buffer, offset ) {

		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	}

	_getValue_toArray( buffer, offset ) {

		this.resolvedProperty.toArray( buffer, offset );

	}

	// Direct

	_setValue_direct( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];

	}

	_setValue_direct_setNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// EntireArray

	_setValue_array( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

	}

	_setValue_array_setNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.needsUpdate = true;

	}

	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// ArrayElement

	_setValue_arrayElement( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	}

	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// HasToFromArray

	_setValue_fromArray( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );

	}

	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.needsUpdate = true;

	}

	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	_getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

	}

	_setValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	}

	// create getter / setter pair for a property in the scene graph
	bind() {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				case 'map':

					if ( 'map' in targetObject ) {

						targetObject = targetObject.map;
						break;

					}

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.map ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );
						return;

					}

					targetObject = targetObject.material.map;
					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( ! targetObject.geometry.morphAttributes ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
					return;

				}

				if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

					propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	}

	unbind() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

}

PropertyBinding.Composite = Composite;

PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};

PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};

PropertyBinding.prototype.GetterByBindingType = [

	PropertyBinding.prototype._getValue_direct,
	PropertyBinding.prototype._getValue_array,
	PropertyBinding.prototype._getValue_arrayElement,
	PropertyBinding.prototype._getValue_toArray,

];

PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

	[
		// Direct
		PropertyBinding.prototype._setValue_direct,
		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	], [

		// EntireArray

		PropertyBinding.prototype._setValue_array,
		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	], [

		// ArrayElement
		PropertyBinding.prototype._setValue_arrayElement,
		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	], [

		// HasToFromArray
		PropertyBinding.prototype._setValue_fromArray,
		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	]

];

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

class AnimationObjectGroup {

	constructor() {

		this.isAnimationObjectGroup = true;

		this.uuid = generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	add() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	remove() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// remove & forget
	uncache() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	}

	unsubscribe_( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

}

class AnimationAction {

	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	// State & Scheduling

	play() {

		this._mixer._activateAction( this );

		return this;

	}

	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	// return true when play has been called
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	startAt( time ) {

		this._startTime = time;

		return this;

	}

	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	crossFadeFrom( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	crossFadeTo( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	// Object Accessors

	getMixer() {

		return this._mixer;

	}

	getClip() {

		return this._clip;

	}

	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				deltaTime = 0;

			} else {


				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}

const _controlInterpolantsResultBuffer = new Float32Array( 1 );


class AnimationMixer extends EventDispatcher {

	constructor( root ) {

		super();

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;

	}

	_bindAction( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				++ binding.referenceCount;
				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	}

	_activateAction( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	}

	_deactivateAction( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	}

	// Memory manager

	_initMemoryManager() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	}

	// Memory management for AnimationAction objects

	_isActiveAction( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	}

	_addInactiveAction( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	}

	_removeInactiveAction( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	}

	_removeInactiveBindingsForAction( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	}

	_lendAction( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	}

	_takeBackAction( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	}

	_removeInactiveBinding( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	}

	_lendBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	}

	_takeBackBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	}


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, _controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	}

	_takeBackControlInterpolant( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	}

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	}

	// get an existing action
	existingAction( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	}

	// deactivates all previously scheduled actions
	stopAllAction() {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	}

	// advance the time and update apply the animation
	update( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	}

	// Allows you to seek to a specific time in an animation.
	setTime( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	}

	// return this mixer's root target object
	getRoot() {

		return this._root;

	}

	// free all resources specific to a particular clip
	uncacheClip( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	}

	// free all resources specific to a particular root target object
	uncacheRoot( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	}

	// remove a targeted clip from the cache
	uncacheAction( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

}

class Uniform {

	constructor( value ) {

		this.value = value;

	}

	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}

let id = 0;

class UniformsGroup extends EventDispatcher {

	constructor() {

		super();

		this.isUniformsGroup = true;

		Object.defineProperty( this, 'id', { value: id ++ } );

		this.name = '';

		this.usage = StaticDrawUsage;
		this.uniforms = [];

	}

	add( uniform ) {

		this.uniforms.push( uniform );

		return this;

	}

	remove( uniform ) {

		const index = this.uniforms.indexOf( uniform );

		if ( index !== - 1 ) this.uniforms.splice( index, 1 );

		return this;

	}

	setName( name ) {

		this.name = name;

		return this;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

		return this;

	}

	copy( source ) {

		this.name = source.name;
		this.usage = source.usage;

		const uniformsSource = source.uniforms;

		this.uniforms.length = 0;

		for ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {

			this.uniforms.push( uniformsSource[ i ].clone() );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class InstancedInterleavedBuffer extends InterleavedBuffer {

	constructor( array, stride, meshPerAttribute = 1 ) {

		super( array, stride );

		this.isInstancedInterleavedBuffer = true;

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	clone( data ) {

		const ib = super.clone( data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	}

	toJSON( data ) {

		const json = super.toJSON( data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

}

class GLBufferAttribute {

	constructor( buffer, type, itemSize, elementSize, count ) {

		this.isGLBufferAttribute = true;

		this.name = '';

		this.buffer = buffer;
		this.type = type;
		this.itemSize = itemSize;
		this.elementSize = elementSize;
		this.count = count;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setBuffer( buffer ) {

		this.buffer = buffer;

		return this;

	}

	setType( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	}

	setItemSize( itemSize ) {

		this.itemSize = itemSize;

		return this;

	}

	setCount( count ) {

		this.count = count;

		return this;

	}

}

class Raycaster {

	constructor( origin, direction, near = 0, far = Infinity ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

	}

	set( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	}

	setFromCamera( coords, camera ) {

		if ( camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	}

	intersectObject( object, recursive = true, intersects = [] ) {

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	}

	intersectObjects( objects, recursive = true, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be between EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {

	constructor( radius = 1, theta = 0, y = 0 ) {

		this.radius = radius; // distance from the origin to a point in the x-z plane
		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = y; // height above the x-z plane

		return this;

	}

	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$4 = /*@__PURE__*/ new Vector2();

class Box2 {

	constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

		this.isBox2 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$4 ).distanceTo( point );

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

class Line3 {

	constructor( start = new Vector3(), end = new Vector3() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$3 = /*@__PURE__*/ new Vector3();

class SpotLightHelper extends Object3D {

	constructor( light, color ) {

		super();

		this.light = light;

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		this.type = 'SpotLightHelper';

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	update() {

		this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector$3 );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}

const _vector$2 = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


class SkeletonHelper extends LineSegments {

	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color( 0, 0, 1 );
		const color2 = new Color( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		this.isSkeletonHelper = true;

		this.type = 'SkeletonHelper';

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object.isBone === true ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

class PointLightHelper extends Mesh {

	constructor( light, sphereSize, color ) {

		const geometry = new SphereGeometry( sphereSize, 4, 2 );
		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		this.light = light;

		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	update() {

		this.light.updateWorldMatrix( true, false );

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}

const _vector$1 = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();

class HemisphereLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();

		this.light = light;

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		this.type = 'HemisphereLightHelper';

		const geometry = new OctahedronGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		this.light.updateWorldMatrix( true, false );

		mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}

class GridHelper extends LineSegments {

	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class PolarGridHelper extends LineSegments {

	constructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const vertices = [];
		const colors = [];

		// create the sectors

		if ( sectors > 1 ) {

			for ( let i = 0; i < sectors; i ++ ) {

				const v = ( i / sectors ) * ( Math.PI * 2 );

				const x = Math.sin( v ) * radius;
				const z = Math.cos( v ) * radius;

				vertices.push( 0, 0, 0 );
				vertices.push( x, 0, z );

				const color = ( i & 1 ) ? color1 : color2;

				colors.push( color.r, color.g, color.b );
				colors.push( color.r, color.g, color.b );

			}

		}

		// create the rings

		for ( let i = 0; i < rings; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / rings * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();

class DirectionalLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();

		this.light = light;

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		this.type = 'DirectionalLightHelper';

		if ( size === undefined ) size = 1;

		let geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	update() {

		this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		_v1.setFromMatrixPosition( this.light.matrixWorld );
		_v2.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3.subVectors( _v2, _v1 );

		this.lightPlane.lookAt( _v2 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2 );
		this.targetLine.scale.z = _v3.length();

	}

}

const _vector = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {

	constructor( camera ) {

		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// near

		addLine( 'n1', 'n2' );
		addLine( 'n2', 'n4' );
		addLine( 'n4', 'n3' );
		addLine( 'n3', 'n1' );

		// far

		addLine( 'f1', 'f2' );
		addLine( 'f2', 'f4' );
		addLine( 'f4', 'f3' );
		addLine( 'f3', 'f1' );

		// sides

		addLine( 'n1', 'f1' );
		addLine( 'n2', 'f2' );
		addLine( 'n3', 'f3' );
		addLine( 'n4', 'f4' );

		// cone

		addLine( 'p', 'n1' );
		addLine( 'p', 'n2' );
		addLine( 'p', 'n3' );
		addLine( 'p', 'n4' );

		// up

		addLine( 'u1', 'u2' );
		addLine( 'u2', 'u3' );
		addLine( 'u3', 'u1' );

		// target

		addLine( 'c', 't' );
		addLine( 'p', 'c' );

		// cross

		addLine( 'cn1', 'cn2' );
		addLine( 'cn3', 'cn4' );

		addLine( 'cf1', 'cf2' );
		addLine( 'cf3', 'cf4' );

		function addLine( a, b ) {

			addPoint( a );
			addPoint( b );

		}

		function addPoint( id ) {

			vertices.push( 0, 0, 0 );
			colors.push( 0, 0, 0 );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

		// colors

		const colorFrustum = new Color( 0xffaa00 );
		const colorCone = new Color( 0xff0000 );
		const colorUp = new Color( 0x00aaff );
		const colorTarget = new Color( 0xffffff );
		const colorCross = new Color( 0x333333 );

		this.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );

	}

	setColors( frustum, cone, up, target, cross ) {

		const geometry = this.geometry;

		const colorAttribute = geometry.getAttribute( 'color' );

		// near

		colorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2
		colorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4
		colorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3
		colorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1

		// far

		colorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2
		colorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4
		colorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3
		colorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1

		// sides

		colorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1
		colorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2
		colorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3
		colorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4

		// cone

		colorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1
		colorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2
		colorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3
		colorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4

		// up

		colorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2
		colorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3
		colorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1

		// target

		colorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t
		colorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c

		// cross

		colorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2
		colorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4

		colorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2
		colorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4

		colorAttribute.needsUpdate = true;

	}

	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// center / target

		setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
		setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
		setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
		setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

		// far

		setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
		setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
		setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
		setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

		}

	}

}

const _box = /*@__PURE__*/ new Box3();

class BoxHelper extends LineSegments {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			_box.setFromObject( this.object );

		}

		if ( _box.isEmpty() ) return;

		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.object = source.object;

		return this;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class Box3Helper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class PlaneHelper extends Line {

	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = size;

		const positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		this.position.set( 0, 0, 0 );

		this.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );

		this.lookAt( this.plane.normal );

		this.translateZ( - this.plane.constant );

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

}

const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {

	// dir is assumed to be normalized

	constructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		super();

		this.type = 'ArrowHelper';

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

	dispose() {

		this.line.geometry.dispose();
		this.line.material.dispose();
		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

}

class AxesHelper extends LineSegments {

	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

	setColors( xAxisColor, yAxisColor, zAxisColor ) {

		const color = new Color();
		const array = this.geometry.attributes.color.array;

		color.set( xAxisColor );
		color.toArray( array, 0 );
		color.toArray( array, 3 );

		color.set( yAxisColor );
		color.toArray( array, 6 );
		color.toArray( array, 9 );

		color.set( zAxisColor );
		color.toArray( array, 12 );
		color.toArray( array, 15 );

		this.geometry.attributes.color.needsUpdate = true;

		return this;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class ShapePath {

	constructor() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	moveTo( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	}

	lineTo( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	}

	splineThru( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	}

	toShapes( isCCW ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = ShapeUtils.isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			let toChange = 0;

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange ++;

							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}

			if ( toChange > 0 && ambiguous === false ) {

				newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

}

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

const _tables = /*@__PURE__*/ _generateTables();

function _generateTables() {

	// float32 to float16 helpers

	const buffer = new ArrayBuffer( 4 );
	const floatView = new Float32Array( buffer );
	const uint32View = new Uint32Array( buffer );

	const baseTable = new Uint32Array( 512 );
	const shiftTable = new Uint32Array( 512 );

	for ( let i = 0; i < 256; ++ i ) {

		const e = i - 127;

		// very small number (0, -0)

		if ( e < - 27 ) {

			baseTable[ i ] = 0x0000;
			baseTable[ i | 0x100 ] = 0x8000;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// small number (denorm)

		} else if ( e < - 14 ) {

			baseTable[ i ] = 0x0400 >> ( - e - 14 );
			baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
			shiftTable[ i ] = - e - 1;
			shiftTable[ i | 0x100 ] = - e - 1;

			// normal number

		} else if ( e <= 15 ) {

			baseTable[ i ] = ( e + 15 ) << 10;
			baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

			// large number (Infinity, -Infinity)

		} else if ( e < 128 ) {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// stay (NaN, Infinity, -Infinity)

		} else {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

		}

	}

	// float16 to float32 helpers

	const mantissaTable = new Uint32Array( 2048 );
	const exponentTable = new Uint32Array( 64 );
	const offsetTable = new Uint32Array( 64 );

	for ( let i = 1; i < 1024; ++ i ) {

		let m = i << 13; // zero pad mantissa bits
		let e = 0; // zero exponent

		// normalized
		while ( ( m & 0x00800000 ) === 0 ) {

			m <<= 1;
			e -= 0x00800000; // decrement exponent

		}

		m &= ~ 0x00800000; // clear leading 1 bit
		e += 0x38800000; // adjust bias

		mantissaTable[ i ] = m | e;

	}

	for ( let i = 1024; i < 2048; ++ i ) {

		mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

	}

	for ( let i = 1; i < 31; ++ i ) {

		exponentTable[ i ] = i << 23;

	}

	exponentTable[ 31 ] = 0x47800000;
	exponentTable[ 32 ] = 0x80000000;

	for ( let i = 33; i < 63; ++ i ) {

		exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

	}

	exponentTable[ 63 ] = 0xc7800000;

	for ( let i = 1; i < 64; ++ i ) {

		if ( i !== 32 ) {

			offsetTable[ i ] = 1024;

		}

	}

	return {
		floatView: floatView,
		uint32View: uint32View,
		baseTable: baseTable,
		shiftTable: shiftTable,
		mantissaTable: mantissaTable,
		exponentTable: exponentTable,
		offsetTable: offsetTable
	};

}

// float32 to float16

function toHalfFloat( val ) {

	if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );

	val = clamp( val, - 65504, 65504 );

	_tables.floatView[ 0 ] = val;
	const f = _tables.uint32View[ 0 ];
	const e = ( f >> 23 ) & 0x1ff;
	return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

}

// float16 to float32

function fromHalfFloat( val ) {

	const m = val >> 10;
	_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
	return _tables.floatView[ 0 ];

}

const DataUtils = {
	toHalfFloat: toHalfFloat,
	fromHalfFloat: fromHalfFloat,
};

// r144

class BoxBufferGeometry extends BoxGeometry {

	constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		console.warn( 'THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry.' );
		super( width, height, depth, widthSegments, heightSegments, depthSegments );


	}

}

// r144

class CapsuleBufferGeometry extends CapsuleGeometry {

	constructor( radius, length, capSegments, radialSegments ) {

		console.warn( 'THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry.' );
		super( radius, length, capSegments, radialSegments );

	}

}

// r144

class CircleBufferGeometry extends CircleGeometry {

	constructor( radius, segments, thetaStart, thetaLength ) {

		console.warn( 'THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry.' );
		super( radius, segments, thetaStart, thetaLength );

	}

}

// r144

class ConeBufferGeometry extends ConeGeometry {

	constructor( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		console.warn( 'THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry.' );
		super( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	}

}

// r144

class CylinderBufferGeometry extends CylinderGeometry {

	constructor( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		console.warn( 'THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry.' );
		super( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	}

}

// r144

class DodecahedronBufferGeometry extends DodecahedronGeometry {

	constructor( radius, detail ) {

		console.warn( 'THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry.' );
		super( radius, detail );

	}

}

// r144

class ExtrudeBufferGeometry extends ExtrudeGeometry {

	constructor( shapes, options ) {

		console.warn( 'THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry.' );
		super( shapes, options );

	}

}

// r144

class IcosahedronBufferGeometry extends IcosahedronGeometry {

	constructor( radius, detail ) {

		console.warn( 'THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry.' );
		super( radius, detail );

	}

}

// r144

class LatheBufferGeometry extends LatheGeometry {

	constructor( points, segments, phiStart, phiLength ) {

		console.warn( 'THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry.' );
		super( points, segments, phiStart, phiLength );

	}

}

// r144

class OctahedronBufferGeometry extends OctahedronGeometry {

	constructor( radius, detail ) {

		console.warn( 'THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry.' );
		super( radius, detail );

	}

}

// r144

class PlaneBufferGeometry extends PlaneGeometry {

	constructor( width, height, widthSegments, heightSegments ) {

		console.warn( 'THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry.' );
		super( width, height, widthSegments, heightSegments );

	}

}

// r144

class PolyhedronBufferGeometry extends PolyhedronGeometry {

	constructor( vertices, indices, radius, detail ) {

		console.warn( 'THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry.' );
		super( vertices, indices, radius, detail );

	}

}

// r144

class RingBufferGeometry extends RingGeometry {

	constructor( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		console.warn( 'THREE.RingBufferGeometry has been renamed to THREE.RingGeometry.' );
		super( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength );

	}

}

// r144

class ShapeBufferGeometry extends ShapeGeometry {

	constructor( shapes, curveSegments ) {

		console.warn( 'THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry.' );
		super( shapes, curveSegments );

	}

}

// r144

class SphereBufferGeometry extends SphereGeometry {

	constructor( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		console.warn( 'THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry.' );
		super( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength );

	}

}

// r144

class TetrahedronBufferGeometry extends TetrahedronGeometry {

	constructor( radius, detail ) {

		console.warn( 'THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry.' );
		super( radius, detail );

	}

}

// r144

class TorusBufferGeometry extends TorusGeometry {

	constructor( radius, tube, radialSegments, tubularSegments, arc ) {

		console.warn( 'THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry.' );
		super( radius, tube, radialSegments, tubularSegments, arc );

	}

}

// r144

class TorusKnotBufferGeometry extends TorusKnotGeometry {

	constructor( radius, tube, tubularSegments, radialSegments, p, q ) {

		console.warn( 'THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry.' );
		super( radius, tube, tubularSegments, radialSegments, p, q );

	}

}

// r144

class TubeBufferGeometry extends TubeGeometry {

	constructor( path, tubularSegments, radius, radialSegments, closed ) {

		console.warn( 'THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry.' );
		super( path, tubularSegments, radius, radialSegments, closed );

	}

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/controls/OrbitControls.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/controls/OrbitControls.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MapControls": () => (/* binding */ MapControls),
/* harmony export */   "OrbitControls": () => (/* binding */ OrbitControls)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };

class OrbitControls extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {

	constructor( object, domElement ) {

		super();

		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Mouse buttons
		this.mouseButtons = { LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE, MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY, RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN };

		// Touch fingers
		this.touches = { ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE, TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.getDistance = function () {

			return this.object.position.distanceTo( this.target );

		};

		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.stopListenToKeyEvents = function () {

			this._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = null;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( _changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

			// so camera.up is the orbit axis
			const quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors( object.up, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 1, 0 ) );
			const quatInverse = quat.clone().invert();

			const lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			const lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();

			const twoPI = 2 * Math.PI;

			return function update() {

				const position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;

				if ( isFinite( min ) && isFinite( max ) ) {

					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

					if ( min <= max ) {

						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

					} else {

						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
							Math.max( min, spherical.theta ) :
							Math.min( max, spherical.theta );

					}

				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				spherical.radius *= scale;

				// restrict radius to be between desired limits
				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

				scale = 1;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

					scope.dispatchEvent( _changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerCancel );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.removeEventListener( 'pointerup', onPointerUp );


			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
				scope._domElementKeyEvents = null;

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();
		const sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();

		let scale = 1;
		const panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		let zoomChanged = false;

		const rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		const panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		const dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		const pointers = [];
		const pointerPositions = {};

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		const panLeft = function () {

			const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		const panUp = function () {

			const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {

			const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

			return function pan( deltaX, deltaY ) {

				const element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					const position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseWheel( event ) {

			if ( event.deltaY < 0 ) {

				dollyIn( getZoomScale() );

			} else if ( event.deltaY > 0 ) {

				dollyOut( getZoomScale() );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			switch ( event.code ) {

				case scope.keys.UP:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, - scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.LEFT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

				case scope.keys.RIGHT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( - scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate() {

			if ( pointers.length === 1 ) {

				rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan() {

			if ( pointers.length === 1 ) {

				panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly() {

			const dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;
			const dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enablePan ) handleTouchStartPan();

		}

		function handleTouchStartDollyRotate() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enableRotate ) handleTouchStartRotate();

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.setPointerCapture( event.pointerId );

				scope.domElement.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.addEventListener( 'pointerup', onPointerUp );

			}

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

		    removePointer( event );

		    if ( pointers.length === 0 ) {

		        scope.domElement.releasePointerCapture( event.pointerId );

		        scope.domElement.removeEventListener( 'pointermove', onPointerMove );
		        scope.domElement.removeEventListener( 'pointerup', onPointerUp );

		    }

		    scope.dispatchEvent( _endEvent );

		    state = STATE.NONE;

		}

		function onPointerCancel( event ) {

			removePointer( event );

		}

		function onMouseDown( event ) {

			let mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = - 1;

			}

			switch ( mouseAction ) {

				case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onMouseMove( event ) {

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

			event.preventDefault();

			scope.dispatchEvent( _startEvent );

			handleMouseWheel( event );

			scope.dispatchEvent( _endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate();

							state = STATE.TOUCH_ROTATE;

							break;

						case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan();

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan();

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate();

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ].pointerId == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.pageX, event.pageY );

		}

		function getSecondPointerPosition( event ) {

			const pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointer.pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerCancel );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		// force an update at start

		this.update();

	}

}


// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move

class MapControls extends OrbitControls {

	constructor( object, domElement ) {

		super( object, domElement );

		this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

		this.mouseButtons.LEFT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN;
		this.mouseButtons.RIGHT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE;

		this.touches.ONE = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN;
		this.touches.TWO = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE;

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/geometries/RoundedBoxGeometry.js":
/*!**************************************************************************!*\
  !*** ./node_modules/three/examples/jsm/geometries/RoundedBoxGeometry.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoundedBoxGeometry": () => (/* binding */ RoundedBoxGeometry)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


const _tempNormal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

function getUv( faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength ) {

	const totArcLength = 2 * Math.PI * radius / 4;

	// length of the planes between the arcs on each axis
	const centerLength = Math.max( sideLength - 2 * radius, 0 );
	const halfArc = Math.PI / 4;

	// Get the vector projected onto the Y plane
	_tempNormal.copy( normal );
	_tempNormal[ projectionAxis ] = 0;
	_tempNormal.normalize();

	// total amount of UV space alloted to a single arc
	const arcUvRatio = 0.5 * totArcLength / ( totArcLength + centerLength );

	// the distance along one arc the point is at
	const arcAngleRatio = 1.0 - ( _tempNormal.angleTo( faceDirVector ) / halfArc );

	if ( Math.sign( _tempNormal[ uvAxis ] ) === 1 ) {

		return arcAngleRatio * arcUvRatio;

	} else {

		// total amount of UV space alloted to the plane between the arcs
		const lenUv = centerLength / ( totArcLength + centerLength );
		return lenUv + arcUvRatio + arcUvRatio * ( 1.0 - arcAngleRatio );

	}

}

class RoundedBoxGeometry extends three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry {

	constructor( width = 1, height = 1, depth = 1, segments = 2, radius = 0.1 ) {

		// ensure segments is odd so we have a plane connecting the rounded corners
		segments = segments * 2 + 1;

		// ensure radius isn't bigger than shortest side
		radius = Math.min( width / 2, height / 2, depth / 2, radius );

		super( 1, 1, 1, segments, segments, segments );

		// if we just have one segment we're the same as a regular box
		if ( segments === 1 ) return;

		const geometry2 = this.toNonIndexed();

		this.index = null;
		this.attributes.position = geometry2.attributes.position;
		this.attributes.normal = geometry2.attributes.normal;
		this.attributes.uv = geometry2.attributes.uv;

		//

		const position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		const box = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( width, height, depth ).divideScalar( 2 ).subScalar( radius );

		const positions = this.attributes.position.array;
		const normals = this.attributes.normal.array;
		const uvs = this.attributes.uv.array;

		const faceTris = positions.length / 6;
		const faceDirVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const halfSegmentSize = 0.5 / segments;

		for ( let i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

			position.fromArray( positions, i );
			normal.copy( position );
			normal.x -= Math.sign( normal.x ) * halfSegmentSize;
			normal.y -= Math.sign( normal.y ) * halfSegmentSize;
			normal.z -= Math.sign( normal.z ) * halfSegmentSize;
			normal.normalize();

			positions[ i + 0 ] = box.x * Math.sign( position.x ) + normal.x * radius;
			positions[ i + 1 ] = box.y * Math.sign( position.y ) + normal.y * radius;
			positions[ i + 2 ] = box.z * Math.sign( position.z ) + normal.z * radius;

			normals[ i + 0 ] = normal.x;
			normals[ i + 1 ] = normal.y;
			normals[ i + 2 ] = normal.z;

			const side = Math.floor( i / faceTris );

			switch ( side ) {

				case 0: // right

					// generate UVs along Z then Y
					faceDirVector.set( 1, 0, 0 );
					uvs[ j + 0 ] = getUv( faceDirVector, normal, 'z', 'y', radius, depth );
					uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );
					break;

				case 1: // left

					// generate UVs along Z then Y
					faceDirVector.set( - 1, 0, 0 );
					uvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'y', radius, depth );
					uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );
					break;

				case 2: // top

					// generate UVs along X then Z
					faceDirVector.set( 0, 1, 0 );
					uvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );
					uvs[ j + 1 ] = getUv( faceDirVector, normal, 'z', 'x', radius, depth );
					break;

				case 3: // bottom

					// generate UVs along X then Z
					faceDirVector.set( 0, - 1, 0 );
					uvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );
					uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'x', radius, depth );
					break;

				case 4: // front

					// generate UVs along X then Y
					faceDirVector.set( 0, 0, 1 );
					uvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'y', radius, width );
					uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );
					break;

				case 5: // back

					// generate UVs along X then Y
					faceDirVector.set( 0, 0, - 1 );
					uvs[ j + 0 ] = getUv( faceDirVector, normal, 'x', 'y', radius, width );
					uvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );
					break;

			}

		}

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/geometries/TextGeometry.js":
/*!********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/geometries/TextGeometry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextGeometry": () => (/* binding */ TextGeometry)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */



class TextGeometry extends three__WEBPACK_IMPORTED_MODULE_0__.ExtrudeGeometry {

	constructor( text, parameters = {} ) {

		const font = parameters.font;

		if ( font === undefined ) {

			super(); // generate default extrude geometry

		} else {

			const shapes = font.generateShapes( text, parameters.size );

			// translate parameters to ExtrudeGeometry API

			parameters.depth = parameters.height !== undefined ? parameters.height : 50;

			// defaults

			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

			super( shapes, parameters );

		}

		this.type = 'TextGeometry';

	}

}





/***/ }),

/***/ "./node_modules/three/examples/jsm/libs/stats.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/libs/stats.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Stats = function () {

	var mode = 0;

	var container = document.createElement( 'div' );
	container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';
	container.addEventListener( 'click', function ( event ) {

		event.preventDefault();
		showPanel( ++ mode % container.children.length );

	}, false );

	//

	function addPanel( panel ) {

		container.appendChild( panel.dom );
		return panel;

	}

	function showPanel( id ) {

		for ( var i = 0; i < container.children.length; i ++ ) {

			container.children[ i ].style.display = i === id ? 'block' : 'none';

		}

		mode = id;

	}

	//

	var beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;

	var fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );
	var msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );

	if ( self.performance && self.performance.memory ) {

		var memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );

	}

	showPanel( 0 );

	return {

		REVISION: 16,

		dom: container,

		addPanel: addPanel,
		showPanel: showPanel,

		begin: function () {

			beginTime = ( performance || Date ).now();

		},

		end: function () {

			frames ++;

			var time = ( performance || Date ).now();

			msPanel.update( time - beginTime, 200 );

			if ( time >= prevTime + 1000 ) {

				fpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );

				prevTime = time;
				frames = 0;

				if ( memPanel ) {

					var memory = performance.memory;
					memPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );

				}

			}

			return time;

		},

		update: function () {

			beginTime = this.end();

		},

		// Backwards Compatibility

		domElement: container,
		setMode: showPanel

	};

};

Stats.Panel = function ( name, fg, bg ) {

	var min = Infinity, max = 0, round = Math.round;
	var PR = round( window.devicePixelRatio || 1 );

	var WIDTH = 80 * PR, HEIGHT = 48 * PR,
		TEXT_X = 3 * PR, TEXT_Y = 2 * PR,
		GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,
		GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;

	var canvas = document.createElement( 'canvas' );
	canvas.width = WIDTH;
	canvas.height = HEIGHT;
	canvas.style.cssText = 'width:80px;height:48px';

	var context = canvas.getContext( '2d' );
	context.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';
	context.textBaseline = 'top';

	context.fillStyle = bg;
	context.fillRect( 0, 0, WIDTH, HEIGHT );

	context.fillStyle = fg;
	context.fillText( name, TEXT_X, TEXT_Y );
	context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );

	context.fillStyle = bg;
	context.globalAlpha = 0.9;
	context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );

	return {

		dom: canvas,

		update: function ( value, maxValue ) {

			min = Math.min( min, value );
			max = Math.max( max, value );

			context.fillStyle = bg;
			context.globalAlpha = 1;
			context.fillRect( 0, 0, WIDTH, GRAPH_Y );
			context.fillStyle = fg;
			context.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );

			context.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );

			context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );

			context.fillStyle = bg;
			context.globalAlpha = 0.9;
			context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );

		}

	};

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Stats);


/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/FontLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/FontLoader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Font": () => (/* binding */ Font),
/* harmony export */   "FontLoader": () => (/* binding */ FontLoader)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


class FontLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			const font = scope.parse( JSON.parse( text ) );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	}

	parse( json ) {

		return new Font( json );

	}

}

//

class Font {

	constructor( data ) {

		this.isFont = true;

		this.type = 'Font';

		this.data = data;

	}

	generateShapes( text, size = 100 ) {

		const shapes = [];
		const paths = createPaths( text, size, this.data );

		for ( let p = 0, pl = paths.length; p < pl; p ++ ) {

			shapes.push( ...paths[ p ].toShapes() );

		}

		return shapes;

	}

}

function createPaths( text, size, data ) {

	const chars = Array.from( text );
	const scale = size / data.resolution;
	const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

	const paths = [];

	let offsetX = 0, offsetY = 0;

	for ( let i = 0; i < chars.length; i ++ ) {

		const char = chars[ i ];

		if ( char === '\n' ) {

			offsetX = 0;
			offsetY -= line_height;

		} else {

			const ret = createPath( char, scale, offsetX, offsetY, data );
			offsetX += ret.offsetX;
			paths.push( ret.path );

		}

	}

	return paths;

}

function createPath( char, scale, offsetX, offsetY, data ) {

	const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

	if ( ! glyph ) {

		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

		return;

	}

	const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();

	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if ( glyph.o ) {

		const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

		for ( let i = 0, l = outline.length; i < l; ) {

			const action = outline[ i ++ ];

			switch ( action ) {

				case 'm': // moveTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.moveTo( x, y );

					break;

				case 'l': // lineTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.lineTo( x, y );

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					break;

				case 'b': // bezierCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;
					cpx2 = outline[ i ++ ] * scale + offsetX;
					cpy2 = outline[ i ++ ] * scale + offsetY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					break;

			}

		}

	}

	return { offsetX: glyph.ha * scale, path: path };

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/GLTFLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/GLTFLoader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GLTFLoader": () => (/* binding */ GLTFLoader)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js");



class GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureAVIFExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsEmissiveStrengthExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIridescenceExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshGpuInstancing( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let json;
		const extensions = {};
		const plugins = {};
		const textDecoder = new TextDecoder();

		if ( typeof data === 'string' ) {

			json = JSON.parse( data );

		} else if ( data instanceof ArrayBuffer ) {

			const magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				json = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );

			} else {

				json = JSON.parse( textDecoder.decode( data ) );

			}

		} else {

			json = data;

		}

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );
			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_TEXTURE_AVIF: 'EXT_texture_avif',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
	EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		assignExtrasToUserData( lightNode, lightDef );

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	getDependency( type, index ) {

		if ( type !== 'light' ) return;

		return this._loadLight( index );

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */
class GLTFMaterialsEmissiveStrengthExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;

		if ( emissiveStrength !== undefined ) {

			materialParams.emissiveIntensity = emissiveStrength;

		}

		return Promise.resolve();

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */
class GLTFMaterialsIridescenceExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.iridescenceFactor !== undefined ) {

			materialParams.iridescence = extension.iridescenceFactor;

		}

		if ( extension.iridescenceTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );

		}

		if ( extension.iridescenceIor !== undefined ) {

			materialParams.iridescenceIOR = extension.iridescenceIor;

		}

		if ( materialParams.iridescenceThicknessRange === undefined ) {

			materialParams.iridescenceThicknessRange = [ 100, 400 ];

		}

		if ( extension.iridescenceThicknessMinimum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;

		}

		if ( extension.iridescenceThicknessMaximum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;

		}

		if ( extension.iridescenceThicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			materialParams.sheenColor.fromArray( extension.sheenColorFactor );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || Infinity;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * AVIF Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif
 */
class GLTFTextureAVIFExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image.
				image.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';
				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return buffer.then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const source = new Uint8Array( res, byteOffset, byteLength );

				if ( decoder.decodeGltfBufferAsync ) {

					return decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {

						return res.buffer;

					} );

				} else {

					// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync
					return decoder.ready.then( function () {

						const result = new ArrayBuffer( count * stride );
						decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
						return result;

					} );

				}

			} );

		} else {

			return null;

		}

	}

}

/**
 * GPU Instancing Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
 *
 */
class GLTFMeshGpuInstancing {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
		this.parser = parser;

	}

	createNodeMesh( nodeIndex ) {

		const json = this.parser.json;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||
			nodeDef.mesh === undefined ) {

			return null;

		}

		const meshDef = json.meshes[ nodeDef.mesh ];

		// No Points or Lines + Instancing support yet

		for ( const primitive of meshDef.primitives ) {

			if ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&
				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
				 primitive.mode !== undefined ) {

				return null;

			}

		}

		const extensionDef = nodeDef.extensions[ this.name ];
		const attributesDef = extensionDef.attributes;

		// @TODO: Can we support InstancedMesh + SkinnedMesh?

		const pending = [];
		const attributes = {};

		for ( const key in attributesDef ) {

			pending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {

				attributes[ key ] = accessor;
				return attributes[ key ];

			} ) );

		}

		if ( pending.length < 1 ) {

			return null;

		}

		pending.push( this.parser.createNodeMesh( nodeIndex ) );

		return Promise.all( pending ).then( results => {

			const nodeObject = results.pop();
			const meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];
			const count = results[ 0 ].count; // All attribute counts should be same
			const instancedMeshes = [];

			for ( const mesh of meshes ) {

				// Temporal variables
				const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
				const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
				const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 1, 1 );

				const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh( mesh.geometry, mesh.material, count );

				for ( let i = 0; i < count; i ++ ) {

					if ( attributes.TRANSLATION ) {

						p.fromBufferAttribute( attributes.TRANSLATION, i );

					}

					if ( attributes.ROTATION ) {

						q.fromBufferAttribute( attributes.ROTATION, i );

					}

					if ( attributes.SCALE ) {

						s.fromBufferAttribute( attributes.SCALE, i );

					}

					instancedMesh.setMatrixAt( i, m.compose( p, q, s ) );

				}

				// Add instance attributes to the geometry, excluding TRS.
				for ( const attributeName in attributes ) {

					if ( attributeName !== 'TRANSLATION' &&
						 attributeName !== 'ROTATION' &&
						 attributeName !== 'SCALE' ) {

						mesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );

					}

				}

				// Just in case
				three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call( instancedMesh, mesh );

				// https://github.com/mrdoob/three.js/issues/18334
				instancedMesh.frustumCulled = false;
				this.parser.assignFinalMaterial( instancedMesh );

				instancedMeshes.push( instancedMesh );

			}

			if ( nodeObject.isGroup ) {

				nodeObject.clear();

				nodeObject.add( ... instancedMeshes );

				return nodeObject;

			}

			return instancedMeshes[ 0 ];

		} );

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
		const textDecoder = new TextDecoder();

		this.header = {
			magic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = textDecoder.decode( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType.name;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( transform.texCoord !== undefined ) {

			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

		}

		if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer;
		const values = this.sampleValues;
		const stride = this.valueSize;

		const stride2 = stride * 2;
		const stride3 = stride * 3;

		const td = t1 - t0;

		const p = ( t - t0 ) / td;
		const pp = p * p;
		const ppp = pp * p;

		const offset1 = i1 * stride3;
		const offset0 = offset1 - stride3;

		const s2 = - 2 * ppp + 3 * pp;
		const s3 = ppp - pp;
		const s0 = 1 - s2;
		const s1 = s3 - pp + p;

		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for ( let i = 0; i !== stride; i ++ ) {

			const p0 = values[ offset0 + i + stride ]; // splineVertex_k
			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	}

}

const _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,
	9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,
	9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,
	9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,
	9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,
	9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,
	33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,
	10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv2',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,
	STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
	let geometryKey;

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

	return 'image/png';

}

const _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Node cache
		this.nodeCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.

		let isSafari = false;
		let isFirefox = false;
		let firefoxVersion = - 1;

		if ( typeof navigator !== 'undefined' ) {

			isSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;
			isFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;
			firefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : - 1;

		}

		if ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {

			this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader( this.options.manager );

		} else {

			this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();
		this.nodeCache = {};

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadNode && ext.loadNode( index );

					} );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadAnimation && ext.loadAnimation( index );

					} );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					dependency = this._invokeOne( function ( ext ) {

						return ext != this && ext.getDependency && ext.getDependency( type, index );

					} );

					if ( ! dependency ) {

						throw new Error( 'Unknown type: ' + type );

					}

					break;

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
			const normalized = accessorDef.normalized === true;

			const array = new TypedArray( accessorDef.count * itemSize );
			return Promise.resolve( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( array, itemSize, normalized ) );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture|null>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			texture.name = textureDef.name || sourceDef.name || '';

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef, encoding ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			if ( ! texture ) return null;

			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			if ( encoding !== undefined ) {

				texture.encoding = encoding;

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();
				three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();
				three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		// workarounds for mesh and geometry

		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

			geometry.setAttribute( 'uv2', geometry.attributes.uv );

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {

			materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

		}

		return Promise.all( pending ).then( function () {

			const material = new materialType( materialParams );

			if ( materialDef.name ) material.name = materialDef.name;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName( originalName || '' );

		let name = sanitizedName;

		for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

			name = sanitizedName + '_' + i;

		}

		this.nodeNamesUsed[ name ] = true;

		return name;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh( geometry, material )
						: new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true ) {

						// normalize skin weights to fix malformed assets (see #15319)
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.toTrianglesDrawMode)( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.toTrianglesDrawMode)( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Skeleton>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const pending = [];

		for ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {

			pending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );

		}

		if ( skinDef.inverseBindMatrices !== undefined ) {

			pending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );

		} else {

			pending.push( null );

		}

		return Promise.all( pending ).then( function ( results ) {

			const inverseBindMatrices = results.pop();
			const jointNodes = results;

			// Note that bones (joint nodes) may or may not be in the
			// scene graph at this time.

			const bones = [];
			const boneInverses = [];

			for ( let i = 0, il = jointNodes.length; i < il; i ++ ) {

				const jointNode = jointNodes[ i ];

				if ( jointNode ) {

					bones.push( jointNode );

					const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();

					if ( inverseBindMatrices !== null ) {

						mat.fromArray( inverseBindMatrices.array, i * 16 );

					}

					boneInverses.push( mat );

				} else {

					console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[ i ] );

				}

			}

			return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton( bones, boneInverses );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;

		const animationDef = json.animations[ animationIndex ];

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node;
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				node.updateMatrix();

				let TypedKeyframeTrack;

				switch ( PATH_PROPERTIES[ target.path ] ) {

					case PATH_PROPERTIES.weights:

						TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;
						break;

					case PATH_PROPERTIES.rotation:

						TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;
						break;

					case PATH_PROPERTIES.position:
					case PATH_PROPERTIES.scale:
					default:

						TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;
						break;

				}

				const targetName = node.name ? node.name : node.uuid;

				const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;

				const targetNames = [];

				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

					node.traverse( function ( object ) {

						if ( object.morphTargetInfluences ) {

							targetNames.push( object.name ? object.name : object.uuid );

						}

					} );

				} else {

					targetNames.push( targetName );

				}

				let outputArray = outputAccessor.array;

				if ( outputAccessor.normalized ) {

					const scale = getNormalizedComponentScale( outputArray.constructor );
					const scaled = new Float32Array( outputArray.length );

					for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

						scaled[ j ] = outputArray[ j ] * scale;

					}

					outputArray = scaled;

				}

				for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

					const track = new TypedKeyframeTrack(
						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
						inputAccessor.array,
						outputArray,
						interpolation
					);

					// Override interpolation with custom factory method.
					if ( sampler.interpolation === 'CUBICSPLINE' ) {

						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
							// must be divided by three to get the interpolant's sampleSize argument.

							const interpolantType = ( this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

							return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

						};

						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

					}

					tracks.push( track );

				}

			}

			const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

			return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip( name, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		const nodePending = parser._loadNodeShallow( nodeIndex );

		const childPending = [];
		const childrenDef = nodeDef.children || [];

		for ( let i = 0, il = childrenDef.length; i < il; i ++ ) {

			childPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );

		}

		const skeletonPending = nodeDef.skin === undefined
			? Promise.resolve( null )
			: parser.getDependency( 'skin', nodeDef.skin );

		return Promise.all( [
			nodePending,
			Promise.all( childPending ),
			skeletonPending
		] ).then( function ( results ) {

			const node = results[ 0 ];
			const children = results[ 1 ];
			const skeleton = results[ 2 ];

			if ( skeleton !== null ) {

				// This full traverse should be fine because
				// child glTF nodes have not been added to this node yet.
				node.traverse( function ( mesh ) {

					if ( ! mesh.isSkinnedMesh ) return;

					mesh.bind( skeleton, _identityMatrix );

				} );

			}

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				node.add( children[ i ] );

			}

			return node;

		} );

	}

	// ._loadNodeShallow() parses a single node.
	// skin and child nodes are created and added in .loadNode() (no '_' prefix).
	_loadNodeShallow( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		// This method is called from .loadNode() and .loadSkin().
		// Cache a node to avoid duplication.

		if ( this.nodeCache[ nodeIndex ] !== undefined ) {

			return this.nodeCache[ nodeIndex ];

		}

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		const pending = [];

		const meshPromise = parser._invokeOne( function ( ext ) {

			return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

		} );

		if ( meshPromise ) {

			pending.push( meshPromise );

		}

		if ( nodeDef.camera !== undefined ) {

			pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

				return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

			} ) );

		}

		parser._invokeAll( function ( ext ) {

			return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

		} ).forEach( function ( promise ) {

			pending.push( promise );

		} );

		this.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();

			} else if ( objects.length > 1 ) {

				node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

		return this.nodeCache[ nodeIndex ];

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( parser.getDependency( 'node', nodeIds[ i ] ) );

		}

		return Promise.all( pending ).then( function ( nodes ) {

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				scene.add( nodes[ i ] );

			}

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/postprocessing/EffectComposer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/three/examples/jsm/postprocessing/EffectComposer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectComposer": () => (/* binding */ EffectComposer)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _shaders_CopyShader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaders/CopyShader.js */ "./node_modules/three/examples/jsm/shaders/CopyShader.js");
/* harmony import */ var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShaderPass.js */ "./node_modules/three/examples/jsm/postprocessing/ShaderPass.js");
/* harmony import */ var _MaskPass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MaskPass.js */ "./node_modules/three/examples/jsm/postprocessing/MaskPass.js");






class EffectComposer {

	constructor( renderer, renderTarget ) {

		this.renderer = renderer;

		if ( renderTarget === undefined ) {

			const size = renderer.getSize( new three__WEBPACK_IMPORTED_MODULE_0__.Vector2() );
			this._pixelRatio = renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio );
			renderTarget.texture.name = 'EffectComposer.rt1';

		} else {

			this._pixelRatio = 1;
			this._width = renderTarget.width;
			this._height = renderTarget.height;

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.renderTarget2.texture.name = 'EffectComposer.rt2';

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		this.renderToScreen = true;

		this.passes = [];

		this.copyPass = new _ShaderPass_js__WEBPACK_IMPORTED_MODULE_1__.ShaderPass( _shaders_CopyShader_js__WEBPACK_IMPORTED_MODULE_2__.CopyShader );

		this.clock = new three__WEBPACK_IMPORTED_MODULE_0__.Clock();

	}

	swapBuffers() {

		const tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	}

	addPass( pass ) {

		this.passes.push( pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	insertPass( pass, index ) {

		this.passes.splice( index, 0, pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	removePass( pass ) {

		const index = this.passes.indexOf( pass );

		if ( index !== - 1 ) {

			this.passes.splice( index, 1 );

		}

	}

	isLastEnabledPass( passIndex ) {

		for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {

			if ( this.passes[ i ].enabled ) {

				return false;

			}

		}

		return true;

	}

	render( deltaTime ) {

		// deltaTime value is in seconds

		if ( deltaTime === undefined ) {

			deltaTime = this.clock.getDelta();

		}

		const currentRenderTarget = this.renderer.getRenderTarget();

		let maskActive = false;

		for ( let i = 0, il = this.passes.length; i < il; i ++ ) {

			const pass = this.passes[ i ];

			if ( pass.enabled === false ) continue;

			pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );
			pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					const context = this.renderer.getContext();
					const stencil = this.renderer.state.buffers.stencil;

					//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
					stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );

					//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
					stencil.setFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( _MaskPass_js__WEBPACK_IMPORTED_MODULE_3__.MaskPass !== undefined ) {

				if ( pass instanceof _MaskPass_js__WEBPACK_IMPORTED_MODULE_3__.MaskPass ) {

					maskActive = true;

				} else if ( pass instanceof _MaskPass_js__WEBPACK_IMPORTED_MODULE_3__.ClearMaskPass ) {

					maskActive = false;

				}

			}

		}

		this.renderer.setRenderTarget( currentRenderTarget );

	}

	reset( renderTarget ) {

		if ( renderTarget === undefined ) {

			const size = this.renderer.getSize( new three__WEBPACK_IMPORTED_MODULE_0__.Vector2() );
			this._pixelRatio = this.renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	}

	setSize( width, height ) {

		this._width = width;
		this._height = height;

		const effectiveWidth = this._width * this._pixelRatio;
		const effectiveHeight = this._height * this._pixelRatio;

		this.renderTarget1.setSize( effectiveWidth, effectiveHeight );
		this.renderTarget2.setSize( effectiveWidth, effectiveHeight );

		for ( let i = 0; i < this.passes.length; i ++ ) {

			this.passes[ i ].setSize( effectiveWidth, effectiveHeight );

		}

	}

	setPixelRatio( pixelRatio ) {

		this._pixelRatio = pixelRatio;

		this.setSize( this._width, this._height );

	}

	dispose() {

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();

		this.copyPass.dispose();

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/postprocessing/MaskPass.js":
/*!********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/postprocessing/MaskPass.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClearMaskPass": () => (/* binding */ ClearMaskPass),
/* harmony export */   "MaskPass": () => (/* binding */ MaskPass)
/* harmony export */ });
/* harmony import */ var _Pass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pass.js */ "./node_modules/three/examples/jsm/postprocessing/Pass.js");


class MaskPass extends _Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass {

	constructor( scene, camera ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.clear = true;
		this.needsSwap = false;

		this.inverse = false;

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const context = renderer.getContext();
		const state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask( false );
		state.buffers.depth.setMask( false );

		// lock buffers

		state.buffers.color.setLocked( true );
		state.buffers.depth.setLocked( true );

		// set up stencil

		let writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		state.buffers.stencil.setTest( true );
		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
		state.buffers.stencil.setClear( clearValue );
		state.buffers.stencil.setLocked( true );

		// draw into the stencil buffer

		renderer.setRenderTarget( readBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		renderer.setRenderTarget( writeBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		// unlock color and depth buffer for subsequent rendering

		state.buffers.color.setLocked( false );
		state.buffers.depth.setLocked( false );

		// only render where stencil is set to 1

		state.buffers.stencil.setLocked( false );
		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1
		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );
		state.buffers.stencil.setLocked( true );

	}

}

class ClearMaskPass extends _Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass {

	constructor() {

		super();

		this.needsSwap = false;

	}

	render( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		renderer.state.buffers.stencil.setLocked( false );
		renderer.state.buffers.stencil.setTest( false );

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/postprocessing/Pass.js":
/*!****************************************************************!*\
  !*** ./node_modules/three/examples/jsm/postprocessing/Pass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FullScreenQuad": () => (/* binding */ FullScreenQuad),
/* harmony export */   "Pass": () => (/* binding */ Pass)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


class Pass {

	constructor() {

		// if set to true, the pass is processed by the composer
		this.enabled = true;

		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;

		// if set to true, the pass clears its buffer before rendering
		this.clear = false;

		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
		this.renderToScreen = false;

	}

	setSize( /* width, height */ ) {}

	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

	}

	dispose() {}

}

// Helper for passes that need to fill the viewport with a single quad.

const _camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

const _geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
_geometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
_geometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

class FullScreenQuad {

	constructor( material ) {

		this._mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( _geometry, material );

	}

	dispose() {

		this._mesh.geometry.dispose();

	}

	render( renderer ) {

		renderer.render( this._mesh, _camera );

	}

	get material() {

		return this._mesh.material;

	}

	set material( value ) {

		this._mesh.material = value;

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/postprocessing/RenderPass.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/postprocessing/RenderPass.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RenderPass": () => (/* binding */ RenderPass)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _Pass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pass.js */ "./node_modules/three/examples/jsm/postprocessing/Pass.js");



class RenderPass extends _Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass {

	constructor( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.overrideMaterial = overrideMaterial;

		this.clearColor = clearColor;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

		this.clear = true;
		this.clearDepth = false;
		this.needsSwap = false;
		this._oldClearColor = new three__WEBPACK_IMPORTED_MODULE_1__.Color();

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		let oldClearAlpha, oldOverrideMaterial;

		if ( this.overrideMaterial !== undefined ) {

			oldOverrideMaterial = this.scene.overrideMaterial;

			this.scene.overrideMaterial = this.overrideMaterial;

		}

		if ( this.clearColor ) {

			renderer.getClearColor( this._oldClearColor );
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		if ( this.clearDepth ) {

			renderer.clearDepth();

		}

		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

		// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
		if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
		renderer.render( this.scene, this.camera );

		if ( this.clearColor ) {

			renderer.setClearColor( this._oldClearColor, oldClearAlpha );

		}

		if ( this.overrideMaterial !== undefined ) {

			this.scene.overrideMaterial = oldOverrideMaterial;

		}

		renderer.autoClear = oldAutoClear;

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/postprocessing/ShaderPass.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/postprocessing/ShaderPass.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderPass": () => (/* binding */ ShaderPass)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _Pass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pass.js */ "./node_modules/three/examples/jsm/postprocessing/Pass.js");



class ShaderPass extends _Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass {

	constructor( shader, textureID ) {

		super();

		this.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';

		if ( shader instanceof three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial ) {

			this.uniforms = shader.uniforms;

			this.material = shader;

		} else if ( shader ) {

			this.uniforms = three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils.clone( shader.uniforms );

			this.material = new three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial( {

				defines: Object.assign( {}, shader.defines ),
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader

			} );

		}

		this.fsQuad = new _Pass_js__WEBPACK_IMPORTED_MODULE_0__.FullScreenQuad( this.material );

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}

		this.fsQuad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( writeBuffer );
			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
			this.fsQuad.render( renderer );

		}

	}

	dispose() {

		this.material.dispose();

		this.fsQuad.dispose();

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnrealBloomPass": () => (/* binding */ UnrealBloomPass)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _Pass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pass.js */ "./node_modules/three/examples/jsm/postprocessing/Pass.js");
/* harmony import */ var _shaders_CopyShader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/CopyShader.js */ "./node_modules/three/examples/jsm/shaders/CopyShader.js");
/* harmony import */ var _shaders_LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaders/LuminosityHighPassShader.js */ "./node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js");





/**
 * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a
 * mip map chain of bloom textures and blurs them with different radii. Because
 * of the weighted combination of mips, and because larger blurs are done on
 * higher mips, this effect provides good quality and performance.
 *
 * Reference:
 * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */
class UnrealBloomPass extends _Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass {

	constructor( resolution, strength, radius, threshold ) {

		super();

		this.strength = ( strength !== undefined ) ? strength : 1;
		this.radius = radius;
		this.threshold = threshold;
		this.resolution = ( resolution !== undefined ) ? new three__WEBPACK_IMPORTED_MODULE_1__.Vector2( resolution.x, resolution.y ) : new three__WEBPACK_IMPORTED_MODULE_1__.Vector2( 256, 256 );

		// create color only once here, reuse it later inside the render function
		this.clearColor = new three__WEBPACK_IMPORTED_MODULE_1__.Color( 0, 0, 0 );

		// render targets
		this.renderTargetsHorizontal = [];
		this.renderTargetsVertical = [];
		this.nMips = 5;
		let resx = Math.round( this.resolution.x / 2 );
		let resy = Math.round( this.resolution.y / 2 );

		this.renderTargetBright = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderTarget( resx, resy );
		this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';
		this.renderTargetBright.texture.generateMipmaps = false;

		for ( let i = 0; i < this.nMips; i ++ ) {

			const renderTargetHorizonal = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderTarget( resx, resy );

			renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;
			renderTargetHorizonal.texture.generateMipmaps = false;

			this.renderTargetsHorizontal.push( renderTargetHorizonal );

			const renderTargetVertical = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderTarget( resx, resy );

			renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;
			renderTargetVertical.texture.generateMipmaps = false;

			this.renderTargetsVertical.push( renderTargetVertical );

			resx = Math.round( resx / 2 );

			resy = Math.round( resy / 2 );

		}

		// luminosity high pass material

		const highPassShader = _shaders_LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2__.LuminosityHighPassShader;
		this.highPassUniforms = three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils.clone( highPassShader.uniforms );

		this.highPassUniforms[ 'luminosityThreshold' ].value = threshold;
		this.highPassUniforms[ 'smoothWidth' ].value = 0.01;

		this.materialHighPassFilter = new three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial( {
			uniforms: this.highPassUniforms,
			vertexShader: highPassShader.vertexShader,
			fragmentShader: highPassShader.fragmentShader,
			defines: {}
		} );

		// Gaussian Blur Materials
		this.separableBlurMaterials = [];
		const kernelSizeArray = [ 3, 5, 7, 9, 11 ];
		resx = Math.round( this.resolution.x / 2 );
		resy = Math.round( this.resolution.y / 2 );

		for ( let i = 0; i < this.nMips; i ++ ) {

			this.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );

			this.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2( resx, resy );

			resx = Math.round( resx / 2 );

			resy = Math.round( resy / 2 );

		}

		// Composite material
		this.compositeMaterial = this.getCompositeMaterial( this.nMips );
		this.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;
		this.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;
		this.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;
		this.compositeMaterial.needsUpdate = true;

		const bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];
		this.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;
		this.bloomTintColors = [ new three__WEBPACK_IMPORTED_MODULE_1__.Vector3( 1, 1, 1 ), new three__WEBPACK_IMPORTED_MODULE_1__.Vector3( 1, 1, 1 ), new three__WEBPACK_IMPORTED_MODULE_1__.Vector3( 1, 1, 1 ), new three__WEBPACK_IMPORTED_MODULE_1__.Vector3( 1, 1, 1 ), new three__WEBPACK_IMPORTED_MODULE_1__.Vector3( 1, 1, 1 ) ];
		this.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;

		// copy material

		const copyShader = _shaders_CopyShader_js__WEBPACK_IMPORTED_MODULE_3__.CopyShader;

		this.copyUniforms = three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils.clone( copyShader.uniforms );
		this.copyUniforms[ 'opacity' ].value = 1.0;

		this.materialCopy = new three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial( {
			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: three__WEBPACK_IMPORTED_MODULE_1__.AdditiveBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		} );

		this.enabled = true;
		this.needsSwap = false;

		this._oldClearColor = new three__WEBPACK_IMPORTED_MODULE_1__.Color();
		this.oldClearAlpha = 1;

		this.basic = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial();

		this.fsQuad = new _Pass_js__WEBPACK_IMPORTED_MODULE_0__.FullScreenQuad( null );

	}

	dispose() {

		for ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {

			this.renderTargetsHorizontal[ i ].dispose();

		}

		for ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {

			this.renderTargetsVertical[ i ].dispose();

		}

		this.renderTargetBright.dispose();

		//

		for ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {

			this.separableBlurMaterials[ i ].dispose();

		}

		this.compositeMaterial.dispose();
		this.materialCopy.dispose();
		this.basic.dispose();

		//

		this.fsQuad.dispose();

	}

	setSize( width, height ) {

		let resx = Math.round( width / 2 );
		let resy = Math.round( height / 2 );

		this.renderTargetBright.setSize( resx, resy );

		for ( let i = 0; i < this.nMips; i ++ ) {

			this.renderTargetsHorizontal[ i ].setSize( resx, resy );
			this.renderTargetsVertical[ i ].setSize( resx, resy );

			this.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2( resx, resy );

			resx = Math.round( resx / 2 );
			resy = Math.round( resy / 2 );

		}

	}

	render( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

		renderer.getClearColor( this._oldClearColor );
		this.oldClearAlpha = renderer.getClearAlpha();
		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setClearColor( this.clearColor, 0 );

		if ( maskActive ) renderer.state.buffers.stencil.setTest( false );

		// Render input to screen

		if ( this.renderToScreen ) {

			this.fsQuad.material = this.basic;
			this.basic.map = readBuffer.texture;

			renderer.setRenderTarget( null );
			renderer.clear();
			this.fsQuad.render( renderer );

		}

		// 1. Extract Bright Areas

		this.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;
		this.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;
		this.fsQuad.material = this.materialHighPassFilter;

		renderer.setRenderTarget( this.renderTargetBright );
		renderer.clear();
		this.fsQuad.render( renderer );

		// 2. Blur All the mips progressively

		let inputRenderTarget = this.renderTargetBright;

		for ( let i = 0; i < this.nMips; i ++ ) {

			this.fsQuad.material = this.separableBlurMaterials[ i ];

			this.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;
			this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;
			renderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );
			renderer.clear();
			this.fsQuad.render( renderer );

			this.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;
			this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;
			renderer.setRenderTarget( this.renderTargetsVertical[ i ] );
			renderer.clear();
			this.fsQuad.render( renderer );

			inputRenderTarget = this.renderTargetsVertical[ i ];

		}

		// Composite All the mips

		this.fsQuad.material = this.compositeMaterial;
		this.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;
		this.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;
		this.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;

		renderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );
		renderer.clear();
		this.fsQuad.render( renderer );

		// Blend it additively over the input texture

		this.fsQuad.material = this.materialCopy;
		this.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;

		if ( maskActive ) renderer.state.buffers.stencil.setTest( true );

		if ( this.renderToScreen ) {

			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( readBuffer );
			this.fsQuad.render( renderer );

		}

		// Restore renderer settings

		renderer.setClearColor( this._oldClearColor, this.oldClearAlpha );
		renderer.autoClear = oldAutoClear;

	}

	getSeperableBlurMaterial( kernelRadius ) {

		return new three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial( {

			defines: {
				'KERNEL_RADIUS': kernelRadius,
				'SIGMA': kernelRadius
			},

			uniforms: {
				'colorTexture': { value: null },
				'texSize': { value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector2( 0.5, 0.5 ) },
				'direction': { value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector2( 0.5, 0.5 ) }
			},

			vertexShader:
				`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

			fragmentShader:
				`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
		} );

	}

	getCompositeMaterial( nMips ) {

		return new three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial( {

			defines: {
				'NUM_MIPS': nMips
			},

			uniforms: {
				'blurTexture1': { value: null },
				'blurTexture2': { value: null },
				'blurTexture3': { value: null },
				'blurTexture4': { value: null },
				'blurTexture5': { value: null },
				'bloomStrength': { value: 1.0 },
				'bloomFactors': { value: null },
				'bloomTintColors': { value: null },
				'bloomRadius': { value: 0.0 }
			},

			vertexShader:
				`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

			fragmentShader:
				`varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
		} );

	}

}

UnrealBloomPass.BlurDirectionX = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2( 1.0, 0.0 );
UnrealBloomPass.BlurDirectionY = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2( 0.0, 1.0 );




/***/ }),

/***/ "./node_modules/three/examples/jsm/shaders/CopyShader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/shaders/CopyShader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CopyShader": () => (/* binding */ CopyShader)
/* harmony export */ });
/**
 * Full-screen textured quad shader
 */

const CopyShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'opacity': { value: 1.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`

};




/***/ }),

/***/ "./node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LuminosityHighPassShader": () => (/* binding */ LuminosityHighPassShader)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


/**
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

const LuminosityHighPassShader = {

	shaderID: 'luminosityHighPass',

	uniforms: {

		'tDiffuse': { value: null },
		'luminosityThreshold': { value: 1.0 },
		'smoothWidth': { value: 1.0 },
		'defaultColor': { value: new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0x000000 ) },
		'defaultOpacity': { value: 0.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`

};




/***/ }),

/***/ "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computeMikkTSpaceTangents": () => (/* binding */ computeMikkTSpaceTangents),
/* harmony export */   "computeMorphedAttributes": () => (/* binding */ computeMorphedAttributes),
/* harmony export */   "computeTangents": () => (/* binding */ computeTangents),
/* harmony export */   "deepCloneAttribute": () => (/* binding */ deepCloneAttribute),
/* harmony export */   "deinterleaveAttribute": () => (/* binding */ deinterleaveAttribute),
/* harmony export */   "deinterleaveGeometry": () => (/* binding */ deinterleaveGeometry),
/* harmony export */   "estimateBytesUsed": () => (/* binding */ estimateBytesUsed),
/* harmony export */   "interleaveAttributes": () => (/* binding */ interleaveAttributes),
/* harmony export */   "mergeBufferAttributes": () => (/* binding */ mergeBufferAttributes),
/* harmony export */   "mergeBufferGeometries": () => (/* binding */ mergeBufferGeometries),
/* harmony export */   "mergeGroups": () => (/* binding */ mergeGroups),
/* harmony export */   "mergeVertices": () => (/* binding */ mergeVertices),
/* harmony export */   "toCreasedNormals": () => (/* binding */ toCreasedNormals),
/* harmony export */   "toTrianglesDrawMode": () => (/* binding */ toTrianglesDrawMode)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


function computeTangents() { // @deprecated, r140

	throw new Error( 'BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.' );

}

function computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {

	if ( ! MikkTSpace || ! MikkTSpace.isReady ) {

		throw new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );

	}

	if ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {

		throw new Error( 'BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.' );

	}

	function getAttributeArray( attribute ) {

		if ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {

			const dstArray = new Float32Array( attribute.getCount() * attribute.itemSize );

			for ( let i = 0, j = 0; i < attribute.getCount(); i ++ ) {

				dstArray[ j ++ ] = attribute.getX( i );
				dstArray[ j ++ ] = attribute.getY( i );

				if ( attribute.itemSize > 2 ) {

					dstArray[ j ++ ] = attribute.getZ( i );

				}

			}

			return dstArray;

		}

		if ( attribute.array instanceof Float32Array ) {

			return attribute.array;

		}

		return new Float32Array( attribute.array );

	}

	// MikkTSpace algorithm requires non-indexed input.

	const _geometry = geometry.index ? geometry.toNonIndexed() : geometry;

	// Compute vertex tangents.

	const tangents = MikkTSpace.generateTangents(

		getAttributeArray( _geometry.attributes.position ),
		getAttributeArray( _geometry.attributes.normal ),
		getAttributeArray( _geometry.attributes.uv )

	);

	// Texture coordinate convention of glTF differs from the apparent
	// default of the MikkTSpace library; .w component must be flipped.

	if ( negateSign ) {

		for ( let i = 3; i < tangents.length; i += 4 ) {

			tangents[ i ] *= - 1;

		}

	}

	//

	_geometry.setAttribute( 'tangent', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( tangents, 4 ) );

	if ( geometry !== _geometry ) {

		geometry.copy( _geometry );

	}

	return geometry;

}

/**
 * @param  {Array<BufferGeometry>} geometries
 * @param  {Boolean} useGroups
 * @return {BufferGeometry}
 */
function mergeBufferGeometries( geometries, useGroups = false ) {

	const isIndexed = geometries[ 0 ].index !== null;

	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
	const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );

	const attributes = {};
	const morphAttributes = {};

	const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;

	const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();

	let offset = 0;

	for ( let i = 0; i < geometries.length; ++ i ) {

		const geometry = geometries[ i ];
		let attributesCount = 0;

		// ensure that all geometries are indexed, or none

		if ( isIndexed !== ( geometry.index !== null ) ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );
			return null;

		}

		// gather attributes, exit early if they're different

		for ( const name in geometry.attributes ) {

			if ( ! attributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );
				return null;

			}

			if ( attributes[ name ] === undefined ) attributes[ name ] = [];

			attributes[ name ].push( geometry.attributes[ name ] );

			attributesCount ++;

		}

		// ensure geometries have the same number of attributes

		if ( attributesCount !== attributesUsed.size ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );
			return null;

		}

		// gather morph attributes, exit early if they're different

		if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );
			return null;

		}

		for ( const name in geometry.morphAttributes ) {

			if ( ! morphAttributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );
				return null;

			}

			if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];

			morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

		}

		if ( useGroups ) {

			let count;

			if ( isIndexed ) {

				count = geometry.index.count;

			} else if ( geometry.attributes.position !== undefined ) {

				count = geometry.attributes.position.count;

			} else {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );
				return null;

			}

			mergedGeometry.addGroup( offset, count, i );

			offset += count;

		}

	}

	// merge indices

	if ( isIndexed ) {

		let indexOffset = 0;
		const mergedIndex = [];

		for ( let i = 0; i < geometries.length; ++ i ) {

			const index = geometries[ i ].index;

			for ( let j = 0; j < index.count; ++ j ) {

				mergedIndex.push( index.getX( j ) + indexOffset );

			}

			indexOffset += geometries[ i ].attributes.position.count;

		}

		mergedGeometry.setIndex( mergedIndex );

	}

	// merge attributes

	for ( const name in attributes ) {

		const mergedAttribute = mergeBufferAttributes( attributes[ name ] );

		if ( ! mergedAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );
			return null;

		}

		mergedGeometry.setAttribute( name, mergedAttribute );

	}

	// merge morph attributes

	for ( const name in morphAttributes ) {

		const numMorphTargets = morphAttributes[ name ][ 0 ].length;

		if ( numMorphTargets === 0 ) break;

		mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
		mergedGeometry.morphAttributes[ name ] = [];

		for ( let i = 0; i < numMorphTargets; ++ i ) {

			const morphAttributesToMerge = [];

			for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {

				morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

			}

			const mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );

			if ( ! mergedMorphAttribute ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );
				return null;

			}

			mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

		}

	}

	return mergedGeometry;

}

/**
 * @param {Array<BufferAttribute>} attributes
 * @return {BufferAttribute}
 */
function mergeBufferAttributes( attributes ) {

	let TypedArray;
	let itemSize;
	let normalized;
	let arrayLength = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		const attribute = attributes[ i ];

		if ( attribute.isInterleavedBufferAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );
			return null;

		}

		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );
			return null;

		}

		if ( itemSize === undefined ) itemSize = attribute.itemSize;
		if ( itemSize !== attribute.itemSize ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );
			return null;

		}

		if ( normalized === undefined ) normalized = attribute.normalized;
		if ( normalized !== attribute.normalized ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );
			return null;

		}

		arrayLength += attribute.array.length;

	}

	const array = new TypedArray( arrayLength );
	let offset = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		array.set( attributes[ i ].array, offset );

		offset += attributes[ i ].array.length;

	}

	return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( array, itemSize, normalized );

}

/**
 * @param {BufferAttribute}
 * @return {BufferAttribute}
 */
function deepCloneAttribute( attribute ) {

	if ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {

		return deinterleaveAttribute( attribute );

	}

	if ( attribute.isInstancedBufferAttribute ) {

		return new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute().copy( attribute );

	}

	return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute().copy( attribute );

}

/**
 * @param {Array<BufferAttribute>} attributes
 * @return {Array<InterleavedBufferAttribute>}
 */
function interleaveAttributes( attributes ) {

	// Interleaves the provided attributes into an InterleavedBuffer and returns
	// a set of InterleavedBufferAttributes for each attribute
	let TypedArray;
	let arrayLength = 0;
	let stride = 0;

	// calculate the length and type of the interleavedBuffer
	for ( let i = 0, l = attributes.length; i < l; ++ i ) {

		const attribute = attributes[ i ];

		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'AttributeBuffers of different types cannot be interleaved' );
			return null;

		}

		arrayLength += attribute.array.length;
		stride += attribute.itemSize;

	}

	// Create the set of buffer attributes
	const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer( new TypedArray( arrayLength ), stride );
	let offset = 0;
	const res = [];
	const getters = [ 'getX', 'getY', 'getZ', 'getW' ];
	const setters = [ 'setX', 'setY', 'setZ', 'setW' ];

	for ( let j = 0, l = attributes.length; j < l; j ++ ) {

		const attribute = attributes[ j ];
		const itemSize = attribute.itemSize;
		const count = attribute.count;
		const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );
		res.push( iba );

		offset += itemSize;

		// Move the data for each attribute into the new interleavedBuffer
		// at the appropriate offset
		for ( let c = 0; c < count; c ++ ) {

			for ( let k = 0; k < itemSize; k ++ ) {

				iba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );

			}

		}

	}

	return res;

}

// returns a new, non-interleaved version of the provided attribute
function deinterleaveAttribute( attribute ) {

	const cons = attribute.data.array.constructor;
	const count = attribute.count;
	const itemSize = attribute.itemSize;
	const normalized = attribute.normalized;

	const array = new cons( count * itemSize );
	let newAttribute;
	if ( attribute.isInstancedInterleavedBufferAttribute ) {

		newAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );

	} else {

		newAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( array, itemSize, normalized );

	}

	for ( let i = 0; i < count; i ++ ) {

		newAttribute.setX( i, attribute.getX( i ) );

		if ( itemSize >= 2 ) {

			newAttribute.setY( i, attribute.getY( i ) );

		}

		if ( itemSize >= 3 ) {

			newAttribute.setZ( i, attribute.getZ( i ) );

		}

		if ( itemSize >= 4 ) {

			newAttribute.setW( i, attribute.getW( i ) );

		}

	}

	return newAttribute;

}

// deinterleaves all attributes on the geometry
function deinterleaveGeometry( geometry ) {

	const attributes = geometry.attributes;
	const morphTargets = geometry.morphTargets;
	const attrMap = new Map();

	for ( const key in attributes ) {

		const attr = attributes[ key ];
		if ( attr.isInterleavedBufferAttribute ) {

			if ( ! attrMap.has( attr ) ) {

				attrMap.set( attr, deinterleaveAttribute( attr ) );

			}

			attributes[ key ] = attrMap.get( attr );

		}

	}

	for ( const key in morphTargets ) {

		const attr = morphTargets[ key ];
		if ( attr.isInterleavedBufferAttribute ) {

			if ( ! attrMap.has( attr ) ) {

				attrMap.set( attr, deinterleaveAttribute( attr ) );

			}

			morphTargets[ key ] = attrMap.get( attr );

		}

	}

}

/**
 * @param {Array<BufferGeometry>} geometry
 * @return {number}
 */
function estimateBytesUsed( geometry ) {

	// Return the estimated memory used by this geometry in bytes
	// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account
	// for InterleavedBufferAttributes.
	let mem = 0;
	for ( const name in geometry.attributes ) {

		const attr = geometry.getAttribute( name );
		mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;

	}

	const indices = geometry.getIndex();
	mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
	return mem;

}

/**
 * @param {BufferGeometry} geometry
 * @param {number} tolerance
 * @return {BufferGeometry}
 */
function mergeVertices( geometry, tolerance = 1e-4 ) {

	tolerance = Math.max( tolerance, Number.EPSILON );

	// Generate an index buffer if the geometry doesn't have one, or optimize it
	// if it's already available.
	const hashToIndex = {};
	const indices = geometry.getIndex();
	const positions = geometry.getAttribute( 'position' );
	const vertexCount = indices ? indices.count : positions.count;

	// next value for triangle indices
	let nextIndex = 0;

	// attributes and new attribute arrays
	const attributeNames = Object.keys( geometry.attributes );
	const tmpAttributes = {};
	const tmpMorphAttributes = {};
	const newIndices = [];
	const getters = [ 'getX', 'getY', 'getZ', 'getW' ];
	const setters = [ 'setX', 'setY', 'setZ', 'setW' ];

	// Initialize the arrays, allocating space conservatively. Extra
	// space will be trimmed in the last step.
	for ( let i = 0, l = attributeNames.length; i < l; i ++ ) {

		const name = attributeNames[ i ];
		const attr = geometry.attributes[ name ];

		tmpAttributes[ name ] = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(
			new attr.array.constructor( attr.count * attr.itemSize ),
			attr.itemSize,
			attr.normalized
		);

		const morphAttr = geometry.morphAttributes[ name ];
		if ( morphAttr ) {

			tmpMorphAttributes[ name ] = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(
				new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),
				morphAttr.itemSize,
				morphAttr.normalized
			);

		}

	}

	// convert the error tolerance to an amount of decimal places to truncate to
	const decimalShift = Math.log10( 1 / tolerance );
	const shiftMultiplier = Math.pow( 10, decimalShift );
	for ( let i = 0; i < vertexCount; i ++ ) {

		const index = indices ? indices.getX( i ) : i;

		// Generate a hash for the vertex attributes at the current index 'i'
		let hash = '';
		for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

			const name = attributeNames[ j ];
			const attribute = geometry.getAttribute( name );
			const itemSize = attribute.itemSize;

			for ( let k = 0; k < itemSize; k ++ ) {

				// double tilde truncates the decimal value
				hash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;

			}

		}

		// Add another reference to the vertex if it's already
		// used by another index
		if ( hash in hashToIndex ) {

			newIndices.push( hashToIndex[ hash ] );

		} else {

			// copy data to the new index in the temporary attributes
			for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

				const name = attributeNames[ j ];
				const attribute = geometry.getAttribute( name );
				const morphAttr = geometry.morphAttributes[ name ];
				const itemSize = attribute.itemSize;
				const newarray = tmpAttributes[ name ];
				const newMorphArrays = tmpMorphAttributes[ name ];

				for ( let k = 0; k < itemSize; k ++ ) {

					const getterFunc = getters[ k ];
					const setterFunc = setters[ k ];
					newarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );

					if ( morphAttr ) {

						for ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {

							newMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );

						}

					}

				}

			}

			hashToIndex[ hash ] = nextIndex;
			newIndices.push( nextIndex );
			nextIndex ++;

		}

	}

	// generate result BufferGeometry
	const result = geometry.clone();
	for ( const name in geometry.attributes ) {

		const tmpAttribute = tmpAttributes[ name ];

		result.setAttribute( name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(
			tmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),
			tmpAttribute.itemSize,
			tmpAttribute.normalized,
		) );

		if ( ! ( name in tmpMorphAttributes ) ) continue;

		for ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {

			const tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];

			result.morphAttributes[ name ][ j ] = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(
				tmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),
				tmpMorphAttribute.itemSize,
				tmpMorphAttribute.normalized,
			);

		}

	}

	// indices

	result.setIndex( newIndices );

	return result;

}

/**
 * @param {BufferGeometry} geometry
 * @param {number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	if ( drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode ) {

		console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );
		return geometry;

	}

	if ( drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode ) {

		let index = geometry.getIndex();

		// generate index if not present

		if ( index === null ) {

			const indices = [];

			const position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( let i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		}

		//

		const numberOfTriangles = index.count - 2;
		const newIndices = [];

		if ( drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode ) {

			// gl.TRIANGLE_FAN

			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP

			for ( let i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );

				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

			console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		}

		// build final geometry

		const newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );
		newGeometry.clearGroups();

		return newGeometry;

	} else {

		console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );
		return geometry;

	}

}

/**
 * Calculates the morphed attributes of a morphed/skinned BufferGeometry.
 * Helpful for Raytracing or Decals.
 * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.
 * @return {Object} An Object with original position/normal attributes and morphed ones.
 */
function computeMorphedAttributes( object ) {

	const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

	const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

	const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

	function _calculateMorphedAttributeData(
		object,
		attribute,
		morphAttribute,
		morphTargetsRelative,
		a,
		b,
		c,
		modifiedAttributeArray
	) {

		_vA.fromBufferAttribute( attribute, a );
		_vB.fromBufferAttribute( attribute, b );
		_vC.fromBufferAttribute( attribute, c );

		const morphInfluences = object.morphTargetInfluences;

		if ( morphAttribute && morphInfluences ) {

			_morphA.set( 0, 0, 0 );
			_morphB.set( 0, 0, 0 );
			_morphC.set( 0, 0, 0 );

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morph = morphAttribute[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morph, a );
				_tempB.fromBufferAttribute( morph, b );
				_tempC.fromBufferAttribute( morph, c );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );
					_morphB.addScaledVector( _tempB, influence );
					_morphC.addScaledVector( _tempC, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( _vA ), influence );
					_morphB.addScaledVector( _tempB.sub( _vB ), influence );
					_morphC.addScaledVector( _tempC.sub( _vC ), influence );

				}

			}

			_vA.add( _morphA );
			_vB.add( _morphB );
			_vC.add( _morphC );

		}

		if ( object.isSkinnedMesh ) {

			object.boneTransform( a, _vA );
			object.boneTransform( b, _vB );
			object.boneTransform( c, _vC );

		}

		modifiedAttributeArray[ a * 3 + 0 ] = _vA.x;
		modifiedAttributeArray[ a * 3 + 1 ] = _vA.y;
		modifiedAttributeArray[ a * 3 + 2 ] = _vA.z;
		modifiedAttributeArray[ b * 3 + 0 ] = _vB.x;
		modifiedAttributeArray[ b * 3 + 1 ] = _vB.y;
		modifiedAttributeArray[ b * 3 + 2 ] = _vB.z;
		modifiedAttributeArray[ c * 3 + 0 ] = _vC.x;
		modifiedAttributeArray[ c * 3 + 1 ] = _vC.y;
		modifiedAttributeArray[ c * 3 + 2 ] = _vC.z;

	}

	const geometry = object.geometry;
	const material = object.material;

	let a, b, c;
	const index = geometry.index;
	const positionAttribute = geometry.attributes.position;
	const morphPosition = geometry.morphAttributes.position;
	const morphTargetsRelative = geometry.morphTargetsRelative;
	const normalAttribute = geometry.attributes.normal;
	const morphNormal = geometry.morphAttributes.position;

	const groups = geometry.groups;
	const drawRange = geometry.drawRange;
	let i, j, il, jl;
	let group;
	let start, end;

	const modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );
	const modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );

	if ( index !== null ) {

		// indexed buffer geometry

		if ( Array.isArray( material ) ) {

			for ( i = 0, il = groups.length; i < il; i ++ ) {

				group = groups[ i ];

				start = Math.max( group.start, drawRange.start );
				end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

				for ( j = start, jl = end; j < jl; j += 3 ) {

					a = index.getX( j );
					b = index.getX( j + 1 );
					c = index.getX( j + 2 );

					_calculateMorphedAttributeData(
						object,
						positionAttribute,
						morphPosition,
						morphTargetsRelative,
						a, b, c,
						modifiedPosition
					);

					_calculateMorphedAttributeData(
						object,
						normalAttribute,
						morphNormal,
						morphTargetsRelative,
						a, b, c,
						modifiedNormal
					);

				}

			}

		} else {

			start = Math.max( 0, drawRange.start );
			end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( i = start, il = end; i < il; i += 3 ) {

				a = index.getX( i );
				b = index.getX( i + 1 );
				c = index.getX( i + 2 );

				_calculateMorphedAttributeData(
					object,
					positionAttribute,
					morphPosition,
					morphTargetsRelative,
					a, b, c,
					modifiedPosition
				);

				_calculateMorphedAttributeData(
					object,
					normalAttribute,
					morphNormal,
					morphTargetsRelative,
					a, b, c,
					modifiedNormal
				);

			}

		}

	} else {

		// non-indexed buffer geometry

		if ( Array.isArray( material ) ) {

			for ( i = 0, il = groups.length; i < il; i ++ ) {

				group = groups[ i ];

				start = Math.max( group.start, drawRange.start );
				end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

				for ( j = start, jl = end; j < jl; j += 3 ) {

					a = j;
					b = j + 1;
					c = j + 2;

					_calculateMorphedAttributeData(
						object,
						positionAttribute,
						morphPosition,
						morphTargetsRelative,
						a, b, c,
						modifiedPosition
					);

					_calculateMorphedAttributeData(
						object,
						normalAttribute,
						morphNormal,
						morphTargetsRelative,
						a, b, c,
						modifiedNormal
					);

				}

			}

		} else {

			start = Math.max( 0, drawRange.start );
			end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( i = start, il = end; i < il; i += 3 ) {

				a = i;
				b = i + 1;
				c = i + 2;

				_calculateMorphedAttributeData(
					object,
					positionAttribute,
					morphPosition,
					morphTargetsRelative,
					a, b, c,
					modifiedPosition
				);

				_calculateMorphedAttributeData(
					object,
					normalAttribute,
					morphNormal,
					morphTargetsRelative,
					a, b, c,
					modifiedNormal
				);

			}

		}

	}

	const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( modifiedPosition, 3 );
	const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( modifiedNormal, 3 );

	return {

		positionAttribute: positionAttribute,
		normalAttribute: normalAttribute,
		morphedPositionAttribute: morphedPositionAttribute,
		morphedNormalAttribute: morphedNormalAttribute

	};

}

function mergeGroups( geometry ) {

	if ( geometry.groups.length === 0 ) {

		console.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );
		return geometry;

	}

	let groups = geometry.groups;

	// sort groups by material index

	groups = groups.sort( ( a, b ) => {

		if ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;

		return a.start - b.start;

	} );

	// create index for non-indexed geometries

	if ( geometry.getIndex() === null ) {

		const positionAttribute = geometry.getAttribute( 'position' );
		const indices = [];

		for ( let i = 0; i < positionAttribute.count; i += 3 ) {

			indices.push( i, i + 1, i + 2 );

		}

		geometry.setIndex( indices );

	}

	// sort index

	const index = geometry.getIndex();

	const newIndices = [];

	for ( let i = 0; i < groups.length; i ++ ) {

		const group = groups[ i ];

		const groupStart = group.start;
		const groupLength = groupStart + group.count;

		for ( let j = groupStart; j < groupLength; j ++ ) {

			newIndices.push( index.getX( j ) );

		}

	}

	geometry.dispose(); // Required to force buffer recreation
	geometry.setIndex( newIndices );

	// update groups indices

	let start = 0;

	for ( let i = 0; i < groups.length; i ++ ) {

		const group = groups[ i ];

		group.start = start;
		start += group.count;

	}

	// merge groups

	let currentGroup = groups[ 0 ];

	geometry.groups = [ currentGroup ];

	for ( let i = 1; i < groups.length; i ++ ) {

		const group = groups[ i ];

		if ( currentGroup.materialIndex === group.materialIndex ) {

			currentGroup.count += group.count;

		} else {

			currentGroup = group;
			geometry.groups.push( currentGroup );

		}

	}

	return geometry;

}


// Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at
// an angle greater than the crease angle.
function toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {

	const creaseDot = Math.cos( creaseAngle );
	const hashMultiplier = ( 1 + 1e-10 ) * 1e2;

	// reusable vertors
	const verts = [ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() ];
	const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

	// hashes a vector
	function hashVertex( v ) {

		const x = ~ ~ ( v.x * hashMultiplier );
		const y = ~ ~ ( v.y * hashMultiplier );
		const z = ~ ~ ( v.z * hashMultiplier );
		return `${x},${y},${z}`;

	}

	const resultGeometry = geometry.toNonIndexed();
	const posAttr = resultGeometry.attributes.position;
	const vertexMap = {};

	// find all the normals shared by commonly located vertices
	for ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {

		const i3 = 3 * i;
		const a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );
		const b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );
		const c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );

		tempVec1.subVectors( c, b );
		tempVec2.subVectors( a, b );

		// add the normal to the map for all vertices
		const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors( tempVec1, tempVec2 ).normalize();
		for ( let n = 0; n < 3; n ++ ) {

			const vert = verts[ n ];
			const hash = hashVertex( vert );
			if ( ! ( hash in vertexMap ) ) {

				vertexMap[ hash ] = [];

			}

			vertexMap[ hash ].push( normal );

		}

	}

	// average normals from all vertices that share a common location if they are within the
	// provided crease threshold
	const normalArray = new Float32Array( posAttr.count * 3 );
	const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( normalArray, 3, false );
	for ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {

		// get the face normal for this vertex
		const i3 = 3 * i;
		const a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );
		const b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );
		const c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );

		tempVec1.subVectors( c, b );
		tempVec2.subVectors( a, b );

		tempNorm.crossVectors( tempVec1, tempVec2 ).normalize();

		// average all normals that meet the threshold and set the normal value
		for ( let n = 0; n < 3; n ++ ) {

			const vert = verts[ n ];
			const hash = hashVertex( vert );
			const otherNormals = vertexMap[ hash ];
			tempNorm2.set( 0, 0, 0 );

			for ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {

				const otherNorm = otherNormals[ k ];
				if ( tempNorm.dot( otherNorm ) > creaseDot ) {

					tempNorm2.add( otherNorm );

				}

			}

			tempNorm2.normalize();
			normAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );

		}

	}

	resultGeometry.setAttribute( 'normal', normAttr );
	return resultGeometry;

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/utils/SkeletonUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three/examples/jsm/utils/SkeletonUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "findBoneTrackData": () => (/* binding */ findBoneTrackData),
/* harmony export */   "getBoneByName": () => (/* binding */ getBoneByName),
/* harmony export */   "getBones": () => (/* binding */ getBones),
/* harmony export */   "getEqualsBonesNames": () => (/* binding */ getEqualsBonesNames),
/* harmony export */   "getHelperFromSkeleton": () => (/* binding */ getHelperFromSkeleton),
/* harmony export */   "getNearestBone": () => (/* binding */ getNearestBone),
/* harmony export */   "getSkeletonOffsets": () => (/* binding */ getSkeletonOffsets),
/* harmony export */   "renameBones": () => (/* binding */ renameBones),
/* harmony export */   "retarget": () => (/* binding */ retarget),
/* harmony export */   "retargetClip": () => (/* binding */ retargetClip)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");



function retarget( target, source, options = {} ) {

	const pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
		quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(),
		scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
		bindBoneMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(),
		relativeMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(),
		globalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();

	options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;
	options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;
	options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;
	options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;
	options.hip = options.hip !== undefined ? options.hip : 'hip';
	options.names = options.names || {};

	const sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),
		bones = target.isObject3D ? target.skeleton.bones : getBones( target );

	let bindBones,
		bone, name, boneTo,
		bonesPosition;

	// reset bones

	if ( target.isObject3D ) {

		target.skeleton.pose();

	} else {

		options.useTargetMatrix = true;
		options.preserveMatrix = false;

	}

	if ( options.preservePosition ) {

		bonesPosition = [];

		for ( let i = 0; i < bones.length; i ++ ) {

			bonesPosition.push( bones[ i ].position.clone() );

		}

	}

	if ( options.preserveMatrix ) {

		// reset matrix

		target.updateMatrixWorld();

		target.matrixWorld.identity();

		// reset children matrix

		for ( let i = 0; i < target.children.length; ++ i ) {

			target.children[ i ].updateMatrixWorld( true );

		}

	}

	if ( options.offsets ) {

		bindBones = [];

		for ( let i = 0; i < bones.length; ++ i ) {

			bone = bones[ i ];
			name = options.names[ bone.name ] || bone.name;

			if ( options.offsets[ name ] ) {

				bone.matrix.multiply( options.offsets[ name ] );

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				bone.updateMatrixWorld();

			}

			bindBones.push( bone.matrixWorld.clone() );

		}

	}

	for ( let i = 0; i < bones.length; ++ i ) {

		bone = bones[ i ];
		name = options.names[ bone.name ] || bone.name;

		boneTo = getBoneByName( name, sourceBones );

		globalMatrix.copy( bone.matrixWorld );

		if ( boneTo ) {

			boneTo.updateMatrixWorld();

			if ( options.useTargetMatrix ) {

				relativeMatrix.copy( boneTo.matrixWorld );

			} else {

				relativeMatrix.copy( target.matrixWorld ).invert();
				relativeMatrix.multiply( boneTo.matrixWorld );

			}

			// ignore scale to extract rotation

			scale.setFromMatrixScale( relativeMatrix );
			relativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );

			// apply to global matrix

			globalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );

			if ( target.isObject3D ) {

				const boneIndex = bones.indexOf( bone ),
					wBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();

				globalMatrix.multiply( wBindMatrix );

			}

			globalMatrix.copyPosition( relativeMatrix );

		}

		if ( bone.parent && bone.parent.isBone ) {

			bone.matrix.copy( bone.parent.matrixWorld ).invert();
			bone.matrix.multiply( globalMatrix );

		} else {

			bone.matrix.copy( globalMatrix );

		}

		if ( options.preserveHipPosition && name === options.hip ) {

			bone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );

		}

		bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		bone.updateMatrixWorld();

	}

	if ( options.preservePosition ) {

		for ( let i = 0; i < bones.length; ++ i ) {

			bone = bones[ i ];
			name = options.names[ bone.name ] || bone.name;

			if ( name !== options.hip ) {

				bone.position.copy( bonesPosition[ i ] );

			}

		}

	}

	if ( options.preserveMatrix ) {

		// restore matrix

		target.updateMatrixWorld( true );

	}

}

function retargetClip( target, source, clip, options = {} ) {

	options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;
	options.fps = options.fps !== undefined ? options.fps : 30;
	options.names = options.names || [];

	if ( ! source.isObject3D ) {

		source = getHelperFromSkeleton( source );

	}

	const numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),
		delta = 1 / options.fps,
		convertedTracks = [],
		mixer = new three__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer( source ),
		bones = getBones( target.skeleton ),
		boneDatas = [];
	let positionOffset,
		bone, boneTo, boneData,
		name;

	mixer.clipAction( clip ).play();
	mixer.update( 0 );

	source.updateMatrixWorld();

	for ( let i = 0; i < numFrames; ++ i ) {

		const time = i * delta;

		retarget( target, source, options );

		for ( let j = 0; j < bones.length; ++ j ) {

			name = options.names[ bones[ j ].name ] || bones[ j ].name;

			boneTo = getBoneByName( name, source.skeleton );

			if ( boneTo ) {

				bone = bones[ j ];
				boneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };

				if ( options.hip === name ) {

					if ( ! boneData.pos ) {

						boneData.pos = {
							times: new Float32Array( numFrames ),
							values: new Float32Array( numFrames * 3 )
						};

					}

					if ( options.useFirstFramePosition ) {

						if ( i === 0 ) {

							positionOffset = bone.position.clone();

						}

						bone.position.sub( positionOffset );

					}

					boneData.pos.times[ i ] = time;

					bone.position.toArray( boneData.pos.values, i * 3 );

				}

				if ( ! boneData.quat ) {

					boneData.quat = {
						times: new Float32Array( numFrames ),
						values: new Float32Array( numFrames * 4 )
					};

				}

				boneData.quat.times[ i ] = time;

				bone.quaternion.toArray( boneData.quat.values, i * 4 );

			}

		}

		mixer.update( delta );

		source.updateMatrixWorld();

	}

	for ( let i = 0; i < boneDatas.length; ++ i ) {

		boneData = boneDatas[ i ];

		if ( boneData ) {

			if ( boneData.pos ) {

				convertedTracks.push( new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack(
					'.bones[' + boneData.bone.name + '].position',
					boneData.pos.times,
					boneData.pos.values
				) );

			}

			convertedTracks.push( new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack(
				'.bones[' + boneData.bone.name + '].quaternion',
				boneData.quat.times,
				boneData.quat.values
			) );

		}

	}

	mixer.uncacheAction( clip );

	return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip( clip.name, - 1, convertedTracks );

}

function getHelperFromSkeleton( skeleton ) {

	const source = new three__WEBPACK_IMPORTED_MODULE_0__.SkeletonHelper( skeleton.bones[ 0 ] );
	source.skeleton = skeleton;

	return source;

}

function getSkeletonOffsets( target, source, options = {} ) {

	const targetParentPos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
		targetPos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
		sourceParentPos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
		sourcePos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
		targetDir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(),
		sourceDir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

	options.hip = options.hip !== undefined ? options.hip : 'hip';
	options.names = options.names || {};

	if ( ! source.isObject3D ) {

		source = getHelperFromSkeleton( source );

	}

	const nameKeys = Object.keys( options.names ),
		nameValues = Object.values( options.names ),
		sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),
		bones = target.isObject3D ? target.skeleton.bones : getBones( target ),
		offsets = [];

	let bone, boneTo,
		name, i;

	target.skeleton.pose();

	for ( i = 0; i < bones.length; ++ i ) {

		bone = bones[ i ];
		name = options.names[ bone.name ] || bone.name;

		boneTo = getBoneByName( name, sourceBones );

		if ( boneTo && name !== options.hip ) {

			const boneParent = getNearestBone( bone.parent, nameKeys ),
				boneToParent = getNearestBone( boneTo.parent, nameValues );

			boneParent.updateMatrixWorld();
			boneToParent.updateMatrixWorld();

			targetParentPos.setFromMatrixPosition( boneParent.matrixWorld );
			targetPos.setFromMatrixPosition( bone.matrixWorld );

			sourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );
			sourcePos.setFromMatrixPosition( boneTo.matrixWorld );

			targetDir.subVectors(
				new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( targetPos.x, targetPos.y ),
				new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( targetParentPos.x, targetParentPos.y )
			).normalize();

			sourceDir.subVectors(
				new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( sourcePos.x, sourcePos.y ),
				new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( sourceParentPos.x, sourceParentPos.y )
			).normalize();

			const laterialAngle = targetDir.angle() - sourceDir.angle();

			const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationFromEuler(
				new three__WEBPACK_IMPORTED_MODULE_0__.Euler(
					0,
					0,
					laterialAngle
				)
			);

			bone.matrix.multiply( offset );

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			bone.updateMatrixWorld();

			offsets[ name ] = offset;

		}

	}

	return offsets;

}

function renameBones( skeleton, names ) {

	const bones = getBones( skeleton );

	for ( let i = 0; i < bones.length; ++ i ) {

		const bone = bones[ i ];

		if ( names[ bone.name ] ) {

			bone.name = names[ bone.name ];

		}

	}

	return this;

}

function getBones( skeleton ) {

	return Array.isArray( skeleton ) ? skeleton : skeleton.bones;

}

function getBoneByName( name, skeleton ) {

	for ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {

		if ( name === bones[ i ].name )

			return bones[ i ];

	}

}

function getNearestBone( bone, names ) {

	while ( bone.isBone ) {

		if ( names.indexOf( bone.name ) !== - 1 ) {

			return bone;

		}

		bone = bone.parent;

	}

}

function findBoneTrackData( name, tracks ) {

	const regexp = /\[(.*)\]\.(.*)/,
		result = { name: name };

	for ( let i = 0; i < tracks.length; ++ i ) {

		// 1 is track name
		// 2 is track type
		const trackData = regexp.exec( tracks[ i ].name );

		if ( trackData && name === trackData[ 1 ] ) {

			result[ trackData[ 2 ] ] = i;

		}

	}

	return result;

}

function getEqualsBonesNames( skeleton, targetSkeleton ) {

	const sourceBones = getBones( skeleton ),
		targetBones = getBones( targetSkeleton ),
		bones = [];

	search : for ( let i = 0; i < sourceBones.length; i ++ ) {

		const boneName = sourceBones[ i ].name;

		for ( let j = 0; j < targetBones.length; j ++ ) {

			if ( boneName === targetBones[ j ].name ) {

				bones.push( boneName );

				continue search;

			}

		}

	}

	return bones;

}

function clone( source ) {

	const sourceLookup = new Map();
	const cloneLookup = new Map();

	const clone = source.clone();

	parallelTraverse( source, clone, function ( sourceNode, clonedNode ) {

		sourceLookup.set( clonedNode, sourceNode );
		cloneLookup.set( sourceNode, clonedNode );

	} );

	clone.traverse( function ( node ) {

		if ( ! node.isSkinnedMesh ) return;

		const clonedMesh = node;
		const sourceMesh = sourceLookup.get( node );
		const sourceBones = sourceMesh.skeleton.bones;

		clonedMesh.skeleton = sourceMesh.skeleton.clone();
		clonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );

		clonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {

			return cloneLookup.get( bone );

		} );

		clonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );

	} );

	return clone;

}




function parallelTraverse( a, b, callback ) {

	callback( a, b );

	for ( let i = 0; i < a.children.length; i ++ ) {

		parallelTraverse( a.children[ i ], b.children[ i ], callback );

	}

}




/***/ }),

/***/ "./node_modules/three/src/constants.js":
/*!*********************************************!*\
  !*** ./node_modules/three/src/constants.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ACESFilmicToneMapping": () => (/* binding */ ACESFilmicToneMapping),
/* harmony export */   "AddEquation": () => (/* binding */ AddEquation),
/* harmony export */   "AddOperation": () => (/* binding */ AddOperation),
/* harmony export */   "AdditiveAnimationBlendMode": () => (/* binding */ AdditiveAnimationBlendMode),
/* harmony export */   "AdditiveBlending": () => (/* binding */ AdditiveBlending),
/* harmony export */   "AlphaFormat": () => (/* binding */ AlphaFormat),
/* harmony export */   "AlwaysDepth": () => (/* binding */ AlwaysDepth),
/* harmony export */   "AlwaysStencilFunc": () => (/* binding */ AlwaysStencilFunc),
/* harmony export */   "BackSide": () => (/* binding */ BackSide),
/* harmony export */   "BasicDepthPacking": () => (/* binding */ BasicDepthPacking),
/* harmony export */   "BasicShadowMap": () => (/* binding */ BasicShadowMap),
/* harmony export */   "ByteType": () => (/* binding */ ByteType),
/* harmony export */   "CineonToneMapping": () => (/* binding */ CineonToneMapping),
/* harmony export */   "ClampToEdgeWrapping": () => (/* binding */ ClampToEdgeWrapping),
/* harmony export */   "CubeReflectionMapping": () => (/* binding */ CubeReflectionMapping),
/* harmony export */   "CubeRefractionMapping": () => (/* binding */ CubeRefractionMapping),
/* harmony export */   "CubeUVReflectionMapping": () => (/* binding */ CubeUVReflectionMapping),
/* harmony export */   "CullFaceBack": () => (/* binding */ CullFaceBack),
/* harmony export */   "CullFaceFront": () => (/* binding */ CullFaceFront),
/* harmony export */   "CullFaceFrontBack": () => (/* binding */ CullFaceFrontBack),
/* harmony export */   "CullFaceNone": () => (/* binding */ CullFaceNone),
/* harmony export */   "CustomBlending": () => (/* binding */ CustomBlending),
/* harmony export */   "CustomToneMapping": () => (/* binding */ CustomToneMapping),
/* harmony export */   "DecrementStencilOp": () => (/* binding */ DecrementStencilOp),
/* harmony export */   "DecrementWrapStencilOp": () => (/* binding */ DecrementWrapStencilOp),
/* harmony export */   "DepthFormat": () => (/* binding */ DepthFormat),
/* harmony export */   "DepthStencilFormat": () => (/* binding */ DepthStencilFormat),
/* harmony export */   "DisplayP3ColorSpace": () => (/* binding */ DisplayP3ColorSpace),
/* harmony export */   "DoubleSide": () => (/* binding */ DoubleSide),
/* harmony export */   "DstAlphaFactor": () => (/* binding */ DstAlphaFactor),
/* harmony export */   "DstColorFactor": () => (/* binding */ DstColorFactor),
/* harmony export */   "DynamicCopyUsage": () => (/* binding */ DynamicCopyUsage),
/* harmony export */   "DynamicDrawUsage": () => (/* binding */ DynamicDrawUsage),
/* harmony export */   "DynamicReadUsage": () => (/* binding */ DynamicReadUsage),
/* harmony export */   "EqualDepth": () => (/* binding */ EqualDepth),
/* harmony export */   "EqualStencilFunc": () => (/* binding */ EqualStencilFunc),
/* harmony export */   "EquirectangularReflectionMapping": () => (/* binding */ EquirectangularReflectionMapping),
/* harmony export */   "EquirectangularRefractionMapping": () => (/* binding */ EquirectangularRefractionMapping),
/* harmony export */   "FloatType": () => (/* binding */ FloatType),
/* harmony export */   "FrontSide": () => (/* binding */ FrontSide),
/* harmony export */   "GLSL1": () => (/* binding */ GLSL1),
/* harmony export */   "GLSL3": () => (/* binding */ GLSL3),
/* harmony export */   "GreaterDepth": () => (/* binding */ GreaterDepth),
/* harmony export */   "GreaterEqualDepth": () => (/* binding */ GreaterEqualDepth),
/* harmony export */   "GreaterEqualStencilFunc": () => (/* binding */ GreaterEqualStencilFunc),
/* harmony export */   "GreaterStencilFunc": () => (/* binding */ GreaterStencilFunc),
/* harmony export */   "HalfFloatType": () => (/* binding */ HalfFloatType),
/* harmony export */   "IncrementStencilOp": () => (/* binding */ IncrementStencilOp),
/* harmony export */   "IncrementWrapStencilOp": () => (/* binding */ IncrementWrapStencilOp),
/* harmony export */   "IntType": () => (/* binding */ IntType),
/* harmony export */   "InterpolateDiscrete": () => (/* binding */ InterpolateDiscrete),
/* harmony export */   "InterpolateLinear": () => (/* binding */ InterpolateLinear),
/* harmony export */   "InterpolateSmooth": () => (/* binding */ InterpolateSmooth),
/* harmony export */   "InvertStencilOp": () => (/* binding */ InvertStencilOp),
/* harmony export */   "KeepStencilOp": () => (/* binding */ KeepStencilOp),
/* harmony export */   "LessDepth": () => (/* binding */ LessDepth),
/* harmony export */   "LessEqualDepth": () => (/* binding */ LessEqualDepth),
/* harmony export */   "LessEqualStencilFunc": () => (/* binding */ LessEqualStencilFunc),
/* harmony export */   "LessStencilFunc": () => (/* binding */ LessStencilFunc),
/* harmony export */   "LinearEncoding": () => (/* binding */ LinearEncoding),
/* harmony export */   "LinearFilter": () => (/* binding */ LinearFilter),
/* harmony export */   "LinearMipMapLinearFilter": () => (/* binding */ LinearMipMapLinearFilter),
/* harmony export */   "LinearMipMapNearestFilter": () => (/* binding */ LinearMipMapNearestFilter),
/* harmony export */   "LinearMipmapLinearFilter": () => (/* binding */ LinearMipmapLinearFilter),
/* harmony export */   "LinearMipmapNearestFilter": () => (/* binding */ LinearMipmapNearestFilter),
/* harmony export */   "LinearSRGBColorSpace": () => (/* binding */ LinearSRGBColorSpace),
/* harmony export */   "LinearToneMapping": () => (/* binding */ LinearToneMapping),
/* harmony export */   "LoopOnce": () => (/* binding */ LoopOnce),
/* harmony export */   "LoopPingPong": () => (/* binding */ LoopPingPong),
/* harmony export */   "LoopRepeat": () => (/* binding */ LoopRepeat),
/* harmony export */   "LuminanceAlphaFormat": () => (/* binding */ LuminanceAlphaFormat),
/* harmony export */   "LuminanceFormat": () => (/* binding */ LuminanceFormat),
/* harmony export */   "MOUSE": () => (/* binding */ MOUSE),
/* harmony export */   "MaxEquation": () => (/* binding */ MaxEquation),
/* harmony export */   "MinEquation": () => (/* binding */ MinEquation),
/* harmony export */   "MirroredRepeatWrapping": () => (/* binding */ MirroredRepeatWrapping),
/* harmony export */   "MixOperation": () => (/* binding */ MixOperation),
/* harmony export */   "MultiplyBlending": () => (/* binding */ MultiplyBlending),
/* harmony export */   "MultiplyOperation": () => (/* binding */ MultiplyOperation),
/* harmony export */   "NearestFilter": () => (/* binding */ NearestFilter),
/* harmony export */   "NearestMipMapLinearFilter": () => (/* binding */ NearestMipMapLinearFilter),
/* harmony export */   "NearestMipMapNearestFilter": () => (/* binding */ NearestMipMapNearestFilter),
/* harmony export */   "NearestMipmapLinearFilter": () => (/* binding */ NearestMipmapLinearFilter),
/* harmony export */   "NearestMipmapNearestFilter": () => (/* binding */ NearestMipmapNearestFilter),
/* harmony export */   "NeverDepth": () => (/* binding */ NeverDepth),
/* harmony export */   "NeverStencilFunc": () => (/* binding */ NeverStencilFunc),
/* harmony export */   "NoBlending": () => (/* binding */ NoBlending),
/* harmony export */   "NoColorSpace": () => (/* binding */ NoColorSpace),
/* harmony export */   "NoToneMapping": () => (/* binding */ NoToneMapping),
/* harmony export */   "NormalAnimationBlendMode": () => (/* binding */ NormalAnimationBlendMode),
/* harmony export */   "NormalBlending": () => (/* binding */ NormalBlending),
/* harmony export */   "NotEqualDepth": () => (/* binding */ NotEqualDepth),
/* harmony export */   "NotEqualStencilFunc": () => (/* binding */ NotEqualStencilFunc),
/* harmony export */   "ObjectSpaceNormalMap": () => (/* binding */ ObjectSpaceNormalMap),
/* harmony export */   "OneFactor": () => (/* binding */ OneFactor),
/* harmony export */   "OneMinusDstAlphaFactor": () => (/* binding */ OneMinusDstAlphaFactor),
/* harmony export */   "OneMinusDstColorFactor": () => (/* binding */ OneMinusDstColorFactor),
/* harmony export */   "OneMinusSrcAlphaFactor": () => (/* binding */ OneMinusSrcAlphaFactor),
/* harmony export */   "OneMinusSrcColorFactor": () => (/* binding */ OneMinusSrcColorFactor),
/* harmony export */   "PCFShadowMap": () => (/* binding */ PCFShadowMap),
/* harmony export */   "PCFSoftShadowMap": () => (/* binding */ PCFSoftShadowMap),
/* harmony export */   "RED_GREEN_RGTC2_Format": () => (/* binding */ RED_GREEN_RGTC2_Format),
/* harmony export */   "RED_RGTC1_Format": () => (/* binding */ RED_RGTC1_Format),
/* harmony export */   "REVISION": () => (/* binding */ REVISION),
/* harmony export */   "RGBADepthPacking": () => (/* binding */ RGBADepthPacking),
/* harmony export */   "RGBAFormat": () => (/* binding */ RGBAFormat),
/* harmony export */   "RGBAIntegerFormat": () => (/* binding */ RGBAIntegerFormat),
/* harmony export */   "RGBA_ASTC_10x10_Format": () => (/* binding */ RGBA_ASTC_10x10_Format),
/* harmony export */   "RGBA_ASTC_10x5_Format": () => (/* binding */ RGBA_ASTC_10x5_Format),
/* harmony export */   "RGBA_ASTC_10x6_Format": () => (/* binding */ RGBA_ASTC_10x6_Format),
/* harmony export */   "RGBA_ASTC_10x8_Format": () => (/* binding */ RGBA_ASTC_10x8_Format),
/* harmony export */   "RGBA_ASTC_12x10_Format": () => (/* binding */ RGBA_ASTC_12x10_Format),
/* harmony export */   "RGBA_ASTC_12x12_Format": () => (/* binding */ RGBA_ASTC_12x12_Format),
/* harmony export */   "RGBA_ASTC_4x4_Format": () => (/* binding */ RGBA_ASTC_4x4_Format),
/* harmony export */   "RGBA_ASTC_5x4_Format": () => (/* binding */ RGBA_ASTC_5x4_Format),
/* harmony export */   "RGBA_ASTC_5x5_Format": () => (/* binding */ RGBA_ASTC_5x5_Format),
/* harmony export */   "RGBA_ASTC_6x5_Format": () => (/* binding */ RGBA_ASTC_6x5_Format),
/* harmony export */   "RGBA_ASTC_6x6_Format": () => (/* binding */ RGBA_ASTC_6x6_Format),
/* harmony export */   "RGBA_ASTC_8x5_Format": () => (/* binding */ RGBA_ASTC_8x5_Format),
/* harmony export */   "RGBA_ASTC_8x6_Format": () => (/* binding */ RGBA_ASTC_8x6_Format),
/* harmony export */   "RGBA_ASTC_8x8_Format": () => (/* binding */ RGBA_ASTC_8x8_Format),
/* harmony export */   "RGBA_BPTC_Format": () => (/* binding */ RGBA_BPTC_Format),
/* harmony export */   "RGBA_ETC2_EAC_Format": () => (/* binding */ RGBA_ETC2_EAC_Format),
/* harmony export */   "RGBA_PVRTC_2BPPV1_Format": () => (/* binding */ RGBA_PVRTC_2BPPV1_Format),
/* harmony export */   "RGBA_PVRTC_4BPPV1_Format": () => (/* binding */ RGBA_PVRTC_4BPPV1_Format),
/* harmony export */   "RGBA_S3TC_DXT1_Format": () => (/* binding */ RGBA_S3TC_DXT1_Format),
/* harmony export */   "RGBA_S3TC_DXT3_Format": () => (/* binding */ RGBA_S3TC_DXT3_Format),
/* harmony export */   "RGBA_S3TC_DXT5_Format": () => (/* binding */ RGBA_S3TC_DXT5_Format),
/* harmony export */   "RGB_ETC1_Format": () => (/* binding */ RGB_ETC1_Format),
/* harmony export */   "RGB_ETC2_Format": () => (/* binding */ RGB_ETC2_Format),
/* harmony export */   "RGB_PVRTC_2BPPV1_Format": () => (/* binding */ RGB_PVRTC_2BPPV1_Format),
/* harmony export */   "RGB_PVRTC_4BPPV1_Format": () => (/* binding */ RGB_PVRTC_4BPPV1_Format),
/* harmony export */   "RGB_S3TC_DXT1_Format": () => (/* binding */ RGB_S3TC_DXT1_Format),
/* harmony export */   "RGFormat": () => (/* binding */ RGFormat),
/* harmony export */   "RGIntegerFormat": () => (/* binding */ RGIntegerFormat),
/* harmony export */   "RedFormat": () => (/* binding */ RedFormat),
/* harmony export */   "RedIntegerFormat": () => (/* binding */ RedIntegerFormat),
/* harmony export */   "ReinhardToneMapping": () => (/* binding */ ReinhardToneMapping),
/* harmony export */   "RepeatWrapping": () => (/* binding */ RepeatWrapping),
/* harmony export */   "ReplaceStencilOp": () => (/* binding */ ReplaceStencilOp),
/* harmony export */   "ReverseSubtractEquation": () => (/* binding */ ReverseSubtractEquation),
/* harmony export */   "SIGNED_RED_GREEN_RGTC2_Format": () => (/* binding */ SIGNED_RED_GREEN_RGTC2_Format),
/* harmony export */   "SIGNED_RED_RGTC1_Format": () => (/* binding */ SIGNED_RED_RGTC1_Format),
/* harmony export */   "SRGBColorSpace": () => (/* binding */ SRGBColorSpace),
/* harmony export */   "ShortType": () => (/* binding */ ShortType),
/* harmony export */   "SrcAlphaFactor": () => (/* binding */ SrcAlphaFactor),
/* harmony export */   "SrcAlphaSaturateFactor": () => (/* binding */ SrcAlphaSaturateFactor),
/* harmony export */   "SrcColorFactor": () => (/* binding */ SrcColorFactor),
/* harmony export */   "StaticCopyUsage": () => (/* binding */ StaticCopyUsage),
/* harmony export */   "StaticDrawUsage": () => (/* binding */ StaticDrawUsage),
/* harmony export */   "StaticReadUsage": () => (/* binding */ StaticReadUsage),
/* harmony export */   "StreamCopyUsage": () => (/* binding */ StreamCopyUsage),
/* harmony export */   "StreamDrawUsage": () => (/* binding */ StreamDrawUsage),
/* harmony export */   "StreamReadUsage": () => (/* binding */ StreamReadUsage),
/* harmony export */   "SubtractEquation": () => (/* binding */ SubtractEquation),
/* harmony export */   "SubtractiveBlending": () => (/* binding */ SubtractiveBlending),
/* harmony export */   "TOUCH": () => (/* binding */ TOUCH),
/* harmony export */   "TangentSpaceNormalMap": () => (/* binding */ TangentSpaceNormalMap),
/* harmony export */   "TriangleFanDrawMode": () => (/* binding */ TriangleFanDrawMode),
/* harmony export */   "TriangleStripDrawMode": () => (/* binding */ TriangleStripDrawMode),
/* harmony export */   "TrianglesDrawMode": () => (/* binding */ TrianglesDrawMode),
/* harmony export */   "TwoPassDoubleSide": () => (/* binding */ TwoPassDoubleSide),
/* harmony export */   "UVMapping": () => (/* binding */ UVMapping),
/* harmony export */   "UnsignedByteType": () => (/* binding */ UnsignedByteType),
/* harmony export */   "UnsignedInt248Type": () => (/* binding */ UnsignedInt248Type),
/* harmony export */   "UnsignedIntType": () => (/* binding */ UnsignedIntType),
/* harmony export */   "UnsignedShort4444Type": () => (/* binding */ UnsignedShort4444Type),
/* harmony export */   "UnsignedShort5551Type": () => (/* binding */ UnsignedShort5551Type),
/* harmony export */   "UnsignedShortType": () => (/* binding */ UnsignedShortType),
/* harmony export */   "VSMShadowMap": () => (/* binding */ VSMShadowMap),
/* harmony export */   "WrapAroundEnding": () => (/* binding */ WrapAroundEnding),
/* harmony export */   "ZeroCurvatureEnding": () => (/* binding */ ZeroCurvatureEnding),
/* harmony export */   "ZeroFactor": () => (/* binding */ ZeroFactor),
/* harmony export */   "ZeroSlopeEnding": () => (/* binding */ ZeroSlopeEnding),
/* harmony export */   "ZeroStencilOp": () => (/* binding */ ZeroStencilOp),
/* harmony export */   "_SRGBAFormat": () => (/* binding */ _SRGBAFormat),
/* harmony export */   "sRGBEncoding": () => (/* binding */ sRGBEncoding)
/* harmony export */ });
const REVISION = '150';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const TwoPassDoubleSide = 2; // r149
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
const NoColorSpace = '';
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';
const DisplayP3ColorSpace = 'display-p3';

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = '100';
const GLSL3 = '300 es';

const _SRGBAFormat = 1035; // fallback for WebGL 1


/***/ }),

/***/ "./src/assets/fonts/Anton-Regular.json":
/*!*********************************************!*\
  !*** ./src/assets/fonts/Anton-Regular.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"glyphs":{"0":{"ha":686,"x_min":27,"x_max":659,"o":"m 343 -11 q 110 74 192 -11 q 27 318 27 159 l 27 857 q 105 1115 27 1025 q 343 1204 184 1204 q 581 1115 503 1204 q 659 857 659 1025 l 659 318 q 577 74 659 159 q 343 -11 495 -11 m 343 209 q 387 234 371 209 q 402 290 402 259 l 402 880 q 393 953 402 922 q 343 985 384 985 q 293 953 302 985 q 284 880 284 922 l 284 290 q 300 234 284 259 q 343 209 316 209 z "},"1":{"ha":459,"x_min":17,"x_max":418,"o":"m 165 0 l 165 920 q 98 872 140 890 q 17 854 55 854 l 17 1045 q 94 1068 53 1050 q 171 1118 136 1086 q 226 1194 207 1149 l 418 1194 l 418 0 l 165 0 z "},"2":{"ha":686,"x_min":39,"x_max":669,"o":"m 42 0 l 42 57 q 70 217 42 146 q 140 348 97 288 q 232 467 184 409 q 321 584 279 524 q 390 714 363 644 q 417 872 417 785 q 405 944 417 914 q 353 975 392 975 q 293 868 293 975 l 293 722 l 42 722 q 40 758 41 738 q 39 795 39 777 q 66 1014 39 924 q 162 1151 94 1104 q 356 1198 231 1198 q 587 1115 505 1198 q 669 877 669 1031 q 642 693 669 772 q 570 549 615 614 q 472 420 526 484 q 398 327 434 374 q 336 225 363 279 l 661 225 l 661 0 l 42 0 z "},"3":{"ha":686,"x_min":26,"x_max":652,"o":"m 328 -14 q 98 70 170 -14 q 26 321 26 153 l 26 446 l 271 446 l 271 321 q 283 240 271 273 q 336 208 295 208 q 390 243 378 208 q 401 359 401 279 l 401 389 q 381 497 401 451 q 300 543 360 543 q 287 543 292 543 q 277 542 281 543 l 277 756 q 371 784 338 756 q 404 876 404 811 q 345 977 404 977 q 294 947 307 977 q 281 872 281 918 l 281 836 l 34 836 q 33 856 33 844 q 33 878 33 867 q 109 1119 33 1042 q 344 1196 186 1196 q 649 878 649 1196 q 625 733 649 790 q 537 652 602 675 q 612 590 588 628 q 644 496 637 552 q 652 359 652 439 q 577 83 652 180 q 328 -14 502 -14 z "},"4":{"ha":686,"x_min":12,"x_max":673,"o":"m 366 -1 l 366 189 l 12 189 l 12 375 l 238 1194 l 610 1194 l 610 388 l 673 388 l 673 189 l 610 189 l 610 -1 l 366 -1 m 225 388 l 366 388 l 366 989 l 225 388 z "},"5":{"ha":686,"x_min":31,"x_max":663,"o":"m 343 -17 q 118 51 205 -17 q 31 260 31 119 l 31 438 l 279 438 l 279 336 q 283 274 279 304 q 300 225 287 244 q 343 206 314 206 q 394 232 382 206 q 406 299 406 258 l 406 534 q 402 591 406 563 q 386 639 399 620 q 345 658 373 658 q 277 559 277 658 l 58 559 l 58 1194 l 627 1194 l 627 970 l 284 970 l 284 802 q 332 841 302 824 q 403 857 362 857 q 535 826 484 857 q 614 739 587 795 q 652 610 642 684 q 663 453 663 537 q 651 259 663 345 q 607 111 640 172 q 511 16 574 49 q 343 -17 448 -17 z "},"6":{"ha":686,"x_min":37,"x_max":670,"o":"m 359 -11 q 164 32 235 -11 q 65 159 94 74 q 37 372 37 245 l 37 695 q 47 914 37 819 q 91 1074 58 1009 q 190 1171 124 1138 q 366 1204 256 1204 q 506 1178 441 1204 q 611 1100 571 1152 q 651 970 651 1048 l 651 842 l 421 842 l 421 866 q 418 926 421 896 q 403 975 415 956 q 361 995 391 995 q 306 973 321 995 q 290 909 290 951 l 290 670 q 341 721 307 702 q 424 741 375 741 q 576 701 523 741 q 650 583 629 661 q 670 386 670 504 q 641 177 670 267 q 544 39 612 88 q 359 -11 475 -11 m 350 209 q 400 244 392 209 q 408 336 408 280 l 408 432 q 353 530 408 530 q 290 445 290 530 l 290 297 q 350 209 290 209 z "},"7":{"ha":686,"x_min":47,"x_max":650,"o":"m 98 1 q 145 313 109 168 q 228 583 181 458 q 318 812 275 708 l 385 973 l 47 973 l 47 1194 l 650 1194 l 650 1064 q 626 919 650 992 q 564 758 602 846 q 430 377 479 566 q 368 1 380 187 l 98 1 z "},"8":{"ha":686,"x_min":31,"x_max":655,"o":"m 343 -13 q 103 83 175 -13 q 31 356 31 180 l 31 435 q 53 583 31 526 q 133 669 75 639 q 55 744 78 691 q 32 874 32 796 l 32 905 q 112 1136 32 1064 q 343 1208 191 1208 q 576 1134 499 1208 q 654 896 654 1060 q 633 751 654 810 q 553 667 613 693 q 636 580 617 634 q 655 435 655 526 l 655 356 q 583 83 655 180 q 343 -13 511 -13 m 343 769 q 406 883 406 769 q 393 955 406 921 q 343 989 380 989 q 293 955 307 989 q 280 883 280 921 q 343 769 280 769 m 343 223 q 408 328 408 223 l 408 437 q 394 522 408 492 q 343 553 379 553 q 292 522 306 553 q 279 437 279 492 l 279 328 q 343 223 279 223 z "},"9":{"ha":686,"x_min":37,"x_max":670,"o":"m 341 -11 q 201 15 266 -11 q 96 94 136 41 q 56 223 56 146 l 56 352 l 286 352 l 286 328 q 289 268 286 298 q 304 218 292 238 q 345 199 317 199 q 401 221 385 199 q 416 284 416 243 l 416 524 q 366 473 399 492 q 283 453 332 453 q 131 493 184 453 q 57 611 77 532 q 37 808 37 690 q 66 1016 37 927 q 163 1155 95 1105 q 348 1204 231 1204 q 543 1162 473 1204 q 641 1035 612 1120 q 670 821 670 949 l 670 498 q 660 279 670 374 q 616 120 649 184 q 517 22 583 56 q 341 -11 451 -11 m 353 664 q 416 749 416 664 l 416 897 q 357 985 416 985 q 307 949 315 985 q 298 858 298 913 l 298 762 q 353 664 298 664 z "},"\\r":{"ha":326,"x_min":0,"x_max":0,"o":""},"\\u0000":{"ha":0,"x_min":0,"x_max":0,"o":""}," ":{"ha":326,"x_min":0,"x_max":0,"o":""},"A":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 z "},"Æ":{"ha":889,"x_min":-30,"x_max":863,"o":"m -30 0 l 188 1194 l 847 1194 l 847 984 l 653 984 l 653 711 l 838 711 l 838 509 l 653 509 l 653 211 l 863 211 l 863 0 l 422 0 l 422 325 l 282 325 l 229 0 l -30 0 m 313 522 l 419 522 l 419 991 l 380 991 l 313 522 z "},"Ǽ":{"ha":889,"x_min":-30,"x_max":863,"o":"m -30 0 l 188 1194 l 847 1194 l 847 984 l 653 984 l 653 711 l 838 711 l 838 509 l 653 509 l 653 211 l 863 211 l 863 0 l 422 0 l 422 325 l 282 325 l 229 0 l -30 0 m 313 522 l 419 522 l 419 991 l 380 991 l 313 522 m 378 1230 l 378 1381 l 701 1529 l 701 1293 l 378 1230 z "},"Ǣ":{"ha":889,"x_min":-30,"x_max":863,"o":"m -30 0 l 188 1194 l 847 1194 l 847 984 l 653 984 l 653 711 l 838 711 l 838 509 l 653 509 l 653 211 l 863 211 l 863 0 l 422 0 l 422 325 l 282 325 l 229 0 l -30 0 m 313 522 l 419 522 l 419 991 l 380 991 l 313 522 m 319 1274 l 319 1378 l 760 1378 l 760 1274 l 319 1274 z "},"Á":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 175 1230 l 175 1381 l 497 1529 l 497 1293 l 175 1230 z "},"Ă":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 338 1256 q 146 1306 220 1256 q 73 1467 73 1356 q 75 1495 73 1481 l 248 1495 q 268 1437 248 1457 q 340 1417 288 1417 q 412 1437 392 1417 q 431 1495 431 1457 l 605 1495 q 606 1482 606 1489 q 606 1472 606 1475 q 533 1307 606 1358 q 338 1256 460 1256 z "},"Ắ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 224 1466 l 224 1537 l 478 1664 l 478 1509 l 224 1466 m 333 1241 q 216 1265 267 1241 q 139 1326 166 1289 q 111 1403 111 1363 q 113 1432 111 1417 l 242 1432 q 262 1368 242 1390 q 333 1346 281 1346 q 405 1368 385 1346 q 424 1432 424 1390 l 560 1432 q 562 1408 562 1415 q 534 1328 562 1366 q 455 1265 507 1289 q 333 1241 404 1241 z "},"Ặ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 336 1256 q 143 1301 217 1256 q 70 1447 70 1347 q 72 1475 70 1461 l 245 1475 q 265 1411 245 1433 q 337 1390 285 1390 q 409 1411 389 1390 q 429 1475 429 1433 l 602 1475 q 604 1451 604 1459 q 531 1302 604 1349 q 336 1256 458 1256 m 216 -269 l 216 -67 l 458 -67 l 458 -269 l 216 -269 z "},"Ằ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 478 1466 l 224 1509 l 224 1664 l 478 1537 l 478 1466 m 333 1241 q 216 1265 267 1241 q 139 1326 166 1289 q 111 1403 111 1363 q 113 1432 111 1417 l 242 1432 q 262 1368 242 1390 q 333 1346 281 1346 q 405 1368 385 1346 q 424 1432 424 1390 l 560 1432 q 562 1408 562 1417 q 534 1328 562 1366 q 455 1265 507 1289 q 333 1241 404 1241 z "},"Ẳ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 340 1444 l 296 1496 q 333 1517 319 1505 q 347 1551 347 1530 q 304 1591 347 1591 q 266 1584 285 1591 l 266 1660 q 343 1674 304 1674 q 425 1648 395 1674 q 455 1574 455 1622 q 422 1490 455 1520 q 340 1444 389 1459 m 333 1241 q 216 1265 267 1241 q 139 1326 166 1289 q 111 1403 111 1363 q 113 1432 111 1417 l 242 1432 q 262 1368 242 1390 q 333 1346 281 1346 q 405 1368 385 1346 q 424 1432 424 1390 l 560 1432 q 561 1418 561 1425 q 562 1408 562 1411 q 534 1328 562 1366 q 455 1265 507 1289 q 333 1241 404 1241 z "},"Ẵ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 430 1474 q 373 1486 399 1474 q 320 1509 346 1497 q 268 1520 294 1520 q 237 1513 252 1520 q 211 1486 223 1506 l 136 1525 q 178 1601 153 1569 q 253 1632 202 1632 q 311 1621 285 1632 q 363 1598 338 1609 q 415 1586 388 1586 q 472 1624 449 1586 l 557 1597 q 513 1512 538 1550 q 430 1474 488 1474 m 333 1241 q 216 1265 267 1241 q 139 1326 166 1289 q 111 1403 111 1363 q 113 1432 111 1417 l 242 1432 q 262 1368 242 1390 q 333 1346 281 1346 q 405 1368 385 1346 q 424 1432 424 1390 l 560 1432 q 561 1418 561 1425 q 562 1408 562 1411 q 534 1328 562 1366 q 455 1265 507 1289 q 333 1241 404 1241 z "},"Ǎ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 198 1255 l 35 1529 l 278 1529 l 336 1335 l 395 1529 l 638 1529 l 475 1255 l 198 1255 z "},"Â":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 35 1255 l 198 1529 l 475 1529 l 638 1255 l 395 1255 l 336 1449 l 278 1255 l 35 1255 z "},"Ấ":{"ha":674,"x_min":20,"x_max":818,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 532 1356 l 610 1495 l 818 1495 l 690 1356 l 532 1356 m 76 1247 l 237 1419 l 436 1419 l 597 1247 l 404 1247 l 336 1339 l 269 1247 l 76 1247 z "},"Ậ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 216 -269 l 216 -67 l 458 -67 l 458 -269 l 216 -269 m 35 1262 l 198 1488 l 475 1488 l 638 1262 l 395 1262 l 336 1408 l 278 1262 l 35 1262 z "},"Ầ":{"ha":674,"x_min":20,"x_max":736,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 578 1356 l 450 1495 l 659 1495 l 736 1356 l 578 1356 m 76 1247 l 237 1419 l 436 1419 l 597 1247 l 404 1247 l 336 1339 l 269 1247 l 76 1247 z "},"Ẩ":{"ha":674,"x_min":20,"x_max":702,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 587 1329 l 543 1381 q 579 1402 566 1390 q 593 1436 593 1415 q 551 1476 593 1476 q 513 1469 532 1476 l 513 1545 q 590 1559 551 1559 q 672 1533 642 1559 q 702 1459 702 1506 q 669 1375 702 1405 q 587 1329 636 1344 m 76 1247 l 237 1419 l 436 1419 l 597 1247 l 404 1247 l 336 1339 l 269 1247 l 76 1247 z "},"Ẫ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 418 1453 q 360 1464 387 1453 q 308 1487 334 1476 q 256 1499 283 1499 q 225 1491 239 1499 q 199 1464 211 1484 l 123 1503 q 165 1579 141 1548 q 241 1611 190 1611 q 299 1599 273 1611 q 351 1576 326 1588 q 403 1565 376 1565 q 460 1603 437 1565 l 545 1575 q 500 1490 526 1528 q 418 1453 475 1453 m 76 1247 l 237 1419 l 436 1419 l 597 1247 l 404 1247 l 336 1339 l 269 1247 l 76 1247 z "},"Ȁ":{"ha":674,"x_min":7,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 203 1252 l 7 1543 l 165 1616 l 315 1291 l 203 1252 m 408 1252 l 239 1543 l 395 1616 l 520 1291 l 408 1252 z "},"Ä":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 374 1261 l 374 1463 l 617 1463 l 617 1261 l 374 1261 m 46 1261 l 46 1463 l 289 1463 l 289 1261 l 46 1261 z "},"Ǟ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 379 1261 l 379 1429 l 622 1429 l 622 1261 l 379 1261 m 51 1261 l 51 1429 l 294 1429 l 294 1261 l 51 1261 m 116 1503 l 116 1607 l 557 1607 l 557 1503 l 116 1503 z "},"Ȧ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 215 1256 l 215 1458 l 458 1458 l 458 1256 l 215 1256 z "},"Ạ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 216 -269 l 216 -67 l 458 -67 l 458 -269 l 216 -269 z "},"Ǡ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 215 1256 l 215 1431 l 458 1431 l 458 1256 l 215 1256 m 116 1491 l 116 1594 l 557 1594 l 557 1491 l 116 1491 z "},"À":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 497 1230 l 175 1293 l 175 1529 l 497 1381 l 497 1230 z "},"Ả":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 317 1246 l 245 1330 q 304 1364 281 1343 q 326 1418 326 1384 q 258 1482 326 1482 q 197 1472 226 1482 l 197 1594 q 321 1616 256 1616 q 453 1574 406 1616 q 501 1455 501 1531 q 448 1319 501 1369 q 317 1246 395 1270 z "},"Ȃ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 85 1267 q 83 1295 83 1280 q 150 1455 83 1405 q 335 1506 216 1506 q 523 1454 457 1506 q 589 1290 589 1403 q 589 1280 589 1286 q 588 1267 589 1274 l 428 1267 q 402 1335 428 1313 q 336 1358 376 1358 q 271 1335 297 1358 q 245 1267 245 1313 l 85 1267 z "},"Ɑ":{"ha":725,"x_min":43,"x_max":718,"o":"m 246 -11 q 115 31 159 -11 q 58 146 72 73 q 43 317 43 220 l 43 878 q 58 1047 43 974 q 115 1163 72 1121 q 246 1204 159 1204 q 339 1175 304 1204 q 394 1088 374 1146 l 394 1194 l 631 1194 l 631 298 q 652 229 631 250 q 718 208 673 208 l 718 -7 q 536 20 602 -7 q 435 128 470 47 q 362 20 413 51 q 246 -11 311 -11 m 338 189 q 382 218 370 189 q 394 292 394 248 l 394 902 q 382 976 394 946 q 338 1005 370 1005 q 292 978 304 1005 q 281 902 281 950 l 281 292 q 292 216 281 244 q 338 189 304 189 z "},"Ā":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 117 1274 l 117 1378 l 557 1378 l 557 1274 l 117 1274 z "},"Ą":{"ha":674,"x_min":20,"x_max":660,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 526 -428 q 408 -404 461 -428 q 322 -333 354 -379 q 290 -224 290 -288 q 469 0 290 -100 l 612 0 q 538 -86 574 -39 q 503 -189 503 -133 q 581 -265 503 -265 q 660 -250 614 -265 l 660 -401 q 526 -428 595 -428 z "},"Å":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 336 1248 q 162 1309 227 1248 q 96 1477 96 1369 q 162 1645 96 1584 q 336 1706 227 1706 q 510 1645 445 1706 q 576 1477 576 1584 q 510 1309 576 1370 q 336 1248 445 1248 m 336 1371 q 407 1402 382 1371 q 433 1477 433 1433 q 407 1552 433 1521 q 336 1584 382 1584 q 266 1552 291 1584 q 240 1477 240 1521 q 266 1402 240 1433 q 336 1371 291 1371 z "},"Ǻ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 336 1248 q 162 1305 228 1248 q 97 1463 97 1362 q 162 1622 97 1565 q 336 1679 228 1679 q 511 1622 446 1679 q 576 1463 576 1565 q 511 1305 576 1363 q 336 1248 446 1248 m 337 1371 q 408 1398 382 1371 q 433 1463 433 1425 q 408 1529 433 1502 q 337 1556 382 1556 q 266 1529 292 1556 q 241 1463 241 1502 q 266 1398 241 1425 q 337 1371 292 1371 m 176 1704 l 176 1835 l 498 1949 l 498 1754 l 176 1704 z "},"Ḁ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 336 -416 q 162 -359 228 -416 q 97 -200 97 -302 q 162 -42 97 -99 q 336 16 228 16 q 511 -42 446 16 q 576 -200 576 -99 q 511 -358 576 -300 q 336 -416 446 -416 m 337 -293 q 408 -266 382 -293 q 433 -200 433 -239 q 408 -134 433 -161 q 337 -107 382 -107 q 266 -134 292 -107 q 241 -200 241 -161 q 266 -266 241 -239 q 337 -293 292 -293 z "},"Ⱥ":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 412 1194 l 454 1356 l 549 1356 l 507 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 196 0 l 163 -126 l 68 -126 l 101 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 z "},"Ã":{"ha":674,"x_min":20,"x_max":654,"o":"m 20 0 l 136 1194 l 541 1194 l 654 0 l 428 0 l 411 193 l 267 193 l 252 0 l 20 0 m 284 383 l 393 383 l 340 990 l 330 990 l 284 383 m 448 1269 q 356 1284 398 1269 q 281 1315 315 1300 q 219 1331 247 1331 q 186 1320 201 1331 q 157 1284 170 1310 l 56 1337 q 93 1413 73 1379 q 144 1468 113 1447 q 224 1489 176 1489 q 311 1474 272 1489 q 382 1446 350 1460 q 441 1432 414 1432 q 475 1443 459 1432 q 504 1482 490 1455 l 616 1446 q 581 1360 600 1400 q 530 1294 561 1319 q 448 1269 499 1269 z "},"B":{"ha":665,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 376 1194 q 566 1130 507 1194 q 625 921 625 1067 l 625 869 q 595 732 625 785 q 503 664 565 680 q 611 569 584 644 q 639 386 639 494 q 617 183 639 270 q 538 48 595 96 q 376 0 481 0 l 53 0 m 286 744 l 335 744 q 378 770 368 744 q 387 831 387 795 l 387 951 q 336 1009 387 1009 l 286 1009 l 286 744 m 310 210 q 403 298 403 210 l 403 448 q 388 528 403 498 q 330 557 372 557 l 286 557 l 286 212 q 310 210 301 210 z "},"Ḃ":{"ha":665,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 376 1194 q 566 1130 507 1194 q 625 921 625 1067 l 625 869 q 595 732 625 785 q 503 664 565 680 q 611 569 584 644 q 639 386 639 494 q 617 183 639 270 q 538 48 595 96 q 376 0 481 0 l 53 0 m 286 744 l 335 744 q 378 770 368 744 q 387 831 387 795 l 387 951 q 336 1009 387 1009 l 286 1009 l 286 744 m 310 210 q 403 298 403 210 l 403 448 q 388 528 403 498 q 330 557 372 557 l 286 557 l 286 212 q 310 210 301 210 m 184 1256 l 184 1458 l 427 1458 l 427 1256 l 184 1256 z "},"Ḅ":{"ha":665,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 376 1194 q 566 1130 507 1194 q 625 921 625 1067 l 625 869 q 595 732 625 785 q 503 664 565 680 q 611 569 584 644 q 639 386 639 494 q 617 183 639 270 q 538 48 595 96 q 376 0 481 0 l 53 0 m 286 744 l 335 744 q 378 770 368 744 q 387 831 387 795 l 387 951 q 336 1009 387 1009 l 286 1009 l 286 744 m 310 210 q 403 298 403 210 l 403 448 q 388 528 403 498 q 330 557 372 557 l 286 557 l 286 212 q 310 210 301 210 m 184 -283 l 184 -81 l 427 -81 l 427 -283 l 184 -283 z "},"Ꞵ":{"ha":665,"x_min":53,"x_max":639,"o":"m 53 -126 l 53 1194 l 376 1194 q 566 1130 507 1194 q 625 921 625 1067 l 625 869 q 595 732 625 785 q 503 664 565 680 q 611 569 584 644 q 639 386 639 494 q 617 183 639 270 q 538 48 595 96 q 376 0 481 0 l 286 0 l 286 -126 l 53 -126 m 286 744 l 335 744 q 378 770 368 744 q 387 831 387 795 l 387 951 q 336 1009 387 1009 l 286 1009 l 286 744 m 310 210 q 403 298 403 210 l 403 448 q 388 528 403 498 q 330 557 372 557 l 286 557 l 286 212 q 310 210 301 210 z "},"Ɓ":{"ha":901,"x_min":3,"x_max":875,"o":"m 289 0 l 289 1009 q 212 906 212 1009 l 212 849 l 3 849 l 3 890 q 35 1047 3 979 q 130 1155 66 1116 q 289 1194 193 1194 l 612 1194 q 802 1130 743 1194 q 861 921 861 1067 l 861 869 q 831 732 861 785 q 739 664 801 680 q 847 569 820 644 q 875 386 875 494 q 853 183 875 270 q 774 48 831 96 q 612 0 718 0 l 289 0 m 522 744 l 571 744 q 614 770 604 744 q 623 831 623 795 l 623 951 q 572 1009 623 1009 l 522 1009 l 522 744 m 546 210 q 639 298 639 210 l 639 448 q 624 528 639 498 q 566 557 608 557 l 522 557 l 522 212 q 546 210 537 210 z "},"Ḇ":{"ha":665,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 376 1194 q 566 1130 507 1194 q 625 921 625 1067 l 625 869 q 595 732 625 785 q 503 664 565 680 q 611 569 584 644 q 639 386 639 494 q 617 183 639 270 q 538 48 595 96 q 376 0 481 0 l 53 0 m 286 744 l 335 744 q 378 770 368 744 q 387 831 387 795 l 387 951 q 336 1009 387 1009 l 286 1009 l 286 744 m 310 210 q 403 298 403 210 l 403 448 q 388 528 403 498 q 330 557 372 557 l 286 557 l 286 212 q 310 210 301 210 m 85 -184 l 85 -81 l 526 -81 l 526 -184 l 85 -184 z "},"Ƀ":{"ha":665,"x_min":0,"x_max":639,"o":"m 53 0 l 53 307 l 0 307 l 0 465 l 53 465 l 53 1194 l 376 1194 q 566 1130 507 1194 q 625 921 625 1067 l 625 869 q 595 732 625 785 q 503 664 565 680 q 611 569 584 644 q 639 386 639 494 q 617 183 639 270 q 538 48 595 96 q 376 0 481 0 l 53 0 m 286 744 l 335 744 q 378 770 368 744 q 387 831 387 795 l 387 951 q 336 1009 387 1009 l 286 1009 l 286 744 m 310 210 q 403 298 403 210 l 403 448 q 388 528 403 498 q 330 557 372 557 l 286 557 l 286 465 l 350 465 l 350 307 l 286 307 l 286 212 q 310 210 301 210 z "},"C":{"ha":659,"x_min":43,"x_max":632,"o":"m 331 -11 q 122 70 201 -11 q 43 296 43 151 l 43 846 q 112 1112 43 1020 q 336 1204 181 1204 q 487 1173 421 1204 q 591 1080 553 1142 q 629 924 629 1018 l 629 718 l 392 718 l 392 894 q 378 966 392 947 q 336 985 365 985 q 292 961 303 985 q 280 897 280 937 l 280 299 q 295 229 280 250 q 336 209 309 209 q 379 234 367 209 q 392 299 392 259 l 392 514 l 632 514 l 632 288 q 553 60 632 131 q 331 -11 473 -11 z "},"Ć":{"ha":659,"x_min":43,"x_max":632,"o":"m 331 -11 q 122 70 201 -11 q 43 296 43 151 l 43 846 q 112 1112 43 1020 q 336 1204 181 1204 q 487 1173 421 1204 q 591 1080 553 1142 q 629 924 629 1018 l 629 718 l 392 718 l 392 894 q 378 966 392 947 q 336 985 365 985 q 292 961 303 985 q 280 897 280 937 l 280 299 q 295 229 280 250 q 336 209 309 209 q 379 234 367 209 q 392 299 392 259 l 392 514 l 632 514 l 632 288 q 553 60 632 131 q 331 -11 473 -11 m 175 1230 l 175 1381 l 497 1529 l 497 1293 l 175 1230 z "},"Č":{"ha":659,"x_min":35,"x_max":638,"o":"m 331 -11 q 122 70 201 -11 q 43 296 43 151 l 43 846 q 112 1112 43 1020 q 336 1204 181 1204 q 487 1173 421 1204 q 591 1080 553 1142 q 629 924 629 1018 l 629 718 l 392 718 l 392 894 q 378 966 392 947 q 336 985 365 985 q 292 961 303 985 q 280 897 280 937 l 280 299 q 295 229 280 250 q 336 209 309 209 q 379 234 367 209 q 392 299 392 259 l 392 514 l 632 514 l 632 288 q 553 60 632 131 q 331 -11 473 -11 m 198 1255 l 35 1529 l 278 1529 l 336 1335 l 395 1529 l 638 1529 l 475 1255 l 198 1255 z "},"Ç":{"ha":659,"x_min":43,"x_max":632,"o":"m 331 -11 q 122 70 201 -11 q 43 296 43 151 l 43 846 q 112 1112 43 1020 q 336 1204 181 1204 q 487 1173 421 1204 q 591 1080 553 1142 q 629 924 629 1018 l 629 718 l 392 718 l 392 894 q 378 966 392 947 q 336 985 365 985 q 292 961 303 985 q 280 897 280 937 l 280 299 q 295 229 280 250 q 336 209 309 209 q 379 234 367 209 q 392 299 392 259 l 392 514 l 632 514 l 632 288 q 553 60 632 131 q 331 -11 473 -11 m 314 -428 q 180 -401 244 -428 l 180 -250 q 221 -261 201 -256 q 260 -265 241 -265 q 316 -247 294 -265 q 339 -185 339 -229 q 320 -98 339 -147 q 269 0 302 -50 l 378 0 q 480 -129 444 -58 q 516 -262 516 -199 q 468 -380 516 -332 q 314 -428 420 -428 z "},"Ḉ":{"ha":659,"x_min":43,"x_max":632,"o":"m 331 -11 q 122 70 201 -11 q 43 296 43 151 l 43 846 q 112 1112 43 1020 q 336 1204 181 1204 q 487 1173 421 1204 q 591 1080 553 1142 q 629 924 629 1018 l 629 718 l 392 718 l 392 894 q 378 966 392 947 q 336 985 365 985 q 292 961 303 985 q 280 897 280 937 l 280 299 q 295 229 280 250 q 336 209 309 209 q 379 234 367 209 q 392 299 392 259 l 392 514 l 632 514 l 632 288 q 553 60 632 131 q 331 -11 473 -11 m 314 -428 q 180 -401 244 -428 l 180 -250 q 221 -261 201 -256 q 260 -265 241 -265 q 316 -247 294 -265 q 339 -185 339 -229 q 320 -98 339 -147 q 269 0 302 -50 l 378 0 q 480 -129 444 -58 q 516 -262 516 -199 q 468 -380 516 -332 q 314 -428 420 -428 m 176 1230 l 176 1381 l 498 1529 l 498 1293 l 176 1230 z "},"Ĉ":{"ha":659,"x_min":35,"x_max":638,"o":"m 331 -11 q 122 70 201 -11 q 43 296 43 151 l 43 846 q 112 1112 43 1020 q 336 1204 181 1204 q 487 1173 421 1204 q 591 1080 553 1142 q 629 924 629 1018 l 629 718 l 392 718 l 392 894 q 378 966 392 947 q 336 985 365 985 q 292 961 303 985 q 280 897 280 937 l 280 299 q 295 229 280 250 q 336 209 309 209 q 379 234 367 209 q 392 299 392 259 l 392 514 l 632 514 l 632 288 q 553 60 632 131 q 331 -11 473 -11 m 35 1255 l 198 1529 l 475 1529 l 638 1255 l 395 1255 l 336 1449 l 278 1255 l 35 1255 z "},"Ċ":{"ha":659,"x_min":43,"x_max":632,"o":"m 331 -11 q 122 70 201 -11 q 43 296 43 151 l 43 846 q 112 1112 43 1020 q 336 1204 181 1204 q 487 1173 421 1204 q 591 1080 553 1142 q 629 924 629 1018 l 629 718 l 392 718 l 392 894 q 378 966 392 947 q 336 985 365 985 q 292 961 303 985 q 280 897 280 937 l 280 299 q 295 229 280 250 q 336 209 309 209 q 379 234 367 209 q 392 299 392 259 l 392 514 l 632 514 l 632 288 q 553 60 632 131 q 331 -11 473 -11 m 215 1256 l 215 1458 l 458 1458 l 458 1256 l 215 1256 z "},"Ꭓ":{"ha":687,"x_min":18,"x_max":669,"o":"m 669 -137 q 461 -82 527 -137 q 379 91 396 -28 l 337 388 l 262 -126 l 25 -126 l 150 572 l 97 910 q 77 986 89 962 q 18 1009 64 1009 l 18 1203 q 227 1149 161 1203 q 309 975 293 1095 l 340 740 l 393 1194 l 622 1194 l 522 572 l 596 157 q 620 81 606 104 q 669 57 634 57 l 669 -137 z "},"Ƈ":{"ha":715,"x_min":43,"x_max":722,"o":"m 331 -11 q 122 70 201 -11 q 43 296 43 151 l 43 846 q 112 1112 43 1020 q 330 1204 180 1204 q 459 1168 404 1204 q 555 1305 487 1254 q 722 1356 623 1356 l 722 1142 q 652 1120 675 1142 q 629 1039 629 1098 l 629 718 l 392 718 l 392 894 q 378 966 392 947 q 336 985 365 985 q 292 961 303 985 q 280 897 280 937 l 280 299 q 295 229 280 250 q 336 209 309 209 q 379 234 367 209 q 392 299 392 259 l 392 514 l 632 514 l 632 288 q 553 60 632 131 q 331 -11 473 -11 z "},"Ȼ":{"ha":659,"x_min":43,"x_max":632,"o":"m 109 -126 l 153 43 q 72 145 101 81 q 43 296 43 210 l 43 846 q 112 1112 43 1020 q 336 1204 181 1204 q 451 1188 399 1204 l 494 1356 l 589 1356 l 535 1144 q 604 1054 579 1109 q 629 924 629 999 l 629 718 l 392 718 l 392 894 q 378 966 392 947 q 336 985 365 985 q 292 961 303 985 q 280 897 280 937 l 280 299 q 295 229 280 250 q 336 209 309 209 q 379 234 367 209 q 392 299 392 259 l 392 514 l 632 514 l 632 288 q 553 60 632 131 q 331 -11 473 -11 q 237 1 281 -11 l 204 -126 l 109 -126 z "},"D":{"ha":685,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 z "},"Ǳ":{"ha":1255,"x_min":53,"x_max":1232,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 707 0 l 707 217 l 980 974 l 733 974 l 733 1194 l 1232 1194 l 1232 985 l 954 220 l 1220 220 l 1220 0 l 707 0 z "},"Ǆ":{"ha":1255,"x_min":53,"x_max":1284,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 707 0 l 707 217 l 980 974 l 733 974 l 733 1194 l 1232 1194 l 1232 985 l 954 220 l 1220 220 l 1220 0 l 707 0 m 844 1255 l 681 1529 l 924 1529 l 983 1335 l 1041 1529 l 1284 1529 l 1121 1255 l 844 1255 z "},"Ɖ":{"ha":685,"x_min":2,"x_max":640,"o":"m 53 0 l 53 545 l 2 545 l 2 703 l 53 703 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 703 l 352 703 l 352 545 l 293 545 l 293 211 z "},"Ď":{"ha":685,"x_min":40,"x_max":644,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 203 1255 l 40 1529 l 283 1529 l 342 1335 l 400 1529 l 644 1529 l 480 1255 l 203 1255 z "},"Ḑ":{"ha":685,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 248 -436 l 293 -276 l 207 -276 l 207 -74 l 460 -74 l 460 -270 l 391 -436 l 248 -436 z "},"Ḓ":{"ha":685,"x_min":41,"x_max":644,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 41 -347 l 204 -74 l 481 -74 l 644 -347 l 401 -347 l 342 -154 l 284 -347 l 41 -347 z "},"Đ":{"ha":685,"x_min":2,"x_max":640,"o":"m 53 0 l 53 545 l 2 545 l 2 703 l 53 703 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 703 l 352 703 l 352 545 l 293 545 l 293 211 z "},"Ḋ":{"ha":685,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 220 1256 l 220 1458 l 463 1458 l 463 1256 l 220 1256 z "},"Ḍ":{"ha":685,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 221 -283 l 221 -81 l 464 -81 l 464 -283 l 221 -283 z "},"Δ":{"ha":748,"x_min":20,"x_max":728,"o":"m 20 0 l 203 1194 l 540 1194 l 728 0 l 20 0 m 243 153 l 453 153 l 360 1058 l 349 1058 l 243 153 z "},"Ɗ":{"ha":922,"x_min":3,"x_max":877,"o":"m 290 0 l 290 985 q 212 890 212 985 l 212 849 l 3 849 l 3 890 q 75 1108 3 1023 q 290 1194 146 1194 l 618 1194 q 812 1122 747 1194 q 877 913 877 1050 l 877 354 q 818 92 877 184 q 610 0 758 0 l 290 0 m 530 211 l 571 211 q 637 275 637 211 l 637 890 q 621 967 637 950 q 556 985 605 985 l 530 985 l 530 211 z "},"Ḏ":{"ha":685,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 122 -184 l 122 -81 l 563 -81 l 563 -184 l 122 -184 z "},"ǲ":{"ha":1221,"x_min":53,"x_max":1211,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 704 0 l 704 149 l 958 825 l 716 825 l 716 1017 l 1209 1017 l 1209 852 l 970 182 l 1211 182 l 1211 0 l 704 0 z "},"ǅ":{"ha":1221,"x_min":53,"x_max":1282,"o":"m 53 0 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 211 m 704 0 l 704 149 l 958 825 l 716 825 l 716 1017 l 1209 1017 l 1209 852 l 970 182 l 1211 182 l 1211 0 l 704 0 m 842 1079 l 679 1352 l 922 1352 l 981 1159 l 1039 1352 l 1282 1352 l 1119 1079 l 842 1079 z "},"E":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 z "},"É":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 140 1230 l 140 1381 l 462 1529 l 462 1293 l 140 1230 z "},"Ĕ":{"ha":572,"x_min":37,"x_max":571,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 303 1256 q 111 1306 184 1256 q 37 1467 37 1356 q 39 1495 37 1481 l 213 1495 q 233 1437 213 1457 q 304 1417 252 1417 q 376 1437 357 1417 q 396 1495 396 1457 l 570 1495 q 571 1482 570 1489 q 571 1472 571 1475 q 498 1307 571 1358 q 303 1256 425 1256 z "},"Ě":{"ha":572,"x_min":-1,"x_max":603,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 163 1255 l -1 1529 l 243 1529 l 301 1335 l 359 1529 l 603 1529 l 439 1255 l 163 1255 z "},"Ȩ":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 275 -428 q 140 -401 205 -428 l 140 -250 q 182 -261 161 -256 q 220 -265 202 -265 q 277 -247 254 -265 q 300 -185 300 -229 q 281 -98 300 -147 q 229 0 262 -50 l 338 0 q 440 -129 404 -58 q 477 -262 477 -199 q 429 -380 477 -332 q 275 -428 380 -428 z "},"Ḝ":{"ha":572,"x_min":28,"x_max":562,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 275 -428 q 140 -401 205 -428 l 140 -250 q 182 -261 161 -256 q 220 -265 202 -265 q 277 -247 254 -265 q 300 -185 300 -229 q 281 -98 300 -147 q 229 0 262 -50 l 338 0 q 440 -129 404 -58 q 477 -262 477 -199 q 429 -380 477 -332 q 275 -428 380 -428 m 294 1256 q 102 1306 176 1256 q 28 1467 28 1356 q 31 1495 28 1481 l 204 1495 q 224 1437 204 1457 q 296 1417 243 1417 q 368 1437 348 1417 q 387 1495 387 1457 l 561 1495 q 562 1482 562 1489 q 562 1472 562 1475 q 489 1307 562 1358 q 294 1256 416 1256 z "},"Ê":{"ha":572,"x_min":-1,"x_max":603,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m -1 1255 l 163 1529 l 439 1529 l 603 1255 l 359 1255 l 301 1449 l 243 1255 l -1 1255 z "},"Ế":{"ha":572,"x_min":35,"x_max":777,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 491 1356 l 568 1495 l 777 1495 l 649 1356 l 491 1356 m 35 1247 l 195 1419 l 395 1419 l 555 1247 l 362 1247 l 295 1339 l 228 1247 l 35 1247 z "},"Ḙ":{"ha":572,"x_min":-2,"x_max":602,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m -2 -347 l 161 -74 l 438 -74 l 602 -347 l 358 -347 l 300 -154 l 241 -347 l -2 -347 z "},"Ệ":{"ha":572,"x_min":-7,"x_max":597,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 178 -283 l 178 -81 l 421 -81 l 421 -283 l 178 -283 m -7 1262 l 157 1488 l 433 1488 l 597 1262 l 353 1262 l 295 1408 l 237 1262 l -7 1262 z "},"Ề":{"ha":572,"x_min":35,"x_max":694,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 536 1356 l 409 1495 l 617 1495 l 694 1356 l 536 1356 m 35 1247 l 195 1419 l 395 1419 l 555 1247 l 362 1247 l 295 1339 l 228 1247 l 35 1247 z "},"Ể":{"ha":572,"x_min":35,"x_max":661,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 546 1329 l 501 1381 q 538 1402 524 1390 q 552 1436 552 1415 q 509 1476 552 1476 q 471 1469 490 1476 l 471 1545 q 549 1559 510 1559 q 631 1533 601 1559 q 661 1459 661 1506 q 628 1375 661 1405 q 546 1329 595 1344 m 35 1247 l 195 1419 l 395 1419 l 555 1247 l 362 1247 l 295 1339 l 228 1247 l 35 1247 z "},"Ễ":{"ha":572,"x_min":35,"x_max":555,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 376 1453 q 319 1464 346 1453 q 267 1487 292 1476 q 214 1499 241 1499 q 184 1491 198 1499 q 157 1464 170 1484 l 82 1503 q 124 1579 100 1548 q 199 1611 149 1611 q 258 1599 231 1611 q 309 1576 284 1588 q 361 1565 334 1565 q 418 1603 395 1565 l 503 1575 q 459 1490 484 1528 q 376 1453 434 1453 m 35 1247 l 195 1419 l 395 1419 l 555 1247 l 362 1247 l 295 1339 l 228 1247 l 35 1247 z "},"Ȅ":{"ha":572,"x_min":-28,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 168 1252 l -28 1543 l 130 1616 l 280 1291 l 168 1252 m 372 1252 l 204 1543 l 360 1616 l 485 1291 l 372 1252 z "},"Ë":{"ha":572,"x_min":11,"x_max":582,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 339 1261 l 339 1463 l 582 1463 l 582 1261 l 339 1261 m 11 1261 l 11 1463 l 254 1463 l 254 1261 l 11 1261 z "},"Ė":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 180 1256 l 180 1458 l 422 1458 l 422 1256 l 180 1256 z "},"Ẹ":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 178 -283 l 178 -81 l 421 -81 l 421 -283 l 178 -283 z "},"È":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 462 1230 l 140 1293 l 140 1529 l 462 1381 l 462 1230 z "},"Ẻ":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 275 1246 l 203 1330 q 262 1364 240 1343 q 285 1418 285 1384 q 216 1482 285 1482 q 155 1472 184 1482 l 155 1594 q 279 1616 215 1616 q 412 1574 364 1616 q 460 1455 460 1531 q 407 1319 460 1369 q 275 1246 354 1270 z "},"Ȇ":{"ha":572,"x_min":47,"x_max":554,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 50 1267 q 47 1295 47 1280 q 114 1455 47 1405 q 300 1506 181 1506 q 488 1454 422 1506 q 554 1290 554 1403 q 554 1280 554 1286 q 553 1267 553 1274 l 393 1267 q 367 1335 393 1313 q 301 1358 341 1358 q 236 1335 262 1358 q 210 1267 210 1313 l 50 1267 z "},"Ē":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 65 1274 l 65 1378 l 506 1378 l 506 1274 l 65 1274 z "},"Ḗ":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 75 1234 l 75 1337 l 515 1337 l 515 1234 l 75 1234 m 138 1370 l 138 1501 l 460 1615 l 460 1420 l 138 1370 z "},"Ḕ":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 75 1234 l 75 1337 l 515 1337 l 515 1234 l 75 1234 m 460 1369 l 138 1419 l 138 1614 l 460 1500 l 460 1369 z "},"Ŋ":{"ha":682,"x_min":53,"x_max":639,"o":"m 303 -331 l 303 -126 q 391 -21 391 -126 l 391 71 l 286 597 l 286 0 l 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 -5 q 551 -249 639 -167 q 303 -331 463 -331 z "},"Ę":{"ha":572,"x_min":53,"x_max":546,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 313 -428 q 195 -404 249 -428 q 110 -333 142 -379 q 77 -224 77 -288 q 256 0 77 -100 l 399 0 q 326 -86 361 -39 q 291 -189 291 -133 q 369 -265 291 -265 q 448 -250 402 -265 l 448 -401 q 313 -428 383 -428 z "},"Ɛ":{"ha":686,"x_min":26,"x_max":652,"o":"m 350 -14 q 101 83 176 -14 q 26 359 26 180 q 34 488 26 434 q 66 579 41 541 q 141 641 90 616 q 53 723 77 664 q 29 878 29 782 q 334 1196 29 1196 q 568 1119 492 1196 q 644 878 644 1042 l 644 836 l 397 836 l 397 872 q 389 946 397 915 q 341 977 381 977 q 275 876 275 977 q 311 778 275 808 q 406 748 348 748 l 449 748 l 449 534 l 378 534 q 298 488 319 534 q 277 381 277 443 l 277 359 q 280 287 277 321 q 297 230 283 252 q 343 208 311 208 q 397 240 387 208 q 407 321 407 273 l 407 446 l 652 446 l 652 321 q 580 70 652 153 q 350 -14 508 -14 z "},"Ǝ":{"ha":572,"x_min":26,"x_max":519,"o":"m 519 0 l 26 0 l 26 233 l 276 233 l 276 506 l 51 506 l 51 730 l 276 730 l 276 963 l 41 963 l 41 1194 l 519 1194 l 519 0 z "},"Ʃ":{"ha":567,"x_min":42,"x_max":539,"o":"m 42 0 l 42 182 l 250 598 l 42 987 l 42 1194 l 528 1194 l 528 963 l 297 963 l 476 628 l 476 576 l 304 233 l 539 233 l 539 0 l 42 0 z "},"Ɇ":{"ha":572,"x_min":53,"x_max":549,"o":"m 53 0 l 53 1194 l 412 1194 l 454 1356 l 549 1356 l 507 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 196 0 l 163 -126 l 68 -126 l 101 0 l 53 0 z "},"Ð":{"ha":685,"x_min":2,"x_max":640,"o":"m 53 0 l 53 545 l 2 545 l 2 703 l 53 703 l 53 1194 l 381 1194 q 575 1122 510 1194 q 640 913 640 1050 l 640 354 q 581 92 640 184 q 373 0 522 0 l 53 0 m 293 211 l 334 211 q 400 275 400 211 l 400 890 q 384 967 400 950 q 319 985 368 985 l 293 985 l 293 703 l 352 703 l 352 545 l 293 545 l 293 211 z "},"Ẽ":{"ha":572,"x_min":21,"x_max":581,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 413 1269 q 321 1284 361 1269 q 248 1315 281 1300 q 184 1331 215 1331 q 151 1320 166 1331 q 121 1284 135 1310 l 21 1337 q 58 1413 38 1379 q 109 1468 78 1447 q 189 1489 140 1489 q 277 1474 239 1489 q 348 1446 316 1460 q 406 1432 379 1432 q 439 1443 424 1432 q 469 1482 455 1455 l 581 1446 q 545 1360 565 1400 q 495 1294 526 1319 q 413 1269 464 1269 z "},"Ḛ":{"ha":572,"x_min":20,"x_max":580,"o":"m 53 0 l 53 1194 l 530 1194 l 530 963 l 296 963 l 296 730 l 521 730 l 521 506 l 296 506 l 296 233 l 546 233 l 546 0 l 53 0 m 412 -295 q 320 -279 361 -295 q 244 -249 278 -264 q 182 -233 210 -233 q 149 -243 165 -233 q 120 -279 134 -254 l 20 -227 q 57 -151 37 -185 q 108 -96 77 -117 q 187 -75 139 -75 q 274 -90 235 -75 q 346 -118 313 -104 q 404 -132 378 -132 q 438 -121 422 -132 q 467 -81 454 -109 l 580 -118 q 544 -204 564 -163 q 493 -270 524 -245 q 412 -295 463 -295 z "},"Ʒ":{"ha":686,"x_min":29,"x_max":652,"o":"m 330 -9 q 101 73 173 -9 q 29 325 29 155 l 29 446 l 273 446 l 273 325 q 287 240 273 271 q 342 210 300 210 q 384 231 372 210 q 399 287 397 252 q 401 363 401 322 l 401 393 q 302 545 401 545 l 223 545 l 223 718 l 384 963 l 60 963 l 60 1194 l 650 1194 l 650 983 l 473 712 q 609 588 567 677 q 652 363 652 499 q 575 85 652 180 q 330 -9 498 -9 z "},"Ǯ":{"ha":686,"x_min":29,"x_max":659,"o":"m 330 -9 q 101 73 173 -9 q 29 325 29 155 l 29 446 l 273 446 l 273 325 q 287 240 273 271 q 342 210 300 210 q 384 231 372 210 q 399 287 397 252 q 401 363 401 322 l 401 393 q 302 545 401 545 l 223 545 l 223 718 l 384 963 l 60 963 l 60 1194 l 650 1194 l 650 983 l 473 712 q 609 588 567 677 q 652 363 652 499 q 575 85 652 180 q 330 -9 498 -9 m 55 1488 l 298 1488 l 357 1342 l 415 1488 l 659 1488 l 495 1262 l 218 1262 l 55 1488 z "},"Ƹ":{"ha":686,"x_min":35,"x_max":657,"o":"m 357 -9 q 111 85 188 -9 q 35 363 35 180 q 77 588 35 499 q 214 712 119 677 l 36 983 l 36 1194 l 627 1194 l 627 963 l 302 963 l 463 718 l 463 545 l 385 545 q 285 393 285 545 l 285 363 q 287 287 285 322 q 302 231 290 252 q 345 210 315 210 q 400 240 387 210 q 414 325 414 271 l 414 446 l 657 446 l 657 325 q 585 73 657 155 q 357 -9 513 -9 z "},"F":{"ha":554,"x_min":53,"x_max":530,"o":"m 53 0 l 53 1194 l 530 1194 l 530 961 l 293 961 l 293 771 l 518 771 l 518 541 l 293 541 l 293 0 l 53 0 z "},"Ḟ":{"ha":554,"x_min":53,"x_max":530,"o":"m 53 0 l 53 1194 l 530 1194 l 530 961 l 293 961 l 293 771 l 518 771 l 518 541 l 293 541 l 293 0 l 53 0 m 185 1256 l 185 1458 l 428 1458 l 428 1256 l 185 1256 z "},"Ƒ":{"ha":554,"x_min":-15,"x_max":530,"o":"m -15 -133 l -15 81 q 37 102 21 81 q 53 171 53 123 l 53 1194 l 530 1194 l 530 961 l 293 961 l 293 771 l 518 771 l 518 541 l 293 541 l 293 171 q 255 14 293 82 q 148 -94 217 -55 q -15 -133 79 -133 z "},"G":{"ha":673,"x_min":43,"x_max":635,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 336 1204 43 1204 q 522 1156 457 1204 q 610 1015 586 1107 q 635 788 635 922 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 489 l 340 489 l 340 695 l 632 695 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 z "},"Ǵ":{"ha":673,"x_min":43,"x_max":635,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 336 1204 43 1204 q 522 1156 457 1204 q 610 1015 586 1107 q 635 788 635 922 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 489 l 340 489 l 340 695 l 632 695 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 m 174 1230 l 174 1381 l 496 1529 l 496 1293 l 174 1230 z "},"Ɣ":{"ha":652,"x_min":16,"x_max":635,"o":"m 326 -133 q 185 -99 243 -133 q 97 -6 127 -65 q 67 128 67 54 q 87 272 67 193 q 136 433 108 351 l 185 574 l 16 1194 l 245 1194 l 326 802 l 406 1194 l 635 1194 l 467 580 l 522 433 q 568 272 553 351 q 584 128 584 193 q 554 -6 584 54 q 466 -99 524 -65 q 326 -133 408 -133 m 326 69 q 363 87 351 69 q 376 131 376 105 q 363 224 376 178 q 326 343 351 271 q 288 224 300 271 q 275 131 275 178 q 288 87 275 105 q 326 69 300 69 z "},"Ğ":{"ha":673,"x_min":43,"x_max":635,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 336 1204 43 1204 q 522 1156 457 1204 q 610 1015 586 1107 q 635 788 635 922 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 489 l 340 489 l 340 695 l 632 695 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 m 338 1256 q 145 1306 219 1256 q 72 1467 72 1356 q 74 1495 72 1481 l 248 1495 q 267 1437 248 1457 q 339 1417 287 1417 q 411 1437 391 1417 q 431 1495 431 1457 l 604 1495 q 605 1482 605 1489 q 606 1472 606 1475 q 533 1307 606 1358 q 338 1256 460 1256 z "},"Ǧ":{"ha":673,"x_min":34,"x_max":637,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 336 1204 43 1204 q 522 1156 457 1204 q 610 1015 586 1107 q 635 788 635 922 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 489 l 340 489 l 340 695 l 632 695 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 m 197 1255 l 34 1529 l 277 1529 l 336 1335 l 394 1529 l 637 1529 l 474 1255 l 197 1255 z "},"Ĝ":{"ha":673,"x_min":34,"x_max":637,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 336 1204 43 1204 q 522 1156 457 1204 q 610 1015 586 1107 q 635 788 635 922 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 489 l 340 489 l 340 695 l 632 695 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 m 34 1255 l 197 1529 l 474 1529 l 637 1255 l 394 1255 l 336 1449 l 277 1255 l 34 1255 z "},"Ģ":{"ha":673,"x_min":43,"x_max":635,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 336 1204 43 1204 q 522 1156 457 1204 q 610 1015 586 1107 q 635 788 635 922 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 489 l 340 489 l 340 695 l 632 695 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 m 248 -436 l 293 -276 l 207 -276 l 207 -74 l 460 -74 l 460 -270 l 391 -436 l 248 -436 z "},"Ġ":{"ha":673,"x_min":43,"x_max":635,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 336 1204 43 1204 q 522 1156 457 1204 q 610 1015 586 1107 q 635 788 635 922 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 489 l 340 489 l 340 695 l 632 695 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 m 214 1256 l 214 1458 l 457 1458 l 457 1256 l 214 1256 z "},"ẞ":{"ha":691,"x_min":39,"x_max":657,"o":"m 39 0 l 39 951 q 116 1142 39 1079 q 333 1205 192 1205 q 509 1179 434 1205 q 633 1117 584 1152 l 633 952 l 546 700 q 635 588 612 670 q 657 365 657 506 q 634 160 657 241 q 554 40 611 79 q 395 0 496 0 l 324 0 l 324 191 q 421 271 421 191 l 421 458 q 399 536 421 513 q 321 558 377 558 l 321 707 l 418 984 q 349 997 385 997 q 277 921 277 997 l 277 0 l 39 0 z "},"Ɠ":{"ha":715,"x_min":43,"x_max":722,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 113 1120 43 1036 q 309 1204 183 1204 q 458 1164 400 1204 q 554 1304 486 1252 q 722 1356 622 1356 l 722 1142 q 652 1120 675 1142 q 629 1039 629 1098 l 629 788 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 489 l 340 489 l 340 695 l 632 695 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 z "},"Ɂ":{"ha":684,"x_min":33,"x_max":663,"o":"m 195 0 l 195 591 q 292 600 252 591 q 358 637 332 608 q 395 723 383 665 q 408 878 408 781 q 396 955 408 922 q 345 988 385 988 q 302 969 315 988 q 284 922 288 951 q 281 862 281 893 l 281 763 l 33 763 l 33 935 q 120 1138 33 1072 q 345 1204 207 1204 q 535 1161 465 1204 q 634 1035 604 1118 q 663 831 663 951 q 635 622 663 714 q 553 477 607 530 q 420 424 498 424 l 420 0 l 195 0 z "},"Ḡ":{"ha":673,"x_min":43,"x_max":635,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 336 1204 43 1204 q 522 1156 457 1204 q 610 1015 586 1107 q 635 788 635 922 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 489 l 340 489 l 340 695 l 632 695 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 m 115 1274 l 115 1378 l 556 1378 l 556 1274 l 115 1274 z "},"Ǥ":{"ha":673,"x_min":43,"x_max":688,"o":"m 299 -11 q 43 355 43 -11 l 43 870 q 336 1204 43 1204 q 522 1156 457 1204 q 610 1015 586 1107 q 635 788 635 922 l 401 788 l 401 894 q 391 959 401 932 q 347 985 380 985 q 293 957 306 985 q 279 896 279 929 l 279 317 q 292 239 279 269 q 341 209 304 209 q 386 230 372 209 q 403 287 399 251 l 338 287 l 338 444 l 404 444 l 404 489 l 340 489 l 340 695 l 632 695 l 632 444 l 688 444 l 688 287 l 632 287 l 632 0 l 536 0 l 496 100 q 299 -11 433 -11 z "},"H":{"ha":693,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 0 l 403 0 l 403 541 l 290 541 l 290 0 l 53 0 z "},"Ħ":{"ha":706,"x_min":-7,"x_max":713,"o":"m 65 0 l 65 910 l -7 910 l -7 1059 l 65 1059 l 65 1194 l 302 1194 l 302 1059 l 415 1059 l 415 1194 l 652 1194 l 652 1059 l 713 1059 l 713 910 l 652 910 l 652 0 l 415 0 l 415 541 l 302 541 l 302 0 l 65 0 m 302 767 l 415 767 l 415 910 l 302 910 l 302 767 z "},"Ḫ":{"ha":693,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 0 l 403 0 l 403 541 l 290 541 l 290 0 l 53 0 m 345 -282 q 153 -232 227 -282 q 79 -71 79 -182 q 81 -43 79 -56 l 255 -43 q 275 -101 255 -81 q 347 -121 294 -121 q 418 -101 399 -121 q 438 -43 438 -81 l 612 -43 q 613 -66 613 -60 q 540 -231 613 -180 q 345 -282 467 -282 z "},"Ȟ":{"ha":693,"x_min":45,"x_max":648,"o":"m 53 0 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 0 l 403 0 l 403 541 l 290 541 l 290 0 l 53 0 m 208 1255 l 45 1529 l 288 1529 l 347 1335 l 405 1529 l 648 1529 l 485 1255 l 208 1255 z "},"Ḩ":{"ha":693,"x_min":26,"x_max":640,"o":"m 53 0 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 0 l 403 0 l 403 541 l 290 541 l 290 0 l 53 0 m 160 -428 q 26 -401 90 -428 l 26 -250 q 67 -261 47 -256 q 106 -265 87 -265 q 162 -247 140 -265 q 185 -185 185 -229 q 166 -98 185 -147 q 115 0 148 -50 l 224 0 q 326 -129 290 -58 q 362 -262 362 -199 q 314 -380 362 -332 q 160 -428 266 -428 z "},"Ĥ":{"ha":693,"x_min":45,"x_max":648,"o":"m 53 0 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 0 l 403 0 l 403 541 l 290 541 l 290 0 l 53 0 m 45 1255 l 208 1529 l 485 1529 l 648 1255 l 405 1255 l 347 1449 l 288 1255 l 45 1255 z "},"Ḧ":{"ha":693,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 0 l 403 0 l 403 541 l 290 541 l 290 0 l 53 0 m 385 1261 l 385 1463 l 627 1463 l 627 1261 l 385 1261 m 56 1261 l 56 1463 l 299 1463 l 299 1261 l 56 1261 z "},"Ḣ":{"ha":693,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 0 l 403 0 l 403 541 l 290 541 l 290 0 l 53 0 m 225 1256 l 225 1458 l 468 1458 l 468 1256 l 225 1256 z "},"Ḥ":{"ha":693,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 0 l 403 0 l 403 541 l 290 541 l 290 0 l 53 0 m 224 -283 l 224 -81 l 467 -81 l 467 -283 l 224 -283 z "},"Ꜧ":{"ha":693,"x_min":53,"x_max":640,"o":"m 349 -133 l 349 81 q 389 97 374 81 q 403 171 403 113 l 403 541 l 290 541 l 290 0 l 53 0 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 157 q 559 -59 640 14 q 349 -133 478 -133 z "},"Ɦ":{"ha":930,"x_min":3,"x_max":877,"o":"m 290 0 l 290 993 q 231 968 250 993 q 212 890 212 944 l 212 849 l 3 849 l 3 890 q 75 1108 3 1023 q 290 1194 146 1194 l 527 1194 l 527 767 l 640 767 l 640 1194 l 877 1194 l 877 0 l 640 0 l 640 541 l 527 541 l 527 0 l 290 0 z "},"Ɥ":{"ha":693,"x_min":53,"x_max":640,"o":"m 403 0 l 403 541 l 53 541 l 53 1194 l 290 1194 l 290 767 l 403 767 l 403 1194 l 640 1194 l 640 0 l 403 0 z "},"I":{"ha":315,"x_min":42,"x_max":273,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 z "},"Ĳ":{"ha":962,"x_min":42,"x_max":924,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 632 -11 q 485 20 551 -11 q 379 113 418 52 q 340 264 340 174 l 340 563 l 576 563 l 576 278 q 589 228 576 247 q 629 209 602 209 q 683 275 683 209 l 683 1194 l 924 1194 l 924 298 q 886 134 924 203 q 783 27 849 64 q 632 -11 718 -11 z "},"Í":{"ha":315,"x_min":-4,"x_max":318,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m -4 1230 l -4 1381 l 318 1529 l 318 1293 l -4 1230 z "},"Ĭ":{"ha":315,"x_min":-106,"x_max":427,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 159 1256 q -33 1306 41 1256 q -106 1467 -106 1356 q -104 1495 -106 1481 l 69 1495 q 89 1437 69 1457 q 161 1417 109 1417 q 233 1437 213 1417 q 252 1495 252 1457 l 426 1495 q 427 1482 427 1489 q 427 1472 427 1475 q 354 1307 427 1358 q 159 1256 281 1256 z "},"Ǐ":{"ha":315,"x_min":-144,"x_max":459,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 19 1255 l -144 1529 l 99 1529 l 157 1335 l 216 1529 l 459 1529 l 296 1255 l 19 1255 z "},"Î":{"ha":315,"x_min":-144,"x_max":459,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m -144 1255 l 19 1529 l 296 1529 l 459 1255 l 216 1255 l 157 1449 l 99 1255 l -144 1255 z "},"Ȉ":{"ha":315,"x_min":-172,"x_max":341,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 24 1252 l -172 1543 l -14 1616 l 136 1291 l 24 1252 m 229 1252 l 60 1543 l 216 1616 l 341 1291 l 229 1252 z "},"Ï":{"ha":315,"x_min":-133,"x_max":438,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 195 1261 l 195 1463 l 438 1463 l 438 1261 l 195 1261 m -133 1261 l -133 1463 l 110 1463 l 110 1261 l -133 1261 z "},"Ḯ":{"ha":315,"x_min":-128,"x_max":443,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 200 1261 l 200 1429 l 443 1429 l 443 1261 l 200 1261 m -128 1261 l -128 1429 l 115 1429 l 115 1261 l -128 1261 m -3 1488 l -3 1619 l 319 1733 l 319 1538 l -3 1488 z "},"İ":{"ha":315,"x_min":36,"x_max":279,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 36 1256 l 36 1458 l 279 1458 l 279 1256 l 36 1256 z "},"Ị":{"ha":315,"x_min":36,"x_max":279,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 36 -283 l 36 -81 l 279 -81 l 279 -283 l 36 -283 z "},"Ì":{"ha":315,"x_min":-4,"x_max":318,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 318 1230 l -4 1293 l -4 1529 l 318 1381 l 318 1230 z "},"Ỉ":{"ha":315,"x_min":18,"x_max":322,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 138 1246 l 66 1330 q 125 1364 102 1343 q 147 1418 147 1384 q 79 1482 147 1482 q 18 1472 47 1482 l 18 1594 q 142 1616 77 1616 q 274 1574 227 1616 q 322 1455 322 1531 q 269 1319 322 1369 q 138 1246 216 1270 z "},"Ȋ":{"ha":315,"x_min":-96,"x_max":410,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m -94 1267 q -96 1295 -96 1280 q -30 1455 -96 1405 q 156 1506 37 1506 q 344 1454 278 1506 q 410 1290 410 1403 q 410 1280 410 1286 q 409 1267 410 1274 l 249 1267 q 223 1335 249 1313 q 157 1358 197 1358 q 92 1335 118 1358 q 66 1267 66 1313 l -94 1267 z "},"Ī":{"ha":315,"x_min":-60,"x_max":380,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m -60 1274 l -60 1378 l 380 1378 l 380 1274 l -60 1274 z "},"Į":{"ha":315,"x_min":-50,"x_max":321,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 186 -428 q 68 -404 122 -428 q -17 -333 15 -379 q -50 -224 -50 -288 q 130 0 -50 -100 l 273 0 q 199 -86 235 -39 q 164 -189 164 -133 q 242 -265 164 -265 q 321 -250 275 -265 l 321 -401 q 186 -428 256 -428 z "},"Ɩ":{"ha":315,"x_min":42,"x_max":327,"o":"m 327 -11 q 122 63 202 -11 q 42 279 42 136 l 42 1194 l 273 1194 l 273 293 q 287 219 273 235 q 327 203 302 203 l 327 -11 z "},"ɪ":{"ha":418,"x_min":22,"x_max":395,"o":"m 22 0 l 22 185 l 91 185 l 91 832 l 22 832 l 22 1017 l 395 1017 l 395 832 l 327 832 l 327 185 l 395 185 l 395 0 l 22 0 z "},"Ɨ":{"ha":357,"x_min":3,"x_max":353,"o":"m 63 0 l 63 532 l 3 532 l 3 690 l 63 690 l 63 1194 l 294 1194 l 294 690 l 353 690 l 353 532 l 294 532 l 294 0 l 63 0 z "},"Ĩ":{"ha":315,"x_min":-123,"x_max":437,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 269 1270 q 177 1286 219 1270 q 102 1317 136 1301 q 40 1332 68 1332 q 7 1322 22 1332 q -22 1286 -9 1312 l -123 1339 q -86 1414 -106 1380 q -35 1469 -66 1449 q 45 1490 -3 1490 q 132 1476 93 1490 q 203 1447 171 1461 q 262 1433 235 1433 q 296 1444 280 1433 q 325 1484 311 1456 l 437 1447 q 401 1361 421 1402 q 351 1295 382 1320 q 269 1270 320 1270 z "},"Ḭ":{"ha":315,"x_min":-123,"x_max":437,"o":"m 42 0 l 42 1194 l 273 1194 l 273 0 l 42 0 m 269 -295 q 177 -279 219 -295 q 102 -249 136 -264 q 40 -233 68 -233 q 7 -243 22 -233 q -22 -279 -9 -254 l -123 -227 q -86 -151 -106 -185 q -35 -96 -66 -117 q 45 -75 -3 -75 q 132 -90 93 -75 q 203 -118 171 -104 q 262 -132 235 -132 q 296 -121 280 -132 q 325 -81 311 -109 l 437 -118 q 401 -204 421 -163 q 351 -270 382 -245 q 269 -295 320 -295 z "},"J":{"ha":648,"x_min":26,"x_max":609,"o":"m 317 -11 q 170 20 237 -11 q 65 113 104 52 q 26 264 26 174 l 26 563 l 262 563 l 262 278 q 274 228 262 247 q 315 209 287 209 q 368 275 368 209 l 368 1194 l 609 1194 l 609 298 q 572 134 609 203 q 469 27 534 64 q 317 -11 403 -11 z "},"Ĵ":{"ha":648,"x_min":26,"x_max":791,"o":"m 317 -11 q 170 20 237 -11 q 65 113 104 52 q 26 264 26 174 l 26 563 l 262 563 l 262 278 q 274 228 262 247 q 315 209 287 209 q 368 275 368 209 l 368 1194 l 609 1194 l 609 298 q 572 134 609 203 q 469 27 534 64 q 317 -11 403 -11 m 187 1255 l 351 1529 l 627 1529 l 791 1255 l 547 1255 l 489 1449 l 431 1255 l 187 1255 z "},"Ʝ":{"ha":661,"x_min":26,"x_max":668,"o":"m 317 -11 q 170 20 237 -11 q 65 113 104 52 q 26 264 26 174 l 26 382 q 110 640 26 541 q 368 750 194 738 l 368 1194 l 609 1194 l 609 717 q 637 707 623 712 q 668 696 652 702 l 668 489 q 637 500 652 495 q 609 510 623 505 l 609 298 q 572 134 609 203 q 469 27 534 64 q 317 -11 403 -11 m 315 209 q 368 275 368 209 l 368 541 q 286 494 311 532 q 262 382 262 456 l 262 278 q 274 228 262 247 q 315 209 287 209 z "},"Ɉ":{"ha":661,"x_min":26,"x_max":667,"o":"m 317 -11 q 170 20 237 -11 q 65 113 104 52 q 26 264 26 174 l 26 563 l 262 563 l 262 278 q 274 228 262 247 q 315 209 287 209 q 368 275 368 209 l 368 715 l 264 715 l 264 873 l 368 873 l 368 1194 l 609 1194 l 609 873 l 667 873 l 667 715 l 609 715 l 609 298 q 572 134 609 203 q 469 27 534 64 q 317 -11 403 -11 z "},"K":{"ha":656,"x_min":53,"x_max":668,"o":"m 53 0 l 53 1194 l 289 1194 l 289 715 l 400 1194 l 640 1194 l 507 647 l 668 0 l 420 0 l 290 578 l 290 0 l 53 0 z "},"Ḱ":{"ha":656,"x_min":53,"x_max":668,"o":"m 53 0 l 53 1194 l 289 1194 l 289 715 l 400 1194 l 640 1194 l 507 647 l 668 0 l 420 0 l 290 578 l 290 0 l 53 0 m 186 1230 l 186 1381 l 508 1529 l 508 1293 l 186 1230 z "},"Ǩ":{"ha":656,"x_min":45,"x_max":668,"o":"m 53 0 l 53 1194 l 289 1194 l 289 715 l 400 1194 l 640 1194 l 507 647 l 668 0 l 420 0 l 290 578 l 290 0 l 53 0 m 208 1255 l 45 1529 l 288 1529 l 347 1335 l 405 1529 l 648 1529 l 485 1255 l 208 1255 z "},"Ķ":{"ha":656,"x_min":53,"x_max":668,"o":"m 53 0 l 53 1194 l 289 1194 l 289 715 l 400 1194 l 640 1194 l 507 647 l 668 0 l 420 0 l 290 578 l 290 0 l 53 0 m 260 -436 l 305 -276 l 219 -276 l 219 -74 l 473 -74 l 473 -270 l 404 -436 l 260 -436 z "},"Ḳ":{"ha":656,"x_min":53,"x_max":668,"o":"m 53 0 l 53 1194 l 289 1194 l 289 715 l 400 1194 l 640 1194 l 507 647 l 668 0 l 420 0 l 290 578 l 290 0 l 53 0 m 233 -283 l 233 -81 l 476 -81 l 476 -283 l 233 -283 z "},"Ƙ":{"ha":656,"x_min":53,"x_max":668,"o":"m 53 0 l 53 1194 l 289 1194 l 289 715 l 400 1194 l 640 1194 l 507 647 l 668 0 l 420 0 l 290 578 l 290 0 l 53 0 z "},"Ḵ":{"ha":656,"x_min":53,"x_max":668,"o":"m 53 0 l 53 1194 l 289 1194 l 289 715 l 400 1194 l 640 1194 l 507 647 l 668 0 l 420 0 l 290 578 l 290 0 l 53 0 m 134 -184 l 134 -81 l 575 -81 l 575 -184 l 134 -184 z "},"Ꝁ":{"ha":666,"x_min":0,"x_max":678,"o":"m 63 0 l 63 1003 l 0 1003 l 0 1160 l 63 1160 l 63 1194 l 299 1194 l 299 1160 l 350 1160 l 350 1003 l 299 1003 l 299 715 l 410 1194 l 650 1194 l 517 647 l 678 0 l 431 0 l 300 578 l 300 0 l 63 0 z "},"L":{"ha":552,"x_min":53,"x_max":537,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 z "},"Ǉ":{"ha":1200,"x_min":53,"x_max":1161,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m 869 -11 q 722 20 789 -11 q 617 113 656 52 q 578 264 578 174 l 578 563 l 814 563 l 814 278 q 826 228 814 247 q 867 209 839 209 q 920 275 920 209 l 920 1194 l 1161 1194 l 1161 298 q 1124 134 1161 203 q 1021 27 1086 64 q 869 -11 955 -11 z "},"Ĺ":{"ha":552,"x_min":11,"x_max":537,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m 11 1230 l 11 1381 l 333 1529 l 333 1293 l 11 1230 z "},"Ƚ":{"ha":552,"x_min":-24,"x_max":537,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m -24 542 l -24 699 l 423 699 l 423 542 l -24 542 z "},"Ɬ":{"ha":681,"x_min":-7,"x_max":666,"o":"m 182 0 l 182 492 q 47 546 101 498 q -7 674 -7 595 q 43 815 -7 764 q 182 871 92 865 l 182 1194 l 420 1194 l 420 648 l 515 648 l 515 491 l 420 491 l 420 203 l 666 203 l 666 0 l 182 0 m 125 688 q 182 648 125 648 l 182 728 q 125 688 125 727 z "},"Ľ":{"ha":552,"x_min":53,"x_max":561,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m 349 831 l 400 991 l 349 991 l 349 1194 l 561 1194 l 561 998 l 492 831 l 349 831 z "},"Ḽ":{"ha":552,"x_min":-8,"x_max":595,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m -8 -347 l 155 -74 l 432 -74 l 595 -347 l 352 -347 l 294 -154 l 235 -347 l -8 -347 z "},"Ļ":{"ha":552,"x_min":53,"x_max":537,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m 199 -436 l 244 -276 l 158 -276 l 158 -74 l 412 -74 l 412 -270 l 342 -436 l 199 -436 z "},"Ŀ":{"ha":627,"x_min":53,"x_max":597,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m 374 513 l 374 742 l 597 742 l 597 513 l 374 513 z "},"Ḷ":{"ha":552,"x_min":53,"x_max":537,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m 172 -283 l 172 -81 l 415 -81 l 415 -283 l 172 -283 z "},"Ḹ":{"ha":552,"x_min":-50,"x_max":537,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m 172 -283 l 172 -81 l 415 -81 l 415 -283 l 172 -283 m -50 1274 l -50 1378 l 391 1378 l 391 1274 l -50 1274 z "},"Ⱡ":{"ha":552,"x_min":-24,"x_max":537,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m -24 664 l -24 821 l 423 821 l 423 664 l -24 664 m -24 420 l -24 577 l 423 577 l 423 420 l -24 420 z "},"ǈ":{"ha":917,"x_min":53,"x_max":869,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m 627 1080 l 627 1282 l 869 1282 l 869 1080 l 627 1080 m 678 -176 q 575 -159 601 -176 l 575 4 q 597 1 587 1 q 622 14 617 1 q 627 49 627 28 l 627 1017 l 869 1017 l 869 56 q 826 -115 869 -53 q 678 -176 783 -176 z "},"Ḻ":{"ha":552,"x_min":53,"x_max":537,"o":"m 53 0 l 53 1194 l 292 1194 l 292 203 l 537 203 l 537 0 l 53 0 m 73 -184 l 73 -81 l 514 -81 l 514 -184 l 73 -184 z "},"Ɫ":{"ha":640,"x_min":-20,"x_max":625,"o":"m 140 0 l 140 1194 l 379 1194 l 379 203 l 625 203 l 625 0 l 140 0 m 372 526 q 279 542 319 526 q 207 573 239 557 q 142 588 174 588 q 109 578 125 588 q 80 542 94 568 l -20 595 q 17 670 -3 636 q 68 725 37 705 q 147 746 99 746 q 236 732 197 746 q 306 703 275 718 q 364 689 338 689 q 398 701 382 689 q 427 740 414 712 l 540 703 q 504 617 524 658 q 453 551 484 576 q 372 526 422 526 z "},"Ł":{"ha":578,"x_min":-7,"x_max":537,"o":"m 53 0 l 53 487 l -7 460 l -7 679 l 53 705 l 53 1194 l 292 1194 l 292 809 l 431 870 l 431 652 l 292 591 l 292 203 l 537 203 l 537 0 l 53 0 z "},"M":{"ha":1036,"x_min":53,"x_max":983,"o":"m 53 0 l 53 1194 l 416 1194 l 517 466 l 616 1194 l 983 1194 l 983 0 l 765 0 l 765 860 l 628 0 l 414 0 l 269 860 l 269 0 l 53 0 z "},"Ḿ":{"ha":1036,"x_min":53,"x_max":983,"o":"m 53 0 l 53 1194 l 416 1194 l 517 466 l 616 1194 l 983 1194 l 983 0 l 765 0 l 765 860 l 628 0 l 414 0 l 269 860 l 269 0 l 53 0 m 356 1230 l 356 1381 l 678 1529 l 678 1293 l 356 1230 z "},"Ṁ":{"ha":1036,"x_min":53,"x_max":983,"o":"m 53 0 l 53 1194 l 416 1194 l 517 466 l 616 1194 l 983 1194 l 983 0 l 765 0 l 765 860 l 628 0 l 414 0 l 269 860 l 269 0 l 53 0 m 395 1256 l 395 1458 l 638 1458 l 638 1256 l 395 1256 z "},"Ṃ":{"ha":1036,"x_min":53,"x_max":983,"o":"m 53 0 l 53 1194 l 416 1194 l 517 466 l 616 1194 l 983 1194 l 983 0 l 765 0 l 765 860 l 628 0 l 414 0 l 269 860 l 269 0 l 53 0 m 397 -283 l 397 -81 l 640 -81 l 640 -283 l 397 -283 z "},"Ɯ":{"ha":1052,"x_min":53,"x_max":999,"o":"m 250 -11 q 97 63 142 -11 q 53 278 53 138 l 53 1194 l 287 1194 l 287 274 q 345 174 287 174 q 393 209 378 174 q 408 291 408 243 l 408 1194 l 642 1194 l 642 274 q 655 203 642 231 q 699 176 668 176 q 750 214 735 176 q 765 304 765 252 l 765 1194 l 999 1194 l 999 0 l 766 0 l 766 120 q 711 21 749 54 q 590 -11 672 -11 q 485 17 530 -11 q 422 92 440 45 q 354 14 392 39 q 250 -11 316 -11 z "},"N":{"ha":692,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 z "},"Ǌ":{"ha":1339,"x_min":53,"x_max":1301,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 1009 -11 q 862 20 928 -11 q 756 113 795 52 q 718 264 718 174 l 718 563 l 954 563 l 954 278 q 966 228 954 247 q 1006 209 979 209 q 1060 275 1060 209 l 1060 1194 l 1301 1194 l 1301 298 q 1263 134 1301 203 q 1160 27 1226 64 q 1009 -11 1095 -11 z "},"Ń":{"ha":692,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 199 1230 l 199 1381 l 521 1529 l 521 1293 l 199 1230 z "},"Ň":{"ha":692,"x_min":53,"x_max":662,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 222 1255 l 58 1529 l 302 1529 l 360 1335 l 418 1529 l 662 1529 l 498 1255 l 222 1255 z "},"Ṋ":{"ha":692,"x_min":39,"x_max":643,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 39 -347 l 203 -74 l 479 -74 l 643 -347 l 399 -347 l 341 -154 l 283 -347 l 39 -347 z "},"Ņ":{"ha":692,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 247 -436 l 292 -276 l 205 -276 l 205 -74 l 459 -74 l 459 -270 l 390 -436 l 247 -436 z "},"Ṅ":{"ha":692,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 239 1256 l 239 1458 l 481 1458 l 481 1256 l 239 1256 z "},"Ṇ":{"ha":692,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 220 -283 l 220 -81 l 463 -81 l 463 -283 l 220 -283 z "},"Ǹ":{"ha":692,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 521 1230 l 199 1293 l 199 1529 l 521 1381 l 521 1230 z "},"Ɲ":{"ha":692,"x_min":-35,"x_max":639,"o":"m -35 -331 l -35 -126 q 53 -21 53 -126 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 -5 q 200 -249 286 -167 q -35 -331 114 -331 z "},"ǋ":{"ha":1057,"x_min":53,"x_max":1009,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 766 1080 l 766 1282 l 1009 1282 l 1009 1080 l 766 1080 m 818 -176 q 715 -159 741 -176 l 715 4 q 737 1 727 1 q 762 14 757 1 q 766 49 766 28 l 766 1017 l 1009 1017 l 1009 56 q 966 -115 1009 -53 q 818 -176 923 -176 z "},"Ṉ":{"ha":692,"x_min":53,"x_max":639,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 121 -184 l 121 -81 l 562 -81 l 562 -184 l 121 -184 z "},"Ƞ":{"ha":692,"x_min":53,"x_max":639,"o":"m 408 -126 l 408 901 q 395 969 408 944 q 351 994 382 994 q 296 964 309 994 q 283 879 283 935 l 283 0 l 53 0 l 53 1194 l 282 1194 l 282 1067 q 339 1166 298 1128 q 441 1204 380 1204 q 591 1143 543 1204 q 639 966 639 1081 l 639 -126 l 408 -126 z "},"Ñ":{"ha":692,"x_min":53,"x_max":640,"o":"m 53 0 l 53 1194 l 298 1194 l 408 622 l 408 1194 l 639 1194 l 639 0 l 406 0 l 286 597 l 286 0 l 53 0 m 472 1269 q 380 1284 422 1269 q 304 1315 338 1300 q 243 1331 271 1331 q 210 1320 225 1331 q 180 1284 194 1310 l 80 1337 q 117 1413 97 1379 q 168 1468 137 1447 q 248 1489 199 1489 q 335 1474 296 1489 q 406 1446 374 1460 q 465 1432 438 1432 q 498 1443 483 1432 q 528 1482 514 1455 l 640 1446 q 604 1360 624 1400 q 554 1294 585 1319 q 472 1269 523 1269 z "},"O":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 z "},"Œ":{"ha":902,"x_min":34,"x_max":876,"o":"m 411 0 q 34 292 34 0 l 34 920 q 81 1084 34 1025 q 212 1169 128 1144 q 406 1194 296 1194 l 860 1194 l 860 984 l 631 984 l 631 734 l 850 734 l 850 532 l 631 532 l 631 211 l 876 211 l 876 0 l 411 0 m 348 211 l 389 211 l 389 984 l 352 984 q 291 959 312 984 q 270 891 270 935 l 270 326 q 288 244 270 278 q 348 211 307 211 z "},"Ȣ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 118 77 193 -11 q 43 325 43 165 l 43 463 q 59 581 43 530 q 104 669 75 632 q 47 884 47 747 l 47 1194 l 279 1194 l 279 880 q 290 791 279 823 q 338 760 301 760 q 385 791 374 760 q 396 880 396 822 l 396 1194 l 628 1194 l 628 884 q 571 669 628 747 q 616 581 600 632 q 632 463 632 530 l 632 325 q 557 76 632 163 q 338 -11 483 -11 m 338 209 q 381 237 370 209 q 392 314 392 264 l 392 481 q 382 544 392 519 q 339 569 372 569 q 279 479 279 569 l 279 313 q 292 235 279 262 q 338 209 304 209 z "},"Ó":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 177 1230 l 177 1381 l 499 1529 l 499 1293 l 177 1230 z "},"Ŏ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 340 1256 q 148 1306 222 1256 q 75 1467 75 1356 q 77 1495 75 1481 l 250 1495 q 270 1437 250 1457 q 342 1417 290 1417 q 414 1437 394 1417 q 433 1495 433 1457 l 607 1495 q 608 1482 608 1489 q 608 1472 608 1475 q 535 1307 608 1358 q 340 1256 463 1256 z "},"Ǒ":{"ha":675,"x_min":37,"x_max":640,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 200 1255 l 37 1529 l 280 1529 l 338 1335 l 397 1529 l 640 1529 l 477 1255 l 200 1255 z "},"Ɵ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 100 522 l 100 679 l 547 679 l 547 522 l 100 522 z "},"Ô":{"ha":675,"x_min":37,"x_max":640,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 37 1255 l 200 1529 l 477 1529 l 640 1255 l 397 1255 l 338 1449 l 280 1255 l 37 1255 z "},"Ố":{"ha":675,"x_min":43,"x_max":819,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 534 1356 l 611 1495 l 819 1495 l 692 1356 l 534 1356 m 77 1247 l 238 1419 l 437 1419 l 598 1247 l 405 1247 l 338 1339 l 271 1247 l 77 1247 z "},"Ộ":{"ha":675,"x_min":36,"x_max":640,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 216 -283 l 216 -81 l 459 -81 l 459 -283 l 216 -283 m 36 1262 l 199 1488 l 476 1488 l 640 1262 l 396 1262 l 338 1408 l 279 1262 l 36 1262 z "},"Ồ":{"ha":675,"x_min":43,"x_max":737,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 579 1356 l 452 1495 l 660 1495 l 737 1356 l 579 1356 m 77 1247 l 238 1419 l 437 1419 l 598 1247 l 405 1247 l 338 1339 l 271 1247 l 77 1247 z "},"Ổ":{"ha":675,"x_min":43,"x_max":703,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 589 1329 l 544 1381 q 581 1402 567 1390 q 595 1436 595 1415 q 552 1476 595 1476 q 514 1469 533 1476 l 514 1545 q 591 1559 553 1559 q 673 1533 644 1559 q 703 1459 703 1506 q 670 1375 703 1405 q 589 1329 637 1344 m 77 1247 l 238 1419 l 437 1419 l 598 1247 l 405 1247 l 338 1339 l 271 1247 l 77 1247 z "},"Ỗ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 419 1453 q 362 1464 389 1453 q 310 1487 335 1476 q 257 1499 284 1499 q 227 1491 241 1499 q 200 1464 212 1484 l 125 1503 q 167 1579 142 1548 q 242 1611 191 1611 q 300 1599 274 1611 q 352 1576 327 1588 q 404 1565 377 1565 q 461 1603 438 1565 l 546 1575 q 502 1490 527 1528 q 419 1453 477 1453 m 77 1247 l 238 1419 l 437 1419 l 598 1247 l 405 1247 l 338 1339 l 271 1247 l 77 1247 z "},"Ȍ":{"ha":675,"x_min":9,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 205 1252 l 9 1543 l 168 1616 l 317 1291 l 205 1252 m 410 1252 l 241 1543 l 397 1616 l 522 1291 l 410 1252 z "},"Ö":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 376 1261 l 376 1463 l 619 1463 l 619 1261 l 376 1261 m 48 1261 l 48 1463 l 291 1463 l 291 1261 l 48 1261 z "},"Ȫ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 380 1261 l 380 1429 l 623 1429 l 623 1261 l 380 1261 m 52 1261 l 52 1429 l 295 1429 l 295 1261 l 52 1261 m 117 1503 l 117 1607 l 558 1607 l 558 1503 l 117 1503 z "},"Ȯ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 217 1256 l 217 1458 l 460 1458 l 460 1256 l 217 1256 z "},"Ȱ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 216 1256 l 216 1431 l 459 1431 l 459 1256 l 216 1256 m 117 1491 l 117 1594 l 558 1594 l 558 1491 l 117 1491 z "},"Ọ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 216 -283 l 216 -81 l 459 -81 l 459 -283 l 216 -283 z "},"Ò":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 499 1230 l 177 1293 l 177 1529 l 499 1381 l 499 1230 z "},"Ω":{"ha":673,"x_min":32,"x_max":641,"o":"m 32 0 l 32 167 l 115 167 q 49 481 49 267 l 49 806 q 122 1018 49 945 q 336 1090 195 1090 q 551 1018 478 1090 q 624 806 624 945 l 624 481 q 558 167 624 267 l 641 167 l 641 0 l 359 0 l 359 168 q 382 196 374 180 q 392 240 389 212 q 394 319 394 269 l 394 821 q 383 881 394 857 q 336 905 372 905 q 290 881 301 905 q 279 821 279 857 l 279 319 q 288 214 279 243 q 314 168 297 185 l 314 0 l 32 0 z "},"Ỏ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 318 1246 l 246 1330 q 305 1364 283 1343 q 328 1418 328 1384 q 259 1482 328 1482 q 198 1472 227 1482 l 198 1594 q 322 1616 258 1616 q 455 1574 407 1616 q 503 1455 503 1531 q 450 1319 503 1369 q 318 1246 397 1270 z "},"Ơ":{"ha":677,"x_min":43,"x_max":657,"o":"m 338 -11 q 117 78 191 -11 q 43 326 43 166 l 43 892 q 119 1125 43 1046 q 339 1204 195 1204 l 391 1204 q 469 1289 469 1204 l 469 1305 l 657 1305 l 657 1295 q 635 1176 657 1223 q 576 1103 613 1129 q 632 892 632 1025 l 632 326 q 558 78 632 166 q 338 -11 484 -11 m 338 209 q 382 240 372 209 q 392 314 392 271 l 392 897 q 383 957 392 928 q 339 985 374 985 q 292 959 304 985 q 279 895 279 932 l 279 313 q 290 237 279 266 q 338 209 301 209 z "},"Ớ":{"ha":677,"x_min":43,"x_max":657,"o":"m 338 -11 q 117 78 191 -11 q 43 326 43 166 l 43 892 q 119 1125 43 1046 q 339 1204 195 1204 l 391 1204 q 469 1289 469 1204 l 469 1305 l 657 1305 l 657 1295 q 635 1176 657 1223 q 576 1103 613 1129 q 632 892 632 1025 l 632 326 q 558 78 632 166 q 338 -11 484 -11 m 338 209 q 382 240 372 209 q 392 314 392 271 l 392 897 q 383 957 392 928 q 339 985 374 985 q 292 959 304 985 q 279 895 279 932 l 279 313 q 290 237 279 266 q 338 209 301 209 m 178 1310 l 178 1441 l 500 1555 l 500 1360 l 178 1310 z "},"Ợ":{"ha":677,"x_min":43,"x_max":657,"o":"m 338 -11 q 117 78 191 -11 q 43 326 43 166 l 43 892 q 119 1125 43 1046 q 339 1204 195 1204 l 391 1204 q 469 1289 469 1204 l 469 1305 l 657 1305 l 657 1295 q 635 1176 657 1223 q 576 1103 613 1129 q 632 892 632 1025 l 632 326 q 558 78 632 166 q 338 -11 484 -11 m 338 209 q 382 240 372 209 q 392 314 392 271 l 392 897 q 383 957 392 928 q 339 985 374 985 q 292 959 304 985 q 279 895 279 932 l 279 313 q 290 237 279 266 q 338 209 301 209 m 216 -283 l 216 -81 l 459 -81 l 459 -283 l 216 -283 z "},"Ờ":{"ha":677,"x_min":43,"x_max":657,"o":"m 338 -11 q 117 78 191 -11 q 43 326 43 166 l 43 892 q 119 1125 43 1046 q 339 1204 195 1204 l 391 1204 q 469 1289 469 1204 l 469 1305 l 657 1305 l 657 1295 q 635 1176 657 1223 q 576 1103 613 1129 q 632 892 632 1025 l 632 326 q 558 78 632 166 q 338 -11 484 -11 m 338 209 q 382 240 372 209 q 392 314 392 271 l 392 897 q 383 957 392 928 q 339 985 374 985 q 292 959 304 985 q 279 895 279 932 l 279 313 q 290 237 279 266 q 338 209 301 209 m 500 1331 l 178 1381 l 178 1575 l 500 1461 l 500 1331 z "},"Ở":{"ha":677,"x_min":43,"x_max":657,"o":"m 338 -11 q 117 78 191 -11 q 43 326 43 166 l 43 892 q 119 1125 43 1046 q 339 1204 195 1204 l 391 1204 q 469 1289 469 1204 l 469 1305 l 657 1305 l 657 1295 q 635 1176 657 1223 q 576 1103 613 1129 q 632 892 632 1025 l 632 326 q 558 78 632 166 q 338 -11 484 -11 m 338 209 q 382 240 372 209 q 392 314 392 271 l 392 897 q 383 957 392 928 q 339 985 374 985 q 292 959 304 985 q 279 895 279 932 l 279 313 q 290 237 279 266 q 338 209 301 209 m 319 1303 l 248 1388 q 307 1421 284 1401 q 329 1476 329 1442 q 260 1540 329 1540 q 199 1529 229 1540 l 199 1651 q 323 1674 259 1674 q 456 1631 408 1674 q 504 1512 504 1589 q 451 1377 504 1426 q 319 1303 398 1328 z "},"Ỡ":{"ha":677,"x_min":43,"x_max":657,"o":"m 338 -11 q 117 78 191 -11 q 43 326 43 166 l 43 892 q 119 1125 43 1046 q 339 1204 195 1204 l 391 1204 q 469 1289 469 1204 l 469 1305 l 657 1305 l 657 1295 q 635 1176 657 1223 q 576 1103 613 1129 q 632 892 632 1025 l 632 326 q 558 78 632 166 q 338 -11 484 -11 m 338 209 q 382 240 372 209 q 392 314 392 271 l 392 897 q 383 957 392 928 q 339 985 374 985 q 292 959 304 985 q 279 895 279 932 l 279 313 q 290 237 279 266 q 338 209 301 209 m 451 1360 q 359 1376 401 1360 q 283 1407 317 1392 q 222 1422 250 1422 q 189 1412 204 1422 q 159 1376 173 1402 l 59 1429 q 96 1497 76 1466 q 147 1548 116 1529 q 227 1567 178 1567 q 314 1552 275 1567 q 386 1524 354 1538 q 444 1510 418 1510 q 477 1521 462 1510 q 507 1560 493 1533 l 619 1524 q 583 1444 603 1482 q 533 1383 564 1407 q 451 1360 502 1360 z "},"Ő":{"ha":675,"x_min":43,"x_max":658,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 462 1265 l 349 1305 l 499 1630 l 658 1556 l 462 1265 m 257 1265 l 144 1305 l 269 1630 l 425 1556 l 257 1265 z "},"Ȏ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 87 1267 q 85 1295 85 1280 q 152 1455 85 1405 q 337 1506 218 1506 q 525 1454 459 1506 q 591 1290 591 1403 q 591 1280 591 1286 q 590 1267 591 1274 l 430 1267 q 404 1335 430 1313 q 338 1358 378 1358 q 273 1335 299 1358 q 247 1267 247 1313 l 87 1267 z "},"Ō":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 117 1274 l 117 1378 l 558 1378 l 558 1274 l 117 1274 z "},"Ṓ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 117 1234 l 117 1337 l 558 1337 l 558 1234 l 117 1234 m 177 1368 l 177 1499 l 499 1613 l 499 1418 l 177 1368 z "},"Ṑ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 117 1234 l 117 1337 l 558 1337 l 558 1234 l 117 1234 m 499 1368 l 177 1418 l 177 1613 l 499 1499 l 499 1368 z "},"Ω":{"ha":673,"x_min":32,"x_max":641,"o":"m 32 0 l 32 167 l 115 167 q 49 481 49 267 l 49 917 q 122 1128 49 1056 q 336 1200 195 1200 q 551 1128 478 1200 q 624 917 624 1056 l 624 481 q 558 167 624 267 l 641 167 l 641 0 l 359 0 l 359 168 q 388 235 381 185 q 394 360 394 284 l 394 932 q 383 992 394 968 q 336 1016 372 1016 q 290 992 301 1016 q 279 932 279 968 l 279 360 q 285 235 279 284 q 314 168 292 185 l 314 0 l 32 0 z "},"Ꞷ":{"ha":1029,"x_min":43,"x_max":985,"o":"m 307 -11 q 107 75 172 -11 q 43 321 43 161 l 43 893 q 76 1054 43 984 q 173 1164 108 1124 q 337 1204 239 1204 l 337 999 q 294 984 308 999 q 280 935 280 969 l 280 313 q 293 235 280 262 q 338 209 305 209 q 382 236 371 209 q 394 313 394 264 l 394 800 l 635 800 l 635 313 q 647 235 635 262 q 692 209 659 209 q 736 236 723 209 q 749 313 749 264 l 749 935 q 735 984 749 969 q 692 999 721 999 l 692 1204 q 856 1164 791 1204 q 953 1054 921 1124 q 985 893 985 984 l 985 321 q 921 74 985 159 q 724 -11 857 -11 q 608 13 662 -11 q 515 99 553 37 q 424 13 477 37 q 307 -11 370 -11 z "},"Ǫ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 449 -374 q 331 -349 385 -374 q 245 -279 277 -325 q 213 -170 213 -233 q 392 54 213 -46 l 535 54 q 462 -32 497 15 q 427 -135 427 -79 q 505 -211 427 -211 q 583 -195 538 -211 l 583 -347 q 449 -374 519 -374 z "},"Ǭ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 449 -374 q 331 -349 385 -374 q 245 -279 277 -325 q 213 -170 213 -233 q 392 54 213 -46 l 535 54 q 458 -34 489 10 q 427 -135 427 -79 q 505 -211 427 -211 q 583 -195 538 -211 l 583 -347 q 449 -374 519 -374 m 117 1234 l 117 1337 l 558 1337 l 558 1234 l 117 1234 z "},"Ɔ":{"ha":659,"x_min":26,"x_max":615,"o":"m 328 -11 q 106 60 185 -11 q 26 288 26 131 l 26 514 l 267 514 l 267 299 q 279 234 267 259 q 322 209 292 209 q 364 229 350 209 q 378 299 378 250 l 378 897 q 367 961 378 937 q 322 985 355 985 q 280 966 294 985 q 267 894 267 947 l 267 718 l 29 718 l 29 924 q 67 1080 29 1018 q 171 1173 105 1142 q 322 1204 237 1204 q 546 1112 477 1204 q 615 846 615 1020 l 615 296 q 536 70 615 151 q 328 -11 457 -11 z "},"Ø":{"ha":675,"x_min":43,"x_max":632,"o":"m 75 -126 l 125 68 q 43 326 43 155 l 43 892 q 119 1125 43 1046 q 338 1204 195 1204 q 445 1191 397 1204 l 488 1356 l 583 1356 l 530 1149 q 632 892 632 1072 l 632 326 q 558 78 632 166 q 338 -11 484 -11 q 206 13 263 -11 l 170 -126 l 75 -126 m 340 209 q 384 240 374 209 q 394 314 394 271 l 394 897 q 385 957 394 928 q 341 985 376 985 q 294 959 307 985 q 281 895 281 932 l 281 313 q 292 237 281 266 q 340 209 303 209 z "},"Ǿ":{"ha":675,"x_min":43,"x_max":632,"o":"m 75 -126 l 125 68 q 43 326 43 155 l 43 892 q 119 1125 43 1046 q 338 1204 195 1204 q 445 1191 397 1204 l 488 1356 l 583 1356 l 530 1149 q 632 892 632 1072 l 632 326 q 558 78 632 166 q 338 -11 484 -11 q 206 13 263 -11 l 170 -126 l 75 -126 m 340 209 q 384 240 374 209 q 394 314 394 271 l 394 897 q 385 957 394 928 q 341 985 376 985 q 294 959 307 985 q 281 895 281 932 l 281 313 q 292 237 281 266 q 340 209 303 209 m 174 1322 l 174 1474 l 496 1622 l 496 1386 l 174 1322 z "},"Õ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 450 1269 q 358 1284 400 1269 q 283 1315 317 1300 q 221 1331 249 1331 q 188 1320 203 1331 q 159 1284 172 1310 l 58 1337 q 95 1413 75 1379 q 146 1468 115 1447 q 226 1489 178 1489 q 313 1474 274 1489 q 384 1446 352 1460 q 443 1432 416 1432 q 477 1443 461 1432 q 506 1482 492 1455 l 618 1446 q 583 1360 602 1400 q 532 1294 563 1319 q 450 1269 501 1269 z "},"Ṍ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 450 1249 q 358 1264 399 1249 q 282 1295 316 1280 q 220 1310 248 1310 q 187 1300 203 1310 q 158 1264 172 1290 l 58 1317 q 95 1385 75 1354 q 146 1436 115 1417 q 225 1455 177 1455 q 313 1440 273 1455 q 385 1412 353 1426 q 442 1398 416 1398 q 476 1409 460 1398 q 505 1449 492 1421 l 618 1412 q 582 1332 602 1370 q 531 1272 562 1295 q 450 1249 500 1249 m 177 1495 l 177 1626 l 499 1740 l 499 1545 l 177 1495 z "},"Ṏ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 450 1249 q 358 1264 399 1249 q 282 1295 316 1280 q 220 1310 248 1310 q 187 1300 203 1310 q 158 1264 172 1290 l 58 1317 q 95 1385 75 1354 q 146 1436 115 1417 q 225 1455 177 1455 q 313 1440 273 1455 q 385 1412 353 1426 q 442 1398 416 1398 q 476 1409 460 1398 q 505 1449 492 1421 l 618 1412 q 582 1332 602 1370 q 531 1272 562 1295 q 450 1249 500 1249 m 380 1537 l 380 1705 l 623 1705 l 623 1537 l 380 1537 m 52 1537 l 52 1705 l 295 1705 l 295 1537 l 52 1537 z "},"Ȭ":{"ha":675,"x_min":43,"x_max":632,"o":"m 338 -11 q 119 76 195 -11 q 43 326 43 162 l 43 892 q 118 1125 43 1046 q 338 1204 193 1204 q 557 1125 482 1204 q 632 892 632 1046 l 632 326 q 556 76 632 162 q 338 -11 481 -11 m 340 209 q 394 314 394 209 l 394 897 q 341 985 394 985 q 281 895 281 985 l 281 313 q 295 233 281 257 q 340 209 309 209 m 450 1249 q 358 1264 399 1249 q 282 1295 316 1280 q 220 1310 248 1310 q 187 1300 203 1310 q 158 1264 172 1290 l 58 1317 q 95 1385 75 1354 q 146 1436 115 1417 q 225 1455 177 1455 q 313 1440 273 1455 q 385 1412 353 1426 q 442 1398 416 1398 q 476 1409 460 1398 q 505 1449 492 1421 l 618 1412 q 582 1332 602 1370 q 531 1272 562 1295 q 450 1249 500 1249 m 117 1510 l 117 1613 l 558 1613 l 558 1510 l 117 1510 z "},"P":{"ha":656,"x_min":53,"x_max":633,"o":"m 53 0 l 53 1194 l 368 1194 q 525 1149 467 1194 q 608 1024 583 1105 q 633 830 633 943 q 612 641 633 722 q 537 517 591 561 q 385 473 484 473 l 288 473 l 288 0 l 53 0 m 288 687 l 301 687 q 382 724 368 687 q 397 834 397 762 q 383 939 397 902 q 314 976 368 976 l 288 976 l 288 687 z "},"Ṕ":{"ha":656,"x_min":53,"x_max":633,"o":"m 53 0 l 53 1194 l 368 1194 q 525 1149 467 1194 q 608 1024 583 1105 q 633 830 633 943 q 612 641 633 722 q 537 517 591 561 q 385 473 484 473 l 288 473 l 288 0 l 53 0 m 288 687 l 301 687 q 382 724 368 687 q 397 834 397 762 q 383 939 397 902 q 314 976 368 976 l 288 976 l 288 687 m 167 1230 l 167 1381 l 489 1529 l 489 1293 l 167 1230 z "},"Ṗ":{"ha":656,"x_min":53,"x_max":633,"o":"m 53 0 l 53 1194 l 368 1194 q 525 1149 467 1194 q 608 1024 583 1105 q 633 830 633 943 q 612 641 633 722 q 537 517 591 561 q 385 473 484 473 l 288 473 l 288 0 l 53 0 m 288 687 l 301 687 q 382 724 368 687 q 397 834 397 762 q 383 939 397 902 q 314 976 368 976 l 288 976 l 288 687 m 206 1256 l 206 1458 l 449 1458 l 449 1256 l 206 1256 z "},"Ƥ":{"ha":892,"x_min":3,"x_max":870,"o":"m 290 0 l 290 993 q 231 968 250 993 q 212 890 212 944 l 212 849 l 3 849 l 3 890 q 75 1108 3 1023 q 290 1194 146 1194 l 605 1194 q 762 1149 704 1194 q 845 1024 820 1105 q 870 830 870 943 q 849 641 870 722 q 774 517 828 561 q 621 473 720 473 l 524 473 l 524 0 l 290 0 m 524 687 l 538 687 q 619 724 604 687 q 634 834 634 762 q 620 939 634 902 q 551 976 605 976 l 524 976 l 524 687 z "},"Ᵽ":{"ha":656,"x_min":0,"x_max":633,"o":"m 53 0 l 53 756 l 0 756 l 0 913 l 53 913 l 53 1194 l 368 1194 q 525 1149 467 1194 q 608 1024 583 1105 q 633 830 633 943 q 612 641 633 722 q 537 517 591 561 q 385 473 484 473 l 288 473 l 288 0 l 53 0 m 288 687 l 301 687 q 382 724 368 687 q 397 834 397 762 q 383 939 397 902 q 314 976 368 976 l 288 976 l 288 913 l 350 913 l 350 756 l 288 756 l 288 687 z "},"Q":{"ha":686,"x_min":37,"x_max":661,"o":"m 581 -127 l 391 -2 q 323 -11 358 -11 q 110 72 184 -11 q 37 313 37 155 l 37 890 q 112 1124 37 1044 q 331 1204 188 1204 q 550 1124 474 1204 q 625 890 625 1044 l 625 313 q 559 81 625 165 l 661 16 l 581 -127 m 331 209 q 368 228 357 209 q 382 275 379 247 q 385 328 385 302 l 385 886 q 375 955 385 924 q 330 985 364 985 q 283 955 294 985 q 273 887 273 926 l 273 323 q 276 273 273 300 q 291 228 279 246 q 331 209 303 209 z "},"Ɋ":{"ha":711,"x_min":43,"x_max":718,"o":"m 718 -133 q 565 -111 632 -133 q 459 -41 498 -90 q 421 88 421 7 l 421 90 q 349 12 395 35 q 246 -11 303 -11 q 115 31 159 -11 q 58 146 72 73 q 43 317 43 220 l 43 878 q 58 1047 43 974 q 115 1163 72 1121 q 246 1204 159 1204 q 339 1175 304 1204 q 394 1088 374 1146 l 394 1194 l 631 1194 l 631 172 q 652 102 631 123 q 718 81 673 81 l 718 -133 m 338 189 q 382 218 370 189 q 394 292 394 248 l 394 902 q 382 976 394 946 q 338 1005 370 1005 q 292 978 304 1005 q 281 902 281 950 l 281 292 q 292 216 281 244 q 338 189 304 189 z "},"R":{"ha":662,"x_min":53,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 z "},"Ŕ":{"ha":662,"x_min":53,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 m 163 1230 l 163 1381 l 486 1529 l 486 1293 l 163 1230 z "},"Ř":{"ha":662,"x_min":23,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 m 186 1255 l 23 1529 l 267 1529 l 325 1335 l 383 1529 l 627 1529 l 463 1255 l 186 1255 z "},"Ŗ":{"ha":662,"x_min":53,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 m 255 -436 l 300 -276 l 214 -276 l 214 -74 l 467 -74 l 467 -270 l 398 -436 l 255 -436 z "},"Ȑ":{"ha":662,"x_min":-5,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 m 191 1252 l -5 1543 l 154 1616 l 304 1291 l 191 1252 m 396 1252 l 228 1543 l 384 1616 l 509 1291 l 396 1252 z "},"Ṙ":{"ha":662,"x_min":53,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 m 203 1256 l 203 1458 l 446 1458 l 446 1256 l 203 1256 z "},"Ṛ":{"ha":662,"x_min":53,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 m 228 -283 l 228 -81 l 471 -81 l 471 -283 l 228 -283 z "},"Ṝ":{"ha":662,"x_min":53,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 m 228 -283 l 228 -81 l 471 -81 l 471 -283 l 228 -283 m 104 1274 l 104 1378 l 545 1378 l 545 1274 l 104 1274 z "},"Ȓ":{"ha":662,"x_min":53,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 m 73 1267 q 71 1295 71 1280 q 138 1455 71 1405 q 323 1506 205 1506 q 512 1454 446 1506 q 578 1290 578 1403 q 577 1280 578 1286 q 576 1267 577 1274 l 416 1267 q 391 1335 416 1313 q 325 1358 365 1358 q 259 1335 286 1358 q 233 1267 233 1313 l 73 1267 z "},"Ṟ":{"ha":662,"x_min":53,"x_max":636,"o":"m 53 0 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 m 129 -184 l 129 -81 l 570 -81 l 570 -184 l 129 -184 z "},"Ɍ":{"ha":662,"x_min":0,"x_max":636,"o":"m 53 0 l 53 572 l 0 572 l 0 729 l 53 729 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 0 l 53 0 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 z "},"Ɽ":{"ha":662,"x_min":53,"x_max":636,"o":"m 342 -133 q 194 -100 259 -133 q 91 -3 128 -67 q 53 157 53 62 l 53 1194 l 419 1194 q 557 1152 511 1194 q 620 1035 604 1110 q 636 859 636 960 q 611 703 636 762 q 518 623 587 645 q 597 567 574 611 q 620 452 620 522 l 620 0 l 385 0 l 385 467 q 363 532 385 519 q 294 545 342 545 l 294 171 q 308 97 294 113 q 342 81 321 81 l 342 -133 m 296 751 l 353 751 q 403 859 403 751 q 392 951 403 929 q 351 972 381 972 l 296 972 l 296 751 z "},"S":{"ha":641,"x_min":28,"x_max":614,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 z "},"Ś":{"ha":641,"x_min":28,"x_max":614,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 m 156 1230 l 156 1381 l 478 1529 l 478 1293 l 156 1230 z "},"Ṥ":{"ha":641,"x_min":28,"x_max":614,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 m 158 1215 l 158 1346 l 480 1460 l 480 1265 l 158 1215 m 197 1472 l 197 1647 l 440 1647 l 440 1472 l 197 1472 z "},"Ꞌ":{"ha":318,"x_min":37,"x_max":280,"o":"m 85 325 l 37 1194 l 280 1194 l 233 325 l 85 325 z "},"Š":{"ha":641,"x_min":16,"x_max":619,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 m 179 1255 l 16 1529 l 259 1529 l 317 1335 l 376 1529 l 619 1529 l 456 1255 l 179 1255 z "},"Ṧ":{"ha":641,"x_min":28,"x_max":614,"o":"m 197 1441 l 197 1616 l 440 1616 l 440 1441 l 197 1441 m 220 1246 l 59 1419 l 252 1419 l 319 1326 l 387 1419 l 580 1419 l 419 1246 l 220 1246 m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 z "},"Ş":{"ha":641,"x_min":28,"x_max":614,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 m 305 -428 q 171 -401 235 -428 l 171 -250 q 212 -261 192 -256 q 251 -265 233 -265 q 308 -247 285 -265 q 330 -185 330 -229 q 312 -98 330 -147 q 260 0 293 -50 l 369 0 q 471 -129 435 -58 q 507 -262 507 -199 q 459 -380 507 -332 q 305 -428 411 -428 z "},"Ə":{"ha":678,"x_min":43,"x_max":632,"o":"m 339 -11 q 188 20 254 -11 q 84 114 122 52 q 46 270 46 176 l 46 604 l 395 604 l 395 895 q 381 964 395 944 q 339 985 367 985 q 296 960 309 985 q 283 895 283 935 l 283 737 l 43 737 l 43 905 q 123 1134 43 1063 q 345 1204 202 1204 q 553 1124 474 1204 q 632 898 632 1043 l 632 347 q 563 81 632 174 q 339 -11 494 -11 m 339 209 q 384 233 372 209 q 395 297 395 258 l 395 420 l 283 420 l 283 300 q 297 228 283 246 q 339 209 311 209 z "},"Ŝ":{"ha":641,"x_min":16,"x_max":619,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 m 16 1255 l 179 1529 l 456 1529 l 619 1255 l 376 1255 l 317 1449 l 259 1255 l 16 1255 z "},"Ș":{"ha":641,"x_min":28,"x_max":614,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 m 229 -436 l 273 -276 l 187 -276 l 187 -74 l 441 -74 l 441 -270 l 372 -436 l 229 -436 z "},"Ṡ":{"ha":641,"x_min":28,"x_max":614,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 m 196 1256 l 196 1458 l 439 1458 l 439 1256 l 196 1256 z "},"Ṣ":{"ha":641,"x_min":28,"x_max":614,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 m 201 -283 l 201 -81 l 444 -81 l 444 -283 l 201 -283 z "},"Ṩ":{"ha":641,"x_min":28,"x_max":614,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 149 633 q 28 892 28 746 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 462 674 q 538 591 503 635 q 593 489 572 547 q 614 348 614 431 q 552 84 614 180 q 336 -11 490 -11 m 201 -283 l 201 -81 l 444 -81 l 444 -283 l 201 -283 m 196 1256 l 196 1458 l 439 1458 l 439 1256 l 196 1256 z "},"Σ":{"ha":567,"x_min":42,"x_max":539,"o":"m 42 -81 l 42 101 l 271 557 l 42 987 l 42 1194 l 528 1194 l 528 979 l 262 979 l 469 587 l 469 536 l 262 119 l 539 119 l 539 -81 l 42 -81 z "},"Ꞩ":{"ha":641,"x_min":28,"x_max":614,"o":"m 336 -11 q 101 71 173 -11 q 28 330 28 152 l 28 446 l 264 446 l 264 297 q 277 232 264 256 q 321 209 290 209 q 366 228 353 209 q 378 290 378 247 q 368 382 378 345 q 330 453 357 419 q 256 531 303 486 l 239 546 l 43 499 l 43 666 l 104 681 q 28 892 28 775 q 99 1124 28 1044 q 304 1204 170 1204 q 537 1117 469 1204 q 606 851 606 1029 l 363 851 l 363 933 q 350 971 363 958 q 312 985 336 985 q 270 969 283 985 q 257 928 257 953 q 271 873 257 903 q 324 806 284 844 l 385 748 l 593 798 l 593 631 l 520 613 q 588 503 561 565 q 614 348 614 441 q 552 84 614 180 q 336 -11 490 -11 z "},"T":{"ha":549,"x_min":14,"x_max":536,"o":"m 155 0 l 155 964 l 14 964 l 14 1194 l 536 1194 l 536 964 l 394 964 l 394 0 l 155 0 z "},"Ŧ":{"ha":549,"x_min":14,"x_max":536,"o":"m 536 1194 l 536 964 l 394 964 l 394 668 l 493 668 l 493 510 l 394 510 l 394 0 l 155 0 l 155 510 l 52 510 l 52 668 l 155 668 l 155 964 l 14 964 l 14 1194 l 536 1194 z "},"Ť":{"ha":549,"x_min":-27,"x_max":576,"o":"m 155 0 l 155 964 l 14 964 l 14 1194 l 536 1194 l 536 964 l 394 964 l 394 0 l 155 0 m 136 1255 l -27 1529 l 216 1529 l 275 1335 l 333 1529 l 576 1529 l 413 1255 l 136 1255 z "},"Ţ":{"ha":549,"x_min":14,"x_max":536,"o":"m 155 0 l 155 964 l 14 964 l 14 1194 l 536 1194 l 536 964 l 394 964 l 394 0 l 155 0 m 255 -428 q 121 -401 185 -428 l 121 -250 q 162 -261 142 -256 q 201 -265 182 -265 q 257 -247 235 -265 q 280 -185 280 -229 q 261 -98 280 -147 q 210 0 243 -50 l 319 0 q 421 -129 385 -58 q 457 -262 457 -199 q 409 -380 457 -332 q 255 -428 361 -428 z "},"Ṱ":{"ha":549,"x_min":-27,"x_max":576,"o":"m 155 0 l 155 964 l 14 964 l 14 1194 l 536 1194 l 536 964 l 394 964 l 394 0 l 155 0 m -27 -347 l 136 -74 l 413 -74 l 576 -347 l 333 -347 l 275 -154 l 216 -347 l -27 -347 z "},"Ț":{"ha":549,"x_min":14,"x_max":536,"o":"m 155 0 l 155 964 l 14 964 l 14 1194 l 536 1194 l 536 964 l 394 964 l 394 0 l 155 0 m 194 -436 l 239 -276 l 153 -276 l 153 -74 l 406 -74 l 406 -270 l 337 -436 l 194 -436 z "},"Ⱦ":{"ha":549,"x_min":4,"x_max":536,"o":"m 4 -126 l 153 452 l 155 452 l 155 964 l 14 964 l 14 1194 l 378 1194 l 420 1356 l 515 1356 l 473 1194 l 536 1194 l 536 964 l 394 964 l 394 0 l 155 0 l 155 92 l 99 -126 l 4 -126 z "},"Ṫ":{"ha":549,"x_min":14,"x_max":536,"o":"m 155 0 l 155 964 l 14 964 l 14 1194 l 536 1194 l 536 964 l 394 964 l 394 0 l 155 0 m 153 1256 l 153 1458 l 396 1458 l 396 1256 l 153 1256 z "},"Ṭ":{"ha":549,"x_min":14,"x_max":536,"o":"m 155 0 l 155 964 l 14 964 l 14 1194 l 536 1194 l 536 964 l 394 964 l 394 0 l 155 0 m 153 -283 l 153 -81 l 396 -81 l 396 -283 l 153 -283 z "},"Ƭ":{"ha":678,"x_min":-3,"x_max":665,"o":"m 284 0 l 284 964 l 283 964 q 224 940 243 964 q 205 861 205 916 l 205 849 l -3 849 l -3 890 q 28 1047 -3 979 q 123 1155 60 1116 q 282 1194 186 1194 l 665 1194 l 665 964 l 523 964 l 523 0 l 284 0 z "},"Þ":{"ha":642,"x_min":42,"x_max":623,"o":"m 42 0 l 42 1194 l 276 1194 l 276 1028 l 357 1028 q 519 981 462 1028 q 600 851 577 934 q 623 660 623 768 q 604 473 623 556 q 531 342 585 391 q 374 294 477 294 l 277 294 l 277 0 l 42 0 m 277 489 l 290 489 q 366 522 346 489 q 387 656 387 555 q 382 748 387 708 q 360 809 377 787 q 303 831 342 831 l 277 831 l 277 489 z "},"Ṯ":{"ha":549,"x_min":14,"x_max":536,"o":"m 155 0 l 155 964 l 14 964 l 14 1194 l 536 1194 l 536 964 l 394 964 l 394 0 l 155 0 m 54 -184 l 54 -81 l 495 -81 l 495 -184 l 54 -184 z "},"Ʈ":{"ha":549,"x_min":14,"x_max":536,"o":"m 441 -133 q 236 -59 317 -133 q 155 157 155 14 l 155 964 l 14 964 l 14 1194 l 536 1194 l 536 964 l 394 964 l 394 171 q 408 97 394 113 q 441 81 421 81 l 441 -133 z "},"U":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 z "},"Ú":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 168 1230 l 168 1381 l 490 1529 l 490 1293 l 168 1230 z "},"Ʉ":{"ha":705,"x_min":-7,"x_max":712,"o":"m 353 -11 q 133 73 203 -11 q 62 319 62 157 l 62 618 l -7 618 l -7 768 l 62 768 l 62 1194 l 294 1194 l 294 768 l 411 768 l 411 1194 l 643 1194 l 643 768 l 712 768 l 712 618 l 643 618 l 643 319 q 572 73 643 157 q 353 -11 502 -11 m 294 329 q 298 272 294 299 q 313 227 301 244 q 353 209 326 209 q 393 226 380 209 q 408 271 405 243 q 411 329 411 299 l 411 618 l 294 618 l 294 329 z "},"Ŭ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 331 1256 q 139 1306 212 1256 q 65 1467 65 1356 q 67 1495 65 1481 l 241 1495 q 260 1437 241 1457 q 332 1417 280 1417 q 404 1437 385 1417 q 424 1495 424 1457 l 597 1495 q 598 1482 598 1489 q 599 1472 599 1475 q 526 1307 599 1358 q 331 1256 453 1256 z "},"Ǔ":{"ha":658,"x_min":27,"x_max":631,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 191 1255 l 27 1529 l 271 1529 l 329 1335 l 387 1529 l 631 1529 l 467 1255 l 191 1255 z "},"Û":{"ha":658,"x_min":27,"x_max":631,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 27 1255 l 191 1529 l 467 1529 l 631 1255 l 387 1255 l 329 1449 l 271 1255 l 27 1255 z "},"Ṷ":{"ha":658,"x_min":27,"x_max":631,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 27 -347 l 191 -74 l 467 -74 l 631 -347 l 387 -347 l 329 -154 l 271 -347 l 27 -347 z "},"Ȕ":{"ha":658,"x_min":-1,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 195 1252 l -1 1543 l 158 1616 l 308 1291 l 195 1252 m 400 1252 l 232 1543 l 388 1616 l 513 1291 l 400 1252 z "},"Ü":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 367 1261 l 367 1463 l 610 1463 l 610 1261 l 367 1261 m 39 1261 l 39 1463 l 281 1463 l 281 1261 l 39 1261 z "},"Ǘ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 372 1261 l 372 1429 l 614 1429 l 614 1261 l 372 1261 m 43 1261 l 43 1429 l 286 1429 l 286 1261 l 43 1261 m 168 1488 l 168 1619 l 490 1733 l 490 1538 l 168 1488 z "},"Ṳ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 372 -283 l 372 -81 l 614 -81 l 614 -283 l 372 -283 m 43 -283 l 43 -81 l 286 -81 l 286 -283 l 43 -283 z "},"Ǚ":{"ha":658,"x_min":39,"x_max":619,"o":"m 229 1495 l 68 1668 l 262 1668 l 329 1575 l 396 1668 l 589 1668 l 429 1495 l 229 1495 m 372 1259 l 372 1428 l 614 1428 l 614 1259 l 372 1259 m 43 1259 l 43 1428 l 286 1428 l 286 1259 l 43 1259 m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 z "},"Ǜ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 372 1261 l 372 1429 l 614 1429 l 614 1261 l 372 1261 m 43 1261 l 43 1429 l 286 1429 l 286 1261 l 43 1261 m 490 1488 l 168 1538 l 168 1733 l 490 1619 l 490 1488 z "},"Ǖ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 372 1261 l 372 1429 l 614 1429 l 614 1261 l 372 1261 m 43 1261 l 43 1429 l 286 1429 l 286 1261 l 43 1261 m 109 1503 l 109 1607 l 549 1607 l 549 1503 l 109 1503 z "},"Ụ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 208 -283 l 208 -81 l 450 -81 l 450 -283 l 208 -283 z "},"Ù":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 490 1230 l 168 1293 l 168 1529 l 490 1381 l 490 1230 z "},"Ủ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 309 1246 l 237 1330 q 296 1364 274 1343 q 319 1418 319 1384 q 250 1482 319 1482 q 189 1472 218 1482 l 189 1594 q 313 1616 249 1616 q 446 1574 398 1616 q 494 1455 494 1531 q 441 1319 494 1369 q 309 1246 388 1270 z "},"Ư":{"ha":734,"x_min":39,"x_max":741,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 475 1194 q 553 1278 553 1194 l 553 1294 l 741 1294 l 741 1284 q 707 1143 741 1195 q 619 1069 673 1092 l 619 319 q 549 73 619 157 q 329 -11 478 -11 z "},"Ứ":{"ha":734,"x_min":39,"x_max":741,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 475 1194 q 553 1278 553 1194 l 553 1294 l 741 1294 l 741 1284 q 707 1143 741 1195 q 619 1069 673 1092 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 168 1219 l 168 1350 l 490 1463 l 490 1269 l 168 1219 z "},"Ự":{"ha":734,"x_min":39,"x_max":741,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 475 1194 q 553 1278 553 1194 l 553 1294 l 741 1294 l 741 1284 q 707 1143 741 1195 q 619 1069 673 1092 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 208 -283 l 208 -81 l 450 -81 l 450 -283 l 208 -283 z "},"Ừ":{"ha":734,"x_min":39,"x_max":741,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 475 1194 q 553 1278 553 1194 l 553 1294 l 741 1294 l 741 1284 q 707 1143 741 1195 q 619 1069 673 1092 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 490 1219 l 168 1269 l 168 1463 l 490 1350 l 490 1219 z "},"Ử":{"ha":734,"x_min":39,"x_max":741,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 475 1194 q 553 1278 553 1194 l 553 1294 l 741 1294 l 741 1284 q 707 1143 741 1195 q 619 1069 673 1092 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 309 1246 l 237 1330 q 296 1364 274 1343 q 319 1418 319 1384 q 250 1482 319 1482 q 189 1472 218 1482 l 189 1594 q 313 1616 249 1616 q 446 1574 398 1616 q 494 1455 494 1531 q 441 1319 494 1369 q 309 1246 388 1270 z "},"Ữ":{"ha":734,"x_min":39,"x_max":741,"o":"m 407 1249 q 323 1264 357 1249 q 265 1295 290 1280 q 212 1310 239 1310 q 178 1300 194 1310 q 149 1264 163 1290 l 49 1317 q 86 1385 66 1354 q 137 1436 106 1417 q 216 1455 168 1455 q 295 1440 264 1455 q 350 1412 326 1426 q 399 1398 374 1398 q 433 1409 418 1398 q 463 1449 449 1421 l 575 1412 q 539 1332 559 1370 q 489 1272 519 1295 q 407 1249 458 1249 m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 475 1194 q 553 1278 553 1194 l 553 1294 l 741 1294 l 741 1284 q 707 1143 741 1195 q 619 1069 673 1092 l 619 319 q 549 73 619 157 q 329 -11 478 -11 z "},"Ű":{"ha":658,"x_min":39,"x_max":680,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 484 1265 l 372 1305 l 522 1630 l 680 1556 l 484 1265 m 279 1265 l 167 1305 l 292 1630 l 448 1556 l 279 1265 z "},"Ȗ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 77 1267 q 75 1295 75 1280 q 142 1455 75 1405 q 328 1506 209 1506 q 516 1454 450 1506 q 582 1290 582 1403 q 582 1280 582 1286 q 581 1267 581 1274 l 420 1267 q 395 1335 420 1313 q 329 1358 369 1358 q 263 1335 290 1358 q 237 1267 237 1313 l 77 1267 z "},"Ū":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 106 1274 l 106 1378 l 547 1378 l 547 1274 l 106 1274 z "},"Ṻ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 109 1274 l 109 1377 l 549 1377 l 549 1274 l 109 1274 m 372 1444 l 372 1612 l 614 1612 l 614 1444 l 372 1444 m 43 1444 l 43 1612 l 286 1612 l 286 1444 l 43 1444 z "},"Ų":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 334 -428 q 216 -404 269 -428 q 130 -333 162 -379 q 98 -224 98 -288 q 277 0 98 -100 l 420 0 q 347 -86 382 -39 q 311 -189 311 -133 q 389 -265 311 -265 q 468 -250 422 -265 l 468 -401 q 334 -428 404 -428 z "},"Ʊ":{"ha":673,"x_min":32,"x_max":641,"o":"m 336 -11 q 122 61 195 -11 q 49 273 49 134 l 49 650 q 115 964 49 864 l 32 964 l 32 1194 l 314 1194 l 314 964 q 292 933 299 952 q 281 870 284 914 q 279 737 279 825 l 279 258 q 290 198 279 222 q 336 174 301 174 q 383 198 372 174 q 394 258 394 222 l 394 737 q 391 870 394 825 q 381 933 389 914 q 359 964 374 952 l 359 1194 l 641 1194 l 641 964 l 558 964 q 624 650 624 864 l 624 273 q 551 61 624 134 q 336 -11 478 -11 z "},"Ů":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 328 1248 q 154 1309 220 1248 q 89 1477 89 1369 q 154 1645 89 1584 q 328 1706 220 1706 q 503 1645 437 1706 q 568 1477 568 1584 q 503 1309 568 1370 q 328 1248 437 1248 m 329 1371 q 400 1402 374 1371 q 425 1477 425 1433 q 400 1552 425 1521 q 329 1584 374 1584 q 258 1552 283 1584 q 233 1477 233 1521 q 258 1402 233 1433 q 329 1371 283 1371 z "},"Ũ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 441 1269 q 349 1284 391 1269 q 273 1315 307 1300 q 212 1331 239 1331 q 178 1320 194 1331 q 149 1284 163 1310 l 49 1337 q 86 1413 66 1379 q 137 1468 106 1447 q 216 1489 168 1489 q 303 1474 264 1489 q 375 1446 342 1460 q 433 1432 407 1432 q 467 1443 452 1432 q 496 1482 483 1455 l 609 1446 q 573 1360 593 1400 q 523 1294 553 1319 q 441 1269 492 1269 z "},"Ṹ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 441 1249 q 349 1264 391 1249 q 273 1295 307 1280 q 212 1310 239 1310 q 178 1300 194 1310 q 149 1264 163 1290 l 49 1317 q 86 1385 66 1354 q 137 1436 106 1417 q 216 1455 168 1455 q 304 1440 264 1455 q 376 1412 344 1426 q 433 1398 408 1398 q 467 1409 452 1398 q 496 1449 483 1421 l 609 1412 q 573 1332 593 1370 q 523 1272 553 1295 q 441 1249 492 1249 m 168 1495 l 168 1626 l 490 1740 l 490 1545 l 168 1495 z "},"Ṵ":{"ha":658,"x_min":39,"x_max":619,"o":"m 329 -11 q 109 73 180 -11 q 39 319 39 157 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 m 441 -295 q 349 -279 391 -295 q 273 -249 307 -264 q 212 -233 239 -233 q 178 -243 194 -233 q 149 -279 163 -254 l 49 -227 q 86 -151 66 -185 q 137 -96 106 -117 q 216 -75 168 -75 q 303 -90 264 -75 q 375 -118 342 -104 q 433 -132 407 -132 q 467 -121 452 -132 q 496 -81 483 -109 l 609 -118 q 573 -204 593 -163 q 523 -270 553 -245 q 441 -295 492 -295 z "},"V":{"ha":652,"x_min":16,"x_max":635,"o":"m 163 0 l 16 1194 l 243 1194 l 330 382 l 408 1194 l 635 1194 l 488 0 l 163 0 z "},"Ṿ":{"ha":652,"x_min":16,"x_max":635,"o":"m 163 0 l 16 1194 l 243 1194 l 330 382 l 408 1194 l 635 1194 l 488 0 l 163 0 m 205 -283 l 205 -81 l 448 -81 l 448 -283 l 205 -283 z "},"Ʋ":{"ha":618,"x_min":16,"x_max":602,"o":"m 162 0 l 16 1186 l 242 1186 l 329 380 l 382 927 q 383 935 383 931 q 383 943 383 939 q 340 991 383 991 l 340 1195 q 537 1141 473 1195 q 602 964 602 1087 q 596 886 602 930 l 486 0 l 162 0 z "},"Ṽ":{"ha":652,"x_min":16,"x_max":635,"o":"m 163 0 l 16 1194 l 243 1194 l 330 382 l 408 1194 l 635 1194 l 488 0 l 163 0 m 438 1269 q 346 1284 386 1269 q 273 1315 306 1300 q 209 1331 240 1331 q 176 1320 191 1331 q 146 1284 160 1310 l 46 1337 q 83 1413 63 1379 q 134 1468 103 1447 q 214 1489 165 1489 q 302 1474 264 1489 q 373 1446 341 1460 q 431 1432 404 1432 q 465 1443 449 1432 q 494 1482 480 1455 l 606 1446 q 570 1360 590 1400 q 520 1294 551 1319 q 438 1269 489 1269 z "},"Ʌ":{"ha":652,"x_min":16,"x_max":636,"o":"m 489 1194 l 636 -1 l 409 -1 l 321 812 l 243 -1 l 16 -1 l 163 1194 l 489 1194 z "},"W":{"ha":989,"x_min":18,"x_max":970,"o":"m 146 0 l 18 1194 l 252 1194 l 317 440 l 385 1194 l 607 1194 l 671 440 l 734 1194 l 970 1194 l 840 0 l 554 0 l 494 574 l 437 0 l 146 0 z "},"Ẃ":{"ha":989,"x_min":18,"x_max":970,"o":"m 146 0 l 18 1194 l 252 1194 l 317 440 l 385 1194 l 607 1194 l 671 440 l 734 1194 l 970 1194 l 840 0 l 554 0 l 494 574 l 437 0 l 146 0 m 342 1230 l 342 1381 l 665 1529 l 665 1293 l 342 1230 z "},"Ŵ":{"ha":989,"x_min":18,"x_max":970,"o":"m 146 0 l 18 1194 l 252 1194 l 317 440 l 385 1194 l 607 1194 l 671 440 l 734 1194 l 970 1194 l 840 0 l 554 0 l 494 574 l 437 0 l 146 0 m 202 1255 l 366 1529 l 642 1529 l 806 1255 l 562 1255 l 504 1449 l 446 1255 l 202 1255 z "},"Ẅ":{"ha":989,"x_min":18,"x_max":970,"o":"m 146 0 l 18 1194 l 252 1194 l 317 440 l 385 1194 l 607 1194 l 671 440 l 734 1194 l 970 1194 l 840 0 l 554 0 l 494 574 l 437 0 l 146 0 m 542 1261 l 542 1463 l 785 1463 l 785 1261 l 542 1261 m 214 1261 l 214 1463 l 456 1463 l 456 1261 l 214 1261 z "},"Ẇ":{"ha":989,"x_min":18,"x_max":970,"o":"m 146 0 l 18 1194 l 252 1194 l 317 440 l 385 1194 l 607 1194 l 671 440 l 734 1194 l 970 1194 l 840 0 l 554 0 l 494 574 l 437 0 l 146 0 m 382 1256 l 382 1458 l 625 1458 l 625 1256 l 382 1256 z "},"Ẉ":{"ha":989,"x_min":18,"x_max":970,"o":"m 146 0 l 18 1194 l 252 1194 l 317 440 l 385 1194 l 607 1194 l 671 440 l 734 1194 l 970 1194 l 840 0 l 554 0 l 494 574 l 437 0 l 146 0 m 373 -283 l 373 -81 l 616 -81 l 616 -283 l 373 -283 z "},"Ẁ":{"ha":989,"x_min":18,"x_max":970,"o":"m 146 0 l 18 1194 l 252 1194 l 317 440 l 385 1194 l 607 1194 l 671 440 l 734 1194 l 970 1194 l 840 0 l 554 0 l 494 574 l 437 0 l 146 0 m 665 1230 l 342 1293 l 342 1529 l 665 1381 l 665 1230 z "},"Ⱳ":{"ha":1014,"x_min":18,"x_max":1021,"o":"m 146 0 l 18 1194 l 252 1194 l 318 439 l 385 1194 l 608 1194 l 673 439 l 716 961 q 797 1146 727 1088 q 1021 1204 867 1204 l 1021 998 q 959 972 973 998 q 939 892 945 947 l 842 0 l 555 0 l 495 574 l 438 0 l 146 0 z "},"X":{"ha":672,"x_min":18,"x_max":654,"o":"m 18 0 l 146 633 l 45 1194 l 278 1194 l 340 784 l 395 1194 l 629 1194 l 527 633 l 654 0 l 413 0 l 338 467 l 260 0 l 18 0 z "},"Ẍ":{"ha":672,"x_min":18,"x_max":654,"o":"m 18 0 l 146 633 l 45 1194 l 278 1194 l 340 784 l 395 1194 l 629 1194 l 527 633 l 654 0 l 413 0 l 338 467 l 260 0 l 18 0 m 374 1261 l 374 1463 l 617 1463 l 617 1261 l 374 1261 m 46 1261 l 46 1463 l 289 1463 l 289 1261 l 46 1261 z "},"Ẋ":{"ha":672,"x_min":18,"x_max":654,"o":"m 18 0 l 146 633 l 45 1194 l 278 1194 l 340 784 l 395 1194 l 629 1194 l 527 633 l 654 0 l 413 0 l 338 467 l 260 0 l 18 0 m 215 1256 l 215 1458 l 458 1458 l 458 1256 l 215 1256 z "},"Y":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 z "},"Ý":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 m 148 1230 l 148 1381 l 470 1529 l 470 1293 l 148 1230 z "},"Ŷ":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 m 7 1255 l 171 1529 l 448 1529 l 611 1255 l 368 1255 l 309 1449 l 251 1255 l 7 1255 z "},"Ÿ":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 m 347 1261 l 347 1463 l 590 1463 l 590 1261 l 347 1261 m 19 1261 l 19 1463 l 262 1463 l 262 1261 l 19 1261 z "},"Ẏ":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 m 188 1256 l 188 1431 l 431 1431 l 431 1256 l 188 1256 z "},"Ỵ":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 m 189 -283 l 189 -81 l 431 -81 l 431 -283 l 189 -283 z "},"Ỳ":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 m 470 1230 l 148 1293 l 148 1529 l 470 1381 l 470 1230 z "},"Ƴ":{"ha":633,"x_min":7,"x_max":640,"o":"m 196 0 l 196 399 l 7 1194 l 243 1194 l 310 790 l 338 963 q 385 1100 353 1046 q 478 1178 416 1153 q 640 1203 539 1203 l 640 999 q 574 974 593 999 q 541 895 555 949 l 422 399 l 422 0 l 196 0 z "},"Ỷ":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 m 290 1246 l 218 1330 q 277 1364 254 1343 q 299 1418 299 1384 q 231 1482 299 1482 q 170 1472 199 1482 l 170 1594 q 294 1616 229 1616 q 426 1574 378 1616 q 474 1455 474 1531 q 421 1319 474 1369 q 290 1246 368 1270 z "},"Ȳ":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 m 90 1274 l 90 1378 l 530 1378 l 530 1274 l 90 1274 z "},"Ɏ":{"ha":619,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 115 736 l 11 736 l 11 886 l 80 886 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 539 886 l 608 886 l 608 736 l 504 736 l 422 393 l 422 0 l 197 0 z "},"Ỹ":{"ha":620,"x_min":7,"x_max":612,"o":"m 197 0 l 197 393 l 7 1194 l 243 1194 l 310 789 l 376 1194 l 612 1194 l 422 393 l 422 0 l 197 0 m 421 1269 q 329 1284 371 1269 q 254 1315 288 1300 q 192 1331 220 1331 q 159 1320 174 1331 q 130 1284 143 1310 l 29 1337 q 66 1413 46 1379 q 117 1468 86 1447 q 197 1489 149 1489 q 284 1474 245 1489 q 355 1446 323 1460 q 414 1432 387 1432 q 448 1443 432 1432 q 477 1482 463 1455 l 589 1446 q 553 1360 573 1400 q 503 1294 534 1319 q 421 1269 472 1269 z "},"Z":{"ha":570,"x_min":22,"x_max":547,"o":"m 22 0 l 22 217 l 295 974 l 48 974 l 48 1194 l 547 1194 l 547 985 l 269 220 l 535 220 l 535 0 l 22 0 z "},"Ź":{"ha":570,"x_min":22,"x_max":547,"o":"m 22 0 l 22 217 l 295 974 l 48 974 l 48 1194 l 547 1194 l 547 985 l 269 220 l 535 220 l 535 0 l 22 0 m 136 1230 l 136 1381 l 458 1529 l 458 1293 l 136 1230 z "},"Ž":{"ha":570,"x_min":-4,"x_max":600,"o":"m 22 0 l 22 217 l 295 974 l 48 974 l 48 1194 l 547 1194 l 547 985 l 269 220 l 535 220 l 535 0 l 22 0 m 159 1255 l -4 1529 l 239 1529 l 298 1335 l 356 1529 l 600 1529 l 436 1255 l 159 1255 z "},"Ẑ":{"ha":570,"x_min":-4,"x_max":600,"o":"m 22 0 l 22 217 l 295 974 l 48 974 l 48 1194 l 547 1194 l 547 985 l 269 220 l 535 220 l 535 0 l 22 0 m -4 1255 l 159 1529 l 436 1529 l 600 1255 l 356 1255 l 298 1449 l 239 1255 l -4 1255 z "},"Ż":{"ha":570,"x_min":22,"x_max":547,"o":"m 22 0 l 22 217 l 295 974 l 48 974 l 48 1194 l 547 1194 l 547 985 l 269 220 l 535 220 l 535 0 l 22 0 m 176 1256 l 176 1458 l 419 1458 l 419 1256 l 176 1256 z "},"Ẓ":{"ha":570,"x_min":22,"x_max":547,"o":"m 22 0 l 22 217 l 295 974 l 48 974 l 48 1194 l 547 1194 l 547 985 l 269 220 l 535 220 l 535 0 l 22 0 m 163 -283 l 163 -81 l 406 -81 l 406 -283 l 163 -283 z "},"Ẕ":{"ha":570,"x_min":22,"x_max":547,"o":"m 22 0 l 22 217 l 295 974 l 48 974 l 48 1194 l 547 1194 l 547 985 l 269 220 l 535 220 l 535 0 l 22 0 m 64 -184 l 64 -81 l 505 -81 l 505 -184 l 64 -184 z "},"Ƶ":{"ha":570,"x_min":22,"x_max":547,"o":"m 22 0 l 22 217 l 135 530 l 64 530 l 64 688 l 192 688 l 295 974 l 48 974 l 48 1194 l 547 1194 l 547 985 l 439 688 l 512 688 l 512 530 l 381 530 l 269 220 l 535 220 l 535 0 l 22 0 z "},"a":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 z "},"á":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 180 1064 l 180 1215 l 502 1363 l 502 1128 l 180 1064 z "},"ă":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 343 1090 q 151 1141 224 1090 q 77 1301 77 1191 q 79 1330 77 1316 l 253 1330 q 273 1271 253 1291 q 345 1251 292 1251 q 416 1271 397 1251 q 436 1330 436 1291 l 610 1330 q 611 1316 610 1323 q 611 1306 611 1310 q 538 1142 611 1193 q 343 1090 465 1090 z "},"ắ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 340 1080 q 148 1125 222 1080 q 75 1270 75 1171 q 77 1299 75 1284 l 250 1299 q 270 1235 250 1257 q 342 1213 290 1213 q 414 1235 394 1213 q 433 1299 433 1257 l 607 1299 q 608 1275 608 1282 q 535 1126 608 1173 q 340 1080 463 1080 m 181 1323 l 181 1454 l 503 1568 l 503 1373 l 181 1323 z "},"ặ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 214 -283 l 214 -81 l 456 -81 l 456 -283 l 214 -283 m 343 1090 q 151 1141 224 1090 q 77 1301 77 1191 q 79 1330 77 1316 l 253 1330 q 273 1271 253 1291 q 345 1251 292 1251 q 416 1271 397 1251 q 436 1330 436 1291 l 610 1330 q 611 1316 610 1323 q 611 1306 611 1310 q 538 1142 611 1193 q 343 1090 465 1090 z "},"ằ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 502 1331 l 180 1375 l 180 1569 l 502 1442 l 502 1331 m 341 1073 q 148 1118 222 1073 q 75 1263 75 1164 q 77 1292 75 1278 l 250 1292 q 270 1228 250 1250 q 341 1206 290 1206 q 413 1228 393 1206 q 432 1292 432 1250 l 606 1292 q 607 1278 606 1285 q 607 1268 607 1272 q 535 1119 607 1166 q 341 1073 463 1073 z "},"ẳ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 320 1297 l 248 1381 q 307 1415 285 1395 q 330 1470 330 1436 q 261 1534 330 1534 q 200 1523 229 1534 l 200 1645 q 324 1668 260 1668 q 457 1625 409 1668 q 505 1506 505 1583 q 452 1371 505 1420 q 320 1297 399 1322 m 341 1073 q 148 1118 222 1073 q 75 1263 75 1164 q 77 1292 75 1278 l 250 1292 q 270 1228 250 1250 q 341 1206 290 1206 q 413 1228 393 1206 q 432 1292 432 1250 l 606 1292 q 607 1278 606 1285 q 607 1268 607 1272 q 535 1119 607 1166 q 341 1073 463 1073 z "},"ẵ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 453 1335 q 377 1351 412 1335 q 307 1382 341 1367 q 237 1397 273 1397 q 197 1387 216 1397 q 161 1351 178 1377 l 61 1404 q 117 1504 85 1462 q 217 1546 149 1546 q 295 1531 259 1546 q 363 1500 330 1516 q 433 1485 397 1485 q 475 1496 458 1485 q 509 1535 492 1508 l 621 1499 q 585 1419 605 1457 q 535 1358 566 1381 q 453 1335 504 1335 m 341 1073 q 148 1118 222 1073 q 75 1263 75 1164 q 77 1292 75 1278 l 250 1292 q 270 1228 250 1250 q 341 1206 290 1206 q 413 1228 393 1206 q 432 1292 432 1250 l 606 1292 q 607 1278 606 1285 q 607 1268 607 1272 q 535 1119 607 1166 q 341 1073 463 1073 z "},"ǎ":{"ha":671,"x_min":28,"x_max":643,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 203 1090 l 39 1363 l 283 1363 l 341 1170 l 399 1363 l 643 1363 l 479 1090 l 203 1090 z "},"â":{"ha":671,"x_min":28,"x_max":643,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 39 1090 l 203 1363 l 479 1363 l 643 1090 l 399 1090 l 341 1283 l 283 1090 l 39 1090 z "},"ấ":{"ha":671,"x_min":28,"x_max":873,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 554 1242 l 665 1442 l 873 1442 l 712 1242 l 554 1242 m 39 1079 l 203 1284 l 479 1284 l 643 1079 l 402 1079 l 341 1211 l 280 1079 l 39 1079 z "},"ậ":{"ha":671,"x_min":28,"x_max":643,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 39 1090 l 203 1363 l 479 1363 l 643 1090 l 399 1090 l 341 1283 l 283 1090 l 39 1090 m 214 -283 l 214 -81 l 456 -81 l 456 -283 l 214 -283 z "},"ầ":{"ha":671,"x_min":28,"x_max":751,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 593 1242 l 432 1442 l 640 1442 l 751 1242 l 593 1242 m 39 1079 l 203 1284 l 479 1284 l 643 1079 l 402 1079 l 341 1211 l 280 1079 l 39 1079 z "},"ẩ":{"ha":671,"x_min":28,"x_max":770,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 586 1219 l 514 1303 q 573 1337 551 1316 q 595 1391 595 1357 q 527 1455 595 1455 q 466 1444 495 1455 l 466 1567 q 590 1589 526 1589 q 723 1547 675 1589 q 770 1428 770 1504 q 718 1292 770 1341 q 586 1219 665 1243 m 73 1079 l 223 1291 l 459 1291 l 609 1079 l 402 1079 l 341 1211 l 280 1079 l 73 1079 z "},"ẫ":{"ha":671,"x_min":28,"x_max":643,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 453 1335 q 377 1351 412 1335 q 307 1382 341 1367 q 237 1397 273 1397 q 197 1387 216 1397 q 161 1351 178 1377 l 61 1404 q 117 1504 85 1462 q 217 1546 149 1546 q 295 1531 259 1546 q 363 1500 330 1516 q 433 1485 397 1485 q 475 1496 458 1485 q 509 1535 492 1508 l 621 1499 q 585 1419 605 1457 q 535 1358 566 1381 q 453 1335 504 1335 m 39 1079 l 203 1284 l 479 1284 l 643 1079 l 402 1079 l 341 1211 l 280 1079 l 39 1079 z "},"´":{"ha":441,"x_min":62,"x_max":384,"o":"m 62 1053 l 62 1204 l 384 1352 l 384 1117 l 62 1053 z "},"́":{"ha":0,"x_min":-161,"x_max":161,"o":"m -161 1053 l -161 1204 l 161 1352 l 161 1117 l -161 1053 z "},"᷇":{"ha":0,"x_min":-221,"x_max":220,"o":"m -221 1371 l -221 1475 l 220 1475 l 220 1371 l -221 1371 m -161 1053 l -161 1204 l 161 1352 l 161 1117 l -161 1053 z "},"ȁ":{"ha":671,"x_min":12,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 208 1086 l 12 1377 l 170 1451 l 320 1126 l 208 1086 m 412 1086 l 244 1377 l 400 1451 l 525 1126 l 412 1086 z "},"ä":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 379 1095 l 379 1297 l 622 1297 l 622 1095 l 379 1095 m 51 1095 l 51 1297 l 294 1297 l 294 1095 l 51 1095 z "},"ǟ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 384 1084 l 384 1253 l 627 1253 l 627 1084 l 384 1084 m 56 1084 l 56 1253 l 298 1253 l 298 1084 l 56 1084 m 121 1326 l 121 1430 l 562 1430 l 562 1326 l 121 1326 z "},"ȧ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 220 1090 l 220 1293 l 463 1293 l 463 1090 l 220 1090 z "},"ạ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 214 -283 l 214 -81 l 456 -81 l 456 -283 l 214 -283 z "},"ǡ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 220 1080 l 220 1255 l 463 1255 l 463 1080 l 220 1080 m 121 1314 l 121 1418 l 562 1418 l 562 1314 l 121 1314 z "},"æ":{"ha":1015,"x_min":26,"x_max":981,"o":"m 304 -12 q 97 70 169 -12 q 26 292 26 151 q 52 466 26 404 q 131 563 79 529 q 258 623 182 597 l 380 665 l 380 734 q 368 815 380 790 q 328 840 355 840 q 277 785 277 840 l 277 716 l 41 716 q 41 730 41 722 q 41 749 41 739 q 107 965 41 901 q 299 1029 174 1029 q 432 1009 385 1029 q 507 947 479 988 q 582 1009 534 988 q 708 1029 629 1029 q 910 957 840 1029 q 981 741 981 885 l 981 667 q 980 551 981 598 q 978 477 979 503 l 625 477 l 625 335 q 639 214 625 251 q 686 176 653 176 q 728 204 716 176 q 739 307 739 232 l 739 393 l 981 393 l 981 335 q 957 148 981 226 q 872 29 932 71 q 703 -12 812 -12 q 580 20 631 -12 q 507 100 528 52 q 432 19 484 51 q 304 -12 380 -12 m 625 631 l 739 631 l 739 737 q 685 847 739 847 q 632 809 640 847 q 625 713 625 772 l 625 631 m 328 178 q 368 203 357 178 q 379 257 379 228 l 379 525 q 301 475 329 505 q 273 387 273 446 l 273 268 q 328 178 273 178 z "},"ǽ":{"ha":1015,"x_min":26,"x_max":981,"o":"m 304 -12 q 97 70 169 -12 q 26 292 26 151 q 52 466 26 404 q 131 563 79 529 q 258 623 182 597 l 380 665 l 380 734 q 368 815 380 790 q 328 840 355 840 q 277 785 277 840 l 277 716 l 41 716 q 41 730 41 722 q 41 749 41 739 q 107 965 41 901 q 299 1029 174 1029 q 432 1009 385 1029 q 507 947 479 988 q 582 1009 534 988 q 708 1029 629 1029 q 910 957 840 1029 q 981 741 981 885 l 981 667 q 980 551 981 598 q 978 477 979 503 l 625 477 l 625 335 q 639 214 625 251 q 686 176 653 176 q 728 204 716 176 q 739 307 739 232 l 739 393 l 981 393 l 981 335 q 957 148 981 226 q 872 29 932 71 q 703 -12 812 -12 q 580 20 631 -12 q 507 100 528 52 q 432 19 484 51 q 304 -12 380 -12 m 625 631 l 739 631 l 739 737 q 685 847 739 847 q 632 809 640 847 q 625 713 625 772 l 625 631 m 328 178 q 368 203 357 178 q 379 257 379 228 l 379 525 q 301 475 329 505 q 273 387 273 446 l 273 268 q 328 178 273 178 m 347 1053 l 347 1204 l 669 1352 l 669 1117 l 347 1053 z "},"ǣ":{"ha":1015,"x_min":26,"x_max":981,"o":"m 304 -12 q 97 70 169 -12 q 26 292 26 151 q 52 466 26 404 q 131 563 79 529 q 258 623 182 597 l 380 665 l 380 734 q 368 815 380 790 q 328 840 355 840 q 277 785 277 840 l 277 716 l 41 716 q 41 730 41 722 q 41 749 41 739 q 107 965 41 901 q 299 1029 174 1029 q 432 1009 385 1029 q 507 947 479 988 q 582 1009 534 988 q 708 1029 629 1029 q 910 957 840 1029 q 981 741 981 885 l 981 667 q 980 551 981 598 q 978 477 979 503 l 625 477 l 625 335 q 639 214 625 251 q 686 176 653 176 q 728 204 716 176 q 739 307 739 232 l 739 393 l 981 393 l 981 335 q 957 148 981 226 q 872 29 932 71 q 703 -12 812 -12 q 580 20 631 -12 q 507 100 528 52 q 432 19 484 51 q 304 -12 380 -12 m 625 631 l 739 631 l 739 737 q 685 847 739 847 q 632 809 640 847 q 625 713 625 772 l 625 631 m 328 178 q 368 203 357 178 q 379 257 379 228 l 379 525 q 301 475 329 505 q 273 387 273 446 l 273 268 q 328 178 273 178 m 287 1098 l 287 1202 l 728 1202 l 728 1098 l 287 1098 z "},"à":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 502 1064 l 180 1128 l 180 1363 l 502 1215 l 502 1064 z "},"ả":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 321 1069 l 250 1154 q 309 1187 286 1167 q 331 1242 331 1208 q 262 1306 331 1306 q 201 1295 231 1306 l 201 1417 q 326 1440 261 1440 q 458 1397 410 1440 q 506 1278 506 1355 q 453 1143 506 1192 q 321 1069 400 1094 z "},"ȃ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 90 1101 q 87 1129 87 1115 q 154 1290 87 1240 q 340 1340 221 1340 q 528 1289 462 1340 q 594 1124 594 1238 q 594 1115 594 1121 q 593 1101 593 1108 l 433 1101 q 407 1170 433 1147 q 341 1192 381 1192 q 276 1170 302 1192 q 250 1101 250 1147 l 90 1101 z "},"ɑ":{"ha":697,"x_min":41,"x_max":697,"o":"m 249 -11 q 137 15 178 -11 q 74 86 95 41 q 47 193 54 132 q 41 323 41 254 l 41 694 q 47 825 41 764 q 74 931 54 886 q 137 1002 95 977 q 249 1028 178 1028 q 346 996 313 1028 q 400 909 380 964 l 400 1017 l 643 1017 l 643 293 q 657 219 643 235 q 697 203 672 203 l 697 -11 q 419 98 500 -11 q 359 21 397 54 q 249 -11 320 -11 m 342 179 q 387 211 374 179 q 400 307 400 243 l 400 719 q 386 810 400 781 q 342 838 372 838 q 298 810 313 838 q 283 718 283 781 l 283 307 q 342 179 283 179 z "},"ā":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 118 1109 l 118 1213 l 559 1213 l 559 1109 l 118 1109 z "},"&":{"ha":722,"x_min":24,"x_max":702,"o":"m 262 -14 q 87 72 151 -14 q 24 309 24 158 q 43 488 24 417 q 97 607 62 559 q 176 690 132 654 l 171 703 q 121 838 142 774 q 100 970 100 902 q 129 1091 100 1038 q 210 1174 158 1144 q 329 1204 262 1204 q 450 1176 395 1204 q 537 1089 505 1147 q 570 943 570 1031 q 534 783 570 848 q 427 659 498 719 l 492 495 q 608 652 532 596 l 702 505 q 570 299 623 441 l 690 0 l 459 0 l 433 64 q 362 9 406 32 q 262 -14 317 -14 m 313 991 q 321 939 313 973 q 363 821 330 905 q 386 863 376 834 q 396 943 396 892 q 384 1017 396 996 q 351 1038 371 1038 q 322 1023 331 1038 q 313 991 313 1008 m 231 280 q 300 159 231 159 q 345 180 328 159 q 368 223 361 201 l 254 500 q 231 334 231 453 l 231 280 z "},"ą":{"ha":671,"x_min":28,"x_max":636,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 502 -428 q 384 -404 437 -428 q 298 -333 330 -379 q 266 -224 266 -288 q 445 0 266 -100 l 588 0 q 511 -89 542 -44 q 479 -189 479 -133 q 557 -265 479 -265 q 636 -250 591 -265 l 636 -401 q 502 -428 572 -428 z "},"ʼ":{"ha":407,"x_min":83,"x_max":336,"o":"m 124 655 l 169 815 l 83 815 l 83 1017 l 336 1017 l 336 821 l 267 655 l 124 655 z "},"≈":{"ha":684,"x_min":34,"x_max":681,"o":"m 496 549 q 409 559 449 549 q 328 585 370 568 q 259 609 286 601 q 212 617 231 617 q 176 606 193 617 q 144 566 159 595 l 34 625 q 75 707 52 669 q 131 767 97 745 q 217 789 164 789 q 308 781 271 789 q 389 755 344 772 q 451 734 429 740 q 488 728 472 728 q 526 740 509 728 q 557 783 543 752 l 681 743 q 641 649 663 693 q 586 577 620 604 q 496 549 553 549 m 496 231 q 409 240 449 231 q 328 266 370 250 q 259 290 286 282 q 212 298 231 298 q 176 287 193 298 q 144 248 159 276 l 34 306 q 75 388 52 351 q 131 448 97 426 q 217 471 164 471 q 308 462 271 471 q 389 436 344 454 q 451 415 429 421 q 488 409 472 409 q 526 421 509 409 q 557 465 543 433 l 681 424 q 641 330 663 374 q 586 258 620 286 q 496 231 553 231 z "},"å":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 340 1082 q 166 1143 232 1082 q 101 1312 101 1204 q 166 1480 101 1419 q 340 1541 232 1541 q 515 1480 450 1541 q 581 1312 581 1419 q 515 1143 581 1204 q 340 1082 450 1082 m 341 1205 q 412 1236 387 1205 q 437 1312 437 1267 q 412 1387 437 1356 q 341 1418 387 1418 q 270 1387 296 1418 q 245 1312 245 1356 q 270 1236 245 1267 q 341 1205 296 1205 z "},"ǻ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 341 1072 q 167 1128 233 1072 q 102 1287 102 1185 q 167 1446 102 1388 q 341 1503 233 1503 q 516 1446 450 1503 q 581 1287 581 1388 q 516 1129 581 1187 q 341 1072 450 1072 m 342 1194 q 413 1221 387 1194 q 438 1287 438 1249 q 413 1353 438 1326 q 342 1380 387 1380 q 271 1353 296 1380 q 245 1287 245 1326 q 271 1221 245 1249 q 342 1194 296 1194 m 180 1528 l 180 1659 l 503 1773 l 503 1578 l 180 1528 z "},"ḁ":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 334 -429 q 160 -372 226 -429 q 95 -214 95 -315 q 160 -55 95 -113 q 334 2 226 2 q 509 -55 444 2 q 574 -214 574 -113 q 509 -372 574 -314 q 334 -429 444 -429 m 335 -307 q 406 -279 380 -307 q 431 -214 431 -252 q 406 -148 431 -175 q 335 -121 380 -121 q 264 -148 290 -121 q 239 -214 239 -175 q 264 -279 239 -252 q 335 -307 290 -307 z "},"^":{"ha":658,"x_min":27,"x_max":631,"o":"m 27 293 l 191 919 l 467 919 l 631 293 l 387 293 l 329 696 l 271 293 l 27 293 z "},"~":{"ha":684,"x_min":34,"x_max":681,"o":"m 496 549 q 409 559 449 549 q 328 585 370 568 q 259 609 286 601 q 212 617 231 617 q 176 606 193 617 q 144 566 159 595 l 34 625 q 75 707 52 669 q 131 767 97 745 q 217 789 164 789 q 308 781 271 789 q 389 755 344 772 q 451 734 429 740 q 488 728 472 728 q 526 740 509 728 q 557 783 543 752 l 681 743 q 641 649 663 693 q 586 577 620 604 q 496 549 553 549 z "},"*":{"ha":628,"x_min":24,"x_max":604,"o":"m 235 503 l 265 707 l 103 579 l 24 715 l 210 794 l 24 868 l 103 1004 l 264 882 l 235 1080 l 393 1080 l 369 886 l 525 1004 l 604 868 l 417 794 l 604 715 l 525 579 l 368 703 l 393 503 l 235 503 z "},"ⱥ":{"ha":671,"x_min":28,"x_max":627,"o":"m 68 -126 l 108 26 q 44 134 60 64 q 28 292 28 203 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 369 1027 355 1028 l 411 1194 l 506 1194 l 460 1010 q 581 926 535 985 q 627 775 627 867 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 q 194 -8 213 -11 l 163 -126 l 68 -126 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 z "},"@":{"ha":1200,"x_min":43,"x_max":1161,"o":"m 623 -107 q 398 -72 503 -107 q 214 38 294 -37 q 89 235 134 114 q 43 527 43 355 q 113 891 43 740 q 314 1124 183 1043 q 629 1204 446 1204 q 923 1132 804 1204 q 1101 923 1041 1059 q 1161 598 1161 787 q 1101 294 1161 400 q 901 188 1040 188 q 754 229 802 188 q 683 333 707 270 q 638 232 671 271 q 549 193 605 193 q 437 240 482 193 q 369 362 391 286 q 346 525 346 437 q 364 704 346 623 q 425 833 382 785 q 541 881 467 881 q 622 855 590 881 q 680 786 654 829 l 706 875 l 859 875 l 859 441 q 876 365 859 388 q 920 342 892 342 q 979 407 964 342 q 994 595 994 471 q 961 834 994 734 q 851 988 928 934 q 644 1042 775 1042 q 341 908 444 1042 q 237 525 237 774 q 346 171 237 290 q 633 53 454 53 q 814 67 706 53 l 835 -86 q 623 -107 715 -107 m 612 361 q 655 393 644 361 q 666 463 666 425 l 666 728 q 600 711 624 728 q 566 652 576 694 q 556 531 556 609 q 561 452 556 491 q 578 387 566 412 q 612 361 591 361 z "},"ã":{"ha":671,"x_min":28,"x_max":627,"o":"m 234 -11 q 105 28 149 -11 q 44 136 60 68 q 28 292 28 205 q 46 444 28 385 q 109 541 64 503 q 231 606 153 579 l 382 657 l 382 762 q 328 844 382 844 q 279 777 279 844 l 279 716 l 43 716 q 43 730 43 722 q 43 749 43 739 q 114 965 43 901 q 341 1028 186 1028 q 487 999 422 1028 q 589 914 551 970 q 627 775 627 858 l 627 0 l 385 0 l 385 121 q 327 23 368 57 q 234 -11 286 -11 m 330 178 q 370 203 359 178 q 381 257 381 228 l 381 541 q 303 489 331 520 q 275 399 275 458 l 275 268 q 330 178 275 178 m 453 1103 q 361 1119 401 1103 q 288 1150 321 1135 q 224 1165 255 1165 q 191 1155 206 1165 q 161 1119 175 1145 l 61 1172 q 98 1247 78 1213 q 149 1302 118 1282 q 229 1323 180 1323 q 317 1309 279 1323 q 388 1280 356 1295 q 446 1266 419 1266 q 479 1278 464 1266 q 509 1317 495 1289 l 621 1280 q 585 1194 605 1235 q 535 1128 566 1154 q 453 1103 504 1103 z "},"b":{"ha":696,"x_min":52,"x_max":656,"o":"m 455 -11 q 358 19 395 -11 q 298 109 321 48 l 298 0 l 52 0 l 52 1194 l 298 1194 l 298 909 q 360 997 321 965 q 474 1028 400 1028 q 615 956 574 1028 q 656 766 656 883 l 656 265 q 634 124 656 187 q 569 25 613 62 q 455 -11 524 -11 m 355 178 q 401 216 393 178 q 410 310 410 254 l 410 707 q 401 801 410 764 q 355 839 393 839 q 307 801 316 839 q 298 707 298 762 l 298 310 q 307 217 298 255 q 355 178 316 178 z "},"\\\\":{"ha":563,"x_min":18,"x_max":543,"o":"m 297 0 l 18 1198 l 265 1198 l 543 0 l 297 0 z "},"|":{"ha":300,"x_min":42,"x_max":258,"o":"m 42 -57 l 42 1324 l 258 1324 l 258 -57 l 42 -57 z "},"ḃ":{"ha":696,"x_min":52,"x_max":656,"o":"m 455 -11 q 358 19 395 -11 q 298 109 321 48 l 298 0 l 52 0 l 52 1194 l 298 1194 l 298 909 q 360 997 321 965 q 474 1028 400 1028 q 615 956 574 1028 q 656 766 656 883 l 656 265 q 634 124 656 187 q 569 25 613 62 q 455 -11 524 -11 m 355 178 q 401 216 393 178 q 410 310 410 254 l 410 707 q 401 801 410 764 q 355 839 393 839 q 307 801 316 839 q 298 707 298 762 l 298 310 q 307 217 298 255 q 355 178 316 178 m 370 1098 l 370 1300 l 613 1300 l 613 1098 l 370 1098 z "},"ḅ":{"ha":696,"x_min":52,"x_max":656,"o":"m 455 -11 q 358 19 395 -11 q 298 109 321 48 l 298 0 l 52 0 l 52 1194 l 298 1194 l 298 909 q 360 997 321 965 q 474 1028 400 1028 q 615 956 574 1028 q 656 766 656 883 l 656 265 q 634 124 656 187 q 569 25 613 62 q 455 -11 524 -11 m 355 178 q 401 216 393 178 q 410 310 410 254 l 410 707 q 401 801 410 764 q 355 839 393 839 q 307 801 316 839 q 298 707 298 762 l 298 310 q 307 217 298 255 q 355 178 316 178 m 227 -283 l 227 -81 l 470 -81 l 470 -283 l 227 -283 z "},"ꞵ":{"ha":683,"x_min":39,"x_max":657,"o":"m 39 -170 l 39 958 q 328 1204 39 1204 q 538 1147 459 1204 q 616 958 616 1090 l 616 878 q 593 758 616 807 q 515 692 570 709 q 629 591 601 671 q 657 379 657 511 q 585 84 657 174 q 382 -7 512 -7 q 277 10 319 -7 l 277 -170 l 39 -170 m 277 213 q 296 174 277 188 q 348 161 316 161 q 400 177 380 161 q 421 228 421 194 l 421 496 q 399 573 421 551 q 321 595 377 595 l 321 764 q 368 787 357 764 q 378 844 378 810 l 378 985 q 328 1037 378 1037 q 277 985 277 1037 l 277 213 z "},"ɓ":{"ha":696,"x_min":49,"x_max":656,"o":"m 455 -11 q 358 19 395 -11 q 298 109 321 48 l 298 0 l 49 0 l 49 901 q 82 1058 49 989 q 185 1165 115 1126 q 369 1204 256 1204 l 369 1017 q 315 995 331 1017 q 298 928 298 972 l 298 842 q 360 930 321 899 q 474 962 400 962 q 615 889 574 962 q 656 699 656 817 l 656 265 q 634 124 656 187 q 569 25 613 62 q 455 -11 524 -11 m 355 178 q 401 216 393 178 q 410 310 410 254 l 410 641 q 401 735 410 697 q 355 772 393 772 q 307 734 316 772 q 298 641 298 696 l 298 310 q 307 217 298 255 q 355 178 316 178 z "},"ʘ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 307 427 l 307 606 l 382 606 l 382 427 l 307 427 z "},"◆":{"ha":1006,"x_min":27,"x_max":979,"o":"m 503 35 l 27 513 l 503 990 l 979 513 l 503 35 z "},"■":{"ha":1120,"x_min":53,"x_max":1067,"o":"m 53 0 l 53 1017 l 1067 1017 l 1067 0 l 53 0 z "},"ḇ":{"ha":696,"x_min":52,"x_max":656,"o":"m 455 -11 q 358 19 395 -11 q 298 109 321 48 l 298 0 l 52 0 l 52 1194 l 298 1194 l 298 909 q 360 997 321 965 q 474 1028 400 1028 q 615 956 574 1028 q 656 766 656 883 l 656 265 q 634 124 656 187 q 569 25 613 62 q 455 -11 524 -11 m 355 178 q 401 216 393 178 q 410 310 410 254 l 410 707 q 401 801 410 764 q 355 839 393 839 q 307 801 316 839 q 298 707 298 762 l 298 310 q 307 217 298 255 q 355 178 316 178 m 128 -184 l 128 -81 l 569 -81 l 569 -184 l 128 -184 z "},"{":{"ha":472,"x_min":21,"x_max":448,"o":"m 448 -127 q 247 -102 319 -125 q 145 -26 174 -79 q 115 122 115 28 l 115 349 q 99 449 115 417 q 21 488 83 481 l 21 621 q 99 660 83 629 q 115 760 115 692 l 115 987 q 145 1135 115 1082 q 247 1211 174 1188 q 448 1236 319 1234 l 448 1055 q 383 1043 412 1053 q 354 998 354 1034 l 354 744 q 333 641 354 679 q 279 583 313 602 q 206 555 245 564 q 279 527 245 546 q 333 469 313 507 q 354 365 354 431 l 354 111 q 383 65 354 75 q 448 54 412 56 l 448 -127 z "},"}":{"ha":473,"x_min":27,"x_max":454,"o":"m 27 -127 l 27 54 q 93 65 64 56 q 121 111 121 75 l 121 365 q 142 469 121 431 q 197 527 163 507 q 269 555 231 546 q 197 583 231 564 q 142 640 163 602 q 121 744 121 678 l 121 998 q 93 1043 121 1034 q 27 1055 64 1053 l 27 1236 q 229 1211 156 1234 q 331 1135 301 1188 q 360 987 360 1082 l 360 760 q 376 660 360 692 q 454 621 393 629 l 454 488 q 376 449 393 481 q 360 349 360 417 l 360 122 q 331 -26 360 28 q 229 -102 301 -79 q 27 -127 156 -125 z "},"[":{"ha":441,"x_min":42,"x_max":418,"o":"m 42 -127 l 42 1236 l 418 1236 l 418 1046 l 281 1046 l 281 63 l 418 63 l 418 -127 l 42 -127 z "},"]":{"ha":441,"x_min":24,"x_max":399,"o":"m 24 -127 l 24 63 l 161 63 l 161 1046 l 24 1046 l 24 1236 l 399 1236 l 399 -127 l 24 -127 z "},"˘":{"ha":688,"x_min":74,"x_max":608,"o":"m 340 1080 q 148 1130 221 1080 q 74 1291 74 1180 q 76 1319 74 1305 l 250 1319 q 269 1260 250 1280 q 341 1240 289 1240 q 413 1260 393 1240 q 433 1319 433 1280 l 606 1319 q 607 1305 607 1312 q 608 1295 608 1299 q 535 1131 608 1182 q 340 1080 462 1080 z "},"̮":{"ha":0,"x_min":-267,"x_max":267,"o":"m -1 -282 q -193 -232 -119 -282 q -267 -71 -267 -182 q -264 -43 -267 -56 l -91 -43 q -71 -101 -91 -81 q 1 -121 -52 -121 q 73 -101 53 -121 q 92 -43 92 -81 l 266 -43 q 267 -66 267 -60 q 194 -231 267 -180 q -1 -282 121 -282 z "},"̆":{"ha":0,"x_min":-267,"x_max":267,"o":"m -1 1080 q -193 1130 -119 1080 q -267 1291 -267 1180 q -264 1319 -267 1305 l -91 1319 q -71 1260 -91 1280 q 1 1240 -52 1240 q 73 1260 53 1240 q 92 1319 92 1280 l 266 1319 q 267 1305 267 1312 q 267 1295 267 1299 q 194 1131 267 1182 q -1 1080 121 1080 z "},"̯":{"ha":0,"x_min":-254,"x_max":253,"o":"m -252 -348 q -254 -319 -254 -334 q -187 -159 -254 -209 q -1 -109 -120 -109 q 187 -160 121 -109 q 253 -324 253 -211 q 253 -334 253 -328 q 252 -348 252 -340 l 92 -348 q 66 -279 92 -302 q 0 -256 40 -256 q -65 -279 -39 -256 q -92 -348 -92 -302 l -252 -348 z "},"̑":{"ha":0,"x_min":-254,"x_max":253,"o":"m -252 1090 q -254 1118 -254 1104 q -187 1279 -254 1229 q -1 1329 -120 1329 q 187 1278 121 1329 q 253 1114 253 1227 q 253 1104 253 1110 q 252 1090 252 1097 l 92 1090 q 66 1159 92 1137 q 0 1181 40 1181 q -65 1159 -39 1181 q -92 1090 -92 1137 l -252 1090 z "},"¦":{"ha":309,"x_min":46,"x_max":262,"o":"m 46 707 l 46 1324 l 262 1324 l 262 707 l 46 707 m 46 -57 l 46 540 l 262 540 l 262 -57 l 46 -57 z "},"ƀ":{"ha":696,"x_min":-53,"x_max":656,"o":"m 455 -11 q 358 19 395 -11 q 298 109 321 48 l 298 0 l 52 0 l 52 1025 l -53 1025 l -53 1129 l 52 1129 l 52 1194 l 298 1194 l 298 1129 l 388 1129 l 388 1025 l 298 1025 l 298 909 q 360 997 321 965 q 474 1028 400 1028 q 615 956 574 1028 q 656 766 656 883 l 656 265 q 634 124 656 187 q 569 25 613 62 q 455 -11 524 -11 m 355 178 q 401 216 393 178 q 410 310 410 254 l 410 707 q 401 801 410 764 q 355 839 393 839 q 307 801 316 839 q 298 707 298 762 l 298 310 q 307 217 298 255 q 355 178 316 178 z "},"•":{"ha":489,"x_min":32,"x_max":457,"o":"m 244 273 q 87 337 143 273 q 32 503 32 400 q 87 669 32 606 q 244 732 143 732 q 401 669 345 732 q 457 503 457 606 q 401 337 457 400 q 244 273 345 273 z "},"∙":{"ha":407,"x_min":102,"x_max":318,"o":"m 102 490 l 102 692 l 318 692 l 318 490 l 102 490 z "},"c":{"ha":682,"x_min":41,"x_max":646,"o":"m 355 -11 q 112 77 184 -11 q 41 334 41 164 l 41 647 q 68 859 41 774 q 163 986 95 944 q 351 1028 231 1028 q 502 998 435 1028 q 608 911 569 968 q 646 770 646 853 l 646 614 l 399 614 l 399 757 q 389 816 399 792 q 345 840 378 840 q 285 755 285 840 l 285 262 q 298 205 285 231 q 343 179 312 179 q 388 204 375 179 q 400 264 400 230 l 400 435 l 646 435 l 646 257 q 609 113 646 173 q 505 21 571 53 q 355 -11 439 -11 z "},"ć":{"ha":682,"x_min":41,"x_max":646,"o":"m 355 -11 q 112 77 184 -11 q 41 334 41 164 l 41 647 q 68 859 41 774 q 163 986 95 944 q 351 1028 231 1028 q 502 998 435 1028 q 608 911 569 968 q 646 770 646 853 l 646 614 l 399 614 l 399 757 q 389 816 399 792 q 345 840 378 840 q 285 755 285 840 l 285 262 q 298 205 285 231 q 343 179 312 179 q 388 204 375 179 q 400 264 400 230 l 400 435 l 646 435 l 646 257 q 609 113 646 173 q 505 21 571 53 q 355 -11 439 -11 m 188 1053 l 188 1204 l 510 1352 l 510 1117 l 188 1053 z "},"̐":{"ha":0,"x_min":-267,"x_max":267,"o":"m -121 1360 l -121 1535 l 122 1535 l 122 1360 l -121 1360 m -1 1080 q -193 1125 -119 1080 q -267 1270 -267 1171 q -264 1299 -267 1284 l -91 1299 q -71 1235 -91 1257 q 1 1213 -52 1213 q 73 1235 53 1213 q 92 1299 92 1257 l 266 1299 q 267 1285 267 1292 q 267 1275 267 1278 q 194 1126 267 1173 q -1 1080 121 1080 z "},"ˇ":{"ha":658,"x_min":27,"x_max":631,"o":"m 191 1079 l 27 1352 l 271 1352 l 329 1159 l 387 1352 l 631 1352 l 467 1079 l 191 1079 z "},"̌":{"ha":0,"x_min":-302,"x_max":302,"o":"m -138 1079 l -302 1352 l -58 1352 l 0 1159 l 58 1352 l 302 1352 l 138 1079 l -138 1079 z "},"č":{"ha":682,"x_min":41,"x_max":651,"o":"m 355 -11 q 112 77 184 -11 q 41 334 41 164 l 41 647 q 68 859 41 774 q 163 986 95 944 q 351 1028 231 1028 q 502 998 435 1028 q 608 911 569 968 q 646 770 646 853 l 646 614 l 399 614 l 399 757 q 389 816 399 792 q 345 840 378 840 q 285 755 285 840 l 285 262 q 298 205 285 231 q 343 179 312 179 q 388 204 375 179 q 400 264 400 230 l 400 435 l 646 435 l 646 257 q 609 113 646 173 q 505 21 571 53 q 355 -11 439 -11 m 211 1079 l 47 1352 l 291 1352 l 349 1159 l 408 1352 l 651 1352 l 488 1079 l 211 1079 z "},"ç":{"ha":682,"x_min":41,"x_max":646,"o":"m 355 -11 q 112 77 184 -11 q 41 334 41 164 l 41 647 q 68 859 41 774 q 163 986 95 944 q 351 1028 231 1028 q 502 998 435 1028 q 608 911 569 968 q 646 770 646 853 l 646 614 l 399 614 l 399 757 q 389 816 399 792 q 345 840 378 840 q 285 755 285 840 l 285 262 q 298 205 285 231 q 343 179 312 179 q 388 204 375 179 q 400 264 400 230 l 400 435 l 646 435 l 646 257 q 609 113 646 173 q 505 21 571 53 q 355 -11 439 -11 m 331 -428 q 197 -401 261 -428 l 197 -250 q 238 -261 218 -256 q 277 -265 258 -265 q 333 -247 311 -265 q 356 -185 356 -229 q 337 -98 356 -147 q 286 0 319 -50 l 395 0 q 497 -129 460 -58 q 533 -262 533 -199 q 485 -380 533 -332 q 331 -428 437 -428 z "},"ḉ":{"ha":682,"x_min":41,"x_max":646,"o":"m 355 -11 q 112 77 184 -11 q 41 334 41 164 l 41 647 q 68 859 41 774 q 163 986 95 944 q 351 1028 231 1028 q 502 998 435 1028 q 608 911 569 968 q 646 770 646 853 l 646 614 l 399 614 l 399 757 q 389 816 399 792 q 345 840 378 840 q 285 755 285 840 l 285 262 q 298 205 285 231 q 343 179 312 179 q 388 204 375 179 q 400 264 400 230 l 400 435 l 646 435 l 646 257 q 609 113 646 173 q 505 21 571 53 q 355 -11 439 -11 m 331 -428 q 197 -401 261 -428 l 197 -250 q 238 -261 218 -256 q 277 -265 258 -265 q 333 -247 311 -265 q 356 -185 356 -229 q 337 -98 356 -147 q 286 0 319 -50 l 395 0 q 497 -129 460 -58 q 533 -262 533 -199 q 485 -380 533 -332 q 331 -428 437 -428 m 189 1053 l 189 1204 l 511 1352 l 511 1117 l 189 1053 z "},"ĉ":{"ha":682,"x_min":41,"x_max":651,"o":"m 355 -11 q 112 77 184 -11 q 41 334 41 164 l 41 647 q 68 859 41 774 q 163 986 95 944 q 351 1028 231 1028 q 502 998 435 1028 q 608 911 569 968 q 646 770 646 853 l 646 614 l 399 614 l 399 757 q 389 816 399 792 q 345 840 378 840 q 285 755 285 840 l 285 262 q 298 205 285 231 q 343 179 312 179 q 388 204 375 179 q 400 264 400 230 l 400 435 l 646 435 l 646 257 q 609 113 646 173 q 505 21 571 53 q 355 -11 439 -11 m 47 1079 l 211 1352 l 488 1352 l 651 1079 l 408 1079 l 349 1272 l 291 1079 l 47 1079 z "},"ċ":{"ha":682,"x_min":41,"x_max":646,"o":"m 355 -11 q 112 77 184 -11 q 41 334 41 164 l 41 647 q 68 859 41 774 q 163 986 95 944 q 351 1028 231 1028 q 502 998 435 1028 q 608 911 569 968 q 646 770 646 853 l 646 614 l 399 614 l 399 757 q 389 816 399 792 q 345 840 378 840 q 285 755 285 840 l 285 262 q 298 205 285 231 q 343 179 312 179 q 388 204 375 179 q 400 264 400 230 l 400 435 l 646 435 l 646 257 q 609 113 646 173 q 505 21 571 53 q 355 -11 439 -11 m 228 1080 l 228 1282 l 471 1282 l 471 1080 l 228 1080 z "},"₵":{"ha":669,"x_min":33,"x_max":638,"o":"m 286 -111 l 286 -9 q 90 94 147 7 q 33 334 33 180 l 33 647 q 55 844 33 762 q 132 971 77 925 q 286 1027 187 1017 l 286 1137 l 404 1137 l 404 1025 q 571 946 504 1010 q 638 770 638 881 l 638 596 l 391 596 l 391 757 q 380 816 391 792 q 336 840 370 840 q 277 755 277 840 l 277 262 q 290 205 277 231 q 335 179 304 179 q 379 204 367 179 q 392 264 392 230 l 392 416 l 638 416 l 638 257 q 572 75 638 143 q 404 -8 505 6 l 404 -111 l 286 -111 z "},"¸":{"ha":391,"x_min":27,"x_max":363,"o":"m 161 -428 q 27 -401 92 -428 l 27 -250 q 68 -261 48 -256 q 107 -265 89 -265 q 164 -247 141 -265 q 186 -185 186 -229 q 168 -98 186 -147 q 116 0 149 -50 l 225 0 q 327 -129 291 -58 q 363 -262 363 -199 q 315 -380 363 -332 q 161 -428 267 -428 z "},"̧":{"ha":0,"x_min":-305,"x_max":31,"o":"m -171 -428 q -305 -401 -241 -428 l -305 -250 q -264 -261 -284 -256 q -225 -265 -243 -265 q -169 -247 -191 -265 q -146 -185 -146 -229 q -164 -98 -146 -147 q -216 0 -183 -50 l -107 0 q -5 -129 -41 -58 q 31 -262 31 -199 q -17 -380 31 -332 q -171 -428 -65 -428 z "},"¢":{"ha":669,"x_min":33,"x_max":638,"o":"m 286 -111 l 286 -9 q 90 94 147 7 q 33 334 33 180 l 33 647 q 55 844 33 762 q 132 971 77 925 q 286 1027 187 1017 l 286 1137 l 404 1137 l 404 1025 q 571 946 504 1010 q 638 770 638 881 l 638 596 l 391 596 l 391 757 q 380 816 391 792 q 336 840 370 840 q 277 755 277 840 l 277 262 q 290 205 277 231 q 335 179 304 179 q 379 204 367 179 q 392 264 392 230 l 392 416 l 638 416 l 638 257 q 572 75 638 143 q 404 -8 505 6 l 404 -111 l 286 -111 z "},"ꭓ":{"ha":637,"x_min":5,"x_max":631,"o":"m 631 -176 q 505 -162 556 -176 q 417 -115 453 -149 q 353 -22 380 -81 q 297 127 325 37 l 288 159 l 189 -170 l 5 -170 l 204 477 l 130 718 q 86 817 107 792 q 27 842 66 842 l 27 1028 q 190 1005 129 1028 q 291 923 252 981 q 364 757 330 864 l 444 1018 l 624 1018 l 446 444 l 541 134 q 581 35 564 60 q 631 9 598 9 l 631 -176 z "},"ƈ":{"ha":711,"x_min":41,"x_max":718,"o":"m 355 -11 q 112 77 184 -11 q 41 334 41 164 l 41 647 q 68 859 41 774 q 163 986 95 944 q 351 1028 231 1028 q 450 1014 409 1028 q 541 1147 474 1095 q 718 1200 608 1200 l 718 1013 q 646 924 646 1013 l 646 614 l 399 614 l 399 757 q 389 816 399 792 q 345 840 378 840 q 285 755 285 840 l 285 262 q 298 205 285 231 q 343 179 312 179 q 388 204 375 179 q 400 264 400 230 l 400 435 l 646 435 l 646 257 q 609 113 646 173 q 505 21 571 53 q 355 -11 439 -11 z "},"ˆ":{"ha":658,"x_min":27,"x_max":631,"o":"m 27 1079 l 191 1352 l 467 1352 l 631 1079 l 387 1079 l 329 1272 l 271 1079 l 27 1079 z "},"̭":{"ha":0,"x_min":-302,"x_max":302,"o":"m -302 -347 l -138 -74 l 138 -74 l 302 -347 l 58 -347 l 0 -154 l -58 -347 l -302 -347 z "},"̂":{"ha":0,"x_min":-302,"x_max":302,"o":"m -302 1079 l -138 1352 l 138 1352 l 302 1079 l 58 1079 l 0 1272 l -58 1079 l -302 1079 z "},"ǂ":{"ha":463,"x_min":-7,"x_max":470,"o":"m 117 -126 l 117 236 l -7 236 l -7 437 l 117 437 l 117 636 l -7 636 l -7 837 l 117 837 l 117 1194 l 348 1194 l 348 837 l 470 837 l 470 636 l 348 636 l 348 437 l 470 437 l 470 236 l 348 236 l 348 -126 l 117 -126 z "},"ǀ":{"ha":315,"x_min":42,"x_max":273,"o":"m 42 -126 l 42 1194 l 273 1194 l 273 -126 l 42 -126 z "},"ǁ":{"ha":681,"x_min":42,"x_max":639,"o":"m 42 -126 l 42 1194 l 273 1194 l 273 -126 l 42 -126 m 408 -126 l 408 1194 l 639 1194 l 639 -126 l 408 -126 z "},"ǃ":{"ha":318,"x_min":37,"x_max":280,"o":"m 85 325 l 37 1194 l 280 1194 l 233 325 l 85 325 m 37 1 l 37 203 l 280 203 l 280 1 l 37 1 z "},":":{"ha":336,"x_min":46,"x_max":289,"o":"m 46 662 l 46 864 l 289 864 l 289 662 l 46 662 m 46 161 l 46 363 l 289 363 l 289 161 l 46 161 z "},"꞉":{"ha":336,"x_min":46,"x_max":289,"o":"m 46 662 l 46 864 l 289 864 l 289 662 l 46 662 m 46 161 l 46 363 l 289 363 l 289 161 l 46 161 z "},"₡":{"ha":707,"x_min":87,"x_max":621,"o":"m 117 -77 l 149 73 q 87 265 87 147 l 87 766 q 151 1004 87 922 q 357 1085 214 1085 l 368 1139 l 439 1139 l 427 1079 q 475 1065 452 1074 l 490 1139 l 562 1139 l 538 1027 q 595 949 575 997 q 616 836 616 901 l 616 646 l 460 646 l 358 155 q 424 191 404 157 q 444 277 444 224 l 444 463 l 621 463 l 621 258 q 549 52 621 117 q 353 -14 478 -14 q 323 -13 338 -14 l 311 -77 l 239 -77 l 256 1 q 209 22 231 9 l 189 -77 l 117 -77 m 260 787 l 260 616 l 320 905 q 272 864 283 896 q 260 787 260 833 m 260 272 q 291 174 262 201 l 432 857 q 391 903 420 891 l 260 272 z "},",":{"ha":328,"x_min":37,"x_max":291,"o":"m 79 -159 l 123 1 l 37 1 l 37 203 l 291 203 l 291 7 l 222 -159 l 79 -159 z "},"̓":{"ha":0,"x_min":-127,"x_max":127,"o":"m -127 1123 l -127 1319 l -58 1485 l 85 1485 l 41 1325 l 127 1325 l 127 1123 l -127 1123 z "},"̦":{"ha":0,"x_min":-135,"x_max":119,"o":"m -94 -436 l -49 -276 l -135 -276 l -135 -74 l 119 -74 l 119 -270 l 50 -436 l -94 -436 z "},"̒":{"ha":0,"x_min":-127,"x_max":127,"o":"m -127 1123 l -127 1319 l -58 1485 l 85 1485 l 41 1325 l 127 1325 l 127 1123 l -127 1123 z "},"ʻ":{"ha":407,"x_min":71,"x_max":324,"o":"m 71 655 l 71 851 l 140 1017 l 283 1017 l 238 857 l 324 857 l 324 655 l 71 655 z "},"⁒":{"ha":665,"x_min":37,"x_max":627,"o":"m 37 991 l 37 1194 l 246 1194 l 246 991 l 37 991 m 108 0 l 386 1194 l 558 1194 l 279 0 l 108 0 m 418 0 l 418 202 l 627 202 l 627 0 l 418 0 z "},"©":{"ha":937,"x_min":23,"x_max":914,"o":"m 469 139 q 293 173 374 139 q 151 267 212 206 q 57 409 90 328 q 23 585 23 490 q 57 761 23 680 q 151 902 90 842 q 293 997 212 963 q 469 1030 374 1030 q 645 997 564 1030 q 786 902 726 963 q 881 761 847 842 q 914 585 914 680 q 881 409 914 490 q 786 267 847 328 q 645 173 726 206 q 469 139 564 139 m 469 227 q 643 275 567 227 q 763 405 719 323 q 806 585 806 486 q 763 765 806 684 q 643 894 719 846 q 469 943 567 943 q 295 894 371 943 q 175 765 218 846 q 131 585 131 684 q 175 405 131 486 q 295 275 218 323 q 469 227 371 227 m 465 288 q 351 328 394 288 q 309 439 309 368 l 309 711 q 346 841 309 797 q 467 885 383 885 q 581 851 536 885 q 627 749 627 818 l 627 646 l 498 646 l 498 714 q 467 766 498 766 q 443 754 448 766 q 437 723 437 743 l 437 446 q 445 416 437 431 q 467 401 453 401 q 498 446 498 401 l 498 547 l 629 547 l 629 436 q 465 288 629 288 z "},"ȼ":{"ha":682,"x_min":41,"x_max":646,"o":"m 136 -126 l 176 26 q 72 142 104 64 q 41 334 41 219 l 41 647 q 68 859 41 774 q 163 986 95 944 q 351 1028 231 1028 q 435 1020 395 1028 l 479 1194 l 574 1194 l 522 988 q 613 902 579 957 q 646 770 646 846 l 646 614 l 399 614 l 399 757 q 389 816 399 792 q 345 840 378 840 q 285 755 285 840 l 285 262 q 298 205 285 231 q 343 179 312 179 q 388 204 375 179 q 400 264 400 230 l 400 435 l 646 435 l 646 257 q 609 113 646 173 q 505 21 571 53 q 355 -11 439 -11 q 263 -3 304 -11 l 231 -126 l 136 -126 z "},"¤":{"ha":678,"x_min":31,"x_max":647,"o":"m 132 345 l 31 447 l 92 509 q 56 654 56 575 q 92 799 56 733 l 31 860 l 132 962 l 191 902 q 338 939 256 939 q 486 903 420 939 l 545 962 l 647 861 l 586 800 q 623 654 623 734 q 586 507 623 574 l 647 446 l 545 345 l 485 405 q 338 370 422 370 q 192 406 254 370 l 132 345 m 338 503 q 441 547 403 503 q 480 655 480 592 q 442 762 480 720 q 338 804 404 804 q 236 760 275 804 q 197 654 197 716 q 236 547 197 591 q 338 503 274 503 z "},"d":{"ha":692,"x_min":42,"x_max":647,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 z "},"†":{"ha":535,"x_min":21,"x_max":514,"o":"m 145 0 l 145 675 l 21 675 l 21 876 l 145 876 l 145 1080 l 392 1080 l 392 876 l 514 876 l 514 675 l 392 675 l 392 0 l 145 0 z "},"‡":{"ha":547,"x_min":27,"x_max":520,"o":"m 151 0 l 151 237 l 27 237 l 27 438 l 151 438 l 151 637 l 27 637 l 27 838 l 151 838 l 151 1080 l 398 1080 l 398 838 l 520 838 l 520 637 l 398 637 l 398 438 l 520 438 l 520 237 l 398 237 l 398 0 l 151 0 z "},"̏":{"ha":0,"x_min":-330,"x_max":184,"o":"m -134 1076 l -330 1367 l -171 1440 l -21 1115 l -134 1076 m 71 1076 l -97 1367 l 59 1440 l 184 1115 l 71 1076 z "},"ď":{"ha":911,"x_min":42,"x_max":911,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 m 699 831 l 751 991 l 700 991 l 700 1194 l 911 1194 l 911 998 l 842 831 l 699 831 z "},"ḑ":{"ha":692,"x_min":42,"x_max":647,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 m 280 -436 l 325 -276 l 239 -276 l 239 -74 l 492 -74 l 492 -270 l 423 -436 l 280 -436 z "},"ḓ":{"ha":692,"x_min":42,"x_max":676,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 m 73 -347 l 236 -74 l 513 -74 l 676 -347 l 433 -347 l 374 -154 l 316 -347 l 73 -347 z "},"đ":{"ha":692,"x_min":42,"x_max":727,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1039 l 286 1039 l 286 1143 l 400 1143 l 400 1194 l 647 1194 l 647 1143 l 727 1143 l 727 1039 l 647 1039 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 z "},"ḋ":{"ha":692,"x_min":42,"x_max":647,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 m 95 1098 l 95 1300 l 338 1300 l 338 1098 l 95 1098 z "},"ḍ":{"ha":692,"x_min":42,"x_max":647,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 m 253 -283 l 253 -81 l 496 -81 l 496 -283 l 253 -283 z "},"°":{"ha":540,"x_min":30,"x_max":509,"o":"m 269 631 q 95 692 161 631 q 30 861 30 753 q 95 1029 30 968 q 269 1090 161 1090 q 444 1029 378 1090 q 509 861 509 968 q 444 692 509 753 q 269 631 378 631 m 270 754 q 341 785 315 754 q 366 861 366 817 q 341 936 366 905 q 270 967 315 967 q 199 936 224 967 q 174 861 174 905 q 199 785 174 817 q 270 754 224 754 z "},"ɗ":{"ha":692,"x_min":42,"x_max":705,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 935 q 427 1080 400 1020 q 520 1173 454 1141 q 705 1204 587 1204 l 705 1017 q 660 995 672 1017 q 647 928 647 972 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 211 376 179 q 400 307 400 243 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 z "},"¨":{"ha":662,"x_min":45,"x_max":616,"o":"m 373 1084 l 373 1286 l 616 1286 l 616 1084 l 373 1084 m 45 1084 l 45 1286 l 288 1286 l 288 1084 l 45 1084 z "},"̤":{"ha":0,"x_min":-286,"x_max":286,"o":"m 43 -283 l 43 -81 l 286 -81 l 286 -283 l 43 -283 m -286 -283 l -286 -81 l -43 -81 l -43 -283 l -286 -283 z "},"̈":{"ha":0,"x_min":-286,"x_max":286,"o":"m 43 1084 l 43 1286 l 286 1286 l 286 1084 l 43 1084 m -286 1084 l -286 1286 l -43 1286 l -43 1084 l -286 1084 z "},"÷":{"ha":464,"x_min":23,"x_max":441,"o":"m 131 662 l 131 864 l 333 864 l 333 662 l 131 662 m 23 433 l 23 590 l 441 590 l 441 433 l 23 433 m 131 161 l 131 363 l 333 363 l 333 161 l 131 161 z "},"∕":{"ha":490,"x_min":20,"x_max":470,"o":"m 20 0 l 298 1194 l 470 1194 l 191 0 l 20 0 z "},"ḏ":{"ha":692,"x_min":42,"x_max":647,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 m 154 -184 l 154 -81 l 595 -81 l 595 -184 l 154 -184 z "},"$":{"ha":642,"x_min":23,"x_max":618,"o":"m 260 -77 l 260 24 q 78 114 133 39 q 23 331 23 189 l 23 368 l 259 368 l 259 340 q 325 235 259 235 q 367 253 353 235 q 380 294 380 271 q 337 380 380 336 l 142 576 q 35 808 35 683 q 66 928 35 876 q 148 1013 97 980 q 260 1057 199 1046 l 260 1139 l 378 1139 l 378 1059 q 554 963 494 1044 q 614 749 614 882 l 372 749 l 372 793 q 357 838 372 823 q 315 854 341 854 q 273 840 287 854 q 258 802 258 825 q 326 701 258 768 l 515 514 q 588 414 557 473 q 618 280 618 355 q 549 101 618 168 q 378 23 481 35 l 378 -77 l 260 -77 z "},"₫":{"ha":707,"x_min":61,"x_max":647,"o":"m 248 -12 q 123 28 163 -12 q 72 138 83 69 q 61 292 61 207 l 61 625 q 109 783 61 718 q 252 848 157 848 q 385 787 340 848 l 385 903 l 199 903 l 199 1016 l 385 1016 l 385 1082 l 604 1082 l 604 1016 l 647 1016 l 647 903 l 604 903 l 604 -1 l 385 -1 l 385 96 q 336 17 366 47 q 248 -12 305 -12 m 332 161 q 373 189 361 161 q 385 277 385 218 l 385 581 q 375 646 385 614 q 333 677 365 677 q 289 647 298 677 q 279 581 279 617 l 279 276 q 332 161 279 161 m 73 -231 l 73 -72 l 591 -72 l 591 -231 l 73 -231 z "},"͘":{"ha":0,"x_min":0,"x_max":243,"o":"m 0 1080 l 0 1282 l 243 1282 l 243 1080 l 0 1080 z "},"˙":{"ha":333,"x_min":45,"x_max":288,"o":"m 45 1080 l 45 1282 l 288 1282 l 288 1080 l 45 1080 z "},"̇":{"ha":0,"x_min":-121,"x_max":121,"o":"m -121 1080 l -121 1282 l 121 1282 l 121 1080 l -121 1080 z "},"̣":{"ha":0,"x_min":-121,"x_max":121,"o":"m -121 -283 l -121 -81 l 121 -81 l 121 -283 l -121 -283 z "},"ˮ":{"ha":732,"x_min":83,"x_max":662,"o":"m 124 655 l 169 815 l 83 815 l 83 1017 l 336 1017 l 336 821 l 267 655 l 124 655 m 450 655 l 494 815 l 408 815 l 408 1017 l 662 1017 l 662 821 l 593 655 l 450 655 z "},"ʺ":{"ha":776,"x_min":90,"x_max":708,"o":"m 375 1017 l 479 1461 l 708 1461 l 519 1017 l 375 1017 m 90 1017 l 195 1461 l 423 1461 l 235 1017 l 90 1017 z "},"↓":{"ha":537,"x_min":41,"x_max":496,"o":"m 269 0 l 41 131 l 41 340 l 164 272 l 164 1028 l 380 1028 l 380 275 l 496 340 l 496 131 l 269 0 z "},"▼":{"ha":1120,"x_min":53,"x_max":1067,"o":"m 560 -11 l 53 1017 l 1067 1017 l 560 -11 z "},"▽":{"ha":1120,"x_min":53,"x_max":1067,"o":"m 560 -11 l 53 1017 l 1067 1017 l 560 -11 m 560 288 l 854 885 l 266 885 l 560 288 z "},"ɖ":{"ha":692,"x_min":42,"x_max":705,"o":"m 705 -133 q 478 -72 549 -133 q 401 111 406 -12 q 347 22 381 55 q 249 -11 313 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 144 q 660 77 647 100 q 705 54 672 54 l 705 -133 m 342 179 q 389 211 378 179 q 400 307 400 243 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 z "},"ǳ":{"ha":1227,"x_min":42,"x_max":1218,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 m 711 0 l 711 149 l 964 825 l 723 825 l 723 1017 l 1216 1017 l 1216 852 l 977 182 l 1218 182 l 1218 0 l 711 0 z "},"ǆ":{"ha":1227,"x_min":42,"x_max":1289,"o":"m 249 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1194 l 647 1194 l 647 0 l 400 0 l 400 108 q 346 21 380 53 q 249 -11 313 -11 m 342 179 q 388 207 376 179 q 400 307 400 235 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 m 711 0 l 711 149 l 964 825 l 723 825 l 723 1017 l 1216 1017 l 1216 852 l 977 182 l 1218 182 l 1218 0 l 711 0 m 849 1079 l 686 1352 l 929 1352 l 987 1159 l 1046 1352 l 1289 1352 l 1126 1079 l 849 1079 z "},"e":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 z "},"é":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 185 1053 l 185 1204 l 507 1352 l 507 1117 l 185 1053 z "},"ĕ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 348 1080 q 156 1130 229 1080 q 82 1291 82 1180 q 84 1319 82 1305 l 258 1319 q 277 1260 258 1280 q 349 1240 297 1240 q 421 1260 401 1240 q 441 1319 441 1280 l 614 1319 q 615 1305 615 1312 q 616 1295 616 1299 q 543 1131 616 1182 q 348 1080 470 1080 z "},"ě":{"ha":678,"x_min":41,"x_max":648,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 208 1079 l 44 1352 l 288 1352 l 346 1159 l 404 1352 l 648 1352 l 484 1079 l 208 1079 z "},"ȩ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 339 -428 q 205 -401 269 -428 l 205 -250 q 246 -261 226 -256 q 285 -265 267 -265 q 341 -247 319 -265 q 364 -185 364 -229 q 346 -98 364 -147 q 294 0 327 -50 l 403 0 q 505 -129 469 -58 q 541 -262 541 -199 q 493 -380 541 -332 q 339 -428 445 -428 z "},"ḝ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 340 -428 q 205 -401 270 -428 l 205 -250 q 247 -261 227 -256 q 286 -265 267 -265 q 342 -247 319 -265 q 365 -185 365 -229 q 346 -98 365 -147 q 294 0 328 -50 l 404 0 q 506 -129 469 -58 q 542 -262 542 -199 q 494 -380 542 -332 q 340 -428 446 -428 m 348 1080 q 156 1130 229 1080 q 82 1291 82 1180 q 84 1319 82 1305 l 258 1319 q 277 1260 258 1280 q 349 1240 297 1240 q 421 1260 401 1240 q 441 1319 441 1280 l 614 1319 q 615 1305 615 1312 q 616 1295 616 1299 q 543 1131 616 1182 q 348 1080 470 1080 z "},"ê":{"ha":678,"x_min":41,"x_max":648,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 44 1079 l 208 1352 l 484 1352 l 648 1079 l 404 1079 l 346 1272 l 288 1079 l 44 1079 z "},"ế":{"ha":678,"x_min":41,"x_max":878,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 559 1242 l 670 1442 l 878 1442 l 717 1242 l 559 1242 m 44 1079 l 208 1284 l 484 1284 l 648 1079 l 407 1079 l 346 1211 l 285 1079 l 44 1079 z "},"ḙ":{"ha":678,"x_min":34,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 34 -347 l 197 -74 l 474 -74 l 637 -347 l 394 -347 l 336 -154 l 277 -347 l 34 -347 z "},"ệ":{"ha":678,"x_min":41,"x_max":648,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 214 -283 l 214 -81 l 457 -81 l 457 -283 l 214 -283 m 44 1079 l 208 1352 l 484 1352 l 648 1079 l 404 1079 l 346 1272 l 288 1079 l 44 1079 z "},"ề":{"ha":678,"x_min":41,"x_max":756,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 598 1242 l 437 1442 l 645 1442 l 756 1242 l 598 1242 m 44 1079 l 208 1284 l 484 1284 l 648 1079 l 407 1079 l 346 1211 l 285 1079 l 44 1079 z "},"ể":{"ha":678,"x_min":41,"x_max":775,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 591 1219 l 519 1303 q 578 1337 555 1316 q 600 1391 600 1357 q 532 1455 600 1455 q 471 1444 500 1455 l 471 1567 q 595 1589 530 1589 q 727 1547 680 1589 q 775 1428 775 1504 q 722 1292 775 1341 q 591 1219 669 1243 m 78 1079 l 228 1291 l 464 1291 l 614 1079 l 407 1079 l 346 1211 l 285 1079 l 78 1079 z "},"ễ":{"ha":678,"x_min":41,"x_max":648,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 458 1335 q 381 1351 417 1335 q 312 1382 346 1367 q 242 1397 278 1397 q 201 1387 220 1397 q 166 1351 182 1377 l 66 1404 q 122 1504 90 1462 q 222 1546 154 1546 q 299 1531 264 1546 q 368 1500 335 1516 q 437 1485 401 1485 q 480 1496 463 1485 q 513 1535 496 1508 l 626 1499 q 590 1419 610 1457 q 539 1358 570 1381 q 458 1335 509 1335 m 44 1079 l 208 1284 l 484 1284 l 648 1079 l 407 1079 l 346 1211 l 285 1079 l 44 1079 z "},"ȅ":{"ha":678,"x_min":16,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 212 1076 l 16 1367 l 175 1440 l 325 1115 l 212 1076 m 417 1076 l 249 1367 l 405 1440 l 530 1115 l 417 1076 z "},"ë":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 384 1084 l 384 1286 l 627 1286 l 627 1084 l 384 1084 m 56 1084 l 56 1286 l 298 1286 l 298 1084 l 56 1084 z "},"ė":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 224 1080 l 224 1282 l 467 1282 l 467 1080 l 224 1080 z "},"ẹ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 214 -283 l 214 -81 l 457 -81 l 457 -283 l 214 -283 z "},"è":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 507 1053 l 184 1117 l 184 1352 l 507 1204 l 507 1053 z "},"ẻ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 346 1083 l 274 1167 q 333 1201 311 1181 q 355 1255 355 1221 q 287 1320 355 1320 q 226 1309 255 1320 l 226 1431 q 350 1453 286 1453 q 483 1411 435 1453 q 530 1292 530 1369 q 477 1157 530 1206 q 346 1083 425 1107 z "},"₈":{"ha":429,"x_min":31,"x_max":398,"o":"m 215 -52 q 74 5 116 -52 q 31 165 31 62 l 31 209 q 44 295 31 262 q 91 346 57 328 q 45 390 59 359 q 32 467 32 421 l 32 485 q 79 621 32 578 q 215 663 125 663 q 352 620 307 663 q 397 479 397 576 q 386 395 397 429 q 338 345 374 360 q 389 284 379 326 q 398 183 398 243 l 398 165 q 356 5 398 62 q 215 -52 314 -52 m 215 405 q 252 472 252 405 q 244 514 252 494 q 215 534 237 534 q 185 514 193 534 q 178 472 178 494 q 215 405 178 405 m 215 87 q 253 157 253 87 l 253 202 q 248 252 253 226 q 215 278 242 278 q 186 257 194 278 q 178 201 178 237 l 178 157 q 215 87 178 87 z "},"⁸":{"ha":429,"x_min":31,"x_max":398,"o":"m 215 530 q 74 587 116 530 q 31 747 31 644 l 31 791 q 44 877 31 844 q 91 928 57 910 q 45 972 59 941 q 32 1048 32 1003 l 32 1067 q 79 1203 32 1160 q 215 1245 125 1245 q 352 1202 307 1245 q 397 1061 397 1158 q 386 977 397 1011 q 338 927 374 942 q 389 866 379 907 q 398 765 398 825 l 398 747 q 356 587 398 644 q 215 530 314 530 m 215 987 q 252 1054 252 987 q 244 1096 252 1076 q 215 1116 237 1116 q 185 1096 193 1116 q 178 1054 178 1076 q 215 987 178 987 m 215 669 q 253 739 253 669 l 253 784 q 248 834 253 808 q 215 860 242 860 q 186 839 194 860 q 178 783 178 819 l 178 739 q 215 669 178 669 z "},"ȇ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 90 1099 q 87 1127 87 1113 q 154 1288 87 1238 q 340 1338 221 1338 q 528 1287 462 1338 q 594 1122 594 1236 q 594 1113 594 1119 q 593 1099 593 1106 l 433 1099 q 407 1168 433 1145 q 341 1190 381 1190 q 276 1168 302 1190 q 250 1099 250 1145 l 90 1099 z "},"…":{"ha":983,"x_min":37,"x_max":946,"o":"m 37 1 l 37 203 l 280 203 l 280 1 l 37 1 m 370 1 l 370 203 l 613 203 l 613 1 l 370 1 m 703 1 l 703 203 l 946 203 l 946 1 l 703 1 z "},"ē":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 125 1098 l 125 1202 l 566 1202 l 566 1098 l 125 1098 z "},"ḗ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 125 1057 l 125 1161 l 566 1161 l 566 1057 l 125 1057 m 185 1197 l 185 1348 l 507 1496 l 507 1261 l 185 1197 z "},"ḕ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 125 1057 l 125 1161 l 566 1161 l 566 1057 l 125 1057 m 507 1197 l 184 1261 l 184 1496 l 507 1348 l 507 1197 z "},"—":{"ha":782,"x_min":41,"x_max":741,"o":"m 41 345 l 41 503 l 741 503 l 741 345 l 41 345 z "},"∅":{"ha":940,"x_min":23,"x_max":917,"o":"m 469 139 q 318 164 389 139 q 191 232 247 189 l 104 145 l 45 203 l 131 289 q 52 423 80 347 q 23 585 23 498 q 57 761 23 680 q 151 902 90 842 q 293 997 212 963 q 469 1030 374 1030 q 631 1002 555 1030 q 764 922 707 973 l 859 1017 l 917 958 l 821 863 q 890 735 865 806 q 914 585 914 665 q 881 409 914 490 q 786 267 847 328 q 645 173 726 206 q 469 139 564 139 m 202 360 l 695 853 q 594 919 652 895 q 469 943 536 943 q 295 894 371 943 q 175 765 218 846 q 131 585 131 684 q 150 464 131 521 q 202 360 169 406 m 469 227 q 643 275 567 227 q 763 405 719 323 q 806 585 806 486 q 748 789 806 699 l 259 300 q 354 246 301 266 q 469 227 408 227 z "},"–":{"ha":432,"x_min":41,"x_max":391,"o":"m 41 345 l 41 503 l 391 503 l 391 345 l 41 345 z "},"ŋ":{"ha":692,"x_min":49,"x_max":646,"o":"m 332 -311 l 332 -133 q 388 -109 368 -133 q 407 -28 407 -84 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 q 561 -233 646 -155 q 332 -311 476 -311 z "},"ę":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 341 -428 q 223 -404 277 -428 q 137 -333 170 -379 q 105 -224 105 -288 q 284 0 105 -100 l 427 0 q 350 -89 381 -44 q 319 -189 319 -133 q 397 -265 319 -265 q 475 -250 430 -265 l 475 -401 q 341 -428 411 -428 z "},"ɛ":{"ha":675,"x_min":35,"x_max":649,"o":"m 354 -14 q 170 28 241 -14 q 67 143 100 70 q 35 312 35 216 q 52 436 35 380 q 123 528 68 491 q 56 606 75 555 q 37 724 37 657 q 113 951 37 874 q 338 1028 189 1028 q 567 953 492 1028 q 642 724 642 878 l 642 683 l 400 683 l 400 735 q 392 808 400 775 q 340 842 383 842 q 275 739 275 842 q 308 648 275 675 q 402 621 340 621 l 402 433 q 392 434 398 434 q 379 435 387 435 q 299 396 321 435 q 277 292 277 357 q 291 199 277 224 q 339 174 304 174 q 395 209 383 174 q 408 304 408 244 l 408 372 l 649 372 l 649 321 q 578 70 649 153 q 354 -14 507 -14 z "},"=":{"ha":432,"x_min":41,"x_max":390,"o":"m 41 605 l 41 757 l 390 757 l 390 605 l 41 605 m 41 345 l 41 503 l 390 503 l 390 345 l 41 345 z "},"ʃ":{"ha":389,"x_min":18,"x_max":365,"o":"m 121 -176 q 65 -174 88 -176 q 18 -166 42 -171 l 18 -7 q 39 -10 27 -10 q 71 31 71 -10 l 71 1026 q 121 1156 71 1108 q 262 1204 170 1204 q 318 1201 295 1204 q 365 1194 342 1198 l 365 1034 q 344 1038 356 1038 q 312 997 312 1038 l 312 1 q 262 -129 312 -81 q 121 -176 213 -176 z "},"℮":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 115 76 189 -11 q 41 332 41 163 l 41 741 q 346 1028 41 1028 q 639 741 639 1028 l 639 500 l 256 500 l 256 161 q 342 47 256 47 q 445 166 445 47 l 445 393 l 639 393 l 639 335 q 566 71 639 153 q 334 -11 494 -11 m 255 566 l 445 566 l 445 866 q 343 976 445 976 q 255 866 255 976 l 255 566 z "},"ɇ":{"ha":678,"x_min":41,"x_max":639,"o":"m 121 -126 l 161 30 q 68 146 96 70 q 41 332 41 223 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 420 1023 386 1028 l 463 1194 l 558 1194 l 509 996 q 639 741 639 933 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 q 248 -3 287 -11 l 216 -126 l 121 -126 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 z "},"ð":{"ha":699,"x_min":33,"x_max":671,"o":"m 345 -11 q 160 38 228 -11 q 62 178 92 86 q 33 399 33 270 q 100 662 33 576 q 315 747 167 747 q 408 730 361 747 q 340 854 383 791 l 220 776 l 163 863 l 267 930 q 57 1048 155 1027 l 121 1203 q 447 1048 290 1187 l 563 1123 l 619 1036 l 521 971 q 632 769 593 871 q 671 542 671 667 l 671 365 q 642 154 671 237 q 541 30 612 71 q 345 -11 469 -11 m 358 189 q 422 285 422 189 l 422 475 q 354 567 422 567 q 295 461 295 567 l 295 327 q 304 228 295 267 q 358 189 313 189 z "},"ẽ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 458 1093 q 366 1108 406 1093 q 293 1139 326 1124 q 229 1154 260 1154 q 195 1144 211 1154 q 166 1108 180 1134 l 66 1161 q 103 1237 83 1202 q 154 1292 123 1271 q 233 1312 185 1312 q 322 1298 283 1312 q 392 1270 361 1284 q 450 1255 424 1255 q 484 1267 469 1255 q 513 1306 500 1278 l 626 1270 q 590 1183 610 1224 q 539 1118 570 1143 q 458 1093 509 1093 z "},"ḛ":{"ha":678,"x_min":41,"x_max":639,"o":"m 334 -11 q 161 30 225 -11 q 68 147 96 71 q 41 332 41 224 l 41 741 q 122 955 41 882 q 346 1028 203 1028 q 639 741 639 1028 l 639 667 q 636 486 639 532 l 283 486 l 283 290 q 287 236 283 262 q 302 193 290 210 q 340 176 314 176 q 388 209 378 176 q 397 295 397 242 l 397 393 l 639 393 l 639 335 q 611 144 639 221 q 516 28 583 67 q 334 -11 449 -11 m 282 607 l 397 607 l 397 744 q 384 823 397 799 q 343 847 370 847 q 298 824 314 847 q 282 744 282 801 l 282 607 m 448 -295 q 356 -279 397 -295 q 280 -249 314 -264 q 218 -233 246 -233 q 185 -243 201 -233 q 156 -279 170 -254 l 56 -227 q 93 -151 73 -185 q 144 -96 113 -117 q 223 -75 175 -75 q 310 -90 271 -75 q 381 -118 349 -104 q 440 -132 414 -132 q 474 -121 458 -132 q 503 -81 490 -109 l 616 -118 q 580 -204 600 -163 q 529 -270 560 -245 q 448 -295 498 -295 z "},"ǝ":{"ha":678,"x_min":39,"x_max":637,"o":"m 332 -11 q 39 277 39 -11 l 39 351 q 42 531 39 485 l 395 531 l 395 728 q 392 781 395 755 q 376 824 389 807 q 338 841 364 841 q 291 808 300 841 q 281 722 281 775 l 281 625 l 39 625 l 39 682 q 67 873 39 797 q 162 989 96 950 q 345 1028 229 1028 q 518 987 454 1028 q 610 870 582 947 q 637 686 637 794 l 637 277 q 556 62 637 135 q 332 -11 475 -11 m 335 170 q 380 193 364 170 q 396 273 396 216 l 396 410 l 281 410 l 281 273 q 294 194 281 218 q 335 170 308 170 z "},"€":{"ha":729,"x_min":27,"x_max":707,"o":"m 411 -11 q 177 82 260 -11 q 95 328 95 174 l 95 387 l 27 387 l 27 511 l 95 511 l 95 545 l 27 545 l 27 670 l 95 670 l 95 731 q 173 982 95 895 q 411 1069 252 1069 q 635 982 563 1069 q 707 741 707 895 l 470 741 l 470 760 q 461 831 470 800 q 411 862 452 862 q 361 831 370 862 q 352 760 352 800 l 352 670 l 566 670 l 566 545 l 352 545 l 352 511 l 566 511 l 566 387 l 352 387 l 352 304 q 368 249 352 273 q 411 225 384 225 q 454 249 439 225 q 470 304 470 273 l 470 321 l 707 321 q 673 150 707 224 q 573 32 639 75 q 411 -11 507 -11 z "},"!":{"ha":318,"x_min":37,"x_max":280,"o":"m 85 325 l 37 1194 l 280 1194 l 233 325 l 85 325 m 37 1 l 37 203 l 280 203 l 280 1 l 37 1 z "},"¡":{"ha":315,"x_min":37,"x_max":280,"o":"m 37 918 l 37 1120 l 280 1120 l 280 918 l 37 918 m 37 -73 l 85 795 l 233 795 l 280 -73 l 37 -73 z "},"ʒ":{"ha":674,"x_min":26,"x_max":640,"o":"m 327 -176 q 98 -94 170 -176 q 26 158 26 -12 l 26 239 l 268 239 l 268 158 q 282 45 268 79 q 337 11 296 11 q 389 64 382 11 q 397 221 397 117 q 369 355 397 314 q 290 395 340 395 l 211 395 l 211 567 l 395 832 l 55 832 l 55 1017 l 638 1017 l 638 807 l 467 559 q 598 433 557 522 q 640 206 640 344 q 564 -81 640 15 q 327 -176 489 -176 z "},"ǯ":{"ha":674,"x_min":26,"x_max":655,"o":"m 327 -176 q 98 -94 170 -176 q 26 158 26 -12 l 26 239 l 268 239 l 268 158 q 282 45 268 79 q 337 11 296 11 q 389 64 382 11 q 397 221 397 117 q 369 355 397 314 q 290 395 340 395 l 211 395 l 211 567 l 395 832 l 55 832 l 55 1017 l 638 1017 l 638 807 l 467 559 q 598 433 557 522 q 640 206 640 344 q 564 -81 640 15 q 327 -176 489 -176 m 215 1079 l 52 1352 l 295 1352 l 353 1159 l 412 1352 l 655 1352 l 492 1079 l 215 1079 z "},"ƹ":{"ha":674,"x_min":35,"x_max":648,"o":"m 347 -176 q 110 -81 186 -176 q 35 206 35 15 q 76 433 35 344 q 208 559 117 522 l 36 807 l 36 1017 l 619 1017 l 619 832 l 279 832 l 463 567 l 463 395 l 385 395 q 306 355 334 395 q 277 221 277 314 q 285 64 277 117 q 337 11 292 11 q 393 45 379 11 q 406 158 406 79 l 406 239 l 648 239 l 648 158 q 576 -94 648 -12 q 347 -176 504 -176 z "},"f":{"ha":389,"x_min":27,"x_max":360,"o":"m 71 0 l 71 787 l 27 787 l 27 972 l 71 972 l 71 1042 q 235 1206 71 1206 q 360 1186 313 1206 l 360 1036 q 338 1040 343 1040 q 312 1024 317 1040 q 307 985 307 1009 l 307 972 l 360 972 l 360 785 l 312 785 l 312 0 l 71 0 z "},"ḟ":{"ha":389,"x_min":27,"x_max":360,"o":"m 71 0 l 71 787 l 27 787 l 27 972 l 71 972 l 71 1042 q 235 1206 71 1206 q 360 1186 313 1206 l 360 1036 q 338 1040 343 1040 q 312 1024 317 1040 q 307 985 307 1009 l 307 972 l 360 972 l 360 785 l 312 785 l 312 0 l 71 0 m 96 1256 l 96 1458 l 339 1458 l 339 1256 l 96 1256 z "},"ﬁ":{"ha":727,"x_min":27,"x_max":680,"o":"m 71 0 l 71 787 l 27 787 l 27 972 l 71 972 l 71 1042 q 235 1206 71 1206 q 360 1186 313 1206 l 360 1036 q 338 1040 343 1040 q 312 1024 317 1040 q 307 985 307 1009 l 307 972 l 360 972 l 360 785 l 312 785 l 312 0 l 71 0 m 437 1080 l 437 1282 l 680 1282 l 680 1080 l 437 1080 m 437 0 l 437 1017 l 680 1017 l 680 0 l 437 0 z "},"‒":{"ha":686,"x_min":41,"x_max":646,"o":"m 41 345 l 41 503 l 646 503 l 646 345 l 41 345 z "}," ":{"ha":686,"x_min":0,"x_max":0,"o":""},"ˉ":{"ha":407,"x_min":-17,"x_max":424,"o":"m -17 1075 l -17 1179 l 424 1179 l 424 1075 l -17 1075 z "},"⅝":{"ha":1116,"x_min":31,"x_max":1084,"o":"m 215 486 q 82 526 134 486 q 31 649 31 566 l 31 753 l 177 753 l 177 693 q 183 641 177 665 q 215 617 189 617 q 244 632 237 617 q 252 671 252 648 l 252 810 q 246 859 252 836 q 216 882 241 882 q 176 825 176 882 l 47 825 l 47 1194 l 381 1194 l 381 1061 l 180 1061 l 180 968 q 208 990 190 981 q 250 1000 226 1000 q 347 968 314 1000 q 391 882 380 936 q 403 762 403 828 q 390 616 403 678 q 337 519 377 553 q 215 486 297 486 m 277 -11 l 670 1204 l 863 1204 l 401 -11 l 277 -11 m 901 -7 q 760 50 802 -7 q 718 210 718 106 l 718 254 q 730 340 718 307 q 777 391 743 373 q 732 435 745 404 q 718 511 718 466 l 718 530 q 765 666 718 623 q 901 708 812 708 q 1038 665 993 708 q 1084 524 1084 621 q 1072 439 1084 474 q 1024 390 1060 405 q 1075 329 1065 370 q 1084 228 1084 288 l 1084 210 q 1042 50 1084 106 q 901 -7 1000 -7 m 901 450 q 938 517 938 450 q 930 559 938 539 q 901 579 923 579 q 872 559 880 579 q 864 517 864 539 q 901 450 864 450 m 901 132 q 939 201 939 132 l 939 247 q 934 297 939 271 q 901 323 928 323 q 872 302 880 323 q 865 245 865 281 l 865 201 q 901 132 865 132 z "},"₅":{"ha":427,"x_min":31,"x_max":403,"o":"m 215 -52 q 82 -11 134 -52 q 31 112 31 29 l 31 216 l 177 216 l 177 156 q 183 104 177 127 q 215 80 189 80 q 244 95 237 80 q 252 134 252 111 l 252 273 q 246 322 252 298 q 216 345 241 345 q 176 288 176 345 l 47 288 l 47 656 l 381 656 l 381 524 l 180 524 l 180 431 q 208 453 190 444 q 250 463 226 463 q 347 431 314 463 q 391 345 380 399 q 403 225 403 291 q 390 79 403 141 q 337 -18 377 16 q 215 -52 297 -52 z "},"⁵":{"ha":427,"x_min":31,"x_max":403,"o":"m 215 533 q 82 573 134 533 q 31 696 31 614 l 31 801 l 177 801 l 177 741 q 183 688 177 712 q 215 665 189 665 q 244 680 237 665 q 252 719 252 695 l 252 857 q 246 906 252 883 q 216 930 241 930 q 176 872 176 930 l 47 872 l 47 1241 l 381 1241 l 381 1109 l 180 1109 l 180 1015 q 208 1038 190 1028 q 250 1047 226 1047 q 347 1015 314 1047 q 391 929 380 983 q 403 810 403 876 q 390 663 403 726 q 337 567 377 601 q 215 533 297 533 z "},"ﬂ":{"ha":734,"x_min":27,"x_max":685,"o":"m 71 0 l 71 787 l 27 787 l 27 972 l 71 972 l 71 1042 q 235 1206 71 1206 q 360 1186 313 1206 l 360 1036 q 338 1040 343 1040 q 312 1024 317 1040 q 307 985 307 1009 l 307 972 l 360 972 l 360 785 l 312 785 l 312 0 l 71 0 m 438 0 l 438 1194 l 685 1194 l 685 0 l 438 0 z "},"ƒ":{"ha":420,"x_min":28,"x_max":392,"o":"m 166 -32 q 28 -12 81 -32 l 28 138 q 57 134 50 134 q 89 149 82 134 q 95 189 95 163 l 95 669 l 32 669 l 32 857 l 90 857 l 90 926 q 254 1090 90 1090 q 392 1070 339 1090 l 392 920 q 363 924 370 924 q 332 909 338 924 q 326 869 326 895 l 326 857 l 392 857 l 392 669 l 330 669 l 330 132 q 166 -32 330 -32 z "},"₄":{"ha":414,"x_min":12,"x_max":401,"o":"m 220 -45 l 220 70 l 12 70 l 12 180 l 145 656 l 363 656 l 363 187 l 401 187 l 401 70 l 363 70 l 363 -45 l 220 -45 m 138 187 l 220 187 l 220 536 l 138 187 z "},"⁴":{"ha":414,"x_min":12,"x_max":401,"o":"m 220 540 l 220 654 l 12 654 l 12 764 l 145 1241 l 363 1241 l 363 772 l 401 772 l 401 654 l 363 654 l 363 540 l 220 540 m 138 772 l 220 772 l 220 1121 l 138 772 z "},"ˋ":{"ha":441,"x_min":60,"x_max":382,"o":"m 382 1053 l 60 1117 l 60 1352 l 382 1204 l 382 1053 z "},"⁄":{"ha":314,"x_min":-136,"x_max":450,"o":"m -136 -11 l 257 1204 l 450 1204 l -12 -11 l -136 -11 z "},"₣":{"ha":705,"x_min":103,"x_max":603,"o":"m 171 0 l 171 220 l 103 220 l 103 342 l 171 342 l 171 1080 l 603 1080 l 603 869 l 389 869 l 389 697 l 592 697 l 592 490 l 389 490 l 389 342 l 525 342 l 525 220 l 389 220 l 389 0 l 171 0 z "},"g":{"ha":700,"x_min":31,"x_max":654,"o":"m 323 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 378 33 349 -5 q 406 130 406 70 l 406 229 q 251 125 377 125 q 134 159 178 125 q 68 253 89 194 q 48 385 48 312 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 356 994 318 1028 q 406 903 393 960 l 406 1017 l 654 1017 l 654 145 q 574 -102 654 -28 q 323 -176 494 -176 m 349 308 q 406 411 406 308 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 411 q 303 341 294 374 q 349 308 312 308 z "},"ǵ":{"ha":700,"x_min":31,"x_max":654,"o":"m 323 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 378 33 349 -5 q 406 130 406 70 l 406 229 q 251 125 377 125 q 134 159 178 125 q 68 253 89 194 q 48 385 48 312 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 356 994 318 1028 q 406 903 393 960 l 406 1017 l 654 1017 l 654 145 q 574 -102 654 -28 q 323 -176 494 -176 m 349 308 q 406 411 406 308 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 411 q 303 341 294 374 q 349 308 312 308 m 184 1053 l 184 1204 l 507 1352 l 507 1117 l 184 1053 z "},"ɣ":{"ha":652,"x_min":16,"x_max":635,"o":"m 326 -176 q 185 -142 243 -176 q 97 -49 127 -109 q 67 85 67 10 q 84 220 67 150 q 137 369 100 290 l 184 472 l 16 1017 l 245 1017 l 326 661 l 406 1017 l 635 1017 l 468 477 l 522 369 q 572 221 560 292 q 584 85 584 150 q 554 -49 584 10 q 466 -142 524 -109 q 326 -176 408 -176 m 326 26 q 376 108 376 26 q 372 156 376 132 q 358 214 368 180 q 326 303 347 248 q 294 214 304 248 q 279 156 283 180 q 275 108 275 132 q 326 26 275 26 z "},"ğ":{"ha":700,"x_min":31,"x_max":654,"o":"m 323 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 378 33 349 -5 q 406 130 406 70 l 406 229 q 251 125 377 125 q 134 159 178 125 q 68 253 89 194 q 48 385 48 312 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 356 994 318 1028 q 406 903 393 960 l 406 1017 l 654 1017 l 654 145 q 574 -102 654 -28 q 323 -176 494 -176 m 349 308 q 406 411 406 308 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 411 q 303 341 294 374 q 349 308 312 308 m 347 1080 q 155 1130 229 1080 q 81 1291 81 1180 q 83 1319 81 1305 l 257 1319 q 277 1260 257 1280 q 349 1240 296 1240 q 420 1260 401 1240 q 440 1319 440 1280 l 614 1319 q 615 1305 614 1312 q 615 1295 615 1299 q 542 1131 615 1182 q 347 1080 469 1080 z "},"ǧ":{"ha":700,"x_min":31,"x_max":654,"o":"m 323 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 378 33 349 -5 q 406 130 406 70 l 406 229 q 251 125 377 125 q 134 159 178 125 q 68 253 89 194 q 48 385 48 312 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 356 994 318 1028 q 406 903 393 960 l 406 1017 l 654 1017 l 654 145 q 574 -102 654 -28 q 323 -176 494 -176 m 349 308 q 406 411 406 308 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 411 q 303 341 294 374 q 349 308 312 308 m 207 1079 l 43 1352 l 287 1352 l 345 1159 l 404 1352 l 647 1352 l 484 1079 l 207 1079 z "},"ĝ":{"ha":700,"x_min":31,"x_max":654,"o":"m 323 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 378 33 349 -5 q 406 130 406 70 l 406 229 q 251 125 377 125 q 134 159 178 125 q 68 253 89 194 q 48 385 48 312 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 356 994 318 1028 q 406 903 393 960 l 406 1017 l 654 1017 l 654 145 q 574 -102 654 -28 q 323 -176 494 -176 m 349 308 q 406 411 406 308 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 411 q 303 341 294 374 q 349 308 312 308 m 43 1079 l 207 1352 l 484 1352 l 647 1079 l 404 1079 l 345 1272 l 287 1079 l 43 1079 z "},"ģ":{"ha":700,"x_min":31,"x_max":654,"o":"m 323 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 378 33 349 -5 q 406 130 406 70 l 406 229 q 251 125 377 125 q 134 159 178 125 q 68 253 89 194 q 48 385 48 312 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 356 994 318 1028 q 406 903 393 960 l 406 1017 l 654 1017 l 654 145 q 574 -102 654 -28 q 323 -176 494 -176 m 349 308 q 406 411 406 308 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 411 q 303 341 294 374 q 349 308 312 308 m 235 1079 l 235 1275 l 304 1441 l 447 1441 l 402 1281 l 488 1281 l 488 1079 l 235 1079 z "},"ġ":{"ha":700,"x_min":31,"x_max":654,"o":"m 323 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 378 33 349 -5 q 406 130 406 70 l 406 229 q 251 125 377 125 q 134 159 178 125 q 68 253 89 194 q 48 385 48 312 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 356 994 318 1028 q 406 903 393 960 l 406 1017 l 654 1017 l 654 145 q 574 -102 654 -28 q 323 -176 494 -176 m 349 308 q 406 411 406 308 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 411 q 303 341 294 374 q 349 308 312 308 m 224 1080 l 224 1282 l 467 1282 l 467 1080 l 224 1080 z "},"ß":{"ha":683,"x_min":39,"x_max":657,"o":"m 39 0 l 39 958 q 328 1204 39 1204 q 538 1147 459 1204 q 616 958 616 1090 l 616 878 q 593 758 616 807 q 515 692 570 709 q 629 591 601 671 q 657 379 657 511 q 634 192 657 278 q 554 53 611 105 q 395 0 496 0 l 324 0 l 324 191 q 421 271 421 191 l 421 496 q 399 573 421 551 q 321 595 377 595 l 321 764 q 368 787 357 764 q 378 844 378 810 l 378 985 q 328 1037 378 1037 q 277 985 277 1037 l 277 0 l 39 0 z "},"ɠ":{"ha":700,"x_min":31,"x_max":726,"o":"m 323 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 378 33 349 -5 q 406 130 406 70 l 406 229 q 251 125 377 125 q 134 159 178 125 q 68 253 89 194 q 48 385 48 312 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 354 996 316 1028 q 405 909 391 964 q 726 1204 419 1204 l 726 1017 q 654 928 654 1017 l 654 145 q 574 -102 654 -28 q 323 -176 494 -176 m 349 308 q 406 411 406 308 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 411 q 303 341 294 374 q 349 308 312 308 z "},"ʔ":{"ha":684,"x_min":33,"x_max":663,"o":"m 195 0 l 195 591 q 292 600 252 591 q 358 637 332 608 q 395 723 383 665 q 408 878 408 781 q 396 955 408 922 q 345 988 385 988 q 302 969 315 988 q 284 922 288 951 q 281 862 281 893 l 281 763 l 33 763 l 33 935 q 120 1138 33 1072 q 345 1204 207 1204 q 535 1161 465 1204 q 634 1035 604 1118 q 663 831 663 951 q 635 622 663 714 q 553 477 607 530 q 420 424 498 424 l 420 0 l 195 0 z "},"ˀ":{"ha":473,"x_min":33,"x_max":453,"o":"m 140 446 l 140 791 q 222 803 191 791 q 268 856 254 815 q 283 983 283 897 q 275 1034 283 1013 q 241 1056 268 1056 q 205 1030 212 1056 q 198 972 198 1004 l 198 899 l 33 899 l 33 1021 q 91 1156 33 1112 q 241 1200 149 1200 q 407 1136 361 1200 q 453 951 453 1072 q 434 812 453 873 q 379 715 416 751 q 291 680 343 680 l 291 446 l 140 446 z "},"ʕ":{"ha":684,"x_min":20,"x_max":651,"o":"m 489 0 l 263 0 l 263 424 q 131 477 185 424 q 48 622 77 530 q 20 831 20 714 q 50 1035 20 951 q 149 1161 79 1118 q 339 1204 219 1204 q 564 1138 477 1204 q 651 935 651 1072 l 651 763 l 403 763 l 403 862 q 399 922 403 893 q 382 969 395 951 q 339 988 369 988 q 287 955 298 988 q 276 878 276 922 q 288 723 276 781 q 326 637 300 665 q 392 600 351 608 q 489 591 432 591 l 489 0 z "},"ɂ":{"ha":684,"x_min":33,"x_max":663,"o":"m 195 0 l 195 414 q 292 423 252 414 q 358 460 332 432 q 395 547 383 489 q 408 701 408 604 q 396 779 408 745 q 345 812 385 812 q 302 793 315 812 q 284 746 288 774 q 281 686 281 717 l 281 587 l 33 587 l 33 759 q 120 962 33 896 q 345 1028 207 1028 q 535 985 465 1028 q 634 858 604 941 q 663 655 663 775 q 635 446 663 538 q 553 300 607 353 q 420 248 498 248 l 420 0 l 195 0 z "},"ḡ":{"ha":700,"x_min":31,"x_max":654,"o":"m 323 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 378 33 349 -5 q 406 130 406 70 l 406 229 q 251 125 377 125 q 134 159 178 125 q 68 253 89 194 q 48 385 48 312 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 356 994 318 1028 q 406 903 393 960 l 406 1017 l 654 1017 l 654 145 q 574 -102 654 -28 q 323 -176 494 -176 m 349 308 q 406 411 406 308 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 411 q 303 341 294 374 q 349 308 312 308 m 125 1098 l 125 1202 l 566 1202 l 566 1098 l 125 1098 z "},"`":{"ha":441,"x_min":41,"x_max":363,"o":"m 363 1053 l 41 1117 l 41 1352 l 363 1204 l 363 1053 z "},"̀":{"ha":0,"x_min":-161,"x_max":161,"o":"m 161 1053 l -161 1117 l -161 1352 l 161 1204 l 161 1053 z "},"᷅":{"ha":0,"x_min":-213,"x_max":213,"o":"m -213 1343 l -6 1202 l 213 1202 l 213 1098 l -5 1098 l -6 1101 l -6 1098 l -213 1162 l -213 1343 z "},">":{"ha":446,"x_min":36,"x_max":422,"o":"m 36 136 l 36 378 l 268 508 l 36 638 l 36 882 l 422 650 l 422 370 l 36 136 z "},"≥":{"ha":448,"x_min":35,"x_max":422,"o":"m 35 198 l 35 441 l 267 570 l 35 701 l 35 944 l 422 713 l 422 432 l 35 198 m 54 0 l 54 157 l 404 157 l 404 0 l 54 0 z "},"ǥ":{"ha":720,"x_min":31,"x_max":709,"o":"m 269 63 l 269 167 l 406 167 l 406 317 q 251 213 377 213 q 134 248 178 213 q 68 341 89 282 q 48 473 48 400 l 48 750 q 66 895 48 832 q 127 993 83 958 q 251 1028 172 1028 q 356 994 318 1028 q 406 903 393 960 l 406 1017 l 654 1017 l 654 189 q 654 167 654 178 l 709 167 l 709 63 l 644 63 q 544 -123 623 -70 q 323 -176 465 -176 q 202 -169 252 -176 q 111 -144 151 -162 q 31 -92 71 -125 l 113 48 q 291 -5 202 -5 q 362 9 335 -5 q 399 63 389 24 l 269 63 m 349 396 q 406 499 406 396 l 406 757 q 390 814 406 785 q 347 843 374 843 q 302 817 311 843 q 294 757 294 791 l 294 499 q 303 429 294 463 q 349 396 312 396 z "},"₲":{"ha":673,"x_min":43,"x_max":635,"o":"m 275 -111 l 275 -10 q 43 355 43 6 l 43 751 q 275 1082 43 1048 l 275 1196 l 394 1196 l 394 1082 q 543 1022 490 1071 q 615 896 595 974 q 635 720 635 819 l 401 720 l 401 775 q 391 840 401 814 q 347 866 380 866 q 293 838 306 866 q 279 777 279 810 l 279 317 q 292 239 279 269 q 341 209 304 209 q 392 239 379 209 q 404 319 404 269 l 404 421 l 340 421 l 340 627 l 632 627 l 632 0 l 536 0 l 496 100 q 394 6 458 33 l 394 -111 l 275 -111 z "},"«":{"ha":803,"x_min":26,"x_max":764,"o":"m 372 176 l 26 370 l 26 650 l 372 834 l 372 591 l 160 508 l 372 419 l 372 176 m 764 176 l 418 370 l 418 650 l 764 834 l 764 591 l 552 508 l 764 419 l 764 176 z "},"»":{"ha":803,"x_min":39,"x_max":777,"o":"m 39 176 l 39 419 l 251 508 l 39 591 l 39 834 l 385 650 l 385 370 l 39 176 m 431 176 l 431 419 l 642 508 l 431 591 l 431 834 l 777 650 l 777 370 l 431 176 z "},"‹":{"ha":411,"x_min":26,"x_max":372,"o":"m 372 176 l 26 370 l 26 650 l 372 834 l 372 591 l 160 508 l 372 419 l 372 176 z "},"›":{"ha":412,"x_min":39,"x_max":385,"o":"m 39 176 l 39 419 l 251 508 l 39 591 l 39 834 l 385 650 l 385 370 l 39 176 z "},"h":{"ha":702,"x_min":49,"x_max":656,"o":"m 49 0 l 49 1194 l 298 1194 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 0 l 410 0 l 410 768 q 396 822 410 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 z "}," ":{"ha":199,"x_min":0,"x_max":0,"o":""},"ħ":{"ha":702,"x_min":-53,"x_max":656,"o":"m 49 0 l 49 1025 l -53 1025 l -53 1129 l 49 1129 l 49 1194 l 298 1194 l 298 1129 l 388 1129 l 388 1025 l 298 1025 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 0 l 410 0 l 410 768 q 396 822 410 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 z "},"ḫ":{"ha":702,"x_min":49,"x_max":656,"o":"m 49 0 l 49 1194 l 298 1194 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 0 l 410 0 l 410 768 q 396 822 410 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 m 350 -282 q 158 -232 231 -282 q 84 -71 84 -182 q 86 -43 84 -56 l 260 -43 q 279 -101 260 -81 q 351 -121 299 -121 q 423 -101 404 -121 q 443 -43 443 -81 l 616 -43 q 618 -66 618 -60 q 545 -231 618 -180 q 350 -282 472 -282 z "},"ȟ":{"ha":702,"x_min":-128,"x_max":656,"o":"m 49 0 l 49 1194 l 298 1194 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 0 l 410 0 l 410 768 q 396 822 410 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 m 35 1255 l -128 1529 l 115 1529 l 174 1335 l 232 1529 l 475 1529 l 312 1255 l 35 1255 z "},"ḩ":{"ha":702,"x_min":21,"x_max":656,"o":"m 49 0 l 49 1194 l 298 1194 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 0 l 410 0 l 410 768 q 396 822 410 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 m 155 -428 q 21 -401 85 -428 l 21 -250 q 62 -261 42 -256 q 101 -265 83 -265 q 158 -247 135 -265 q 180 -185 180 -229 q 162 -98 180 -147 q 110 0 143 -50 l 219 0 q 321 -129 285 -58 q 357 -262 357 -199 q 309 -380 357 -332 q 155 -428 261 -428 z "},"ĥ":{"ha":702,"x_min":-128,"x_max":656,"o":"m 49 0 l 49 1194 l 298 1194 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 0 l 410 0 l 410 768 q 396 822 410 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 m -128 1255 l 35 1529 l 312 1529 l 475 1255 l 232 1255 l 174 1449 l 115 1255 l -128 1255 z "},"ḧ":{"ha":702,"x_min":-117,"x_max":656,"o":"m 49 0 l 49 1194 l 298 1194 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 0 l 410 0 l 410 768 q 396 822 410 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 m 212 1261 l 212 1463 l 454 1463 l 454 1261 l 212 1261 m -117 1261 l -117 1463 l 126 1463 l 126 1261 l -117 1261 z "},"ḣ":{"ha":702,"x_min":49,"x_max":656,"o":"m 49 0 l 49 1194 l 298 1194 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 0 l 410 0 l 410 768 q 396 822 410 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 m 392 1098 l 392 1300 l 635 1300 l 635 1098 l 392 1098 z "},"ḥ":{"ha":702,"x_min":49,"x_max":656,"o":"m 49 0 l 49 1194 l 298 1194 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 0 l 410 0 l 410 768 q 396 822 410 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 m 230 -283 l 230 -81 l 473 -81 l 473 -283 l 230 -283 z "},"ꜧ":{"ha":702,"x_min":49,"x_max":656,"o":"m 354 -176 l 354 11 q 400 34 387 11 q 413 100 413 57 l 413 768 q 398 822 413 801 q 353 843 382 843 q 313 821 328 843 q 298 770 298 800 l 298 0 l 49 0 l 49 1194 l 298 1194 l 298 916 q 359 1001 318 973 q 454 1028 399 1028 q 608 962 559 1028 q 656 783 656 895 l 656 94 q 629 -52 656 8 q 537 -144 603 -113 q 354 -176 471 -176 z "},"ɦ":{"ha":702,"x_min":49,"x_max":656,"o":"m 49 0 l 49 901 q 82 1058 49 989 q 185 1165 115 1126 q 369 1204 256 1204 l 369 1017 q 315 995 331 1017 q 298 928 298 972 l 298 848 q 454 960 337 960 q 605 894 555 960 q 656 715 656 827 l 656 0 l 413 0 l 413 700 q 398 754 413 733 q 353 775 382 775 q 313 753 328 775 q 298 702 298 732 l 298 0 l 49 0 z "},"ʰ":{"ha":528,"x_min":57,"x_max":471,"o":"m 57 541 l 57 1356 l 228 1356 l 228 1167 q 329 1243 254 1243 q 436 1198 401 1243 q 471 1076 471 1153 l 471 541 l 304 541 l 304 1065 q 294 1103 304 1088 q 264 1117 285 1117 q 238 1102 248 1117 q 228 1067 228 1088 l 228 541 l 57 541 z "},"̉":{"ha":0,"x_min":-120,"x_max":184,"o":"m 0 1083 l -72 1167 q -13 1201 -35 1181 q 9 1255 9 1221 q -59 1320 9 1320 q -120 1309 -91 1320 l -120 1431 q 4 1453 -60 1453 q 137 1411 89 1453 q 184 1292 184 1369 q 132 1157 184 1206 q 0 1083 79 1107 z "},"―":{"ha":782,"x_min":41,"x_max":741,"o":"m 41 345 l 41 503 l 741 503 l 741 345 l 41 345 z "},"̛":{"ha":0,"x_min":0,"x_max":319,"o":"m 92 1052 q 0 1066 41 1052 l 0 1194 l 52 1194 q 130 1279 130 1194 l 130 1366 l 319 1366 l 319 1284 q 288 1148 319 1200 q 206 1075 258 1097 q 92 1052 155 1052 z "},"ɥ":{"ha":693,"x_min":46,"x_max":644,"o":"m 401 -170 l 401 109 q 343 20 378 50 q 238 -11 307 -11 q 115 23 157 -11 q 60 118 74 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 295 q 303 203 290 227 q 345 179 316 179 q 389 207 375 179 q 402 300 402 235 l 402 1017 l 644 1017 l 644 -170 l 401 -170 z "},"˝":{"ha":622,"x_min":54,"x_max":568,"o":"m 372 1089 l 259 1128 l 409 1453 l 568 1380 l 372 1089 m 167 1089 l 54 1128 l 179 1453 l 335 1380 l 167 1089 z "},"̋":{"ha":0,"x_min":-203,"x_max":311,"o":"m 115 1089 l 2 1128 l 152 1453 l 311 1380 l 115 1089 m -90 1089 l -203 1128 l -78 1453 l 78 1380 l -90 1089 z "},"-":{"ha":432,"x_min":41,"x_max":391,"o":"m 41 345 l 41 503 l 391 503 l 391 345 l 41 345 z "},"‐":{"ha":432,"x_min":41,"x_max":391,"o":"m 41 345 l 41 503 l 391 503 l 391 345 l 41 345 z "},"i":{"ha":338,"x_min":47,"x_max":290,"o":"m 47 1080 l 47 1282 l 290 1282 l 290 1080 l 47 1080 m 47 0 l 47 1017 l 290 1017 l 290 0 l 47 0 z "},"í":{"ha":327,"x_min":3,"x_max":325,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 3 1053 l 3 1204 l 325 1352 l 325 1117 l 3 1053 z "},"ĭ":{"ha":327,"x_min":-100,"x_max":433,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 165 1080 q -27 1130 47 1080 q -100 1291 -100 1180 q -98 1319 -100 1305 l 75 1319 q 95 1260 75 1280 q 167 1240 115 1240 q 239 1260 219 1240 q 258 1319 258 1280 l 432 1319 q 433 1305 433 1312 q 433 1295 433 1299 q 360 1131 433 1182 q 165 1080 288 1080 z "},"ǐ":{"ha":327,"x_min":-138,"x_max":465,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 25 1079 l -138 1352 l 105 1352 l 163 1159 l 222 1352 l 465 1352 l 302 1079 l 25 1079 z "},"î":{"ha":327,"x_min":-138,"x_max":465,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m -138 1079 l 25 1352 l 302 1352 l 465 1079 l 222 1079 l 163 1272 l 105 1079 l -138 1079 z "},"ȉ":{"ha":327,"x_min":-166,"x_max":347,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 30 1076 l -166 1367 l -7 1440 l 142 1115 l 30 1076 m 235 1076 l 66 1367 l 222 1440 l 347 1115 l 235 1076 z "},"ï":{"ha":327,"x_min":-127,"x_max":444,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 201 1084 l 201 1286 l 444 1286 l 444 1084 l 201 1084 m -127 1084 l -127 1286 l 116 1286 l 116 1084 l -127 1084 z "},"ḯ":{"ha":327,"x_min":-127,"x_max":444,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 201 1084 l 201 1253 l 444 1253 l 444 1084 l 201 1084 m -127 1084 l -127 1253 l 116 1253 l 116 1084 l -127 1084 m -2 1312 l -2 1442 l 320 1556 l 320 1362 l -2 1312 z "},"ị":{"ha":327,"x_min":42,"x_max":285,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 42 1080 l 42 1282 l 285 1282 l 285 1080 l 42 1080 m 42 -283 l 42 -81 l 285 -81 l 285 -283 l 42 -283 z "},"ı":{"ha":327,"x_min":42,"x_max":285,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 z "},"ì":{"ha":327,"x_min":2,"x_max":324,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 324 1053 l 2 1117 l 2 1352 l 324 1204 l 324 1053 z "},"ỉ":{"ha":327,"x_min":42,"x_max":348,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 163 1083 l 92 1167 q 151 1201 128 1181 q 173 1255 173 1221 q 104 1320 173 1320 q 43 1309 73 1320 l 43 1431 q 168 1453 103 1453 q 300 1411 252 1453 q 348 1292 348 1369 q 295 1157 348 1206 q 163 1083 242 1107 z "},"ȋ":{"ha":327,"x_min":-90,"x_max":416,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m -88 1090 q -90 1118 -90 1104 q -23 1279 -90 1229 q 162 1329 43 1329 q 350 1278 284 1329 q 416 1114 416 1227 q 416 1104 416 1110 q 415 1090 416 1097 l 255 1090 q 229 1159 255 1137 q 163 1181 203 1181 q 98 1159 124 1181 q 72 1090 72 1137 l -88 1090 z "},"ĳ":{"ha":703,"x_min":47,"x_max":655,"o":"m 47 1080 l 47 1282 l 290 1282 l 290 1080 l 47 1080 m 47 0 l 47 1017 l 290 1017 l 290 0 l 47 0 m 412 1080 l 412 1282 l 655 1282 l 655 1080 l 412 1080 m 464 -176 q 361 -159 387 -176 l 361 4 q 383 1 373 1 q 408 14 403 1 q 412 49 412 28 l 412 1017 l 655 1017 l 655 56 q 612 -115 655 -53 q 464 -176 569 -176 z "},"ī":{"ha":327,"x_min":-57,"x_max":384,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m -57 1098 l -57 1202 l 384 1202 l 384 1098 l -57 1098 z "},"∆":{"ha":625,"x_min":23,"x_max":602,"o":"m 23 0 l 147 1194 l 480 1194 l 602 0 l 23 0 m 255 156 l 368 156 l 322 984 l 300 984 l 255 156 z "},"∞":{"ha":794,"x_min":33,"x_max":761,"o":"m 578 298 q 468 329 514 298 q 393 397 422 359 q 316 336 364 365 q 210 307 267 307 q 77 360 122 307 q 33 505 33 413 q 78 646 33 594 q 210 697 124 697 q 393 600 306 697 q 578 706 478 706 q 714 652 667 706 q 761 505 761 597 q 715 354 761 410 q 578 298 669 298 m 538 454 q 602 502 602 454 q 538 550 602 550 q 435 502 487 550 q 538 454 483 454 m 253 454 q 351 502 300 454 q 253 549 302 549 q 193 502 193 549 q 253 454 193 454 z "},"∫":{"ha":411,"x_min":24,"x_max":388,"o":"m 162 -32 q 24 -12 77 -32 l 24 138 q 53 134 45 134 q 81 150 77 134 q 85 189 85 165 l 85 926 q 125 1049 85 1008 q 250 1090 165 1090 q 388 1070 335 1090 l 388 920 q 359 924 366 924 q 328 909 334 924 q 321 869 321 895 l 321 132 q 283 9 321 51 q 162 -32 245 -32 z "},"į":{"ha":338,"x_min":-73,"x_max":297,"o":"m 47 1080 l 47 1282 l 290 1282 l 290 1080 l 47 1080 m 47 0 l 47 1017 l 290 1017 l 290 0 l 47 0 m 163 -428 q 45 -404 98 -428 q -41 -333 -9 -379 q -73 -224 -73 -288 q 106 0 -73 -100 l 249 0 q 172 -89 203 -44 q 140 -189 140 -133 q 218 -265 140 -265 q 297 -250 252 -265 l 297 -401 q 163 -428 233 -428 z "},"ɩ":{"ha":339,"x_min":42,"x_max":339,"o":"m 339 -11 q 124 63 205 -11 q 42 279 42 136 l 42 1017 l 285 1017 l 285 266 q 299 192 285 208 q 339 176 314 176 l 339 -11 z "},"ɨ":{"ha":434,"x_min":7,"x_max":427,"o":"m 96 1080 l 96 1282 l 338 1282 l 338 1080 l 96 1080 m 96 0 l 96 460 l 7 460 l 7 618 l 96 618 l 96 1017 l 338 1017 l 338 618 l 427 618 l 427 460 l 338 460 l 338 0 l 96 0 z "},"ĩ":{"ha":327,"x_min":-117,"x_max":444,"o":"m 42 0 l 42 1017 l 285 1017 l 285 0 l 42 0 m 275 1093 q 183 1108 223 1093 q 110 1139 143 1124 q 46 1154 77 1154 q 13 1144 28 1154 q -16 1108 -3 1134 l -117 1161 q -80 1237 -100 1202 q -28 1292 -60 1271 q 51 1312 3 1312 q 140 1298 101 1312 q 210 1270 178 1284 q 268 1255 241 1255 q 302 1267 286 1255 q 331 1306 317 1278 l 444 1270 q 408 1183 427 1224 q 357 1118 388 1143 q 275 1093 326 1093 z "},"ḭ":{"ha":338,"x_min":-111,"x_max":449,"o":"m 47 1080 l 47 1282 l 290 1282 l 290 1080 l 47 1080 m 47 0 l 47 1017 l 290 1017 l 290 0 l 47 0 m 281 -295 q 189 -279 231 -295 q 113 -249 147 -264 q 52 -233 79 -233 q 18 -243 34 -233 q -11 -279 3 -254 l -111 -227 q -74 -151 -94 -185 q -23 -96 -54 -117 q 56 -75 8 -75 q 143 -90 104 -75 q 215 -118 182 -104 q 273 -132 247 -132 q 307 -121 292 -132 q 336 -81 323 -109 l 449 -118 q 413 -204 433 -163 q 362 -270 393 -245 q 281 -295 332 -295 z "},"j":{"ha":365,"x_min":23,"x_max":317,"o":"m 75 1080 l 75 1282 l 317 1282 l 317 1080 l 75 1080 m 126 -176 q 23 -159 49 -176 l 23 4 q 45 1 35 1 q 70 14 65 1 q 75 49 75 28 l 75 1017 l 317 1017 l 317 56 q 274 -115 317 -53 q 126 -176 231 -176 z "},"ǰ":{"ha":365,"x_min":-100,"x_max":503,"o":"m 126 -176 q 23 -159 49 -176 l 23 4 q 45 1 35 1 q 70 14 65 1 q 75 49 75 28 l 75 1017 l 317 1017 l 317 56 q 274 -115 317 -53 q 126 -176 231 -176 m 63 1079 l -100 1352 l 143 1352 l 201 1159 l 260 1352 l 503 1352 l 340 1079 l 63 1079 z "},"ĵ":{"ha":365,"x_min":-100,"x_max":503,"o":"m 126 -176 q 23 -159 49 -176 l 23 4 q 45 1 35 1 q 70 14 65 1 q 75 49 75 28 l 75 1017 l 317 1017 l 317 56 q 274 -115 317 -53 q 126 -176 231 -176 m -100 1079 l 63 1352 l 340 1352 l 503 1079 l 260 1079 l 201 1272 l 143 1079 l -100 1079 z "},"ʝ":{"ha":581,"x_min":-7,"x_max":588,"o":"m 286 1080 l 286 1282 l 529 1282 l 529 1080 l 286 1080 m 256 -176 q 62 -104 132 -176 q -7 118 -7 -31 q 24 253 -7 189 q 120 360 55 316 q 286 415 185 404 l 286 1017 l 529 1017 l 529 388 q 588 363 557 378 l 588 177 q 558 191 573 184 q 529 202 543 197 l 529 56 q 455 -115 529 -53 q 256 -176 382 -176 m 248 1 q 277 14 269 1 q 286 49 286 28 l 286 226 q 221 182 241 214 q 202 91 202 149 q 214 19 202 38 q 248 1 226 1 z "},"ȷ":{"ha":365,"x_min":23,"x_max":317,"o":"m 126 -176 q 23 -159 49 -176 l 23 4 q 45 1 35 1 q 70 14 65 1 q 75 49 75 28 l 75 1017 l 317 1017 l 317 56 q 274 -115 317 -53 q 126 -176 231 -176 z "},"ɉ":{"ha":445,"x_min":31,"x_max":425,"o":"m 106 1080 l 106 1282 l 349 1282 l 349 1080 l 106 1080 m 158 -176 q 55 -159 81 -176 l 55 4 q 77 1 67 1 q 102 14 97 1 q 106 49 106 28 l 106 440 l 31 440 l 31 597 l 106 597 l 106 1017 l 349 1017 l 349 597 l 425 597 l 425 440 l 349 440 l 349 56 q 306 -115 349 -53 q 158 -176 263 -176 z "},"k":{"ha":682,"x_min":49,"x_max":699,"o":"m 49 0 l 49 1194 l 289 1194 l 289 667 l 406 1017 l 657 1017 l 505 575 l 699 0 l 440 0 l 289 479 l 289 0 l 49 0 z "},"ḱ":{"ha":682,"x_min":8,"x_max":699,"o":"m 49 0 l 49 1194 l 289 1194 l 289 667 l 406 1017 l 657 1017 l 505 575 l 699 0 l 440 0 l 289 479 l 289 0 l 49 0 m 8 1230 l 8 1381 l 330 1529 l 330 1293 l 8 1230 z "},"ǩ":{"ha":682,"x_min":-133,"x_max":699,"o":"m 49 0 l 49 1194 l 289 1194 l 289 667 l 406 1017 l 657 1017 l 505 575 l 699 0 l 440 0 l 289 479 l 289 0 l 49 0 m 31 1255 l -133 1529 l 111 1529 l 169 1335 l 227 1529 l 471 1529 l 307 1255 l 31 1255 z "},"ķ":{"ha":682,"x_min":49,"x_max":699,"o":"m 49 0 l 49 1194 l 289 1194 l 289 667 l 406 1017 l 657 1017 l 505 575 l 699 0 l 440 0 l 289 479 l 289 0 l 49 0 m 270 -436 l 315 -276 l 229 -276 l 229 -74 l 482 -74 l 482 -270 l 413 -436 l 270 -436 z "},"ḳ":{"ha":682,"x_min":49,"x_max":699,"o":"m 49 0 l 49 1194 l 289 1194 l 289 667 l 406 1017 l 657 1017 l 505 575 l 699 0 l 440 0 l 289 479 l 289 0 l 49 0 m 243 -283 l 243 -81 l 486 -81 l 486 -283 l 243 -283 z "},"ĸ":{"ha":684,"x_min":49,"x_max":699,"o":"m 49 0 l 49 1017 l 289 1017 l 289 644 l 406 1017 l 657 1017 l 505 553 l 699 0 l 440 0 l 289 457 l 289 0 l 49 0 z "},"ƙ":{"ha":682,"x_min":49,"x_max":699,"o":"m 657 1017 l 505 575 l 699 0 l 440 0 l 289 479 l 289 0 l 49 0 l 49 901 q 81 1058 49 989 q 182 1165 114 1126 q 359 1204 251 1204 l 359 1017 q 305 995 321 1017 q 289 928 289 972 l 289 667 l 406 1017 l 657 1017 z "},"₭":{"ha":707,"x_min":52,"x_max":655,"o":"m 119 0 l 119 502 l 52 502 l 52 667 l 119 667 l 119 1080 l 306 1080 l 306 667 l 312 667 l 433 1080 l 630 1080 l 507 667 l 597 667 l 597 502 l 507 502 l 655 0 l 452 0 l 312 502 l 307 502 l 307 0 l 119 0 z "},"ḵ":{"ha":682,"x_min":49,"x_max":699,"o":"m 49 0 l 49 1194 l 289 1194 l 289 667 l 406 1017 l 657 1017 l 505 575 l 699 0 l 440 0 l 289 479 l 289 0 l 49 0 m 144 -184 l 144 -81 l 585 -81 l 585 -184 l 144 -184 z "},"ꝁ":{"ha":682,"x_min":-25,"x_max":699,"o":"m 49 0 l 49 1025 l -25 1025 l -25 1129 l 49 1129 l 49 1194 l 289 1194 l 289 1129 l 389 1129 l 389 1025 l 289 1025 l 289 667 l 406 1017 l 657 1017 l 505 575 l 699 0 l 440 0 l 289 479 l 289 0 l 49 0 z "},"l":{"ha":345,"x_min":49,"x_max":296,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 z "},"ĺ":{"ha":345,"x_min":12,"x_max":334,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 m 12 1230 l 12 1381 l 334 1529 l 334 1293 l 12 1230 z "},"ƛ":{"ha":640,"x_min":1,"x_max":649,"o":"m 1 0 l 154 829 l 47 829 l 47 932 l 176 932 q 127 995 163 973 q 45 1017 92 1017 l 45 1204 q 233 1174 160 1204 q 347 1086 305 1144 q 410 941 389 1027 l 412 932 l 532 932 l 532 829 l 438 829 l 578 270 q 607 196 592 212 q 649 180 622 180 l 649 -7 q 483 23 541 -7 q 396 112 425 54 q 345 256 367 171 l 296 452 l 248 0 l 1 0 z "},"ƚ":{"ha":434,"x_min":-7,"x_max":441,"o":"m 94 0 l 94 1194 l 340 1194 l 340 0 l 94 0 m -7 522 l -7 679 l 441 679 l 441 522 l -7 522 z "},"ɬ":{"ha":522,"x_min":-7,"x_max":529,"o":"m 182 0 l 182 469 q 47 523 101 475 q -7 651 -7 572 q 43 792 -7 741 q 182 848 92 842 l 182 1194 l 429 1194 l 429 625 l 529 625 l 529 468 l 429 468 l 429 0 l 182 0 m 125 665 q 182 625 125 625 l 182 705 q 125 665 125 704 z "},"ľ":{"ha":560,"x_min":49,"x_max":560,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 m 348 831 l 399 991 l 349 991 l 349 1194 l 560 1194 l 560 998 l 491 831 l 348 831 z "},"ḽ":{"ha":345,"x_min":-130,"x_max":474,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 m -130 -347 l 34 -74 l 311 -74 l 474 -347 l 231 -347 l 172 -154 l 114 -347 l -130 -347 z "},"ļ":{"ha":345,"x_min":49,"x_max":303,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 m 91 -436 l 136 -276 l 50 -276 l 50 -74 l 303 -74 l 303 -270 l 234 -436 l 91 -436 z "},"ŀ":{"ha":567,"x_min":49,"x_max":564,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 m 348 558 l 348 774 l 564 774 l 564 558 l 348 558 z "},"ḷ":{"ha":345,"x_min":49,"x_max":296,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 m 51 -283 l 51 -81 l 294 -81 l 294 -283 l 51 -283 z "},"ḹ":{"ha":345,"x_min":-49,"x_max":392,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 m -49 1236 l -49 1340 l 392 1340 l 392 1236 l -49 1236 m 51 -283 l 51 -81 l 294 -81 l 294 -283 l 51 -283 z "},"ⱡ":{"ha":434,"x_min":-7,"x_max":441,"o":"m 90 0 l 90 1194 l 336 1194 l 336 0 l 90 0 m -7 664 l -7 821 l 441 821 l 441 664 l -7 664 m -7 420 l -7 577 l 441 577 l 441 420 l -7 420 z "},"←":{"ha":947,"x_min":14,"x_max":906,"o":"m 144 283 l 14 511 l 144 739 l 354 739 l 286 615 l 906 615 l 906 399 l 289 399 l 354 283 l 144 283 z "},"◀":{"ha":1034,"x_min":20,"x_max":981,"o":"m 981 0 l 20 508 l 981 1015 l 981 0 z "},"◁":{"ha":1034,"x_min":20,"x_max":981,"o":"m 981 0 l 20 508 l 981 1015 l 981 0 m 848 220 l 848 795 l 303 508 l 848 220 z "},"⟨":{"ha":492,"x_min":26,"x_max":452,"o":"m 249 -69 l 26 596 l 249 1261 l 452 1261 l 230 596 l 452 -69 l 249 -69 z "},"<":{"ha":446,"x_min":24,"x_max":410,"o":"m 410 136 l 24 370 l 24 650 l 410 882 l 410 638 l 178 508 l 410 378 l 410 136 z "},"≤":{"ha":448,"x_min":26,"x_max":413,"o":"m 413 198 l 26 432 l 26 713 l 413 944 l 413 701 l 181 570 l 413 441 l 413 198 m 45 0 l 45 157 l 395 157 l 395 0 l 45 0 z "},"₤":{"ha":658,"x_min":19,"x_max":633,"o":"m 28 0 l 28 191 q 108 250 79 220 q 144 336 137 280 l 19 336 l 19 458 l 144 458 q 140 499 143 478 q 134 539 138 519 l 19 539 l 19 661 l 112 661 q 94 755 101 711 q 86 830 86 798 q 161 1028 86 965 q 369 1090 236 1090 q 525 1050 467 1090 q 608 937 583 1010 q 633 763 633 863 l 416 763 q 407 862 416 833 q 373 890 397 890 q 343 873 352 890 q 335 825 335 856 q 342 743 335 782 q 359 661 349 704 l 553 661 l 553 539 l 386 539 q 393 499 389 519 q 399 458 396 479 l 553 458 l 553 336 l 402 336 q 368 253 395 288 q 308 197 342 218 l 627 197 l 627 0 l 28 0 z "},"₺":{"ha":705,"x_min":56,"x_max":650,"o":"m 123 0 l 123 412 l 56 390 l 56 519 l 123 541 l 123 629 l 56 607 l 56 736 l 123 758 l 123 1080 l 297 1080 l 297 817 l 522 892 l 522 763 l 297 688 l 297 600 l 522 675 l 522 546 l 297 471 l 297 163 l 411 163 q 473 237 473 163 l 473 435 l 650 435 l 650 279 q 596 73 650 146 q 408 0 542 0 l 123 0 z "},"ℓ":{"ha":345,"x_min":49,"x_max":296,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 z "},"ǉ":{"ha":709,"x_min":49,"x_max":662,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 m 419 1080 l 419 1282 l 662 1282 l 662 1080 l 419 1080 m 471 -176 q 368 -159 393 -176 l 368 4 q 390 1 380 1 q 414 14 410 1 q 419 49 419 28 l 419 1017 l 662 1017 l 662 56 q 619 -115 662 -53 q 471 -176 576 -176 z "},"ḻ":{"ha":345,"x_min":-48,"x_max":393,"o":"m 49 0 l 49 1194 l 296 1194 l 296 0 l 49 0 m -48 -184 l -48 -81 l 393 -81 l 393 -184 l -48 -184 z "},"ɫ":{"ha":547,"x_min":-7,"x_max":553,"o":"m 150 0 l 150 1194 l 397 1194 l 397 0 l 150 0 m 385 526 q 293 542 333 526 q 220 573 253 557 q 156 588 187 588 q 123 578 138 588 q 94 542 107 568 l -7 595 q 30 670 10 636 q 81 725 50 705 q 161 746 113 746 q 250 732 211 746 q 320 703 288 718 q 378 689 351 689 q 412 701 396 689 q 441 740 427 712 l 553 703 q 517 617 537 658 q 467 551 498 576 q 385 526 436 526 z "},"¬":{"ha":561,"x_min":25,"x_max":519,"o":"m 309 298 l 309 543 l 25 543 l 25 664 l 519 664 l 519 298 l 309 298 z "},"ſ":{"ha":389,"x_min":27,"x_max":376,"o":"m 71 0 l 71 787 l 27 787 l 27 972 l 75 972 q 162 1135 89 1069 q 376 1200 235 1200 l 376 1013 q 327 993 342 1013 q 312 924 312 972 l 312 0 l 71 0 z "},"̲":{"ha":0,"x_min":-221,"x_max":221,"o":"m -221 -245 l -221 -88 l 221 -88 l 221 -245 l -221 -245 z "},"◊":{"ha":625,"x_min":23,"x_max":602,"o":"m 147 0 l 23 484 l 147 974 l 480 974 l 602 484 l 480 0 l 147 0 m 300 121 l 322 121 l 413 484 l 322 846 l 300 846 l 210 484 l 300 121 z "},"ł":{"ha":400,"x_min":-2,"x_max":402,"o":"m 76 0 l 76 464 l -2 433 l -2 618 l 76 648 l 76 1198 l 323 1198 l 323 744 l 402 775 l 402 591 l 323 559 l 323 0 l 76 0 z "},"m":{"ha":1053,"x_min":49,"x_max":1007,"o":"m 49 0 l 49 1017 l 286 1017 l 286 899 q 342 995 302 962 q 457 1028 381 1028 q 561 1000 518 1028 q 622 926 604 972 q 687 1002 650 976 q 795 1028 725 1028 q 925 992 880 1028 q 989 891 971 956 q 1007 743 1007 827 l 1007 0 l 765 0 l 765 747 q 715 846 765 846 q 674 828 688 846 q 654 783 660 810 q 649 730 649 757 l 649 0 l 407 0 l 407 747 q 399 811 407 779 q 359 843 391 843 q 317 823 332 843 q 297 775 302 804 q 292 718 292 746 l 292 0 l 49 0 z "},"¯":{"ha":495,"x_min":27,"x_max":468,"o":"m 27 1098 l 27 1202 l 468 1202 l 468 1098 l 27 1098 z "},"᷄":{"ha":0,"x_min":-213,"x_max":213,"o":"m -213 1202 l 6 1202 l 213 1343 l 213 1162 l 6 1098 l 6 1101 l 5 1098 l -213 1098 l -213 1202 z "},"̱":{"ha":0,"x_min":-220,"x_max":220,"o":"m -220 -184 l -220 -81 l 220 -81 l 220 -184 l -220 -184 z "},"̄":{"ha":0,"x_min":-220,"x_max":220,"o":"m -220 1098 l -220 1202 l 220 1202 l 220 1098 l -220 1098 z "},"᷆":{"ha":0,"x_min":-213,"x_max":213,"o":"m 6 1340 l 6 1343 l 213 1279 l 213 1098 l 6 1239 l -213 1239 l -213 1343 l 5 1343 l 6 1340 z "},"ḿ":{"ha":1053,"x_min":49,"x_max":1007,"o":"m 49 0 l 49 1017 l 286 1017 l 286 899 q 342 995 302 962 q 457 1028 381 1028 q 561 1000 518 1028 q 622 926 604 972 q 687 1002 650 976 q 795 1028 725 1028 q 925 992 880 1028 q 989 891 971 956 q 1007 743 1007 827 l 1007 0 l 765 0 l 765 747 q 715 846 765 846 q 674 828 688 846 q 654 783 660 810 q 649 730 649 757 l 649 0 l 407 0 l 407 747 q 399 811 407 779 q 359 843 391 843 q 317 823 332 843 q 297 775 302 804 q 292 718 292 746 l 292 0 l 49 0 m 368 1053 l 368 1204 l 690 1352 l 690 1117 l 368 1053 z "},"₼":{"ha":707,"x_min":25,"x_max":682,"o":"m 25 0 l 25 553 q 88 778 25 708 q 271 862 151 848 l 271 1080 l 444 1080 l 444 861 q 621 775 561 845 q 682 553 682 705 l 682 0 l 508 0 l 508 557 q 496 638 508 604 q 444 689 484 672 l 444 0 l 271 0 l 271 690 q 214 638 229 673 q 199 557 199 604 l 199 0 l 25 0 z "},"ṁ":{"ha":1053,"x_min":49,"x_max":1007,"o":"m 49 0 l 49 1017 l 286 1017 l 286 899 q 342 995 302 962 q 457 1028 381 1028 q 561 1000 518 1028 q 622 926 604 972 q 687 1002 650 976 q 795 1028 725 1028 q 925 992 880 1028 q 989 891 971 956 q 1007 743 1007 827 l 1007 0 l 765 0 l 765 747 q 715 846 765 846 q 674 828 688 846 q 654 783 660 810 q 649 730 649 757 l 649 0 l 407 0 l 407 747 q 399 811 407 779 q 359 843 391 843 q 317 823 332 843 q 297 775 302 804 q 292 718 292 746 l 292 0 l 49 0 m 407 1080 l 407 1282 l 650 1282 l 650 1080 l 407 1080 z "},"ṃ":{"ha":1053,"x_min":49,"x_max":1007,"o":"m 49 0 l 49 1017 l 286 1017 l 286 899 q 342 995 302 962 q 457 1028 381 1028 q 561 1000 518 1028 q 622 926 604 972 q 687 1002 650 976 q 795 1028 725 1028 q 925 992 880 1028 q 989 891 971 956 q 1007 743 1007 827 l 1007 0 l 765 0 l 765 747 q 715 846 765 846 q 674 828 688 846 q 654 783 660 810 q 649 730 649 757 l 649 0 l 407 0 l 407 747 q 399 811 407 779 q 359 843 391 843 q 317 823 332 843 q 297 775 302 804 q 292 718 292 746 l 292 0 l 49 0 m 406 -283 l 406 -81 l 648 -81 l 648 -283 l 406 -283 z "},"µ":{"ha":680,"x_min":46,"x_max":644,"o":"m 46 -126 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 357 31 382 60 q 283 -7 332 2 l 283 -126 l 46 -126 z "},"−":{"ha":432,"x_min":41,"x_max":391,"o":"m 41 345 l 41 503 l 391 503 l 391 345 l 41 345 z "},"˗":{"ha":432,"x_min":41,"x_max":391,"o":"m 41 345 l 41 503 l 391 503 l 391 345 l 41 345 z "},"′":{"ha":297,"x_min":28,"x_max":267,"o":"m 96 762 l 28 1194 l 267 1194 l 215 762 l 96 762 z "},"ɯ":{"ha":1053,"x_min":46,"x_max":1004,"o":"m 1004 1017 l 1004 0 l 767 0 l 767 118 q 712 23 751 56 q 596 -11 673 -11 q 492 17 535 -11 q 431 92 449 45 q 366 15 404 41 q 258 -11 329 -11 q 128 25 174 -11 q 64 126 82 62 q 46 274 46 191 l 46 1017 l 288 1017 l 288 270 q 338 172 288 172 q 379 190 365 172 q 399 234 393 208 q 404 287 404 261 l 404 1017 l 646 1017 l 646 270 q 654 206 646 238 q 694 174 662 174 q 736 194 722 174 q 756 243 751 214 q 762 299 762 272 l 762 1017 l 1004 1017 z "},"×":{"ha":481,"x_min":30,"x_max":452,"o":"m 141 213 l 30 324 l 130 424 l 30 524 l 141 635 l 241 535 l 340 635 l 452 524 l 352 424 l 452 324 l 340 213 l 241 313 l 141 213 z "},"n":{"ha":692,"x_min":49,"x_max":646,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 z "},"ń":{"ha":692,"x_min":49,"x_max":646,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 186 1053 l 186 1204 l 509 1352 l 509 1117 l 186 1053 z "},"₦":{"ha":709,"x_min":22,"x_max":687,"o":"m 90 0 l 90 363 l 22 363 l 22 485 l 90 485 l 90 621 l 22 621 l 22 743 l 90 743 l 90 1080 l 268 1080 l 365 743 l 454 743 l 454 1080 l 619 1080 l 619 743 l 687 743 l 687 621 l 619 621 l 619 485 l 687 485 l 687 363 l 619 363 l 619 0 l 441 0 l 339 363 l 256 363 l 256 0 l 90 0 m 256 659 l 256 485 l 304 485 l 256 659 m 454 434 l 454 621 l 400 621 l 454 434 z "},"ŉ":{"ha":692,"x_min":-109,"x_max":646,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m -68 1080 l -23 1240 l -109 1240 l -109 1442 l 144 1442 l 144 1246 l 75 1080 l -68 1080 z "},"ň":{"ha":692,"x_min":46,"x_max":650,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 210 1079 l 46 1352 l 290 1352 l 348 1159 l 406 1352 l 650 1352 l 486 1079 l 210 1079 z "},"ṋ":{"ha":692,"x_min":45,"x_max":648,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 45 -347 l 208 -74 l 485 -74 l 648 -347 l 405 -347 l 347 -154 l 288 -347 l 45 -347 z "},"ņ":{"ha":692,"x_min":49,"x_max":646,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 252 -436 l 297 -276 l 211 -276 l 211 -74 l 465 -74 l 465 -270 l 395 -436 l 252 -436 z "},"ṅ":{"ha":692,"x_min":49,"x_max":646,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 227 1080 l 227 1282 l 469 1282 l 469 1080 l 227 1080 z "},"ṇ":{"ha":692,"x_min":49,"x_max":646,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 225 -283 l 225 -81 l 468 -81 l 468 -283 l 225 -283 z "},"ǹ":{"ha":692,"x_min":49,"x_max":646,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 509 1053 l 186 1117 l 186 1352 l 509 1204 l 509 1053 z "},"ɲ":{"ha":708,"x_min":-7,"x_max":662,"o":"m -7 -311 l -7 -133 q 64 -48 64 -133 l 64 1017 l 307 1017 l 307 888 q 358 987 321 946 q 460 1028 395 1028 q 614 963 566 1028 q 662 785 662 898 l 662 0 l 422 0 l 422 760 q 410 815 422 789 q 368 840 398 840 q 327 821 340 840 q 311 773 314 802 q 307 715 307 744 l 307 0 q 222 -233 307 -155 q -7 -311 137 -311 z "},"₉":{"ha":439,"x_min":35,"x_max":407,"o":"m 214 -52 q 97 -17 148 -52 q 45 86 45 18 l 45 162 l 181 162 l 181 148 q 186 97 181 121 q 216 72 191 72 q 249 85 240 72 q 258 122 258 98 l 258 263 q 228 233 248 244 q 180 221 208 221 q 63 274 92 221 q 35 430 35 326 q 75 599 35 535 q 218 663 115 663 q 367 607 328 663 q 407 438 407 551 l 407 248 q 395 84 407 151 q 341 -17 382 17 q 214 -52 300 -52 m 221 345 q 258 395 258 345 l 258 482 q 223 534 258 534 q 193 513 198 534 q 189 460 189 492 l 189 403 q 221 345 189 345 z "},"⁹":{"ha":439,"x_min":35,"x_max":407,"o":"m 214 530 q 97 565 148 530 q 45 668 45 600 l 45 744 l 181 744 l 181 730 q 186 679 181 703 q 216 654 191 654 q 249 667 240 654 q 258 704 258 680 l 258 845 q 228 814 248 826 q 180 803 208 803 q 63 856 92 803 q 35 1012 35 908 q 75 1181 35 1117 q 218 1245 115 1245 q 367 1189 328 1245 q 407 1020 407 1133 l 407 830 q 395 666 407 733 q 341 565 382 599 q 214 530 300 530 m 221 927 q 258 977 258 927 l 258 1064 q 223 1116 258 1116 q 193 1095 198 1116 q 189 1042 189 1074 l 189 985 q 221 927 189 927 z "},"ǌ":{"ha":1057,"x_min":49,"x_max":1010,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 767 1080 l 767 1282 l 1010 1282 l 1010 1080 l 767 1080 m 819 -176 q 715 -159 741 -176 l 715 4 q 738 1 728 1 q 762 14 758 1 q 767 49 767 28 l 767 1017 l 1010 1017 l 1010 56 q 967 -115 1010 -53 q 819 -176 924 -176 z "},"ƞ":{"ha":692,"x_min":49,"x_max":646,"o":"m 407 -170 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 -170 l 407 -170 z "},"ṉ":{"ha":692,"x_min":49,"x_max":646,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 126 -184 l 126 -81 l 567 -81 l 567 -184 l 126 -184 z "},"≠":{"ha":432,"x_min":41,"x_max":390,"o":"m 41 605 l 41 757 l 390 757 l 390 605 l 41 605 m 41 345 l 41 503 l 390 503 l 390 345 l 41 345 z "},"ñ":{"ha":692,"x_min":49,"x_max":646,"o":"m 49 0 l 49 1017 l 292 1017 l 292 888 q 342 987 305 946 q 445 1028 379 1028 q 598 963 551 1028 q 646 785 646 898 l 646 0 l 407 0 l 407 760 q 395 815 407 789 q 353 840 382 840 q 312 821 325 840 q 295 773 298 802 q 292 715 292 744 l 292 0 l 49 0 m 460 1093 q 368 1108 408 1093 q 295 1139 328 1124 q 231 1154 262 1154 q 197 1144 213 1154 q 168 1108 182 1134 l 68 1161 q 105 1237 85 1202 q 156 1292 125 1271 q 235 1312 187 1312 q 324 1298 286 1312 q 394 1270 363 1284 q 452 1255 426 1255 q 486 1267 471 1255 q 515 1306 502 1278 l 628 1270 q 592 1183 612 1224 q 542 1118 572 1143 q 460 1093 511 1093 z "},"#":{"ha":759,"x_min":26,"x_max":734,"o":"m 26 0 l 93 345 l 28 345 l 28 503 l 123 503 l 142 601 l 68 601 l 68 758 l 173 758 l 236 1080 l 429 1080 l 366 758 l 478 758 l 541 1080 l 734 1080 l 671 758 l 734 758 l 734 601 l 640 601 l 621 503 l 694 503 l 694 345 l 590 345 l 523 0 l 331 0 l 398 345 l 285 345 l 218 0 l 26 0 m 316 503 l 429 503 l 448 601 l 335 601 l 316 503 z "},"№":{"ha":1311,"x_min":53,"x_max":1250,"o":"m 976 457 q 775 529 849 457 q 702 745 702 601 l 702 916 q 774 1131 702 1058 q 976 1204 847 1204 q 1177 1131 1104 1204 q 1250 916 1250 1058 l 1250 745 q 1177 530 1250 603 q 976 457 1103 457 m 53 0 l 53 1194 l 275 1194 l 408 622 l 408 1194 l 618 1194 l 618 0 l 406 0 l 263 597 l 263 0 l 53 0 m 976 633 q 1020 654 1006 633 q 1033 709 1033 675 l 1033 941 q 976 1028 1033 1028 q 919 941 919 1028 l 919 709 q 932 654 919 675 q 976 633 945 633 m 729 215 l 729 385 l 1223 385 l 1223 215 l 729 215 z "},"o":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 z "},"ó":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 184 1064 l 184 1215 l 506 1363 l 506 1128 l 184 1064 z "},"ɵ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 118 434 l 118 591 l 566 591 l 566 434 l 118 434 z "},"ŏ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 347 1090 q 154 1141 228 1090 q 81 1301 81 1191 q 83 1330 81 1316 l 256 1330 q 276 1271 256 1291 q 348 1251 296 1251 q 420 1271 400 1251 q 439 1330 439 1291 l 613 1330 q 614 1316 614 1323 q 614 1306 614 1310 q 542 1142 614 1193 q 347 1090 469 1090 z "},"ǒ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 206 1090 l 43 1363 l 286 1363 l 345 1170 l 403 1363 l 646 1363 l 483 1090 l 206 1090 z "},"ô":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 43 1090 l 206 1363 l 483 1363 l 646 1090 l 403 1090 l 345 1283 l 286 1090 l 43 1090 z "},"ố":{"ha":690,"x_min":41,"x_max":877,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 557 1242 l 669 1442 l 877 1442 l 715 1242 l 557 1242 m 43 1079 l 206 1284 l 483 1284 l 646 1079 l 406 1079 l 345 1211 l 283 1079 l 43 1079 z "},"ộ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 43 1090 l 206 1363 l 483 1363 l 646 1090 l 403 1090 l 345 1283 l 286 1090 l 43 1090 m 223 -283 l 223 -81 l 466 -81 l 466 -283 l 223 -283 z "},"ồ":{"ha":690,"x_min":41,"x_max":755,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 597 1242 l 435 1442 l 644 1442 l 755 1242 l 597 1242 m 43 1079 l 206 1284 l 483 1284 l 646 1079 l 406 1079 l 345 1211 l 283 1079 l 43 1079 z "},"ổ":{"ha":690,"x_min":41,"x_max":774,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 589 1219 l 517 1303 q 576 1337 554 1316 q 599 1391 599 1357 q 530 1455 599 1455 q 469 1444 498 1455 l 469 1567 q 593 1589 529 1589 q 726 1547 678 1589 q 774 1428 774 1504 q 721 1292 774 1341 q 589 1219 668 1243 m 77 1079 l 227 1291 l 463 1291 l 612 1079 l 406 1079 l 345 1211 l 283 1079 l 77 1079 z "},"ỗ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 456 1335 q 380 1351 416 1335 q 311 1382 345 1367 q 241 1397 277 1397 q 200 1387 219 1397 q 165 1351 181 1377 l 64 1404 q 120 1504 88 1462 q 220 1546 153 1546 q 298 1531 262 1546 q 367 1500 334 1516 q 436 1485 400 1485 q 478 1496 462 1485 q 512 1535 495 1508 l 625 1499 q 589 1419 608 1457 q 538 1358 569 1381 q 456 1335 507 1335 m 43 1079 l 206 1284 l 483 1284 l 646 1079 l 406 1079 l 345 1211 l 283 1079 l 43 1079 z "},"ȍ":{"ha":690,"x_min":15,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 211 1086 l 15 1377 l 174 1451 l 323 1126 l 211 1086 m 416 1086 l 248 1377 l 404 1451 l 528 1126 l 416 1086 z "},"ö":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 382 1095 l 382 1297 l 625 1297 l 625 1095 l 382 1095 m 54 1095 l 54 1297 l 297 1297 l 297 1095 l 54 1095 z "},"ȫ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 387 1084 l 387 1253 l 630 1253 l 630 1084 l 387 1084 m 59 1084 l 59 1253 l 302 1253 l 302 1084 l 59 1084 m 124 1326 l 124 1430 l 565 1430 l 565 1326 l 124 1326 z "},"ȯ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 223 1090 l 223 1293 l 466 1293 l 466 1090 l 223 1090 z "},"ȱ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 223 1080 l 223 1255 l 466 1255 l 466 1080 l 223 1080 m 124 1314 l 124 1418 l 565 1418 l 565 1314 l 124 1314 z "},"ọ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 223 -283 l 223 -81 l 466 -81 l 466 -283 l 223 -283 z "},"œ":{"ha":1026,"x_min":33,"x_max":991,"o":"m 336 -12 q 33 304 33 -12 l 33 713 q 113 943 33 857 q 336 1029 194 1029 q 516 964 440 1029 q 699 1029 585 1029 q 991 741 991 1029 l 991 667 q 991 551 991 598 q 989 477 990 503 l 636 477 l 636 290 q 649 204 636 232 q 696 176 661 176 q 740 213 728 176 q 751 300 751 249 l 751 393 l 991 393 l 991 335 q 963 144 991 221 q 868 27 935 66 q 686 -12 802 -12 q 519 47 584 -12 q 336 -12 448 -12 m 635 631 l 750 631 l 750 737 q 694 847 750 847 q 647 820 659 847 q 635 734 635 792 l 635 631 m 336 176 q 380 198 367 176 q 393 254 393 220 l 393 751 q 336 840 393 840 q 279 751 279 840 l 279 254 q 293 198 279 220 q 336 176 306 176 z "},"˛":{"ha":425,"x_min":27,"x_max":397,"o":"m 263 -428 q 145 -404 199 -428 q 59 -333 92 -379 q 27 -224 27 -288 q 206 0 27 -100 l 349 0 q 276 -86 311 -39 q 241 -189 241 -133 q 319 -265 241 -265 q 397 -250 352 -265 l 397 -401 q 263 -428 333 -428 z "},"̨":{"ha":0,"x_min":-420,"x_max":-50,"o":"m -184 -428 q -302 -404 -248 -428 q -388 -333 -355 -379 q -420 -224 -420 -288 q -241 0 -420 -100 l -98 0 q -175 -89 -144 -44 q -206 -189 -206 -133 q -128 -265 -206 -265 q -50 -250 -95 -265 l -50 -401 q -184 -428 -114 -428 z "},"ò":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 505 1064 l 183 1128 l 183 1363 l 505 1215 l 505 1064 z "},"ỏ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 345 1094 l 273 1178 q 332 1212 309 1192 q 354 1266 354 1232 q 286 1331 354 1331 q 224 1320 254 1331 l 224 1442 q 349 1464 284 1464 q 481 1422 433 1464 q 529 1303 529 1379 q 476 1167 529 1217 q 345 1094 423 1118 z "},"ơ":{"ha":690,"x_min":41,"x_max":664,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 l 397 1028 q 475 1113 475 1028 l 475 1128 l 664 1128 l 664 1118 q 642 1000 664 1047 q 583 926 620 953 q 649 713 649 844 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 z "},"ớ":{"ha":690,"x_min":41,"x_max":664,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 l 397 1028 q 475 1113 475 1028 l 475 1128 l 664 1128 l 664 1118 q 642 1000 664 1047 q 583 926 620 953 q 649 713 649 844 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 184 1112 l 184 1263 l 506 1411 l 506 1175 l 184 1112 z "},"ợ":{"ha":690,"x_min":41,"x_max":664,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 l 397 1028 q 475 1113 475 1028 l 475 1128 l 664 1128 l 664 1118 q 642 1000 664 1047 q 583 926 620 953 q 649 713 649 844 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 223 -283 l 223 -81 l 466 -81 l 466 -283 l 223 -283 z "},"ờ":{"ha":690,"x_min":41,"x_max":664,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 l 397 1028 q 475 1113 475 1028 l 475 1128 l 664 1128 l 664 1118 q 642 1000 664 1047 q 583 926 620 953 q 649 713 649 844 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 505 1156 l 183 1219 l 183 1455 l 505 1307 l 505 1156 z "},"ở":{"ha":690,"x_min":41,"x_max":664,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 l 397 1028 q 475 1113 475 1028 l 475 1128 l 664 1128 l 664 1118 q 642 1000 664 1047 q 583 926 620 953 q 649 713 649 844 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 345 1121 l 273 1205 q 332 1239 309 1219 q 354 1293 354 1259 q 286 1358 354 1358 q 224 1347 254 1358 l 224 1469 q 349 1491 284 1491 q 481 1449 433 1491 q 529 1330 529 1407 q 476 1195 529 1244 q 345 1121 423 1145 z "},"ỡ":{"ha":690,"x_min":41,"x_max":664,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 l 397 1028 q 475 1113 475 1028 l 475 1128 l 664 1128 l 664 1118 q 642 1000 664 1047 q 583 926 620 953 q 649 713 649 844 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 456 1164 q 364 1180 404 1164 q 291 1211 324 1196 q 227 1226 258 1226 q 194 1216 210 1226 q 165 1180 178 1206 l 64 1233 q 101 1309 81 1274 q 153 1363 121 1343 q 232 1384 184 1384 q 321 1370 282 1384 q 391 1341 359 1356 q 449 1327 422 1327 q 483 1339 467 1327 q 512 1378 498 1350 l 625 1341 q 589 1255 608 1296 q 538 1190 569 1215 q 456 1164 507 1164 z "},"ő":{"ha":690,"x_min":41,"x_max":673,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 477 1100 l 364 1139 l 514 1464 l 673 1391 l 477 1100 m 272 1100 l 159 1139 l 284 1464 l 440 1391 l 272 1100 z "},"ȏ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 93 1101 q 91 1129 91 1115 q 158 1290 91 1240 q 343 1340 224 1340 q 531 1289 465 1340 q 597 1124 597 1238 q 597 1115 597 1121 q 596 1101 597 1108 l 436 1101 q 410 1170 436 1147 q 345 1192 385 1192 q 279 1170 305 1192 q 253 1101 253 1147 l 93 1101 z "},"ō":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 124 1109 l 124 1213 l 565 1213 l 565 1109 l 124 1109 z "},"ṓ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 124 1057 l 124 1161 l 565 1161 l 565 1057 l 124 1057 m 184 1197 l 184 1348 l 506 1496 l 506 1261 l 184 1197 z "},"ṑ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 124 1057 l 124 1161 l 565 1161 l 565 1057 l 124 1057 m 505 1197 l 183 1261 l 183 1496 l 505 1348 l 505 1197 z "},"ꞷ":{"ha":1042,"x_min":41,"x_max":994,"o":"m 317 -11 q 113 68 186 -11 q 41 304 41 146 l 41 713 q 121 942 41 857 q 345 1028 202 1028 l 345 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 q 388 198 375 176 q 401 254 401 220 l 401 679 l 633 679 l 633 254 q 647 198 633 220 q 690 176 660 176 q 734 198 721 176 q 747 254 747 220 l 747 751 q 690 840 747 840 l 690 1028 q 913 942 833 1028 q 994 713 994 857 l 994 304 q 922 68 994 146 q 718 -11 849 -11 q 600 11 652 -11 q 517 81 549 33 q 435 11 486 33 q 317 -11 383 -11 z "},"⅛":{"ha":983,"x_min":16,"x_max":952,"o":"m 103 492 l 103 1032 q 64 1004 89 1015 q 16 994 39 994 l 16 1105 q 85 1132 48 1110 q 139 1194 122 1154 l 252 1194 l 252 492 l 103 492 m 159 -11 l 551 1204 l 744 1204 l 283 -11 l 159 -11 m 769 -7 q 628 50 670 -7 q 585 210 585 106 l 585 254 q 598 340 585 307 q 645 391 611 373 q 600 435 613 404 q 586 511 586 466 l 586 530 q 633 666 586 623 q 769 708 680 708 q 906 665 861 708 q 951 524 951 621 q 940 439 951 474 q 892 390 928 405 q 943 329 933 370 q 952 228 952 288 l 952 210 q 910 50 952 106 q 769 -7 868 -7 m 769 450 q 806 517 806 450 q 798 559 806 539 q 769 579 791 579 q 740 559 747 579 q 732 517 732 539 q 769 450 732 450 m 769 132 q 807 201 807 132 l 807 247 q 802 297 807 271 q 769 323 796 323 q 740 302 748 323 q 732 245 732 281 l 732 201 q 769 132 732 132 z "},"½":{"ha":1008,"x_min":16,"x_max":991,"o":"m 103 493 l 103 1033 q 64 1005 89 1016 q 16 994 39 994 l 16 1106 q 85 1133 48 1111 q 139 1194 122 1155 l 252 1194 l 252 493 l 103 493 m 185 -4 l 578 1211 l 770 1211 l 309 -4 l 185 -4 m 623 0 l 623 37 q 657 172 623 116 q 734 279 692 227 q 810 385 777 329 q 844 517 844 440 q 836 559 844 541 q 806 576 829 576 q 770 515 770 576 l 770 429 l 623 429 l 623 472 q 660 647 623 585 q 808 708 697 708 q 943 659 895 708 q 991 520 991 610 q 975 411 991 458 q 931 325 958 363 q 876 250 905 287 q 832 194 853 223 q 795 132 812 165 l 987 132 l 987 0 l 623 0 z "},"₁":{"ha":294,"x_min":16,"x_max":252,"o":"m 103 -45 l 103 495 q 64 467 89 478 q 16 456 39 456 l 16 568 q 85 595 48 573 q 139 656 122 617 l 252 656 l 252 -45 l 103 -45 z "},"¼":{"ha":1131,"x_min":98,"x_max":1038,"o":"m 185 492 l 185 1032 q 146 1004 171 1015 q 98 994 121 994 l 98 1105 q 167 1132 130 1110 q 221 1194 204 1154 l 334 1194 l 334 492 l 185 492 m 284 -11 l 677 1204 l 869 1204 l 408 -11 l 284 -11 m 857 0 l 857 115 l 648 115 l 648 224 l 781 701 l 1000 701 l 1000 232 l 1038 232 l 1038 115 l 1000 115 l 1000 0 l 857 0 m 774 232 l 857 232 l 857 581 l 774 232 z "},"¹":{"ha":294,"x_min":16,"x_max":252,"o":"m 103 540 l 103 1080 q 64 1052 89 1063 q 16 1041 39 1041 l 16 1153 q 85 1180 48 1158 q 139 1241 122 1202 l 252 1241 l 252 540 l 103 540 z "},"⅓":{"ha":1026,"x_min":16,"x_max":989,"o":"m 103 492 l 103 1032 q 64 1004 89 1015 q 16 994 39 994 l 16 1105 q 85 1132 48 1110 q 139 1194 122 1154 l 252 1194 l 252 492 l 103 492 m 185 -4 l 578 1211 l 770 1211 l 309 -4 l 185 -4 m 800 -7 q 664 42 707 -7 q 622 191 622 92 l 622 264 l 766 264 l 766 190 q 773 143 766 162 q 805 123 780 123 q 834 142 827 123 q 842 213 842 161 l 842 230 q 830 293 842 267 q 783 320 818 320 l 769 320 l 769 446 q 824 462 805 446 q 844 516 844 478 q 809 579 844 579 q 780 565 789 579 q 772 517 772 551 l 772 493 l 626 493 l 626 518 q 671 663 626 617 q 808 708 715 708 q 988 518 988 708 q 974 433 988 467 q 922 385 960 399 q 978 323 967 363 q 989 213 989 283 q 945 50 989 107 q 800 -7 901 -7 z "},"ǫ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 486 -360 q 368 -336 421 -360 q 282 -266 314 -311 q 250 -156 250 -220 q 429 68 250 -33 l 572 68 q 494 -21 526 24 q 463 -121 463 -65 q 541 -197 463 -197 q 620 -182 574 -197 l 620 -333 q 486 -360 555 -360 z "},"ǭ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 486 -360 q 368 -336 421 -360 q 282 -266 314 -311 q 250 -156 250 -220 q 429 68 250 -33 l 572 68 q 494 -21 526 24 q 463 -121 463 -65 q 541 -197 463 -197 q 620 -182 574 -197 l 620 -333 q 486 -360 555 -360 m 124 1057 l 124 1161 l 565 1161 l 565 1057 l 124 1057 z "},"ɔ":{"ha":682,"x_min":36,"x_max":642,"o":"m 328 -11 q 177 21 243 -11 q 74 113 111 53 q 36 257 36 173 l 36 435 l 282 435 l 282 264 q 295 204 282 230 q 339 179 308 179 q 384 205 370 179 q 397 262 397 231 l 397 755 q 338 840 397 840 q 294 816 304 840 q 283 757 283 792 l 283 614 l 36 614 l 36 770 q 75 911 36 853 q 180 998 113 968 q 331 1028 247 1028 q 520 986 452 1028 q 614 859 587 944 q 642 647 642 774 l 642 334 q 570 77 642 164 q 328 -11 498 -11 z "},"ª":{"ha":545,"x_min":30,"x_max":505,"o":"m 194 528 q 92 560 127 528 q 43 646 56 591 q 30 769 30 701 q 41 879 30 834 q 82 956 52 924 q 168 1013 113 987 q 311 1065 223 1039 l 311 1139 q 305 1186 311 1168 q 270 1204 298 1204 q 230 1160 230 1204 l 230 1106 l 43 1106 q 42 1117 42 1111 q 42 1133 42 1124 q 99 1303 42 1253 q 282 1354 157 1354 q 442 1302 379 1354 q 505 1153 505 1250 l 505 538 l 314 538 l 314 622 q 271 558 305 589 q 194 528 236 528 m 270 679 q 302 699 294 679 q 311 742 311 719 l 311 954 q 249 915 271 939 q 227 844 227 892 l 227 750 q 270 679 227 679 z "},"º":{"ha":551,"x_min":34,"x_max":517,"o":"m 275 528 q 34 779 34 528 l 34 1103 q 98 1285 34 1216 q 275 1354 161 1354 q 453 1286 389 1354 q 517 1103 517 1218 l 517 779 q 457 592 517 656 q 275 528 397 528 m 275 678 q 320 740 320 678 l 320 1134 q 275 1204 320 1204 q 230 1134 230 1204 l 230 740 q 275 678 230 678 z "},"ø":{"ha":690,"x_min":41,"x_max":649,"o":"m 123 -126 l 163 31 q 41 304 41 104 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 421 1021 385 1028 l 455 1154 l 550 1154 l 509 989 q 612 880 576 951 q 649 713 649 808 l 649 304 q 345 -11 649 -11 q 250 -2 293 -11 l 218 -126 l 123 -126 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 z "},"ǿ":{"ha":690,"x_min":41,"x_max":649,"o":"m 123 -126 l 163 31 q 41 304 41 104 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 421 1021 385 1028 l 455 1154 l 550 1154 l 509 989 q 612 880 576 951 q 649 713 649 808 l 649 304 q 345 -11 649 -11 q 250 -2 293 -11 l 218 -126 l 123 -126 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 184 1157 l 184 1308 l 506 1456 l 506 1221 l 184 1157 z "},"õ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 456 1103 q 364 1119 404 1103 q 291 1150 324 1135 q 227 1165 258 1165 q 194 1155 210 1165 q 165 1119 178 1145 l 64 1172 q 101 1247 81 1213 q 153 1302 121 1282 q 232 1323 184 1323 q 321 1309 282 1323 q 391 1280 359 1295 q 449 1266 422 1266 q 483 1278 467 1266 q 512 1317 498 1289 l 625 1280 q 589 1194 608 1235 q 538 1128 569 1154 q 456 1103 507 1103 z "},"ṍ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 456 1103 q 364 1119 404 1103 q 291 1150 324 1135 q 227 1165 258 1165 q 194 1155 210 1165 q 165 1119 178 1145 l 64 1172 q 101 1247 81 1213 q 153 1302 121 1282 q 232 1323 184 1323 q 321 1309 282 1323 q 391 1280 359 1295 q 449 1266 422 1266 q 483 1278 467 1266 q 512 1317 498 1289 l 625 1280 q 589 1194 608 1235 q 538 1128 569 1154 q 456 1103 507 1103 m 184 1354 l 184 1485 l 506 1598 l 506 1404 l 184 1354 z "},"ṏ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 456 1103 q 364 1119 404 1103 q 291 1150 324 1135 q 227 1165 258 1165 q 194 1155 210 1165 q 165 1119 178 1145 l 64 1172 q 101 1247 81 1213 q 153 1302 121 1282 q 232 1323 184 1323 q 321 1309 282 1323 q 391 1280 359 1295 q 449 1266 422 1266 q 483 1278 467 1266 q 512 1317 498 1289 l 625 1280 q 589 1194 608 1235 q 538 1128 569 1154 q 456 1103 507 1103 m 387 1390 l 387 1558 l 630 1558 l 630 1390 l 387 1390 m 59 1390 l 59 1558 l 302 1558 l 302 1390 l 59 1390 z "},"ȭ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 713 q 121 942 41 857 q 345 1028 202 1028 q 568 942 488 1028 q 649 713 649 857 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 751 q 345 840 401 840 q 288 751 288 840 l 288 254 q 301 198 288 220 q 345 176 314 176 m 456 1072 q 365 1088 406 1072 q 289 1119 323 1103 q 227 1134 255 1134 q 194 1124 210 1134 q 165 1088 178 1114 l 64 1141 q 101 1209 81 1178 q 153 1259 121 1240 q 232 1278 184 1278 q 320 1264 280 1278 q 391 1236 359 1250 q 449 1221 423 1221 q 483 1233 467 1221 q 512 1272 498 1244 l 625 1236 q 589 1156 608 1194 q 538 1095 569 1118 q 456 1072 507 1072 m 124 1333 l 124 1437 l 565 1437 l 565 1333 l 124 1333 z "},"ȣ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 387 q 125 615 41 531 q 41 843 41 699 l 41 1017 l 288 1017 l 288 798 q 345 709 288 709 q 401 798 401 709 l 401 1017 l 649 1017 l 649 843 q 564 615 649 699 q 649 387 649 532 l 649 304 q 345 -11 649 -11 m 345 176 q 388 198 375 176 q 401 254 401 220 l 401 433 q 345 522 401 522 q 288 433 288 522 l 288 254 q 301 198 288 220 q 345 176 314 176 z "},"p":{"ha":696,"x_min":49,"x_max":653,"o":"m 49 -170 l 49 1017 l 296 1017 l 296 909 q 358 997 318 965 q 471 1028 397 1028 q 612 956 571 1028 q 653 766 653 883 l 653 265 q 631 124 653 187 q 562 25 609 62 q 439 -11 515 -11 q 296 109 340 -11 l 296 -170 l 49 -170 m 353 178 q 399 216 391 178 q 407 310 407 254 l 407 707 q 399 801 407 764 q 353 839 391 839 q 305 801 314 839 q 296 707 296 762 l 296 310 q 305 217 296 255 q 353 178 314 178 z "},"ṕ":{"ha":696,"x_min":49,"x_max":653,"o":"m 49 -170 l 49 1017 l 296 1017 l 296 909 q 358 997 318 965 q 471 1028 397 1028 q 612 956 571 1028 q 653 766 653 883 l 653 265 q 631 124 653 187 q 562 25 609 62 q 439 -11 515 -11 q 296 109 340 -11 l 296 -170 l 49 -170 m 353 178 q 399 216 391 178 q 407 310 407 254 l 407 707 q 399 801 407 764 q 353 839 391 839 q 305 801 314 839 q 296 707 296 762 l 296 310 q 305 217 296 255 q 353 178 314 178 m 187 1053 l 187 1204 l 509 1352 l 509 1117 l 187 1053 z "},"¶":{"ha":691,"x_min":21,"x_max":649,"o":"m 256 0 l 256 541 q 78 621 135 554 q 21 821 21 688 q 71 981 21 924 q 205 1059 121 1037 q 395 1080 290 1080 l 649 1080 l 649 0 l 487 0 l 487 873 l 423 873 l 423 0 l 256 0 z "},"(":{"ha":404,"x_min":33,"x_max":380,"o":"m 380 -127 q 195 -73 273 -123 q 75 64 117 -22 q 33 265 33 151 l 33 844 q 119 1130 33 1029 q 380 1236 204 1232 l 380 1055 q 307 1014 328 1046 q 286 922 286 982 l 286 189 q 313 107 286 138 q 380 66 340 77 l 380 -127 z "},")":{"ha":404,"x_min":24,"x_max":371,"o":"m 24 -127 l 24 66 q 92 107 64 77 q 119 189 119 138 l 119 922 q 97 1014 119 982 q 24 1055 76 1046 l 24 1236 q 286 1130 200 1232 q 371 844 371 1029 l 371 265 q 329 62 371 151 q 209 -77 287 -26 q 24 -127 132 -127 z "},"∂":{"ha":727,"x_min":25,"x_max":699,"o":"m 302 -14 q 91 60 156 -14 q 25 280 25 135 q 38 443 25 362 q 82 590 51 524 q 166 696 113 656 q 302 736 220 736 q 444 710 366 736 q 451 789 451 759 q 428 911 451 862 q 344 960 404 960 q 262 951 306 960 q 192 933 218 943 l 155 1090 q 420 1140 313 1140 q 586 1097 525 1140 q 672 974 646 1053 q 699 786 699 895 q 687 469 699 614 q 637 214 675 323 q 518 46 598 106 q 302 -14 439 -14 m 332 199 q 382 224 366 199 q 401 284 398 249 l 422 515 q 362 538 388 538 q 298 437 309 538 l 287 322 q 283 265 283 286 q 293 217 283 235 q 332 199 303 199 z "},"ṗ":{"ha":696,"x_min":49,"x_max":653,"o":"m 49 -170 l 49 1017 l 296 1017 l 296 909 q 358 997 318 965 q 471 1028 397 1028 q 612 956 571 1028 q 653 766 653 883 l 653 265 q 631 124 653 187 q 562 25 609 62 q 439 -11 515 -11 q 296 109 340 -11 l 296 -170 l 49 -170 m 353 178 q 399 216 391 178 q 407 310 407 254 l 407 707 q 399 801 407 764 q 353 839 391 839 q 305 801 314 839 q 296 707 296 762 l 296 310 q 305 217 296 255 q 353 178 314 178 m 226 1080 l 226 1282 l 469 1282 l 469 1080 l 226 1080 z "},"%":{"ha":1468,"x_min":28,"x_max":1439,"o":"m 448 0 l 814 1198 l 1034 1198 l 667 0 l 448 0 m 294 358 q 98 436 168 358 q 28 643 28 513 l 28 889 q 94 1099 28 1026 q 294 1173 160 1173 q 493 1099 427 1173 q 559 889 559 1026 l 559 643 q 490 436 559 513 q 294 358 420 358 m 294 536 q 338 555 320 536 q 357 603 357 574 l 357 932 q 345 996 357 972 q 294 1019 334 1019 q 242 995 254 1019 q 231 932 231 972 l 231 603 q 249 555 231 574 q 294 536 267 536 m 1173 -12 q 978 65 1047 -12 q 908 273 908 143 l 908 519 q 974 729 908 656 q 1173 802 1040 802 q 1373 729 1307 802 q 1439 519 1439 656 l 1439 273 q 1370 65 1439 143 q 1173 -12 1300 -12 m 1173 165 q 1218 185 1200 165 q 1236 233 1236 204 l 1236 562 q 1225 625 1236 602 q 1173 648 1213 648 q 1122 625 1134 648 q 1110 562 1110 602 l 1110 233 q 1128 185 1110 204 q 1173 165 1147 165 z "},".":{"ha":317,"x_min":37,"x_max":280,"o":"m 37 1 l 37 203 l 280 203 l 280 1 l 37 1 z "},"·":{"ha":326,"x_min":55,"x_max":271,"o":"m 55 490 l 55 692 l 271 692 l 271 490 l 55 490 z "},"‰":{"ha":2056,"x_min":28,"x_max":2027,"o":"m 448 0 l 814 1198 l 1034 1198 l 667 0 l 448 0 m 294 358 q 98 436 168 358 q 28 643 28 513 l 28 889 q 94 1099 28 1026 q 294 1173 160 1173 q 493 1099 427 1173 q 559 889 559 1026 l 559 643 q 490 436 559 513 q 294 358 420 358 m 294 536 q 338 555 320 536 q 357 603 357 574 l 357 932 q 345 996 357 972 q 294 1019 334 1019 q 242 995 254 1019 q 231 932 231 972 l 231 603 q 249 555 231 574 q 294 536 267 536 m 1173 -12 q 978 65 1047 -12 q 908 273 908 143 l 908 519 q 974 729 908 656 q 1173 802 1040 802 q 1373 729 1307 802 q 1439 519 1439 656 l 1439 273 q 1370 65 1439 143 q 1173 -12 1300 -12 m 1761 -12 q 1566 65 1635 -12 q 1496 273 1496 143 l 1496 519 q 1562 729 1496 656 q 1761 802 1628 802 q 1961 729 1895 802 q 2027 519 2027 656 l 2027 273 q 1958 65 2027 143 q 1761 -12 1888 -12 m 1173 165 q 1218 185 1200 165 q 1236 233 1236 204 l 1236 562 q 1225 625 1236 602 q 1173 648 1213 648 q 1122 625 1134 648 q 1110 562 1110 602 l 1110 233 q 1128 185 1110 204 q 1173 165 1147 165 m 1761 165 q 1806 185 1788 165 q 1824 233 1824 204 l 1824 562 q 1813 625 1824 602 q 1761 648 1801 648 q 1710 625 1722 648 q 1698 562 1698 602 l 1698 233 q 1716 185 1698 204 q 1761 165 1735 165 z "},"₧":{"ha":1522,"x_min":53,"x_max":1496,"o":"m 53 0 l 53 1080 l 302 1080 q 515 995 452 1080 q 578 711 578 909 q 509 442 578 525 q 285 359 441 359 l 227 359 l 227 0 l 53 0 m 830 -11 q 726 27 753 -11 q 699 142 699 64 l 699 717 l 637 717 l 637 884 l 699 884 l 699 1080 l 873 1080 l 873 884 l 935 884 l 935 717 l 873 717 l 873 200 q 877 167 873 182 q 907 153 882 153 q 935 155 921 153 l 935 5 q 890 -6 916 -1 q 830 -11 864 -11 m 1259 -11 q 1002 265 1002 -11 l 1002 331 l 1176 331 l 1176 243 q 1191 174 1176 199 q 1243 149 1206 149 q 1302 221 1302 149 q 1285 292 1302 260 q 1227 362 1267 323 l 1093 490 q 1028 584 1052 530 q 1004 709 1004 637 q 1036 830 1004 781 q 1119 904 1067 879 q 1231 928 1171 928 q 1479 662 1479 928 l 1479 645 l 1305 645 l 1305 680 q 1293 742 1305 711 q 1245 772 1281 772 q 1192 709 1192 772 q 1204 653 1192 681 q 1246 597 1217 625 l 1367 488 q 1466 369 1435 425 q 1496 236 1496 313 q 1433 52 1496 115 q 1259 -11 1370 -11 m 227 522 l 277 522 q 362 544 336 522 q 397 608 389 565 q 404 713 404 650 q 384 864 404 810 q 289 917 363 917 l 227 917 l 227 522 z "},"₱":{"ha":707,"x_min":23,"x_max":684,"o":"m 91 0 l 91 570 l 23 570 l 23 665 l 91 665 l 91 749 l 23 749 l 23 844 l 91 844 l 91 1080 l 340 1080 q 523 1024 460 1080 q 606 844 587 969 l 684 844 l 684 749 l 615 749 q 616 698 616 724 q 615 665 616 681 l 684 665 l 684 570 l 607 570 q 519 389 587 446 q 323 332 450 332 l 264 332 l 264 0 l 91 0 m 264 917 l 264 844 l 428 844 q 393 898 417 880 q 327 917 370 917 l 264 917 m 442 700 q 441 749 442 728 l 264 749 l 264 665 l 442 665 q 442 700 442 680 m 264 495 l 315 495 q 395 514 368 495 q 431 570 421 533 l 264 570 l 264 495 z "},"ƥ":{"ha":694,"x_min":49,"x_max":656,"o":"m 49 -170 l 49 901 q 82 1058 49 989 q 185 1165 115 1126 q 369 1204 256 1204 l 369 1017 q 315 995 331 1017 q 298 928 298 972 l 298 843 q 365 933 321 905 q 473 962 409 962 q 616 887 576 962 q 656 688 656 813 l 656 265 q 634 124 656 187 q 565 25 612 62 q 441 -11 517 -11 q 298 109 342 -11 l 298 -170 l 49 -170 m 355 178 q 398 208 387 178 q 410 310 410 238 l 410 665 q 402 742 410 711 q 358 772 394 772 q 310 743 321 772 q 298 668 298 714 l 298 310 q 307 217 298 255 q 355 178 316 178 z "},"π":{"ha":842,"x_min":25,"x_max":818,"o":"m 119 0 l 119 799 l 25 799 l 25 1017 l 818 1017 l 818 799 l 724 799 l 724 0 l 483 0 l 483 799 l 360 799 l 360 0 l 119 0 z "},"+":{"ha":494,"x_min":27,"x_max":467,"o":"m 168 204 l 168 345 l 27 345 l 27 503 l 168 503 l 168 644 l 326 644 l 326 503 l 467 503 l 467 345 l 326 345 l 326 204 l 168 204 z "},"±":{"ha":498,"x_min":31,"x_max":471,"o":"m 172 281 l 172 422 l 31 422 l 31 579 l 172 579 l 172 720 l 330 720 l 330 579 l 471 579 l 471 422 l 330 422 l 330 281 l 172 281 m 59 -1 l 59 157 l 409 157 l 409 -1 l 59 -1 z "},"ʹ":{"ha":491,"x_min":90,"x_max":423,"o":"m 90 1017 l 195 1461 l 423 1461 l 235 1017 l 90 1017 z "},"∏":{"ha":671,"x_min":42,"x_max":629,"o":"m 42 0 l 42 1194 l 629 1194 l 629 0 l 392 0 l 392 989 l 279 989 l 279 0 l 42 0 z "},"ᵽ":{"ha":755,"x_min":7,"x_max":749,"o":"m 75 -170 l 75 440 l 7 440 l 7 597 l 75 597 l 75 1017 l 322 1017 l 322 909 q 384 997 345 965 q 498 1028 424 1028 q 638 956 597 1028 q 680 766 680 883 l 680 597 l 749 597 l 749 440 l 680 440 l 680 265 q 657 124 680 187 q 588 25 635 62 q 465 -11 541 -11 q 322 109 366 -11 l 322 -170 l 75 -170 m 322 707 l 322 597 l 433 597 l 433 707 q 426 801 433 764 q 380 839 418 839 q 331 801 340 839 q 322 707 322 762 m 380 178 q 426 216 418 178 q 433 310 433 254 l 433 440 l 322 440 l 322 310 q 331 217 322 255 q 380 178 340 178 z "}," ":{"ha":317,"x_min":0,"x_max":0,"o":""},"q":{"ha":692,"x_min":42,"x_max":647,"o":"m 400 -170 l 400 108 q 346 21 380 53 q 249 -11 313 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1017 l 647 1017 l 647 -170 l 400 -170 m 342 179 q 387 212 374 179 q 400 305 400 245 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 z "},"ɋ":{"ha":692,"x_min":42,"x_max":718,"o":"m 718 -176 q 488 -106 564 -176 q 399 76 412 -37 q 340 12 377 35 q 249 -11 302 -11 q 137 15 178 -11 q 75 86 96 41 q 48 193 55 132 q 42 323 42 254 l 42 766 q 84 956 42 883 q 225 1028 125 1028 q 339 997 299 1028 q 400 909 378 965 l 400 1017 l 647 1017 l 647 100 q 663 34 647 57 q 718 11 680 11 l 718 -176 m 342 179 q 388 212 376 179 q 400 305 400 245 l 400 734 q 390 805 400 770 q 343 840 379 840 q 294 807 304 840 q 283 734 283 774 l 283 307 q 342 179 283 179 z "},"?":{"ha":684,"x_min":33,"x_max":663,"o":"m 86 309 l 86 591 q 232 600 171 591 q 331 637 292 608 q 389 723 370 665 q 408 878 408 781 q 396 955 408 922 q 345 988 385 988 q 302 969 315 988 q 284 922 288 951 q 281 862 281 893 l 281 763 l 33 763 l 33 935 q 120 1138 33 1072 q 345 1204 207 1204 q 535 1161 465 1204 q 634 1035 604 1118 q 663 831 663 951 q 625 622 663 714 q 509 477 587 530 q 312 424 431 424 l 312 309 l 86 309 m 79 1 l 79 203 l 321 203 l 321 1 l 79 1 z "},"¿":{"ha":684,"x_min":26,"x_max":656,"o":"m 610 1116 l 610 914 l 368 914 l 368 1116 l 610 1116 m 603 808 l 603 526 q 457 517 518 526 q 358 480 397 509 q 300 394 319 452 q 281 239 281 336 q 293 162 281 195 q 345 129 304 129 q 388 148 374 129 q 405 195 401 166 q 408 255 408 224 l 408 354 l 656 354 l 656 182 q 569 -21 656 45 q 345 -87 482 -87 q 155 -44 224 -87 q 55 82 85 -1 q 26 286 26 165 q 64 495 26 403 q 180 640 102 587 q 377 693 258 693 l 377 808 l 603 808 z "},"\\"":{"ha":595,"x_min":28,"x_max":565,"o":"m 96 762 l 28 1194 l 267 1194 l 215 762 l 96 762 m 394 762 l 326 1194 l 565 1194 l 513 762 l 394 762 z "},"„":{"ha":649,"x_min":37,"x_max":612,"o":"m 79 -160 l 123 0 l 37 0 l 37 202 l 291 202 l 291 6 l 222 -160 l 79 -160 m 399 -160 l 444 0 l 358 0 l 358 202 l 612 202 l 612 6 l 543 -160 l 399 -160 z "},"“":{"ha":644,"x_min":37,"x_max":608,"o":"m 37 831 l 37 1027 l 106 1194 l 249 1194 l 204 1034 l 290 1034 l 290 831 l 37 831 m 355 831 l 355 1027 l 424 1194 l 567 1194 l 522 1034 l 608 1034 l 608 831 l 355 831 z "},"”":{"ha":643,"x_min":34,"x_max":608,"o":"m 75 831 l 120 991 l 34 991 l 34 1194 l 288 1194 l 288 998 l 218 831 l 75 831 m 396 831 l 441 991 l 355 991 l 355 1194 l 608 1194 l 608 998 l 539 831 l 396 831 z "},"‘":{"ha":326,"x_min":37,"x_max":290,"o":"m 37 831 l 37 1027 l 106 1194 l 249 1194 l 204 1034 l 290 1034 l 290 831 l 37 831 z "},"’":{"ha":322,"x_min":34,"x_max":288,"o":"m 75 844 l 120 1004 l 34 1004 l 34 1206 l 288 1206 l 288 1010 l 218 844 l 75 844 z "},"‚":{"ha":328,"x_min":37,"x_max":291,"o":"m 79 -160 l 123 0 l 37 0 l 37 202 l 291 202 l 291 6 l 222 -160 l 79 -160 z "},"\'":{"ha":297,"x_min":28,"x_max":267,"o":"m 96 762 l 28 1194 l 267 1194 l 215 762 l 96 762 z "},"r":{"ha":481,"x_min":49,"x_max":471,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 z "},"ŕ":{"ha":481,"x_min":49,"x_max":471,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 m 102 1053 l 102 1204 l 425 1352 l 425 1117 l 102 1053 z "},"√":{"ha":961,"x_min":20,"x_max":937,"o":"m 168 0 l 20 503 l 202 503 l 279 229 l 372 1018 l 937 1018 l 937 861 l 582 861 l 442 0 l 168 0 z "},"᷊":{"ha":0,"x_min":-79,"x_max":80,"o":"m -79 -436 l -79 -54 l 14 -54 l 14 -96 q 80 -50 28 -50 l 80 -125 q 39 -131 63 -125 q 14 -144 14 -136 l 14 -436 l -79 -436 z "},"ř":{"ha":481,"x_min":-39,"x_max":565,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 m 125 1079 l -39 1352 l 205 1352 l 263 1159 l 321 1352 l 565 1352 l 401 1079 l 125 1079 z "},"ŗ":{"ha":481,"x_min":48,"x_max":471,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 m 90 -436 l 134 -276 l 48 -276 l 48 -74 l 302 -74 l 302 -270 l 233 -436 l 90 -436 z "},"ȑ":{"ha":481,"x_min":-66,"x_max":471,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 m 130 1076 l -66 1367 l 92 1440 l 242 1115 l 130 1076 m 334 1076 l 166 1367 l 322 1440 l 447 1115 l 334 1076 z "},"ṙ":{"ha":481,"x_min":49,"x_max":471,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 m 142 1080 l 142 1282 l 385 1282 l 385 1080 l 142 1080 z "},"ṛ":{"ha":481,"x_min":49,"x_max":471,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 m 62 -283 l 62 -81 l 305 -81 l 305 -283 l 62 -283 z "},"ṝ":{"ha":481,"x_min":43,"x_max":484,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 m 43 1098 l 43 1202 l 484 1202 l 484 1098 l 43 1098 m 62 -283 l 62 -81 l 305 -81 l 305 -283 l 62 -283 z "},"®":{"ha":937,"x_min":23,"x_max":914,"o":"m 469 139 q 293 173 374 139 q 151 267 212 206 q 57 409 90 328 q 23 585 23 490 q 57 761 23 680 q 151 902 90 842 q 293 997 212 963 q 469 1030 374 1030 q 645 997 564 1030 q 786 902 726 963 q 881 761 847 842 q 914 585 914 680 q 881 409 914 490 q 786 267 847 328 q 645 173 726 206 q 469 139 564 139 m 469 227 q 643 275 567 227 q 763 405 719 323 q 806 585 806 486 q 763 765 806 684 q 643 894 719 846 q 469 943 567 943 q 295 894 371 943 q 175 765 218 846 q 131 585 131 684 q 175 405 131 486 q 295 275 218 323 q 469 227 371 227 m 318 292 l 318 869 l 514 869 q 609 825 588 869 q 630 707 630 781 q 617 632 630 661 q 567 592 604 604 q 621 509 621 582 l 621 292 l 496 292 l 496 517 q 484 549 496 543 q 447 555 473 555 l 447 292 l 318 292 m 448 654 l 480 654 q 505 707 505 654 q 494 753 505 743 q 448 762 484 762 l 448 654 z "},"ɾ":{"ha":363,"x_min":35,"x_max":352,"o":"m 35 0 l 35 719 q 67 876 35 808 q 171 984 100 945 q 352 1023 241 1023 l 352 836 q 298 813 314 836 q 281 746 281 790 l 281 0 l 35 0 z "},"ɽ":{"ha":481,"x_min":49,"x_max":471,"o":"m 366 -176 q 185 -137 255 -176 q 82 -30 115 -98 q 49 127 49 39 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 100 q 312 34 296 57 q 366 11 328 11 l 366 -176 z "},"→":{"ha":947,"x_min":41,"x_max":933,"o":"m 593 283 l 658 399 l 41 399 l 41 615 l 661 615 l 593 739 l 802 739 l 933 511 l 802 283 l 593 283 z "},"▶":{"ha":1034,"x_min":53,"x_max":1013,"o":"m 53 0 l 53 1015 l 1013 508 l 53 0 z "},"▷":{"ha":1034,"x_min":53,"x_max":1013,"o":"m 53 0 l 53 1015 l 1013 508 l 53 0 m 185 220 l 730 508 l 185 795 l 185 220 z "},"⟩":{"ha":492,"x_min":39,"x_max":466,"o":"m 243 -69 l 39 -69 l 262 596 l 39 1261 l 243 1261 l 466 596 l 243 -69 z "},"˚":{"ha":545,"x_min":37,"x_max":516,"o":"m 276 1072 q 102 1132 168 1072 q 37 1301 37 1193 q 102 1469 37 1408 q 276 1530 168 1530 q 451 1469 385 1530 q 516 1301 516 1408 q 451 1133 516 1194 q 276 1072 385 1072 m 277 1194 q 348 1225 322 1194 q 373 1301 373 1257 q 348 1376 373 1345 q 277 1407 322 1407 q 206 1376 231 1407 q 180 1301 180 1345 q 206 1225 180 1257 q 277 1194 231 1194 z "},"̥":{"ha":0,"x_min":-239,"x_max":240,"o":"m 0 -429 q -174 -372 -109 -429 q -239 -214 -239 -315 q -174 -55 -239 -113 q 0 2 -109 2 q 175 -55 109 2 q 240 -214 240 -113 q 175 -372 240 -314 q 0 -429 109 -429 m 1 -307 q 72 -279 46 -307 q 97 -214 97 -252 q 72 -148 97 -175 q 1 -121 46 -121 q -70 -148 -45 -121 q -96 -214 -96 -175 q -70 -279 -96 -252 q 1 -307 -45 -307 z "},"̊":{"ha":0,"x_min":-239,"x_max":240,"o":"m 0 1072 q -174 1132 -109 1072 q -239 1301 -239 1193 q -174 1469 -239 1408 q 0 1530 -109 1530 q 175 1469 109 1530 q 240 1301 240 1408 q 175 1133 240 1194 q 0 1072 109 1072 m 1 1194 q 72 1225 46 1194 q 97 1301 97 1257 q 72 1376 97 1345 q 1 1407 46 1407 q -70 1376 -45 1407 q -96 1301 -96 1345 q -70 1225 -96 1257 q 1 1194 -45 1194 z "},"ʿ":{"ha":313,"x_min":37,"x_max":277,"o":"m 277 1009 q 102 1073 168 1009 q 37 1238 37 1136 q 102 1404 37 1341 q 277 1468 168 1468 l 277 1338 q 212 1310 237 1338 q 187 1238 187 1282 q 212 1166 187 1194 q 277 1139 237 1139 l 277 1009 z "},"ʾ":{"ha":313,"x_min":37,"x_max":277,"o":"m 37 1009 l 37 1139 q 102 1166 77 1139 q 126 1238 126 1194 q 102 1310 126 1282 q 37 1338 77 1338 l 37 1468 q 212 1404 146 1468 q 277 1238 277 1341 q 212 1073 277 1136 q 37 1009 146 1009 z "},"ȓ":{"ha":481,"x_min":9,"x_max":516,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 m 12 1090 q 9 1118 9 1104 q 76 1279 9 1229 q 262 1329 143 1329 q 450 1278 384 1329 q 516 1114 516 1227 q 516 1104 516 1110 q 515 1090 515 1097 l 355 1090 q 329 1159 355 1137 q 263 1181 303 1181 q 198 1159 224 1181 q 172 1090 172 1137 l 12 1090 z "},"ṟ":{"ha":481,"x_min":-37,"x_max":471,"o":"m 49 0 l 49 1017 l 296 1017 l 296 904 q 358 996 313 963 q 471 1029 403 1029 l 471 827 q 399 820 441 827 q 327 803 358 814 q 296 778 296 791 l 296 0 l 49 0 m -37 -184 l -37 -81 l 404 -81 l 404 -184 l -37 -184 z "},"ɍ":{"ha":515,"x_min":7,"x_max":505,"o":"m 83 0 l 83 440 l 7 440 l 7 597 l 83 597 l 83 1017 l 330 1017 l 330 904 q 392 996 347 963 q 505 1029 437 1029 l 505 827 q 433 820 475 827 q 361 803 392 814 q 330 778 330 791 l 330 597 l 427 597 l 427 440 l 330 440 l 330 0 l 83 0 z "},"₽":{"ha":661,"x_min":67,"x_max":639,"o":"m 135 0 l 135 142 l 67 142 l 67 292 l 135 292 l 135 400 l 67 400 l 67 563 l 135 563 l 135 1080 l 385 1080 q 581 1001 523 1080 q 639 739 639 922 q 575 480 639 559 q 367 400 512 400 l 309 400 l 309 292 l 504 292 l 504 142 l 309 142 l 309 0 l 135 0 m 368 917 l 309 917 l 309 563 l 356 563 q 445 604 425 563 q 465 741 465 645 q 445 876 465 834 q 368 917 424 917 z "},"₹":{"ha":707,"x_min":87,"x_max":621,"o":"m 389 0 l 87 450 l 87 600 l 262 600 q 350 625 325 600 q 381 702 375 650 l 87 702 l 87 824 l 381 824 q 350 902 375 877 q 262 926 325 926 l 87 926 l 87 1076 l 621 1076 l 621 926 l 534 926 q 555 824 549 883 l 621 824 l 621 702 l 555 702 q 482 517 545 585 q 289 450 419 450 l 285 450 l 586 0 l 389 0 z "},"s":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 z "},"ś":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 m 171 1053 l 171 1204 l 493 1352 l 493 1117 l 171 1053 z "},"ṥ":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 m 171 1042 l 171 1173 l 493 1287 l 493 1093 l 171 1042 m 210 1312 l 210 1487 l 453 1487 l 453 1312 l 210 1312 z "},"ꞌ":{"ha":318,"x_min":37,"x_max":280,"o":"m 85 528 l 37 1126 l 280 1126 l 233 528 l 85 528 z "},"š":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 m 193 1079 l 30 1352 l 273 1352 l 332 1159 l 390 1352 l 633 1352 l 470 1079 l 193 1079 z "},"ṧ":{"ha":659,"x_min":26,"x_max":633,"o":"m 210 1290 l 210 1465 l 453 1465 l 453 1290 l 210 1290 m 233 1080 l 73 1253 l 266 1253 l 333 1160 l 400 1253 l 593 1253 l 433 1080 l 233 1080 m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 z "},"ş":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 m 307 -428 q 172 -401 237 -428 l 172 -250 q 214 -261 193 -256 q 252 -265 234 -265 q 309 -247 286 -265 q 332 -185 332 -229 q 313 -98 332 -147 q 261 0 294 -50 l 370 0 q 472 -129 436 -58 q 509 -262 509 -199 q 460 -380 509 -332 q 307 -428 412 -428 z "},"ə":{"ha":678,"x_min":39,"x_max":637,"o":"m 332 -11 q 39 277 39 -11 l 39 351 q 42 531 39 485 l 395 531 l 395 728 q 391 781 395 755 q 376 824 388 807 q 336 841 363 841 q 292 816 304 841 q 281 722 281 791 l 281 625 l 39 625 l 39 682 q 67 873 39 797 q 162 989 96 950 q 345 1028 229 1028 q 518 987 454 1028 q 610 870 582 947 q 637 686 637 794 l 637 277 q 556 62 637 135 q 332 -11 475 -11 m 335 170 q 396 280 396 170 l 396 410 l 281 410 l 281 280 q 335 170 281 170 z "},"ŝ":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 m 30 1079 l 193 1352 l 470 1352 l 633 1079 l 390 1079 l 332 1272 l 273 1079 l 30 1079 z "},"ș":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 m 235 -436 l 280 -276 l 194 -276 l 194 -74 l 448 -74 l 448 -270 l 378 -436 l 235 -436 z "},"ṡ":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 m 210 1080 l 210 1282 l 453 1282 l 453 1080 l 210 1080 z "},"ṣ":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 m 208 -283 l 208 -81 l 451 -81 l 451 -283 l 208 -283 z "},"ṩ":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 155 524 q 62 624 94 571 q 31 771 31 677 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 467 590 q 586 469 538 539 q 633 283 633 399 q 552 64 633 140 q 328 -11 470 -11 m 210 1080 l 210 1282 l 453 1282 l 453 1080 l 210 1080 m 208 -283 l 208 -81 l 451 -81 l 451 -283 l 208 -283 z "},"″":{"ha":595,"x_min":28,"x_max":565,"o":"m 96 762 l 28 1194 l 267 1194 l 215 762 l 96 762 m 394 762 l 326 1194 l 565 1194 l 513 762 l 394 762 z "},"ˊ":{"ha":441,"x_min":62,"x_max":384,"o":"m 62 1053 l 62 1204 l 384 1352 l 384 1117 l 62 1053 z "},"§":{"ha":624,"x_min":27,"x_max":593,"o":"m 318 -13 q 103 49 179 -13 q 27 249 27 111 l 254 249 q 323 164 258 164 q 362 178 349 164 q 376 213 376 193 q 363 249 376 233 q 316 283 350 265 q 220 327 283 302 q 81 425 121 367 q 41 539 41 483 q 134 699 41 629 q 41 865 41 768 q 79 985 41 935 q 179 1063 117 1036 q 316 1090 242 1090 q 523 1027 452 1090 q 593 828 593 964 l 387 828 q 320 913 383 913 q 274 899 290 913 q 258 864 258 886 q 290 809 258 831 q 403 750 322 786 q 553 649 514 701 q 593 537 593 597 q 499 378 593 448 q 593 212 593 308 q 555 92 593 142 q 455 14 517 41 q 318 -13 393 -13 m 371 460 q 398 497 391 479 q 406 529 406 514 q 372 578 406 553 q 269 622 338 604 q 235 551 235 582 q 268 503 235 524 q 371 460 301 482 z "},";":{"ha":340,"x_min":45,"x_max":298,"o":"m 45 662 l 45 864 l 288 864 l 288 662 l 45 662 m 86 0 l 131 160 l 45 160 l 45 362 l 298 362 l 298 166 l 229 0 l 86 0 z "},"⅞":{"ha":1086,"x_min":47,"x_max":1055,"o":"m 77 492 q 128 761 87 640 q 215 991 170 882 l 245 1064 l 47 1064 l 47 1194 l 401 1194 l 401 1123 q 377 1008 401 1076 q 322 869 353 941 q 266 695 288 788 q 236 492 243 602 l 77 492 m 235 -11 l 627 1204 l 820 1204 l 359 -11 l 235 -11 m 872 -7 q 731 50 773 -7 q 688 210 688 106 l 688 254 q 701 340 688 307 q 748 391 714 373 q 703 435 716 404 q 689 511 689 466 l 689 530 q 736 666 689 623 q 872 708 783 708 q 1009 665 964 708 q 1055 524 1055 621 q 1043 439 1055 474 q 995 390 1031 405 q 1046 329 1036 370 q 1055 228 1055 288 l 1055 210 q 1013 50 1055 106 q 872 -7 971 -7 m 872 450 q 909 517 909 450 q 901 559 909 539 q 872 579 894 579 q 843 559 850 579 q 835 517 835 539 q 872 450 835 450 m 872 132 q 910 201 910 132 l 910 247 q 905 297 910 271 q 872 323 899 323 q 843 302 851 323 q 836 245 836 281 l 836 201 q 872 132 836 132 z "},"₇":{"ha":438,"x_min":47,"x_max":401,"o":"m 77 -45 q 128 224 87 102 q 215 454 170 345 l 245 527 l 47 527 l 47 656 l 401 656 l 401 586 q 377 471 401 538 q 322 332 353 404 q 266 158 288 251 q 236 -45 243 65 l 77 -45 z "},"⁷":{"ha":438,"x_min":47,"x_max":401,"o":"m 77 540 q 128 808 87 687 q 215 1038 170 930 l 245 1112 l 47 1112 l 47 1241 l 401 1241 l 401 1171 q 377 1056 401 1123 q 322 916 353 989 q 266 743 288 836 q 236 540 243 650 l 77 540 z "},"꞊":{"ha":432,"x_min":41,"x_max":390,"o":"m 41 605 l 41 757 l 390 757 l 390 605 l 41 605 m 41 345 l 41 503 l 390 503 l 390 345 l 41 345 z "},"₆":{"ha":425,"x_min":37,"x_max":409,"o":"m 226 -52 q 77 5 117 -52 q 37 174 37 61 l 37 363 q 49 528 37 461 q 103 629 62 595 q 230 663 144 663 q 347 629 296 663 q 398 526 398 594 l 398 450 l 263 450 l 263 465 q 258 515 263 490 q 228 540 254 540 q 195 527 204 540 q 186 490 186 514 l 186 349 q 215 379 195 368 q 264 391 235 391 q 380 338 351 391 q 409 182 409 286 q 369 13 409 77 q 226 -52 329 -52 m 221 78 q 251 99 246 78 q 255 153 255 119 l 255 209 q 223 267 255 267 q 186 216 186 267 l 186 130 q 221 78 186 78 z "},"⁶":{"ha":425,"x_min":37,"x_max":409,"o":"m 226 530 q 77 587 117 530 q 37 755 37 643 l 37 945 q 49 1110 37 1043 q 103 1211 62 1177 q 230 1245 144 1245 q 347 1211 296 1245 q 398 1107 398 1176 l 398 1031 l 263 1031 l 263 1046 q 258 1097 263 1072 q 228 1122 254 1122 q 195 1109 204 1122 q 186 1072 186 1096 l 186 931 q 215 961 195 949 q 264 972 235 972 q 380 920 351 972 q 409 764 409 867 q 369 594 409 659 q 226 530 329 530 m 221 660 q 251 681 246 660 q 255 734 255 701 l 255 791 q 223 848 255 848 q 186 798 186 848 l 186 711 q 221 660 186 660 z "},"/":{"ha":563,"x_min":20,"x_max":545,"o":"m 20 0 l 298 1198 l 545 1198 l 266 0 l 20 0 z "},"ꞩ":{"ha":659,"x_min":26,"x_max":633,"o":"m 328 -11 q 26 294 26 -11 l 26 375 l 271 375 l 271 256 q 284 201 271 221 q 328 182 298 182 q 380 261 380 182 q 353 360 380 328 q 285 424 325 393 l 251 450 l 35 404 l 35 557 l 101 572 q 48 654 66 608 q 31 771 31 701 q 72 916 31 859 q 183 1000 114 972 q 332 1028 252 1028 q 627 733 627 1028 l 627 714 l 376 714 l 376 753 q 366 812 376 783 q 325 840 355 840 q 273 786 273 840 q 317 700 273 731 l 404 636 l 621 682 l 621 529 l 552 515 q 611 416 589 472 q 633 283 633 361 q 552 64 633 140 q 328 -11 470 -11 z "},"­":{"ha":407,"x_min":41,"x_max":391,"o":"m 41 345 l 41 503 l 391 503 l 391 345 l 41 345 z "}," ":{"ha":326,"x_min":0,"x_max":0,"o":""},"£":{"ha":658,"x_min":28,"x_max":633,"o":"m 28 0 l 28 191 q 96 238 69 215 q 135 295 122 261 q 148 385 148 329 q 142 456 148 430 l 32 456 l 32 614 l 123 614 l 114 654 q 103 707 109 674 q 91 774 96 740 q 86 830 86 808 q 161 1028 86 965 q 369 1090 236 1090 q 525 1050 467 1090 q 608 937 583 1010 q 633 763 633 863 l 416 763 q 407 864 416 838 q 373 890 397 890 q 344 877 353 890 q 335 831 335 865 l 335 816 q 345 737 335 785 q 373 614 354 689 l 566 614 l 566 456 l 397 456 l 404 367 q 374 264 401 307 q 308 197 347 221 l 627 197 l 627 0 l 28 0 z "},"̵":{"ha":0,"x_min":-224,"x_max":224,"o":"m -224 440 l -224 597 l 224 597 l 224 440 l -224 440 z "},"∑":{"ha":576,"x_min":29,"x_max":547,"o":"m 29 0 l 29 184 l 172 604 l 29 1009 l 29 1194 l 547 1194 l 547 989 l 281 989 l 426 604 l 281 204 l 547 204 l 547 0 l 29 0 z "},"t":{"ha":424,"x_min":22,"x_max":395,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 z "},"ŧ":{"ha":424,"x_min":22,"x_max":395,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 440 l 23 440 l 23 597 l 91 597 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 597 l 395 597 l 395 440 l 327 440 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 z "},"ť":{"ha":532,"x_min":22,"x_max":578,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 m 366 1035 l 417 1195 l 366 1195 l 366 1397 l 578 1397 l 578 1201 l 509 1035 l 366 1035 z "},"ţ":{"ha":424,"x_min":22,"x_max":427,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 m 224 -428 q 90 -401 155 -428 l 90 -250 q 132 -261 111 -256 q 170 -265 152 -265 q 227 -247 204 -265 q 250 -185 250 -229 q 231 -98 250 -147 q 179 0 212 -50 l 288 0 q 390 -129 354 -58 q 427 -262 427 -199 q 378 -380 427 -332 q 224 -428 330 -428 z "},"ṱ":{"ha":424,"x_min":-43,"x_max":561,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 m -43 -347 l 121 -74 l 397 -74 l 561 -347 l 317 -347 l 259 -154 l 201 -347 l -43 -347 z "},"ț":{"ha":424,"x_min":22,"x_max":395,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 m 165 -436 l 210 -276 l 123 -276 l 123 -74 l 377 -74 l 377 -270 l 308 -436 l 165 -436 z "},"ⱦ":{"ha":452,"x_min":21,"x_max":458,"o":"m 21 -126 l 91 144 q 91 159 91 151 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 307 1194 l 307 978 l 309 978 l 363 1194 l 458 1194 l 395 944 l 395 793 l 327 793 l 327 222 q 366 170 327 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 q 151 10 189 -11 l 116 -126 l 21 -126 z "},"ẗ":{"ha":424,"x_min":-77,"x_max":494,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 m 252 1261 l 252 1463 l 494 1463 l 494 1261 l 252 1261 m -77 1261 l -77 1463 l 166 1463 l 166 1261 l -77 1261 z "},"ṫ":{"ha":424,"x_min":22,"x_max":395,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 m 92 1256 l 92 1458 l 335 1458 l 335 1256 l 92 1256 z "},"ṭ":{"ha":424,"x_min":22,"x_max":395,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 m 138 -283 l 138 -81 l 380 -81 l 380 -283 l 138 -283 z "}," ":{"ha":278,"x_min":0,"x_max":0,"o":""},"ƭ":{"ha":424,"x_min":22,"x_max":395,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 94 978 q 182 1139 109 1074 q 395 1204 256 1204 l 395 1017 q 334 978 349 1017 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 z "},"þ":{"ha":683,"x_min":42,"x_max":649,"o":"m 42 -170 l 42 1200 l 292 1200 l 292 968 q 427 1030 353 1030 q 600 956 551 1030 q 649 755 649 881 l 649 265 q 627 124 649 187 q 558 24 605 61 q 435 -12 511 -12 q 292 109 336 -12 l 292 -170 l 42 -170 m 349 178 q 395 216 387 178 q 403 310 403 254 l 403 733 q 395 810 403 779 q 351 840 387 840 q 303 811 315 840 q 292 736 292 782 l 292 310 q 300 217 292 255 q 349 178 309 178 z "},"⅜":{"ha":1109,"x_min":26,"x_max":1078,"o":"m 204 483 q 69 532 111 483 q 26 680 26 581 l 26 753 l 170 753 l 170 680 q 177 632 170 652 q 210 613 184 613 q 239 632 231 613 q 247 703 247 650 l 247 720 q 235 783 247 756 q 187 810 222 810 l 174 810 l 174 936 q 229 952 210 936 q 248 1006 248 968 q 214 1069 248 1069 q 185 1055 193 1069 q 176 1006 176 1040 l 176 983 l 31 983 l 31 1008 q 75 1152 31 1107 q 213 1198 120 1198 q 393 1008 393 1198 q 379 922 393 956 q 327 875 365 888 q 383 813 372 853 q 394 703 394 773 q 350 540 394 597 q 204 483 306 483 m 273 -11 l 665 1204 l 858 1204 l 397 -11 l 273 -11 m 895 -7 q 754 50 796 -7 q 711 210 711 106 l 711 254 q 724 340 711 307 q 771 391 737 373 q 726 435 739 404 q 712 511 712 466 l 712 530 q 759 666 712 623 q 895 708 806 708 q 1032 665 987 708 q 1078 524 1078 621 q 1066 439 1078 474 q 1018 390 1054 405 q 1069 329 1059 370 q 1078 228 1078 288 l 1078 210 q 1036 50 1078 106 q 895 -7 994 -7 m 895 450 q 932 517 932 450 q 924 559 932 539 q 895 579 917 579 q 866 559 873 579 q 858 517 858 539 q 895 450 858 450 m 895 132 q 933 201 933 132 l 933 247 q 928 297 933 271 q 895 323 922 323 q 866 302 874 323 q 859 245 859 281 l 859 201 q 895 132 859 132 z "},"₃":{"ha":429,"x_min":26,"x_max":394,"o":"m 204 -52 q 69 -2 111 -52 q 26 146 26 47 l 26 219 l 170 219 l 170 145 q 177 98 170 117 q 210 79 184 79 q 239 97 231 79 q 247 168 247 116 l 247 185 q 235 249 247 222 q 187 275 222 275 l 174 275 l 174 401 q 229 417 210 401 q 248 471 248 433 q 214 534 248 534 q 185 520 193 534 q 176 472 176 506 l 176 448 l 31 448 l 31 473 q 75 618 31 572 q 213 663 120 663 q 393 473 393 663 q 379 388 393 422 q 327 340 365 354 q 383 279 372 319 q 394 168 394 239 q 350 5 394 62 q 204 -52 306 -52 z "},"¾":{"ha":1187,"x_min":100,"x_max":1094,"o":"m 277 483 q 142 532 184 483 q 100 680 100 581 l 100 753 l 243 753 l 243 680 q 251 632 243 652 q 283 613 258 613 q 312 632 304 613 q 320 703 320 650 l 320 720 q 308 783 320 756 q 260 810 296 810 l 247 810 l 247 936 q 302 952 283 936 q 321 1006 321 968 q 287 1069 321 1069 q 258 1055 267 1069 q 250 1006 250 1040 l 250 983 l 104 983 l 104 1008 q 149 1152 104 1107 q 286 1198 193 1198 q 466 1008 466 1198 q 452 922 466 956 q 400 875 438 888 q 456 813 445 853 q 467 703 467 773 q 423 540 467 597 q 277 483 379 483 m 351 -11 l 743 1204 l 936 1204 l 475 -11 l 351 -11 m 913 0 l 913 115 l 705 115 l 705 224 l 838 701 l 1056 701 l 1056 232 l 1094 232 l 1094 115 l 1056 115 l 1056 0 l 913 0 m 830 232 l 913 232 l 913 581 l 830 232 z "},"³":{"ha":429,"x_min":26,"x_max":394,"o":"m 204 530 q 69 579 111 530 q 26 728 26 629 l 26 801 l 170 801 l 170 727 q 177 680 170 699 q 210 661 184 661 q 239 679 231 661 q 247 750 247 698 l 247 767 q 235 830 247 804 q 187 857 222 857 l 174 857 l 174 983 q 229 999 210 983 q 248 1053 248 1015 q 214 1116 248 1116 q 185 1102 193 1116 q 176 1054 176 1088 l 176 1030 l 31 1030 l 31 1055 q 75 1200 31 1154 q 213 1245 120 1245 q 393 1055 393 1245 q 379 970 393 1004 q 327 922 365 936 q 383 861 372 901 q 394 750 394 821 q 350 587 394 644 q 204 530 306 530 z "},"˜":{"ha":688,"x_min":60,"x_max":621,"o":"m 452 1093 q 360 1108 402 1093 q 285 1139 319 1124 q 223 1154 251 1154 q 190 1144 205 1154 q 161 1108 174 1134 l 60 1161 q 97 1237 77 1202 q 149 1292 117 1271 q 228 1312 180 1312 q 315 1298 276 1312 q 386 1270 354 1284 q 445 1255 418 1255 q 479 1267 463 1255 q 508 1306 494 1278 l 621 1270 q 585 1183 604 1224 q 534 1118 565 1143 q 452 1093 503 1093 z "},"̰":{"ha":0,"x_min":-280,"x_max":280,"o":"m 112 -295 q 20 -279 62 -295 q -56 -249 -22 -264 q -117 -233 -90 -233 q -151 -243 -135 -233 q -180 -279 -166 -254 l -280 -227 q -243 -151 -263 -185 q -192 -96 -223 -117 q -113 -75 -161 -75 q -25 -90 -64 -75 q 46 -118 14 -104 q 104 -132 78 -132 q 138 -121 123 -132 q 168 -81 154 -109 l 280 -118 q 244 -204 264 -163 q 194 -270 224 -245 q 112 -295 163 -295 z "},"̃":{"ha":0,"x_min":-280,"x_max":280,"o":"m 112 1093 q 20 1108 60 1093 q -53 1139 -20 1124 q -117 1154 -86 1154 q -151 1144 -135 1154 q -180 1108 -166 1134 l -280 1161 q -243 1237 -263 1202 q -192 1292 -223 1271 q -113 1312 -161 1312 q -24 1298 -62 1312 q 46 1270 15 1284 q 104 1255 78 1255 q 138 1267 123 1255 q 168 1306 154 1278 l 280 1270 q 244 1183 264 1224 q 194 1118 224 1143 q 112 1093 163 1093 z "},"̴":{"ha":0,"x_min":-280,"x_max":280,"o":"m 112 597 q 20 613 62 597 q -56 644 -22 629 q -117 659 -90 659 q -151 649 -135 659 q -180 613 -166 639 l -280 666 q -243 734 -263 703 q -192 785 -223 766 q -113 804 -161 804 q -25 789 -64 804 q 47 761 15 775 q 104 747 79 747 q 138 758 123 747 q 168 798 154 770 l 280 761 q 244 681 264 719 q 194 621 224 644 q 112 597 163 597 z "},"ṯ":{"ha":424,"x_min":22,"x_max":479,"o":"m 258 -11 q 125 31 159 -11 q 91 159 91 73 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 327 793 l 327 216 q 335 180 327 191 q 366 170 343 170 q 395 173 382 170 l 395 7 q 345 -3 387 5 q 258 -11 302 -11 m 39 -184 l 39 -81 l 479 -81 l 479 -184 l 39 -184 z "},"™":{"ha":1284,"x_min":34,"x_max":1209,"o":"m 141 375 l 141 1036 l 34 1036 l 34 1194 l 430 1194 l 430 1036 l 322 1036 l 322 375 l 141 375 m 504 375 l 504 1194 l 779 1194 l 856 766 l 932 1194 l 1209 1194 l 1209 375 l 1034 375 l 1034 966 l 940 375 l 777 375 l 677 966 l 677 375 l 504 375 z "},"ʈ":{"ha":424,"x_min":22,"x_max":395,"o":"m 395 -7 q 223 31 290 -7 q 123 132 155 68 q 91 270 91 195 l 91 793 l 22 793 l 22 978 l 91 978 l 91 1194 l 327 1194 l 327 978 l 395 978 l 395 793 l 328 793 l 328 270 q 345 201 328 221 q 395 180 362 180 l 395 -7 z "},"₂":{"ha":427,"x_min":41,"x_max":410,"o":"m 41 -45 l 41 -7 q 76 127 41 71 q 153 234 111 182 q 228 340 195 284 q 262 472 262 395 q 254 514 262 496 q 224 532 247 532 q 189 470 189 532 l 189 384 l 41 384 l 41 427 q 78 602 41 541 q 226 663 115 663 q 361 614 313 663 q 410 475 410 566 q 393 366 410 414 q 349 280 376 319 q 294 205 323 242 q 251 149 271 178 q 214 87 230 120 l 405 87 l 405 -45 l 41 -45 z "},"²":{"ha":427,"x_min":41,"x_max":410,"o":"m 41 537 l 41 574 q 76 709 41 653 q 153 816 111 764 q 228 922 195 866 q 262 1054 262 977 q 254 1096 262 1078 q 224 1114 247 1114 q 189 1052 189 1114 l 189 966 l 41 966 l 41 1009 q 78 1184 41 1122 q 226 1245 115 1245 q 361 1196 313 1245 q 410 1057 410 1147 q 393 948 410 996 q 349 862 376 901 q 294 787 323 824 q 251 731 271 760 q 214 669 230 702 l 405 669 l 405 537 l 41 537 z "},"⅔":{"ha":1099,"x_min":41,"x_max":1064,"o":"m 41 490 l 41 527 q 76 661 41 606 q 153 768 111 717 q 228 874 195 819 q 262 1006 262 930 q 254 1048 262 1031 q 224 1066 247 1066 q 189 1004 189 1066 l 189 918 l 41 918 l 41 962 q 78 1136 41 1075 q 226 1198 115 1198 q 361 1149 313 1198 q 410 1010 410 1100 q 393 901 410 948 q 349 815 376 853 q 294 740 323 777 q 251 684 271 713 q 214 622 230 654 l 405 622 l 405 490 l 41 490 m 287 -4 l 680 1211 l 872 1211 l 411 -4 l 287 -4 m 874 -7 q 739 42 781 -7 q 696 191 696 92 l 696 264 l 840 264 l 840 190 q 847 143 840 162 q 880 123 854 123 q 909 142 901 123 q 917 213 917 161 l 917 230 q 905 293 917 267 q 857 320 892 320 l 844 320 l 844 446 q 899 462 880 446 q 918 516 918 478 q 884 579 918 579 q 855 565 863 579 q 846 517 846 551 l 846 493 l 701 493 l 701 518 q 745 663 701 617 q 883 708 790 708 q 1063 518 1063 708 q 1049 433 1063 467 q 997 385 1035 399 q 1053 323 1042 363 q 1064 213 1064 283 q 1020 50 1064 107 q 874 -7 976 -7 z "},"u":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 z "},"ú":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 186 1053 l 186 1204 l 509 1352 l 509 1117 l 186 1053 z "},"ʉ":{"ha":755,"x_min":14,"x_max":742,"o":"m 277 -11 q 153 23 196 -11 q 94 118 110 57 q 79 260 79 178 l 79 522 l 14 522 l 14 679 l 79 679 l 79 1017 l 323 1017 l 323 679 l 435 679 l 435 1017 l 677 1017 l 677 679 l 742 679 l 742 522 l 677 522 l 677 0 l 434 0 l 434 109 q 379 20 411 50 q 277 -11 347 -11 m 323 288 q 332 203 323 227 q 377 179 342 179 q 425 213 415 179 q 435 300 435 247 l 435 522 l 323 522 l 323 288 z "},"ŭ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 349 1080 q 157 1130 231 1080 q 83 1291 83 1180 q 85 1319 83 1305 l 259 1319 q 279 1260 259 1280 q 351 1240 298 1240 q 422 1260 403 1240 q 442 1319 442 1280 l 616 1319 q 617 1305 616 1312 q 617 1295 617 1299 q 544 1131 617 1182 q 349 1080 471 1080 z "},"ǔ":{"ha":693,"x_min":45,"x_max":649,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 209 1079 l 45 1352 l 289 1352 l 347 1159 l 406 1352 l 649 1352 l 486 1079 l 209 1079 z "},"û":{"ha":693,"x_min":45,"x_max":649,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 45 1079 l 209 1352 l 486 1352 l 649 1079 l 406 1079 l 347 1272 l 289 1079 l 45 1079 z "},"ṷ":{"ha":693,"x_min":46,"x_max":667,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 64 -347 l 227 -74 l 504 -74 l 667 -347 l 424 -347 l 366 -154 l 307 -347 l 64 -347 z "},"ȕ":{"ha":693,"x_min":18,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 214 1076 l 18 1367 l 176 1440 l 326 1115 l 214 1076 m 418 1076 l 250 1367 l 406 1440 l 531 1115 l 418 1076 z "},"ü":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 385 1084 l 385 1286 l 628 1286 l 628 1084 l 385 1084 m 57 1084 l 57 1286 l 300 1286 l 300 1084 l 57 1084 z "},"ǘ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 385 1084 l 385 1253 l 628 1253 l 628 1084 l 385 1084 m 57 1084 l 57 1253 l 300 1253 l 300 1084 l 57 1084 m 182 1312 l 182 1442 l 504 1556 l 504 1362 l 182 1312 z "},"ṳ":{"ha":693,"x_min":46,"x_max":651,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 408 -283 l 408 -81 l 651 -81 l 651 -283 l 408 -283 m 80 -283 l 80 -81 l 323 -81 l 323 -283 l 80 -283 z "},"ǚ":{"ha":693,"x_min":46,"x_max":644,"o":"m 229 1312 l 68 1485 l 262 1485 l 329 1392 l 396 1485 l 589 1485 l 429 1312 l 229 1312 m 385 1084 l 385 1253 l 628 1253 l 628 1084 l 385 1084 m 57 1084 l 57 1253 l 300 1253 l 300 1084 l 57 1084 m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 z "},"ǜ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 385 1084 l 385 1253 l 628 1253 l 628 1084 l 385 1084 m 57 1084 l 57 1253 l 300 1253 l 300 1084 l 57 1084 m 503 1312 l 181 1362 l 181 1556 l 503 1442 l 503 1312 z "},"ǖ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 385 1084 l 385 1253 l 628 1253 l 628 1084 l 385 1084 m 57 1084 l 57 1253 l 300 1253 l 300 1084 l 57 1084 m 122 1326 l 122 1430 l 563 1430 l 563 1326 l 122 1326 z "},"ụ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 244 -283 l 244 -81 l 487 -81 l 487 -283 l 244 -283 z "},"ù":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 508 1053 l 186 1117 l 186 1352 l 508 1204 l 508 1053 z "},"ủ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 347 1083 l 275 1167 q 334 1201 312 1181 q 357 1255 357 1221 q 288 1320 357 1320 q 227 1309 256 1320 l 227 1431 q 351 1453 287 1453 q 484 1411 436 1453 q 532 1292 532 1369 q 479 1157 532 1206 q 347 1083 426 1107 z "},"ư":{"ha":792,"x_min":46,"x_max":792,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 295 q 301 201 290 223 q 345 179 312 179 q 390 209 378 179 q 402 300 402 239 l 402 1017 l 526 1017 q 604 1102 604 1017 l 604 1118 l 792 1118 l 792 1107 q 750 956 792 1008 q 644 884 709 903 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 z "},"ứ":{"ha":792,"x_min":46,"x_max":792,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 295 q 301 201 290 223 q 345 179 312 179 q 390 209 378 179 q 402 300 402 239 l 402 1017 l 526 1017 q 604 1102 604 1017 l 604 1118 l 792 1118 l 792 1107 q 750 956 792 1008 q 644 884 709 903 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 186 1074 l 186 1225 l 509 1373 l 509 1137 l 186 1074 z "},"ự":{"ha":792,"x_min":46,"x_max":792,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 295 q 301 201 290 223 q 345 179 312 179 q 390 209 378 179 q 402 300 402 239 l 402 1017 l 526 1017 q 604 1102 604 1017 l 604 1118 l 792 1118 l 792 1107 q 750 956 792 1008 q 644 884 709 903 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 244 -283 l 244 -81 l 487 -81 l 487 -283 l 244 -283 z "},"ừ":{"ha":792,"x_min":46,"x_max":792,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 295 q 301 201 290 223 q 345 179 312 179 q 390 209 378 179 q 402 300 402 239 l 402 1017 l 526 1017 q 604 1102 604 1017 l 604 1118 l 792 1118 l 792 1107 q 750 956 792 1008 q 644 884 709 903 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 508 1074 l 186 1137 l 186 1373 l 508 1225 l 508 1074 z "},"ử":{"ha":792,"x_min":46,"x_max":792,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 295 q 301 201 290 223 q 345 179 312 179 q 390 209 378 179 q 402 300 402 239 l 402 1017 l 526 1017 q 604 1102 604 1017 l 604 1118 l 792 1118 l 792 1107 q 750 956 792 1008 q 644 884 709 903 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 347 1103 l 275 1187 q 334 1221 312 1201 q 357 1276 357 1242 q 288 1340 357 1340 q 227 1329 256 1340 l 227 1451 q 351 1474 287 1474 q 484 1431 436 1474 q 532 1312 532 1389 q 479 1177 532 1226 q 347 1103 426 1128 z "},"ữ":{"ha":792,"x_min":46,"x_max":792,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 295 q 301 201 290 223 q 345 179 312 179 q 390 209 378 179 q 402 300 402 239 l 402 1017 l 526 1017 q 604 1102 604 1017 l 604 1118 l 792 1118 l 792 1107 q 750 956 792 1008 q 644 884 709 903 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 459 1113 q 367 1128 407 1113 q 294 1159 327 1144 q 230 1175 261 1175 q 197 1164 212 1175 q 168 1128 181 1154 l 67 1181 q 104 1257 84 1223 q 155 1312 124 1291 q 235 1333 186 1333 q 323 1318 285 1333 q 394 1290 362 1304 q 452 1276 425 1276 q 486 1287 470 1276 q 515 1326 501 1299 l 627 1290 q 591 1204 611 1244 q 541 1138 572 1163 q 459 1113 510 1113 z "},"ű":{"ha":693,"x_min":46,"x_max":658,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 462 1089 l 349 1128 l 499 1453 l 658 1380 l 462 1089 m 257 1089 l 144 1128 l 269 1453 l 425 1380 l 257 1089 z "},"ȗ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 96 1090 q 94 1118 94 1104 q 160 1279 94 1229 q 346 1329 227 1329 q 534 1278 468 1329 q 600 1114 600 1227 q 600 1104 600 1110 q 599 1090 600 1097 l 439 1090 q 413 1159 439 1137 q 347 1181 387 1181 q 282 1159 308 1181 q 256 1090 256 1137 l 96 1090 z "},"ū":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 127 1098 l 127 1202 l 568 1202 l 568 1098 l 127 1098 z "},"ṻ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 127 1098 l 127 1202 l 568 1202 l 568 1098 l 127 1098 m 385 1269 l 385 1471 l 628 1471 l 628 1269 l 385 1269 m 57 1269 l 57 1471 l 300 1471 l 300 1269 l 57 1269 z "},"_":{"ha":507,"x_min":33,"x_max":475,"o":"m 33 -245 l 33 -88 l 475 -88 l 475 -245 l 33 -245 z "},"Ɪ":{"ha":418,"x_min":22,"x_max":395,"o":"m 22 0 l 22 185 l 91 185 l 91 1008 l 22 1008 l 22 1194 l 395 1194 l 395 1008 l 327 1008 l 327 185 l 395 185 l 395 0 l 22 0 z "},"Ꞹ":{"ha":658,"x_min":39,"x_max":619,"o":"m 89 -126 l 134 48 q 39 319 39 128 l 39 1194 l 271 1194 l 271 329 q 274 272 271 299 q 290 227 277 244 q 329 209 302 209 q 369 226 357 209 q 384 271 381 243 q 387 329 387 299 l 387 1194 l 431 1194 l 474 1356 l 569 1356 l 526 1194 l 619 1194 l 619 319 q 549 73 619 157 q 329 -11 478 -11 q 218 4 267 -11 l 184 -126 l 89 -126 z "},"ꞹ":{"ha":693,"x_min":46,"x_max":644,"o":"m 127 -126 l 160 2 q 69 95 92 27 q 46 260 46 163 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 424 1017 l 469 1194 l 564 1194 l 519 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 348 21 378 52 q 252 -11 317 -9 l 222 -126 l 127 -126 z "},"ų":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 502 -428 q 384 -404 437 -428 q 298 -333 330 -379 q 266 -224 266 -288 q 445 0 266 -100 l 588 0 q 511 -89 542 -44 q 479 -189 479 -133 q 557 -265 479 -265 q 636 -250 591 -265 l 636 -401 q 502 -428 572 -428 z "},"↑":{"ha":537,"x_min":41,"x_max":496,"o":"m 164 0 l 164 756 l 41 688 l 41 897 l 269 1028 l 496 897 l 496 688 l 380 753 l 380 0 l 164 0 z "},"▲":{"ha":1120,"x_min":53,"x_max":1067,"o":"m 53 0 l 560 1028 l 1067 0 l 53 0 z "},"△":{"ha":1120,"x_min":53,"x_max":1067,"o":"m 53 0 l 560 1028 l 1067 0 l 53 0 m 266 132 l 854 132 l 560 729 l 266 132 z "},"ʊ":{"ha":690,"x_min":22,"x_max":667,"o":"m 345 -11 q 116 72 191 -11 q 41 304 41 155 l 41 536 q 57 712 41 643 q 106 832 73 782 l 22 832 l 22 1017 l 323 1017 l 323 850 q 301 818 309 838 q 290 753 293 798 q 288 623 288 708 l 288 269 q 299 202 288 228 q 345 176 310 176 q 390 202 379 176 q 401 269 401 228 l 401 623 q 399 752 401 708 q 389 817 396 796 q 366 850 381 837 l 366 1017 l 667 1017 l 667 832 l 583 832 q 633 712 616 782 q 649 536 649 643 l 649 304 q 574 72 649 155 q 345 -11 499 -11 z "},"ů":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 347 1072 q 173 1132 238 1072 q 107 1301 107 1193 q 173 1469 107 1408 q 347 1530 238 1530 q 521 1469 456 1530 q 587 1301 587 1408 q 521 1133 587 1194 q 347 1072 456 1072 m 347 1194 q 418 1225 393 1194 q 444 1301 444 1257 q 418 1376 444 1345 q 347 1407 393 1407 q 276 1376 302 1407 q 251 1301 251 1345 q 276 1225 251 1257 q 347 1194 302 1194 z "},"ũ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 459 1093 q 367 1108 407 1093 q 294 1139 327 1124 q 230 1154 261 1154 q 197 1144 212 1154 q 168 1108 181 1134 l 67 1161 q 104 1237 84 1202 q 155 1292 124 1271 q 235 1312 186 1312 q 323 1298 285 1312 q 394 1270 362 1284 q 452 1255 425 1255 q 486 1267 470 1255 q 515 1306 501 1278 l 627 1270 q 591 1183 611 1224 q 541 1118 572 1143 q 459 1093 510 1093 z "},"ṹ":{"ha":693,"x_min":46,"x_max":644,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 459 1093 q 367 1108 407 1093 q 294 1139 327 1124 q 230 1154 261 1154 q 197 1144 212 1154 q 168 1108 181 1134 l 67 1161 q 104 1237 84 1202 q 155 1292 124 1271 q 235 1312 186 1312 q 323 1298 285 1312 q 394 1270 362 1284 q 452 1255 425 1255 q 486 1267 470 1255 q 515 1306 501 1278 l 627 1270 q 591 1183 611 1224 q 541 1118 572 1143 q 459 1093 510 1093 m 186 1348 l 186 1499 l 509 1647 l 509 1412 l 186 1348 z "},"ṵ":{"ha":693,"x_min":46,"x_max":646,"o":"m 245 -11 q 120 23 163 -11 q 62 118 77 57 q 46 260 46 178 l 46 1017 l 290 1017 l 290 288 q 300 203 290 227 q 345 179 309 179 q 392 213 382 179 q 402 300 402 247 l 402 1017 l 644 1017 l 644 0 l 401 0 l 401 109 q 346 20 378 50 q 245 -11 314 -11 m 477 -295 q 386 -279 427 -295 q 310 -249 344 -264 q 248 -233 276 -233 q 215 -243 231 -233 q 186 -279 199 -254 l 85 -227 q 122 -151 102 -185 q 174 -96 142 -117 q 253 -75 205 -75 q 340 -90 301 -75 q 411 -118 379 -104 q 470 -132 444 -132 q 504 -121 488 -132 q 533 -81 519 -109 l 646 -118 q 610 -204 629 -163 q 559 -270 590 -245 q 477 -295 528 -295 z "},"v":{"ha":640,"x_min":15,"x_max":625,"o":"m 178 0 l 15 1017 l 258 1017 l 317 338 l 382 1017 l 625 1017 l 459 0 l 178 0 z "},"ṿ":{"ha":640,"x_min":15,"x_max":625,"o":"m 178 0 l 15 1017 l 258 1017 l 317 338 l 382 1017 l 625 1017 l 459 0 l 178 0 m 199 -283 l 199 -81 l 441 -81 l 441 -283 l 199 -283 z "},"̍":{"ha":0,"x_min":-104,"x_max":104,"o":"m -104 1148 l -104 1532 l 104 1532 l 104 1148 l -104 1148 z "},"̩":{"ha":0,"x_min":-104,"x_max":104,"o":"m -104 -436 l -104 -52 l 104 -52 l 104 -436 l -104 -436 z "},"ˌ":{"ha":317,"x_min":47,"x_max":270,"o":"m 47 -159 l 47 258 l 270 258 l 270 -159 l 47 -159 z "},"ˈ":{"ha":317,"x_min":47,"x_max":270,"o":"m 47 776 l 47 1194 l 270 1194 l 270 776 l 47 776 z "},"ʋ":{"ha":690,"x_min":41,"x_max":649,"o":"m 345 -11 q 41 304 41 -11 l 41 1017 l 288 1017 l 288 254 q 301 198 288 220 q 345 176 314 176 q 388 198 375 176 q 401 254 401 220 l 401 747 q 389 817 401 796 q 355 837 376 837 l 355 1024 q 520 986 455 1024 q 617 885 585 948 q 649 747 649 823 l 649 304 q 345 -11 649 -11 z "},"ṽ":{"ha":640,"x_min":15,"x_max":625,"o":"m 178 0 l 15 1017 l 258 1017 l 317 338 l 382 1017 l 625 1017 l 459 0 l 178 0 m 432 1093 q 340 1108 380 1093 q 267 1139 300 1124 q 203 1154 234 1154 q 170 1144 185 1154 q 140 1108 154 1134 l 40 1161 q 77 1237 57 1202 q 128 1292 97 1271 q 208 1312 159 1312 q 296 1298 258 1312 q 367 1270 335 1284 q 425 1255 398 1255 q 458 1267 443 1255 q 488 1306 474 1278 l 600 1270 q 564 1183 584 1224 q 514 1118 545 1143 q 432 1093 483 1093 z "},"ʌ":{"ha":640,"x_min":15,"x_max":625,"o":"m 15 0 l 181 1017 l 462 1017 l 625 0 l 382 0 l 323 680 l 258 0 l 15 0 z "},"w":{"ha":967,"x_min":33,"x_max":935,"o":"m 155 0 l 33 1017 l 241 1017 l 308 471 l 367 1017 l 600 1017 l 669 471 l 726 1017 l 935 1017 l 810 0 l 555 0 l 481 577 l 418 0 l 155 0 z "},"ẃ":{"ha":967,"x_min":33,"x_max":935,"o":"m 155 0 l 33 1017 l 241 1017 l 308 471 l 367 1017 l 600 1017 l 669 471 l 726 1017 l 935 1017 l 810 0 l 555 0 l 481 577 l 418 0 l 155 0 m 323 1053 l 323 1204 l 645 1352 l 645 1117 l 323 1053 z "},"ŵ":{"ha":967,"x_min":33,"x_max":935,"o":"m 155 0 l 33 1017 l 241 1017 l 308 471 l 367 1017 l 600 1017 l 669 471 l 726 1017 l 935 1017 l 810 0 l 555 0 l 481 577 l 418 0 l 155 0 m 182 1079 l 345 1352 l 622 1352 l 785 1079 l 542 1079 l 484 1272 l 425 1079 l 182 1079 z "},"ẅ":{"ha":967,"x_min":33,"x_max":935,"o":"m 155 0 l 33 1017 l 241 1017 l 308 471 l 367 1017 l 600 1017 l 669 471 l 726 1017 l 935 1017 l 810 0 l 555 0 l 481 577 l 418 0 l 155 0 m 522 1084 l 522 1286 l 764 1286 l 764 1084 l 522 1084 m 193 1084 l 193 1286 l 436 1286 l 436 1084 l 193 1084 z "},"ẇ":{"ha":967,"x_min":33,"x_max":935,"o":"m 155 0 l 33 1017 l 241 1017 l 308 471 l 367 1017 l 600 1017 l 669 471 l 726 1017 l 935 1017 l 810 0 l 555 0 l 481 577 l 418 0 l 155 0 m 362 1080 l 362 1282 l 605 1282 l 605 1080 l 362 1080 z "},"ẉ":{"ha":967,"x_min":33,"x_max":935,"o":"m 155 0 l 33 1017 l 241 1017 l 308 471 l 367 1017 l 600 1017 l 669 471 l 726 1017 l 935 1017 l 810 0 l 555 0 l 481 577 l 418 0 l 155 0 m 362 -283 l 362 -81 l 605 -81 l 605 -283 l 362 -283 z "},"ẁ":{"ha":967,"x_min":33,"x_max":935,"o":"m 155 0 l 33 1017 l 241 1017 l 308 471 l 367 1017 l 600 1017 l 669 471 l 726 1017 l 935 1017 l 810 0 l 555 0 l 481 577 l 418 0 l 155 0 m 644 1053 l 322 1117 l 322 1352 l 644 1204 l 644 1053 z "},"◇":{"ha":1006,"x_min":27,"x_max":979,"o":"m 503 35 l 27 513 l 503 990 l 979 513 l 503 35 m 503 222 l 793 513 l 503 803 l 214 513 l 503 222 z "},"□":{"ha":1120,"x_min":53,"x_max":1067,"o":"m 53 0 l 53 1017 l 1067 1017 l 1067 0 l 53 0 m 189 136 l 932 136 l 932 882 l 189 882 l 189 136 z "},"ⱳ":{"ha":967,"x_min":33,"x_max":962,"o":"m 155 0 l 33 1017 l 241 1017 l 308 471 l 367 1017 l 600 1017 l 669 471 l 692 758 q 763 955 701 882 q 962 1028 825 1028 l 962 841 q 915 820 930 841 q 895 749 900 800 l 810 0 l 555 0 l 481 577 l 418 0 l 155 0 z "},"ʷ":{"ha":726,"x_min":56,"x_max":671,"o":"m 139 541 l 56 1236 l 197 1236 l 243 863 l 284 1236 l 443 1236 l 490 863 l 529 1236 l 671 1236 l 587 541 l 412 541 l 362 935 l 319 541 l 139 541 z "},"₩":{"ha":833,"x_min":0,"x_max":833,"o":"m 151 0 l 94 469 l 0 469 l 0 591 l 79 591 l 68 686 l 0 686 l 0 808 l 53 808 l 20 1080 l 203 1080 l 225 808 l 323 808 l 351 1080 l 484 1080 l 515 808 l 611 808 l 630 1080 l 813 1080 l 780 808 l 833 808 l 833 686 l 765 686 l 753 591 l 833 591 l 833 469 l 739 469 l 682 0 l 492 0 l 446 469 l 387 469 l 341 0 l 151 0 m 416 764 l 399 591 l 433 591 l 416 764 m 540 591 l 596 591 l 603 686 l 529 686 l 540 591 m 243 591 l 300 591 l 310 686 l 235 686 l 243 591 m 268 283 l 288 469 l 253 469 l 268 283 m 575 283 l 588 469 l 554 469 l 575 283 z "},"x":{"ha":637,"x_min":5,"x_max":632,"o":"m 5 0 l 192 547 l 22 1018 l 270 1018 l 357 771 l 444 1018 l 624 1018 l 449 515 l 632 0 l 389 0 l 286 286 l 189 0 l 5 0 z "},"ẍ":{"ha":637,"x_min":5,"x_max":633,"o":"m 5 0 l 192 547 l 22 1018 l 270 1018 l 357 771 l 444 1018 l 624 1018 l 449 515 l 632 0 l 389 0 l 286 286 l 189 0 l 5 0 m 391 1084 l 391 1286 l 633 1286 l 633 1084 l 391 1084 m 62 1084 l 62 1286 l 305 1286 l 305 1084 l 62 1084 z "},"ẋ":{"ha":637,"x_min":5,"x_max":632,"o":"m 5 0 l 192 547 l 22 1018 l 270 1018 l 357 771 l 444 1018 l 624 1018 l 449 515 l 632 0 l 389 0 l 286 286 l 189 0 l 5 0 m 231 1080 l 231 1282 l 474 1282 l 474 1080 l 231 1080 z "},"y":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 z "},"ý":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 159 1053 l 159 1204 l 481 1352 l 481 1117 l 159 1053 z "},"ŷ":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 18 1079 l 181 1352 l 458 1352 l 621 1079 l 378 1079 l 319 1272 l 261 1079 l 18 1079 z "},"ÿ":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 357 1084 l 357 1286 l 600 1286 l 600 1084 l 357 1084 m 29 1084 l 29 1286 l 272 1286 l 272 1084 l 29 1084 z "},"ẏ":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 198 1080 l 198 1282 l 441 1282 l 441 1080 l 198 1080 z "},"ỵ":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 182 -452 l 182 -250 l 425 -250 l 425 -452 l 182 -452 z "},"¥":{"ha":643,"x_min":7,"x_max":612,"o":"m 62 184 l 62 302 l 197 302 l 197 368 l 62 368 l 62 486 l 172 486 l 7 1080 l 243 1080 l 310 654 l 376 1080 l 612 1080 l 448 486 l 553 486 l 553 368 l 422 368 l 422 302 l 553 302 l 553 184 l 422 184 l 422 0 l 197 0 l 197 184 l 62 184 z "},"ỳ":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 480 1053 l 158 1117 l 158 1352 l 480 1204 l 480 1053 z "},"ƴ":{"ha":640,"x_min":11,"x_max":631,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 29 172 15 l 11 1017 l 243 1017 l 311 267 l 355 758 q 428 955 367 882 q 631 1028 490 1028 l 631 841 q 592 820 605 841 q 570 749 579 800 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 z "},"ỷ":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 319 1083 l 248 1167 q 307 1201 284 1181 q 329 1255 329 1221 q 260 1320 329 1320 q 199 1309 229 1320 l 199 1431 q 323 1453 259 1453 q 456 1411 408 1453 q 504 1292 504 1369 q 451 1157 504 1206 q 319 1083 398 1107 z "},"ȳ":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 99 1098 l 99 1202 l 540 1202 l 540 1098 l 99 1098 z "},"ɏ":{"ha":640,"x_min":6,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 90 522 l 6 522 l 6 679 l 65 679 l 11 1017 l 243 1017 l 274 679 l 355 679 l 391 1017 l 625 1017 l 566 679 l 623 679 l 623 522 l 538 522 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 288 522 l 311 269 l 338 522 l 288 522 z "},"ỹ":{"ha":640,"x_min":11,"x_max":625,"o":"m 29 -170 l 29 -16 l 146 -16 q 172 3 172 -16 q 170 22 172 12 l 11 1017 l 243 1017 l 311 269 l 391 1017 l 625 1017 l 437 -53 q 398 -140 427 -111 q 303 -170 369 -170 l 29 -170 m 431 1093 q 339 1108 379 1093 q 266 1139 299 1124 q 202 1154 233 1154 q 169 1144 184 1154 q 140 1108 153 1134 l 39 1161 q 76 1237 56 1202 q 127 1292 96 1271 q 207 1312 159 1312 q 296 1298 257 1312 q 366 1270 334 1284 q 424 1255 397 1255 q 458 1267 442 1255 q 487 1306 473 1278 l 600 1270 q 564 1183 583 1224 q 513 1118 544 1143 q 431 1093 482 1093 z "},"z":{"ha":536,"x_min":19,"x_max":526,"o":"m 19 0 l 19 149 l 273 825 l 31 825 l 31 1017 l 524 1017 l 524 852 l 285 182 l 526 182 l 526 0 l 19 0 z "},"ź":{"ha":536,"x_min":19,"x_max":526,"o":"m 19 0 l 19 149 l 273 825 l 31 825 l 31 1017 l 524 1017 l 524 852 l 285 182 l 526 182 l 526 0 l 19 0 m 135 1053 l 135 1204 l 457 1352 l 457 1117 l 135 1053 z "},"ž":{"ha":536,"x_min":-6,"x_max":597,"o":"m 19 0 l 19 149 l 273 825 l 31 825 l 31 1017 l 524 1017 l 524 852 l 285 182 l 526 182 l 526 0 l 19 0 m 157 1079 l -6 1352 l 237 1352 l 296 1159 l 354 1352 l 597 1352 l 434 1079 l 157 1079 z "},"ẑ":{"ha":536,"x_min":-6,"x_max":597,"o":"m 19 0 l 19 149 l 273 825 l 31 825 l 31 1017 l 524 1017 l 524 852 l 285 182 l 526 182 l 526 0 l 19 0 m -6 1079 l 157 1352 l 434 1352 l 597 1079 l 354 1079 l 296 1272 l 237 1079 l -6 1079 z "},"ż":{"ha":536,"x_min":19,"x_max":526,"o":"m 19 0 l 19 149 l 273 825 l 31 825 l 31 1017 l 524 1017 l 524 852 l 285 182 l 526 182 l 526 0 l 19 0 m 174 1080 l 174 1282 l 417 1282 l 417 1080 l 174 1080 z "},"ẓ":{"ha":536,"x_min":19,"x_max":526,"o":"m 19 0 l 19 149 l 273 825 l 31 825 l 31 1017 l 524 1017 l 524 852 l 285 182 l 526 182 l 526 0 l 19 0 m 146 -283 l 146 -81 l 389 -81 l 389 -283 l 146 -283 z "},"₀":{"ha":426,"x_min":27,"x_max":399,"o":"m 213 -52 q 76 -2 124 -52 q 27 142 27 48 l 27 458 q 73 610 27 557 q 213 663 119 663 q 353 610 307 663 q 399 458 399 557 l 399 142 q 350 -2 399 48 q 213 -52 302 -52 m 213 78 q 238 93 229 78 q 248 125 248 107 l 248 472 q 242 516 248 497 q 213 534 237 534 q 184 516 189 534 q 178 472 178 497 l 178 125 q 188 93 178 107 q 213 78 197 78 z "},"⁰":{"ha":426,"x_min":27,"x_max":399,"o":"m 213 530 q 76 580 124 530 q 27 724 27 630 l 27 1040 q 73 1192 27 1139 q 213 1245 119 1245 q 353 1192 307 1245 q 399 1040 399 1139 l 399 724 q 350 580 399 630 q 213 530 302 530 m 213 660 q 238 674 229 660 q 248 707 248 689 l 248 1054 q 242 1098 248 1079 q 213 1116 237 1116 q 184 1098 189 1116 q 178 1054 178 1079 l 178 707 q 188 674 178 689 q 213 660 197 660 z "},"​":{"ha":0,"x_min":0,"x_max":0,"o":""},"ẕ":{"ha":536,"x_min":19,"x_max":526,"o":"m 19 0 l 19 149 l 273 825 l 31 825 l 31 1017 l 524 1017 l 524 852 l 285 182 l 526 182 l 526 0 l 19 0 m 47 -184 l 47 -81 l 488 -81 l 488 -184 l 47 -184 z "},"ᶻ":{"ha":434,"x_min":47,"x_max":393,"o":"m 47 541 l 47 643 l 220 1105 l 55 1105 l 55 1236 l 392 1236 l 392 1123 l 229 665 l 393 665 l 393 541 l 47 541 z "},"ƶ":{"ha":536,"x_min":19,"x_max":526,"o":"m 19 0 l 19 149 l 128 440 l 58 440 l 58 597 l 187 597 l 273 825 l 31 825 l 31 1017 l 524 1017 l 524 852 l 433 597 l 506 597 l 506 440 l 377 440 l 285 182 l 526 182 l 526 0 l 19 0 z "}},"familyName":"Anton","ascender":1634,"descender":-457,"underlinePosition":-208,"underlineThickness":69,"boundingBox":{"yMin":-452,"xMin":-420,"yMax":1949,"xMax":2027},"resolution":1000,"original_font_information":{"format":0,"copyright":"Copyright 2020 The Anton Project Authors (https://github.com/googlefonts/AntonFont.git)","fontFamily":"Anton","fontSubfamily":"Regular","uniqueID":"2.116;newt;Anton-Regular","fullName":"Anton Regular","version":"Version 2.116; ttfautohint (v1.8.3)","postScriptName":"Anton-Regular","manufacturer":"Vernon Adams","designer":"Vernon Adams","manufacturerURL":"http://www.sansoxygen.com","designerURL":"http://www.sansoxygen.com","licence":"This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is available with a FAQ at: https://scripts.sil.org/OFL","licenceURL":"https://scripts.sil.org/OFL"},"cssFontWeight":"normal","cssFontStyle":"normal"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!****************************************************!*\
  !*** ./build-config/entry-points/preview-entry.js ***!
  \****************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shared_dependencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared-dependencies */ "./build-config/shared-dependencies.js");
/* harmony import */ var _shared_dependencies__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_dependencies__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _networks_preview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../networks/preview */ "./build-config/networks/preview.js");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/index */ "./src/index.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ "./build-config/config.ts");
// Shared dependencies




window.network = (0,_networks_preview__WEBPACK_IMPORTED_MODULE_1__.network)(_src_index__WEBPACK_IMPORTED_MODULE_2__.app, _config__WEBPACK_IMPORTED_MODULE_3__.config);
window.network.start();
})();

/******/ })()
;
//# sourceMappingURL=main.js.map